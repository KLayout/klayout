// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: layoutView.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "geometry.capnp.h"
#include "repetition.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9b5b2a4703ca5f35);
CAPNP_DECLARE_SCHEMA(b750d92ac62b9fc2);
CAPNP_DECLARE_SCHEMA(abac22840c889893);
CAPNP_DECLARE_SCHEMA(b24841000c998eed);
CAPNP_DECLARE_SCHEMA(df03c9c3399688cd);
CAPNP_DECLARE_SCHEMA(9de3506f30432621);
CAPNP_DECLARE_SCHEMA(868a1468cf991b01);
CAPNP_DECLARE_SCHEMA(bf57a20c40ddf224);
CAPNP_DECLARE_SCHEMA(f154827dbacd9dff);
CAPNP_DECLARE_SCHEMA(a41ef417a8cd6629);
CAPNP_DECLARE_SCHEMA(b86aa231e67a92b2);

}  // namespace schemas
}  // namespace capnp

namespace stream {
namespace layoutView {

template <typename Object = ::capnp::AnyPointer>
struct SingleObject {
  SingleObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b5b2a4703ca5f35, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object = ::capnp::AnyPointer>
struct ObjectArray {
  ObjectArray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b750d92ac62b9fc2, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object = ::capnp::AnyPointer>
struct ObjectWithProperties {
  ObjectWithProperties() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abac22840c889893, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object = ::capnp::AnyPointer>
struct ObjectContainerForType {
  ObjectContainerForType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b24841000c998eed, 0, 4)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Layer {
  Layer() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df03c9c3399688cd, 1, 9)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellTransformation {
  CellTransformation() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Transformation;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9de3506f30432621, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellTransformation::Transformation {
  Transformation() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SIMPLE,
    COMPLEX,
  };
  struct Simple;
  struct Complex;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(868a1468cf991b01, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellTransformation::Transformation::Simple {
  Simple() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf57a20c40ddf224, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellTransformation::Transformation::Complex {
  Complex() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f154827dbacd9dff, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CellInstance {
  CellInstance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a41ef417a8cd6629, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LayoutView {
  LayoutView() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b86aa231e67a92b2, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

template <typename Object>
class SingleObject<Object>::Reader {
public:
  typedef SingleObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename SingleObject<Object2>::Reader asGeneric() {
    return typename SingleObject<Object2>::Reader(_reader);
  }

  inline bool hasBasic() const;
  inline  ::capnp::ReaderFor<Object> getBasic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class SingleObject<Object>::Builder {
public:
  typedef SingleObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename SingleObject<Object2>::Builder asGeneric() {
    return typename SingleObject<Object2>::Builder(_builder);
  }

  inline bool hasBasic();
  inline  ::capnp::BuilderFor<Object> getBasic();
  inline void setBasic( ::capnp::ReaderFor<Object> value);
  inline  ::capnp::BuilderFor<Object> initBasic();
  inline  ::capnp::BuilderFor<Object> initBasic(unsigned int size);
  inline void adoptBasic(::capnp::Orphan<Object>&& value);
  inline ::capnp::Orphan<Object> disownBasic();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class SingleObject<Object>::Pipeline {
public:
  typedef SingleObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Object> getBasic();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class ObjectArray<Object>::Reader {
public:
  typedef ObjectArray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectArray<Object2>::Reader asGeneric() {
    return typename ObjectArray<Object2>::Reader(_reader);
  }

  inline bool hasBasic() const;
  inline  ::capnp::ReaderFor<Object> getBasic() const;

  inline  ::uint64_t getRepetitionId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class ObjectArray<Object>::Builder {
public:
  typedef ObjectArray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectArray<Object2>::Builder asGeneric() {
    return typename ObjectArray<Object2>::Builder(_builder);
  }

  inline bool hasBasic();
  inline  ::capnp::BuilderFor<Object> getBasic();
  inline void setBasic( ::capnp::ReaderFor<Object> value);
  inline  ::capnp::BuilderFor<Object> initBasic();
  inline  ::capnp::BuilderFor<Object> initBasic(unsigned int size);
  inline void adoptBasic(::capnp::Orphan<Object>&& value);
  inline ::capnp::Orphan<Object> disownBasic();

  inline  ::uint64_t getRepetitionId();
  inline void setRepetitionId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class ObjectArray<Object>::Pipeline {
public:
  typedef ObjectArray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Object> getBasic();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class ObjectWithProperties<Object>::Reader {
public:
  typedef ObjectWithProperties Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectWithProperties<Object2>::Reader asGeneric() {
    return typename ObjectWithProperties<Object2>::Reader(_reader);
  }

  inline bool hasBasic() const;
  inline  ::capnp::ReaderFor<Object> getBasic() const;

  inline  ::uint64_t getPropertySetId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class ObjectWithProperties<Object>::Builder {
public:
  typedef ObjectWithProperties Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectWithProperties<Object2>::Builder asGeneric() {
    return typename ObjectWithProperties<Object2>::Builder(_builder);
  }

  inline bool hasBasic();
  inline  ::capnp::BuilderFor<Object> getBasic();
  inline void setBasic( ::capnp::ReaderFor<Object> value);
  inline  ::capnp::BuilderFor<Object> initBasic();
  inline  ::capnp::BuilderFor<Object> initBasic(unsigned int size);
  inline void adoptBasic(::capnp::Orphan<Object>&& value);
  inline ::capnp::Orphan<Object> disownBasic();

  inline  ::uint64_t getPropertySetId();
  inline void setPropertySetId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class ObjectWithProperties<Object>::Pipeline {
public:
  typedef ObjectWithProperties Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Object> getBasic();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class ObjectContainerForType<Object>::Reader {
public:
  typedef ObjectContainerForType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectContainerForType<Object2>::Reader asGeneric() {
    return typename ObjectContainerForType<Object2>::Reader(_reader);
  }

  inline bool hasBasic() const;
  inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Reader getBasic() const;

  inline bool hasWithProperties() const;
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Reader getWithProperties() const;

  inline bool hasArrays() const;
  inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Reader getArrays() const;

  inline bool hasArraysWithProperties() const;
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Reader getArraysWithProperties() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class ObjectContainerForType<Object>::Builder {
public:
  typedef ObjectContainerForType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename ObjectContainerForType<Object2>::Builder asGeneric() {
    return typename ObjectContainerForType<Object2>::Builder(_builder);
  }

  inline bool hasBasic();
  inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Builder getBasic();
  inline void setBasic(typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Builder initBasic(unsigned int size);
  inline void adoptBasic(::capnp::Orphan< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>> disownBasic();

  inline bool hasWithProperties();
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Builder getWithProperties();
  inline void setWithProperties(typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Builder initWithProperties(unsigned int size);
  inline void adoptWithProperties(::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>> disownWithProperties();

  inline bool hasArrays();
  inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Builder getArrays();
  inline void setArrays(typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Builder initArrays(unsigned int size);
  inline void adoptArrays(::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>> disownArrays();

  inline bool hasArraysWithProperties();
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Builder getArraysWithProperties();
  inline void setArraysWithProperties(typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Builder initArraysWithProperties(unsigned int size);
  inline void adoptArraysWithProperties(::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>> disownArraysWithProperties();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class ObjectContainerForType<Object>::Pipeline {
public:
  typedef ObjectContainerForType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Layer::Reader {
public:
  typedef Layer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLayerId() const;

  inline bool hasRepetitions() const;
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader getRepetitions() const;

  inline bool hasBoxes() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Reader getBoxes() const;

  inline bool hasPolygons() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Reader getPolygons() const;

  inline bool hasSimplePolygons() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Reader getSimplePolygons() const;

  inline bool hasPaths() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Reader getPaths() const;

  inline bool hasLabels() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Reader getLabels() const;

  inline bool hasEdges() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Reader getEdges() const;

  inline bool hasEdgePairs() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Reader getEdgePairs() const;

  inline bool hasPoints() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Reader getPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Layer::Builder {
public:
  typedef Layer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLayerId();
  inline void setLayerId( ::uint64_t value);

  inline bool hasRepetitions();
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder getRepetitions();
  inline void setRepetitions( ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder initRepetitions(unsigned int size);
  inline void adoptRepetitions(::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>> disownRepetitions();

  inline bool hasBoxes();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Builder getBoxes();
  inline void setBoxes( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Builder initBoxes();
  inline void adoptBoxes(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>> disownBoxes();

  inline bool hasPolygons();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Builder getPolygons();
  inline void setPolygons( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Builder initPolygons();
  inline void adoptPolygons(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>> disownPolygons();

  inline bool hasSimplePolygons();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Builder getSimplePolygons();
  inline void setSimplePolygons( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Builder initSimplePolygons();
  inline void adoptSimplePolygons(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>> disownSimplePolygons();

  inline bool hasPaths();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Builder getPaths();
  inline void setPaths( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Builder initPaths();
  inline void adoptPaths(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>> disownPaths();

  inline bool hasLabels();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Builder getLabels();
  inline void setLabels( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Builder initLabels();
  inline void adoptLabels(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>> disownLabels();

  inline bool hasEdges();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Builder getEdges();
  inline void setEdges( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Builder initEdges();
  inline void adoptEdges(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>> disownEdges();

  inline bool hasEdgePairs();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Builder getEdgePairs();
  inline void setEdgePairs( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Builder initEdgePairs();
  inline void adoptEdgePairs(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>> disownEdgePairs();

  inline bool hasPoints();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Builder getPoints();
  inline void setPoints( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Builder initPoints();
  inline void adoptPoints(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>> disownPoints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Layer::Pipeline {
public:
  typedef Layer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Pipeline getBoxes();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Pipeline getPolygons();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Pipeline getSimplePolygons();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Pipeline getPaths();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Pipeline getLabels();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Pipeline getEdges();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Pipeline getEdgePairs();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Pipeline getPoints();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellTransformation::Reader {
public:
  typedef CellTransformation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDisplacement() const;
  inline  ::stream::geometry::Vector::Reader getDisplacement() const;

  inline typename Transformation::Reader getTransformation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellTransformation::Builder {
public:
  typedef CellTransformation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDisplacement();
  inline  ::stream::geometry::Vector::Builder getDisplacement();
  inline void setDisplacement( ::stream::geometry::Vector::Reader value);
  inline  ::stream::geometry::Vector::Builder initDisplacement();
  inline void adoptDisplacement(::capnp::Orphan< ::stream::geometry::Vector>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Vector> disownDisplacement();

  inline typename Transformation::Builder getTransformation();
  inline typename Transformation::Builder initTransformation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellTransformation::Pipeline {
public:
  typedef CellTransformation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Vector::Pipeline getDisplacement();
  inline typename Transformation::Pipeline getTransformation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellTransformation::Transformation::Reader {
public:
  typedef Transformation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isSimple() const;
  inline typename Simple::Reader getSimple() const;

  inline bool isComplex() const;
  inline typename Complex::Reader getComplex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellTransformation::Transformation::Builder {
public:
  typedef Transformation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isSimple();
  inline typename Simple::Builder getSimple();
  inline typename Simple::Builder initSimple();

  inline bool isComplex();
  inline typename Complex::Builder getComplex();
  inline typename Complex::Builder initComplex();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellTransformation::Transformation::Pipeline {
public:
  typedef Transformation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellTransformation::Transformation::Simple::Reader {
public:
  typedef Simple Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::stream::geometry::FixPointTransformation getOrientation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellTransformation::Transformation::Simple::Builder {
public:
  typedef Simple Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::stream::geometry::FixPointTransformation getOrientation();
  inline void setOrientation( ::stream::geometry::FixPointTransformation value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellTransformation::Transformation::Simple::Pipeline {
public:
  typedef Simple Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellTransformation::Transformation::Complex::Reader {
public:
  typedef Complex Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getAngle() const;

  inline bool getMirror() const;

  inline double getScale() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellTransformation::Transformation::Complex::Builder {
public:
  typedef Complex Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getAngle();
  inline void setAngle(double value);

  inline bool getMirror();
  inline void setMirror(bool value);

  inline double getScale();
  inline void setScale(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellTransformation::Transformation::Complex::Pipeline {
public:
  typedef Complex Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CellInstance::Reader {
public:
  typedef CellInstance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getCellId() const;

  inline bool hasTransformation() const;
  inline  ::stream::layoutView::CellTransformation::Reader getTransformation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CellInstance::Builder {
public:
  typedef CellInstance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getCellId();
  inline void setCellId( ::uint64_t value);

  inline bool hasTransformation();
  inline  ::stream::layoutView::CellTransformation::Builder getTransformation();
  inline void setTransformation( ::stream::layoutView::CellTransformation::Reader value);
  inline  ::stream::layoutView::CellTransformation::Builder initTransformation();
  inline void adoptTransformation(::capnp::Orphan< ::stream::layoutView::CellTransformation>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::CellTransformation> disownTransformation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CellInstance::Pipeline {
public:
  typedef CellInstance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::layoutView::CellTransformation::Pipeline getTransformation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LayoutView::Reader {
public:
  typedef LayoutView Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBoundingBox() const;
  inline  ::stream::geometry::Box::Reader getBoundingBox() const;

  inline bool hasLayers() const;
  inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Reader getLayers() const;

  inline bool hasInstanceRepetitions() const;
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader getInstanceRepetitions() const;

  inline bool hasInstances() const;
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Reader getInstances() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LayoutView::Builder {
public:
  typedef LayoutView Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBoundingBox();
  inline  ::stream::geometry::Box::Builder getBoundingBox();
  inline void setBoundingBox( ::stream::geometry::Box::Reader value);
  inline  ::stream::geometry::Box::Builder initBoundingBox();
  inline void adoptBoundingBox(::capnp::Orphan< ::stream::geometry::Box>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Box> disownBoundingBox();

  inline bool hasLayers();
  inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Builder getLayers();
  inline void setLayers( ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Builder initLayers(unsigned int size);
  inline void adoptLayers(::capnp::Orphan< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>> disownLayers();

  inline bool hasInstanceRepetitions();
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder getInstanceRepetitions();
  inline void setInstanceRepetitions( ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder initInstanceRepetitions(unsigned int size);
  inline void adoptInstanceRepetitions(::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>> disownInstanceRepetitions();

  inline bool hasInstances();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Builder getInstances();
  inline void setInstances( ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Reader value);
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Builder initInstances();
  inline void adoptInstances(::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>&& value);
  inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>> disownInstances();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LayoutView::Pipeline {
public:
  typedef LayoutView Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Box::Pipeline getBoundingBox();
  inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Pipeline getInstances();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

template <typename Object>
inline bool SingleObject<Object>::Reader::hasBasic() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool SingleObject<Object>::Builder::hasBasic() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline  ::capnp::ReaderFor<Object> SingleObject<Object>::Reader::getBasic() const {
  return ::capnp::_::PointerHelpers<Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> SingleObject<Object>::Builder::getBasic() {
  return ::capnp::_::PointerHelpers<Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Object>
inline  ::capnp::PipelineFor<Object> SingleObject<Object>::Pipeline::getBasic() {
  return  ::capnp::PipelineFor<Object>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Object>
inline void SingleObject<Object>::Builder::setBasic( ::capnp::ReaderFor<Object> value) {
  ::capnp::_::PointerHelpers<Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> SingleObject<Object>::Builder::initBasic() {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> SingleObject<Object>::Builder::initBasic(unsigned int size) {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void SingleObject<Object>::Builder::adoptBasic(
    ::capnp::Orphan<Object>&& value) {
  ::capnp::_::PointerHelpers<Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan<Object> SingleObject<Object>::Builder::disownBasic() {
  return ::capnp::_::PointerHelpers<Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// SingleObject<Object>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr uint16_t SingleObject<Object>::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t SingleObject<Object>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr ::capnp::Kind SingleObject<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* SingleObject<Object>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope SingleObject<Object>::_capnpPrivate::brandScopes[] = {
  { 0x9b5b2a4703ca5f35, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding SingleObject<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema SingleObject<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9b5b2a4703ca5f35, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Object>
inline bool ObjectArray<Object>::Reader::hasBasic() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectArray<Object>::Builder::hasBasic() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline  ::capnp::ReaderFor<Object> ObjectArray<Object>::Reader::getBasic() const {
  return ::capnp::_::PointerHelpers<Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectArray<Object>::Builder::getBasic() {
  return ::capnp::_::PointerHelpers<Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Object>
inline  ::capnp::PipelineFor<Object> ObjectArray<Object>::Pipeline::getBasic() {
  return  ::capnp::PipelineFor<Object>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Object>
inline void ObjectArray<Object>::Builder::setBasic( ::capnp::ReaderFor<Object> value) {
  ::capnp::_::PointerHelpers<Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectArray<Object>::Builder::initBasic() {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectArray<Object>::Builder::initBasic(unsigned int size) {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectArray<Object>::Builder::adoptBasic(
    ::capnp::Orphan<Object>&& value) {
  ::capnp::_::PointerHelpers<Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan<Object> ObjectArray<Object>::Builder::disownBasic() {
  return ::capnp::_::PointerHelpers<Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Object>
inline  ::uint64_t ObjectArray<Object>::Reader::getRepetitionId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Object>
inline  ::uint64_t ObjectArray<Object>::Builder::getRepetitionId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Object>
inline void ObjectArray<Object>::Builder::setRepetitionId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// ObjectArray<Object>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr uint16_t ObjectArray<Object>::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t ObjectArray<Object>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr ::capnp::Kind ObjectArray<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* ObjectArray<Object>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope ObjectArray<Object>::_capnpPrivate::brandScopes[] = {
  { 0xb750d92ac62b9fc2, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding ObjectArray<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema ObjectArray<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b750d92ac62b9fc2, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Object>
inline bool ObjectWithProperties<Object>::Reader::hasBasic() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectWithProperties<Object>::Builder::hasBasic() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline  ::capnp::ReaderFor<Object> ObjectWithProperties<Object>::Reader::getBasic() const {
  return ::capnp::_::PointerHelpers<Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectWithProperties<Object>::Builder::getBasic() {
  return ::capnp::_::PointerHelpers<Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Object>
inline  ::capnp::PipelineFor<Object> ObjectWithProperties<Object>::Pipeline::getBasic() {
  return  ::capnp::PipelineFor<Object>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Object>
inline void ObjectWithProperties<Object>::Builder::setBasic( ::capnp::ReaderFor<Object> value) {
  ::capnp::_::PointerHelpers<Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectWithProperties<Object>::Builder::initBasic() {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> ObjectWithProperties<Object>::Builder::initBasic(unsigned int size) {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectWithProperties<Object>::Builder::adoptBasic(
    ::capnp::Orphan<Object>&& value) {
  ::capnp::_::PointerHelpers<Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan<Object> ObjectWithProperties<Object>::Builder::disownBasic() {
  return ::capnp::_::PointerHelpers<Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Object>
inline  ::uint64_t ObjectWithProperties<Object>::Reader::getPropertySetId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Object>
inline  ::uint64_t ObjectWithProperties<Object>::Builder::getPropertySetId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Object>
inline void ObjectWithProperties<Object>::Builder::setPropertySetId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// ObjectWithProperties<Object>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr uint16_t ObjectWithProperties<Object>::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t ObjectWithProperties<Object>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr ::capnp::Kind ObjectWithProperties<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* ObjectWithProperties<Object>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope ObjectWithProperties<Object>::_capnpPrivate::brandScopes[] = {
  { 0xabac22840c889893, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding ObjectWithProperties<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema ObjectWithProperties<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_abac22840c889893, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Object>
inline bool ObjectContainerForType<Object>::Reader::hasBasic() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectContainerForType<Object>::Builder::hasBasic() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Reader ObjectContainerForType<Object>::Reader::getBasic() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::getBasic() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::setBasic(typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::initBasic(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::adoptBasic(
    ::capnp::Orphan< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>> ObjectContainerForType<Object>::Builder::disownBasic() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::SingleObject<Object>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Object>
inline bool ObjectContainerForType<Object>::Reader::hasWithProperties() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectContainerForType<Object>::Builder::hasWithProperties() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Reader ObjectContainerForType<Object>::Reader::getWithProperties() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::getWithProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::setWithProperties(typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::initWithProperties(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::adoptWithProperties(
    ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>> ObjectContainerForType<Object>::Builder::disownWithProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties<Object>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Object>
inline bool ObjectContainerForType<Object>::Reader::hasArrays() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectContainerForType<Object>::Builder::hasArrays() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Reader ObjectContainerForType<Object>::Reader::getArrays() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::getArrays() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::setArrays(typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::initArrays(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::adoptArrays(
    ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>> ObjectContainerForType<Object>::Builder::disownArrays() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectArray<Object>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

template <typename Object>
inline bool ObjectContainerForType<Object>::Reader::hasArraysWithProperties() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool ObjectContainerForType<Object>::Builder::hasArraysWithProperties() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Reader ObjectContainerForType<Object>::Reader::getArraysWithProperties() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::getArraysWithProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::setArraysWithProperties(typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline typename  ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>::Builder ObjectContainerForType<Object>::Builder::initArraysWithProperties(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void ObjectContainerForType<Object>::Builder::adoptArraysWithProperties(
    ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>> ObjectContainerForType<Object>::Builder::disownArraysWithProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

// ObjectContainerForType<Object>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr uint16_t ObjectContainerForType<Object>::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t ObjectContainerForType<Object>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
constexpr ::capnp::Kind ObjectContainerForType<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* ObjectContainerForType<Object>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope ObjectContainerForType<Object>::_capnpPrivate::brandScopes[] = {
  { 0xb24841000c998eed, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding ObjectContainerForType<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Dependency ObjectContainerForType<Object>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::stream::layoutView::SingleObject<Object>::_capnpPrivate::brand() },
  { 16777217,  ::stream::layoutView::ObjectWithProperties<Object>::_capnpPrivate::brand() },
  { 16777218,  ::stream::layoutView::ObjectArray<Object>::_capnpPrivate::brand() },
  { 16777219,  ::stream::layoutView::ObjectWithProperties< ::stream::layoutView::ObjectArray<Object>>::_capnpPrivate::brand() },
};
template <typename Object>
const ::capnp::_::RawBrandedSchema ObjectContainerForType<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b24841000c998eed, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

inline  ::uint64_t Layer::Reader::getLayerId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Layer::Builder::getLayerId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setLayerId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Reader::hasRepetitions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasRepetitions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader Layer::Reader::getRepetitions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder Layer::Builder::getRepetitions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Layer::Builder::setRepetitions( ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder Layer::Builder::initRepetitions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Layer::Builder::adoptRepetitions(
    ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>> Layer::Builder::disownRepetitions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasBoxes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasBoxes() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Reader Layer::Reader::getBoxes() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Builder Layer::Builder::getBoxes() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Pipeline Layer::Pipeline::getBoxes() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setBoxes( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>::Builder Layer::Builder::initBoxes() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptBoxes(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>> Layer::Builder::disownBoxes() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Box>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasPolygons() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasPolygons() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Reader Layer::Reader::getPolygons() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Builder Layer::Builder::getPolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Pipeline Layer::Pipeline::getPolygons() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setPolygons( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>::Builder Layer::Builder::initPolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptPolygons(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>> Layer::Builder::disownPolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Polygon>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasSimplePolygons() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasSimplePolygons() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Reader Layer::Reader::getSimplePolygons() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Builder Layer::Builder::getSimplePolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Pipeline Layer::Pipeline::getSimplePolygons() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setSimplePolygons( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>::Builder Layer::Builder::initSimplePolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptSimplePolygons(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>> Layer::Builder::disownSimplePolygons() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::SimplePolygon>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasPaths() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasPaths() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Reader Layer::Reader::getPaths() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Builder Layer::Builder::getPaths() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Pipeline Layer::Pipeline::getPaths() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setPaths( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>::Builder Layer::Builder::initPaths() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptPaths(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>> Layer::Builder::disownPaths() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Path>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasLabels() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasLabels() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Reader Layer::Reader::getLabels() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Builder Layer::Builder::getLabels() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Pipeline Layer::Pipeline::getLabels() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setLabels( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>::Builder Layer::Builder::initLabels() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptLabels(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>> Layer::Builder::disownLabels() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Label>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Reader Layer::Reader::getEdges() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Builder Layer::Builder::getEdges() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Pipeline Layer::Pipeline::getEdges() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setEdges( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>::Builder Layer::Builder::initEdges() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptEdges(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>> Layer::Builder::disownEdges() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Edge>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasEdgePairs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasEdgePairs() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Reader Layer::Reader::getEdgePairs() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Builder Layer::Builder::getEdgePairs() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Pipeline Layer::Pipeline::getEdgePairs() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setEdgePairs( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>::Builder Layer::Builder::initEdgePairs() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptEdgePairs(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>> Layer::Builder::disownEdgePairs() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::EdgePair>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool Layer::Reader::hasPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Reader Layer::Reader::getPoints() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Builder Layer::Builder::getPoints() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Pipeline Layer::Pipeline::getPoints() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void Layer::Builder::setPoints( ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>::Builder Layer::Builder::initPoints() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void Layer::Builder::adoptPoints(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>> Layer::Builder::disownPoints() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::geometry::Point>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool CellTransformation::Reader::hasDisplacement() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CellTransformation::Builder::hasDisplacement() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Vector::Reader CellTransformation::Reader::getDisplacement() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Vector::Builder CellTransformation::Builder::getDisplacement() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Vector::Pipeline CellTransformation::Pipeline::getDisplacement() {
  return  ::stream::geometry::Vector::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CellTransformation::Builder::setDisplacement( ::stream::geometry::Vector::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Vector::Builder CellTransformation::Builder::initDisplacement() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CellTransformation::Builder::adoptDisplacement(
    ::capnp::Orphan< ::stream::geometry::Vector>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Vector> CellTransformation::Builder::disownDisplacement() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename CellTransformation::Transformation::Reader CellTransformation::Reader::getTransformation() const {
  return typename CellTransformation::Transformation::Reader(_reader);
}
inline typename CellTransformation::Transformation::Builder CellTransformation::Builder::getTransformation() {
  return typename CellTransformation::Transformation::Builder(_builder);
}
#if !CAPNP_LITE
inline typename CellTransformation::Transformation::Pipeline CellTransformation::Pipeline::getTransformation() {
  return typename CellTransformation::Transformation::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename CellTransformation::Transformation::Builder CellTransformation::Builder::initTransformation() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename CellTransformation::Transformation::Builder(_builder);
}
inline  ::stream::layoutView::CellTransformation::Transformation::Which CellTransformation::Transformation::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::stream::layoutView::CellTransformation::Transformation::Which CellTransformation::Transformation::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool CellTransformation::Transformation::Reader::isSimple() const {
  return which() == CellTransformation::Transformation::SIMPLE;
}
inline bool CellTransformation::Transformation::Builder::isSimple() {
  return which() == CellTransformation::Transformation::SIMPLE;
}
inline typename CellTransformation::Transformation::Simple::Reader CellTransformation::Transformation::Reader::getSimple() const {
  KJ_IREQUIRE((which() == CellTransformation::Transformation::SIMPLE),
              "Must check which() before get()ing a union member.");
  return typename CellTransformation::Transformation::Simple::Reader(_reader);
}
inline typename CellTransformation::Transformation::Simple::Builder CellTransformation::Transformation::Builder::getSimple() {
  KJ_IREQUIRE((which() == CellTransformation::Transformation::SIMPLE),
              "Must check which() before get()ing a union member.");
  return typename CellTransformation::Transformation::Simple::Builder(_builder);
}
inline typename CellTransformation::Transformation::Simple::Builder CellTransformation::Transformation::Builder::initSimple() {
  _builder.setDataField<CellTransformation::Transformation::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, CellTransformation::Transformation::SIMPLE);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  return typename CellTransformation::Transformation::Simple::Builder(_builder);
}
inline bool CellTransformation::Transformation::Reader::isComplex() const {
  return which() == CellTransformation::Transformation::COMPLEX;
}
inline bool CellTransformation::Transformation::Builder::isComplex() {
  return which() == CellTransformation::Transformation::COMPLEX;
}
inline typename CellTransformation::Transformation::Complex::Reader CellTransformation::Transformation::Reader::getComplex() const {
  KJ_IREQUIRE((which() == CellTransformation::Transformation::COMPLEX),
              "Must check which() before get()ing a union member.");
  return typename CellTransformation::Transformation::Complex::Reader(_reader);
}
inline typename CellTransformation::Transformation::Complex::Builder CellTransformation::Transformation::Builder::getComplex() {
  KJ_IREQUIRE((which() == CellTransformation::Transformation::COMPLEX),
              "Must check which() before get()ing a union member.");
  return typename CellTransformation::Transformation::Complex::Builder(_builder);
}
inline typename CellTransformation::Transformation::Complex::Builder CellTransformation::Transformation::Builder::initComplex() {
  _builder.setDataField<CellTransformation::Transformation::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, CellTransformation::Transformation::COMPLEX);
  _builder.setDataField<bool>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename CellTransformation::Transformation::Complex::Builder(_builder);
}
inline  ::stream::geometry::FixPointTransformation CellTransformation::Transformation::Simple::Reader::getOrientation() const {
  return _reader.getDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stream::geometry::FixPointTransformation CellTransformation::Transformation::Simple::Builder::getOrientation() {
  return _builder.getDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CellTransformation::Transformation::Simple::Builder::setOrientation( ::stream::geometry::FixPointTransformation value) {
  _builder.setDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double CellTransformation::Transformation::Complex::Reader::getAngle() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double CellTransformation::Transformation::Complex::Builder::getAngle() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CellTransformation::Transformation::Complex::Builder::setAngle(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool CellTransformation::Transformation::Complex::Reader::getMirror() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool CellTransformation::Transformation::Complex::Builder::getMirror() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CellTransformation::Transformation::Complex::Builder::setMirror(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double CellTransformation::Transformation::Complex::Reader::getScale() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double CellTransformation::Transformation::Complex::Builder::getScale() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CellTransformation::Transformation::Complex::Builder::setScale(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CellInstance::Reader::getCellId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CellInstance::Builder::getCellId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CellInstance::Builder::setCellId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CellInstance::Reader::hasTransformation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CellInstance::Builder::hasTransformation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::CellTransformation::Reader CellInstance::Reader::getTransformation() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::CellTransformation::Builder CellInstance::Builder::getTransformation() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::CellTransformation::Pipeline CellInstance::Pipeline::getTransformation() {
  return  ::stream::layoutView::CellTransformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CellInstance::Builder::setTransformation( ::stream::layoutView::CellTransformation::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::CellTransformation::Builder CellInstance::Builder::initTransformation() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CellInstance::Builder::adoptTransformation(
    ::capnp::Orphan< ::stream::layoutView::CellTransformation>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::CellTransformation> CellInstance::Builder::disownTransformation() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::CellTransformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LayoutView::Reader::hasBoundingBox() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool LayoutView::Builder::hasBoundingBox() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Box::Reader LayoutView::Reader::getBoundingBox() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Box>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Box::Builder LayoutView::Builder::getBoundingBox() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Box>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Box::Pipeline LayoutView::Pipeline::getBoundingBox() {
  return  ::stream::geometry::Box::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void LayoutView::Builder::setBoundingBox( ::stream::geometry::Box::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Box>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Box::Builder LayoutView::Builder::initBoundingBox() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Box>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void LayoutView::Builder::adoptBoundingBox(
    ::capnp::Orphan< ::stream::geometry::Box>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Box>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Box> LayoutView::Builder::disownBoundingBox() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Box>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool LayoutView::Reader::hasLayers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool LayoutView::Builder::hasLayers() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Reader LayoutView::Reader::getLayers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Builder LayoutView::Builder::getLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void LayoutView::Builder::setLayers( ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>::Builder LayoutView::Builder::initLayers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void LayoutView::Builder::adoptLayers(
    ::capnp::Orphan< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>> LayoutView::Builder::disownLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::layoutView::Layer,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool LayoutView::Reader::hasInstanceRepetitions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool LayoutView::Builder::hasInstanceRepetitions() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader LayoutView::Reader::getInstanceRepetitions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder LayoutView::Builder::getInstanceRepetitions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void LayoutView::Builder::setInstanceRepetitions( ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>::Builder LayoutView::Builder::initInstanceRepetitions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void LayoutView::Builder::adoptInstanceRepetitions(
    ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>> LayoutView::Builder::disownInstanceRepetitions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::repetition::Repetition,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool LayoutView::Reader::hasInstances() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool LayoutView::Builder::hasInstances() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Reader LayoutView::Reader::getInstances() const {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Builder LayoutView::Builder::getInstances() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Pipeline LayoutView::Pipeline::getInstances() {
  return  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void LayoutView::Builder::setInstances( ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>::Builder LayoutView::Builder::initInstances() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void LayoutView::Builder::adoptInstances(
    ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>&& value) {
  ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>> LayoutView::Builder::disownInstances() {
  return ::capnp::_::PointerHelpers< ::stream::layoutView::ObjectContainerForType< ::stream::layoutView::CellInstance>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

