<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Global Functions</title>
<keyword name="global"/>
<p>
Some functions are available on global level and can be used without any object.
Most of them are convenience functions that basically act on some default object
or provide function-like alternatives for the methods.
</p>
<h2-index/>
<a name="antenna_check"/><h2>"antenna_check" - Performs an antenna check</h2>
<keyword name="antenna_check"/>
<p>Usage:</p>
<ul>
<li><tt>antenna_check(gate, metal, ratio, [ diode_specs ... ])</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#antenna_check">Netter#antenna_check</a> for a description of that function.
</p>
<a name="bjt3"/><h2>"bjt3" - Supplies the BJT3 transistor extractor class</h2>
<keyword name="bjt3"/>
<p>Usage:</p>
<ul>
<li><tt>bjt3(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
bipolar junction transistor
</p><p>
See <class_doc href="DeviceExtractorBJT3Transistor">DeviceExtractorBJT3Transistor</class_doc> for more details
about this extractor.
</p>
<a name="bjt4"/><h2>"bjt4" - Supplies the BJT4 transistor extractor class</h2>
<keyword name="bjt4"/>
<p>Usage:</p>
<ul>
<li><tt>bjt4(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
bipolar junction transistor with a substrate terminal
</p><p>
See <class_doc href="DeviceExtractorBJT4Transistor">DeviceExtractorBJT4Transistor</class_doc> for more details
about this extractor.
</p>
<a name="box"/><h2>"box" - Creates a box object</h2>
<keyword name="box"/>
<p>Usage:</p>
<ul>
<li><tt>box(...)</tt></li>
</ul>
<p>
This function creates a box object. The arguments are the same than for the 
<class_doc href="DBox">DBox</class_doc> constructors.
</p>
<a name="capacitor"/><h2>"capacitor" - Supplies the capacitor extractor class</h2>
<keyword name="capacitor"/>
<p>Usage:</p>
<ul>
<li><tt>capacitor(name, area_cap)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a capacitor.
The area_cap argument is the capacitance in Farad per square micrometer.
</p><p>
See <class_doc href="DeviceExtractorCapacitor">DeviceExtractorCapacitor</class_doc> for more details
about this extractor.
</p>
<a name="capacitor_with_bulk"/><h2>"capacitor_with_bulk" - Supplies the capacitor extractor class that includes a bulk terminal</h2>
<keyword name="capacitor_with_bulk"/>
<p>Usage:</p>
<ul>
<li><tt>capacitor_with_bulk(name, area_cap)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a capacitor 
with a bulk terminal.
The area_cap argument is the capacitance in Farad per square micrometer.
</p><p>
See <class_doc href="DeviceExtractorCapacitorWithBulk">DeviceExtractorCapacitorWithBulk</class_doc> for more details
about this extractor.
</p>
<a name="cell"/><h2>"cell" - Selects a cell for input on the default source</h2>
<keyword name="cell"/>
<p>Usage:</p>
<ul>
<li><tt>cell(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#cell">Source#cell</a> for a description of that function.
In addition to the functionality described there, the global function will also send the output
to the specified cell.
</p><p>
The following code will select cell "MACRO" from the input layout:
</p><p>
<pre>
cell("MACRO")
# shapes now will be taken from cell "MACRO"
l1 = input(1, 0)
</pre>
</p>
<a name="cheat"/><h2>"cheat" - Hierarchy cheats</h2>
<keyword name="cheat"/>
<p>Usage:</p>
<ul>
<li><tt>cheat(args) { block }</tt></li>
</ul>
<p>
Hierarchy cheats can be used in deep mode to shortcut hierarchy evaluation
for certain cells and consider their local configuration only.
Cheats are useful for example when dealing with memory arrays. Often
such arrays are build from unit cells and those often overlap with their
neighbors. Now, if the hierarchical engine encounters such a situation, it
will first analyse all these interactions (which can be expensive) and then
it may come to the conclusion that boundary instances need to be handled
differently than inside instances. This in turn might lead to propagation of
shapes and in an LVS context to device externalisation: because some devices
might have different parameters for boundary cells than for inside cells, the
device instances can no longer be kept inside the unit cell. Specifically for
memory arrays, this is not desired as eventually this leads to flattening
of the whole array. 
</p><p>
The solution is to cheat: provided the unit cell is fully fledged and neighbors
do not disturb the unit cell's configuration in critical ways, the unit cell 
can be treated as being isolated and results are put together in the usual way.
</p><p>
Cheats can be applied on layout operations - specifically booleans - and device
extraction operations. Cheats are only effective in <a href="#deep">deep</a> mode.
</p><p>
For booleans, a cheat means that the cheating cell's boolean results are computed
locally and are combined afterwards. A cheat is introduced this way:
</p><p>
<pre>
deep

l1 = input(1, 0)
l2 = input(2, 0)

# usual booleans
l1and2 = l1 &amp; l2

# will compute "UNIT_CELL" isolated and everything else in normal hierarchical mode:
l1minus2 = cheat("UNIT_CELL) { l1 - l2 }
</pre>
</p><p>
The cheat block can also be wrapped in do .. end statements and can return multiple
layer objects:
</p><p>
<pre>
deep

l1 = input(1, 0)
l2 = input(2, 0)

# computes both AND and NOT of l1 and l2 with cheating for "UNIT_CELL"
l1and2, l1minus2 = cheat("UNIT_CELL) do
[ l1 &amp; l2, l1 - l2 ]
end
</pre>
</p><p>
(Technically, the cheat code block is a Ruby Proc and cannot create variables
outside its scope. Hence the results of this code block have to be passed
through the "cheat" method).
</p><p>
To apply cheats for device extraction, use the following scheme:
</p><p>
<pre>
deep

poly = input(1, 0)
active = input(2, 0)

sd = active - poly
gate = active &amp; poly

# device extraction with cheating for "UNIT_CELL":
cheat("UNIT_CELL") do
extract_devices(mos3("NMOS"), { "SD" =&gt; sd, "G" =&gt; gate, "tS" =&gt; sd, "tD" =&gt; sd, "tG" =&gt; poly }
end
</pre>
</p><p>
The argument to the cheat method is a list of cell name pattern (glob-style
pattern). For example:
</p><p>
<pre>
cheat("UNIT_CELL*") { ... }
cheat("UNIT_CELL1", "UNIT_CELL2") { ... }
cheat("UNIT_CELL{1,2}") { ... }
</pre>
</p><p>
For LVS applications, it's usually sufficient to cheat in the device extraction step. 
Cheats have been introduced in version 0.26.1.
</p>
<a name="clear_connections"/><h2>"clear_connections" - Clears all connections stored so far</h2>
<keyword name="clear_connections"/>
<p>Usage:</p>
<ul>
<li><tt>clear_connections</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#clear_connections">Netter#clear_connections</a> for a description of that function.
</p>
<a name="clip"/><h2>"clip" - Specifies clipped input on the default source</h2>
<keyword name="clip"/>
<p>Usage:</p>
<ul>
<li><tt>clip(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#clip">Source#clip</a> for a description of that function.
</p><p>
The following code will select shapes within a 500x600 micron rectangle (lower left corner at 0,0) 
from the input layout. The shapes will be clipped to that rectangle:
</p><p>
<pre>
clip(0.mm, 0.mm, 0.5.mm, 0.6.mm)
# shapes now will be taken from the given rectangle and clipped to it
l1 = input(1, 0)
</pre>
</p>
<a name="connect"/><h2>"connect" - Specifies a connection between two layers</h2>
<keyword name="connect"/>
<p>Usage:</p>
<ul>
<li><tt>connect(a, b)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect">Netter#connect</a> for a description of that function.
</p>
<a name="connect_global"/><h2>"connect_global" - Specifies a connection to a global net</h2>
<keyword name="connect_global"/>
<p>Usage:</p>
<ul>
<li><tt>connect_global(l, name)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect_global">Netter#connect_global</a> for a description of that function.
</p>
<a name="connect_implicit"/><h2>"connect_implicit" - Specifies a label pattern for implicit net connections</h2>
<keyword name="connect_implicit"/>
<p>Usage:</p>
<ul>
<li><tt>connect_implicit(label_pattern)</tt></li>
<li><tt>connect_implicit(cell_pattern, label_pattern)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect_implicit">Netter#connect_implicit</a> for a description of that function.
</p>
<a name="dbu"/><h2>"dbu" - Gets or sets the database unit to use</h2>
<keyword name="dbu"/>
<p>Usage:</p>
<ul>
<li><tt>dbu(dbu)</tt></li>
<li><tt>dbu</tt></li>
</ul>
<p>
Without any argument, this method gets the database unit
used inside the DRC engine. 
</p><p>
With an argument, sets the database unit used internally in the DRC engine.
Without using that method, the database unit is automatically
taken as the database unit of the last input. 
A specific database unit can be set in order to optimize
for two layouts (i.e. take the largest common denominator).
When the database unit is set, it must be set at the beginning
of the script and before any operation that uses it.
</p>
<a name="deep"/><h2>"deep" - Enters deep (hierarchical) mode</h2>
<keyword name="deep"/>
<p>Usage:</p>
<ul>
<li><tt>deep</tt></li>
</ul>
<p>
In deep mode, the operations will be performed in a hierarchical fashion. 
Sometimes this reduces the time and memory required for an operation, but this
will also add some overhead for the hierarchical analysis.
</p><p>
"deepness" is a property of layers. Layers created with "input" while in 
deep mode carry hierarchy. Operations involving such layers at the only
or the first argument are carried out in hierarchical mode. 
</p><p>
Hierarchical mode has some more implications, like "merged_semantics" being
implied always. Sometimes cell variants will be created.
</p><p>
Deep mode can be cancelled with <a href="#tiles">tiles</a> or <a href="#flat">flat</a>.
</p>
<a name="device_scaling"/><h2>"device_scaling" - Specifies a dimension scale factor for the geometrical device properties</h2>
<keyword name="device_scaling"/>
<p>Usage:</p>
<ul>
<li><tt>device_scaling(factor)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#device_scaling">Netter#device_scaling</a> for a description of that function.
</p>
<a name="diode"/><h2>"diode" - Supplies the diode extractor class</h2>
<keyword name="diode"/>
<p>Usage:</p>
<ul>
<li><tt>diode(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
planar diode 
</p><p>
See <class_doc href="DeviceExtractorDiode">DeviceExtractorDiode</class_doc> for more details
about this extractor.
</p>
<a name="dmos3"/><h2>"dmos3" - Supplies the DMOS3 transistor extractor class</h2>
<keyword name="dmos3"/>
<p>Usage:</p>
<ul>
<li><tt>dmos3(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
three-terminal DMOS transistor. A DMOS transistor is essentially
the same than a MOS transistor, but source and drain are 
separated.
</p><p>
See <class_doc href="DeviceExtractorMOS3Transistor">DeviceExtractorMOS3Transistor</class_doc> for more details
about this extractor (strict mode applies for 'dmos3').
</p>
<a name="dmos4"/><h2>"dmos4" - Supplies the MOS4 transistor extractor class</h2>
<keyword name="dmos4"/>
<p>Usage:</p>
<ul>
<li><tt>dmos4(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
four-terminal DMOS transistor. A DMOS transistor is essentially
the same than a MOS transistor, but source and drain are 
separated.
</p><p>
See <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc> for more details
about this extractor (strict mode applies for 'dmos4').
</p>
<a name="edge"/><h2>"edge" - Creates an edge object</h2>
<keyword name="edge"/>
<p>Usage:</p>
<ul>
<li><tt>edge(...)</tt></li>
</ul>
<p>
This function creates an edge object. The arguments are the same than for the 
<class_doc href="DEdge">DEdge</class_doc> constructors.
</p>
<a name="edge_layer"/><h2>"edge_layer" - Creates an empty edge layer</h2>
<keyword name="edge_layer"/>
<p>Usage:</p>
<ul>
<li><tt>edge_layer</tt></li>
</ul>
<p>
The intention of that method is to create an empty layer which can be 
filled with edge objects using <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
</p>
<a name="edge_pairs"/><h2>"edge_pairs" - Gets the edges from an original layer</h2>
<keyword name="edge_pairs"/>
<p>Usage:</p>
<ul>
<li><tt>edge_pairs(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#edge_pairs">Source#edge_pairs</a> for a description of that function.
</p>
<a name="edges"/><h2>"edges" - Gets the edges from an original layer</h2>
<keyword name="edges"/>
<p>Usage:</p>
<ul>
<li><tt>edges(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#edges">Source#edges</a> for a description of that function.
</p>
<a name="error"/><h2>"error" - Prints an error</h2>
<keyword name="error"/>
<p>Usage:</p>
<ul>
<li><tt>error(message)</tt></li>
</ul>
<p>
Similar to <a href="#log">log</a>, but the message is printed formatted as an error
</p>
<a name="extent"/><h2>"extent" - Creates a new layer with the bounding box of the default source</h2>
<keyword name="extent"/>
<p>Usage:</p>
<ul>
<li><tt>extent</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#extent">Source#extent</a> for a description of that function.
</p>
<a name="extract_devices"/><h2>"extract_devices" - Extracts devices for a given device extractor and device layer selection</h2>
<keyword name="extract_devices"/>
<p>Usage:</p>
<ul>
<li><tt>extract_devices(extractor, layer_hash)</tt></li>
<li><tt>extract_devices(extractor_class, name, layer_hash)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#extract_devices">Netter#extract_devices</a> for a description of that function.
</p>
<a name="flat"/><h2>"flat" - Disables tiling mode</h2>
<keyword name="flat"/>
<p>Usage:</p>
<ul>
<li><tt>flat</tt></li>
</ul>
<p>
Disables tiling mode. Tiling mode can be enabled again with <a href="#tiles">tiles</a> later.
</p>
<a name="info"/><h2>"info" - Outputs as message to the logger window</h2>
<keyword name="info"/>
<p>Usage:</p>
<ul>
<li><tt>info(message)</tt></li>
</ul>
<p>
Prints the message to the log window in verbose mode.
In non-verbose more, nothing is printed.
<a href="#log">log</a> is a function that always prints a message.
</p>
<a name="input"/><h2>"input" - Fetches the shapes from the specified input from the default source</h2>
<keyword name="input"/>
<p>Usage:</p>
<ul>
<li><tt>input(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#input">Source#input</a> for a description of that function. This method will fetch
polygons and labels. See <a href="#polygons">polygons</a> and <a href="#labels">labels</a> for more specific versions of
this method.
</p>
<a name="is_deep?"/><h2>"is_deep?" - Returns true, if in deep mode</h2>
<keyword name="is_deep?"/>
<p>Usage:</p>
<ul>
<li><tt>is_deep?</tt></li>
</ul>
<a name="is_tiled?"/><h2>"is_tiled?" - Returns true, if in tiled mode</h2>
<keyword name="is_tiled?"/>
<p>Usage:</p>
<ul>
<li><tt>is_tiled?</tt></li>
</ul>
<a name="l2n_data"/><h2>"l2n_data" - Gets the internal <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object for the default <a href="#Netter">Netter</a></h2>
<keyword name="l2n_data"/>
<p>Usage:</p>
<ul>
<li><tt>l2n_data</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#l2n_data">Netter#l2n_data</a> for a description of that function.
</p>
<a name="labels"/><h2>"labels" - Gets the labels (text) from an original layer</h2>
<keyword name="labels"/>
<p>Usage:</p>
<ul>
<li><tt>labels(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#labels">Source#labels</a> for a description of that function.
</p>
<a name="layers"/><h2>"layers" - Gets the layers contained in the default source</h2>
<keyword name="layers"/>
<p>Usage:</p>
<ul>
<li><tt>layers</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#layers">Source#layers</a> for a description of that function.
</p>
<a name="layout"/><h2>"layout" - Specifies an additional layout for the input source.</h2>
<keyword name="layout"/>
<p>Usage:</p>
<ul>
<li><tt>layout</tt></li>
<li><tt>layout(what)</tt></li>
</ul>
<p>
This function can be used to specify a new layout for input.
It returns an Source object representing that layout. The "input" method
of that object can be used to get input layers for that layout.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" specifying input from a cellview in the current view </li>
<li>A layout filename plus an optional cell name </li>
<li>A <class_doc href="Layout">Layout</class_doc> object </li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Without any arguments the default layout is returned.
</p><p>
If a file name is given, a cell name can be specified as the second argument.
If not, the top cell is taken which must be unique in that case.
</p><p>
Having specified a layout for input enables to use the input method
for getting input:
</p><p>
<pre>
# XOR between layers 1 or the default input and "second_layout.gds":
l2 = layout("second_layout.gds")
(input(1, 0) ^ l2.input(1, 0)).output(100, 0)
</pre>
</p><p>
For further methods on the source object see <a href="#Source">Source</a>.
</p>
<a name="log"/><h2>"log" - Outputs as message to the logger window</h2>
<keyword name="log"/>
<p>Usage:</p>
<ul>
<li><tt>log(message)</tt></li>
</ul>
<p>
Prints the message to the log window.
<a href="#info">info</a> is a function that prints a message only if 
verbose mode is enabled.
</p>
<a name="log_file"/><h2>"log_file" - Specify the log file where to send to log to</h2>
<keyword name="log_file"/>
<p>Usage:</p>
<ul>
<li><tt>log_file(filename)</tt></li>
</ul>
<p>
After using that method, the log output is sent to the 
given file instead of the logger window or the terminal.
</p>
<a name="make_layer"/><h2>"make_layer" - Creates an empty polygon layer based on the hierarchical scheme selected</h2>
<keyword name="make_layer"/>
<p>Usage:</p>
<ul>
<li><tt>make_layer</tt></li>
</ul>
<p>
The intention of this method is to provide an empty polygon layer based on the
hierarchical scheme selected. This will create a new layer with the hierarchy
of the current layout in deep mode and a flat layer in flat mode.
This method is similar to <a href="#polygon_layer">polygon_layer</a>, but the latter does not create
a hierarchical layer. Hence the layer created by <a href="#make_layer">make_layer</a> is suitable
for use in device extraction for example, while the one
delivered by <a href="#polygon_layer">polygon_layer</a> is not.
</p><p>
On the other hand, a layer created by the <a href="#make_layer">make_layer</a> method is not intended to be
filled with <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
</p>
<a name="mos3"/><h2>"mos3" - Supplies the MOS3 transistor extractor class</h2>
<keyword name="mos3"/>
<p>Usage:</p>
<ul>
<li><tt>mos3(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
three-terminal MOS transistor.
</p><p>
See <class_doc href="DeviceExtractorMOS3Transistor">DeviceExtractorMOS3Transistor</class_doc> for more details
about this extractor (non-strict mode applies for 'mos3').
</p>
<a name="mos4"/><h2>"mos4" - Supplies the MOS4 transistor extractor class</h2>
<keyword name="mos4"/>
<p>Usage:</p>
<ul>
<li><tt>mos4(name)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
four-terminal MOS transistor.
</p><p>
See <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc> for more details
about this extractor (non-strict mode applies for 'mos4').
</p>
<a name="netlist"/><h2>"netlist" - Obtains the extracted netlist from the default <a href="#Netter">Netter</a></h2>
<keyword name="netlist"/>
<p>
The netlist is a <class_doc href="Netlist">Netlist</class_doc> object. If no netlist is extracted 
yet, this method will trigger the extraction process.
See <a href="/about/drc_ref_netter.xml#netlist">Netter#netlist</a> for a description of this function.
</p>
<a name="netter"/><h2>"netter" - Creates a new netter object</h2>
<keyword name="netter"/>
<p>Usage:</p>
<ul>
<li><tt>netter</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml">Netter</a> for more details
</p>
<a name="no_borders"/><h2>"no_borders" - Reset the tile borders</h2>
<keyword name="no_borders"/>
<p>Usage:</p>
<ul>
<li><tt>no_borders</tt></li>
</ul>
<p>
Resets the tile borders - see <a href="#tile_borders">tile_borders</a> for a description of tile borders.
</p>
<a name="output"/><h2>"output" - Outputs a layer to the report database or output layout</h2>
<keyword name="output"/>
<p>Usage:</p>
<ul>
<li><tt>output(layer, args)</tt></li>
</ul>
<p>
This function is equivalent to "layer.output(args)". See <a href="/about/drc_ref_layer.xml#output">Layer#output</a> for details about this function.
</p>
<a name="output_cell"/><h2>"output_cell" - Specifies a target cell, but does not change the target layout</h2>
<keyword name="output_cell"/>
<p>Usage:</p>
<ul>
<li><tt>output_cell(cellname)</tt></li>
</ul>
<p>
This method switches output to the specified cell, but does not
change the target layout nor does it switch the output channel to
layout if is report database. 
</p>
<a name="p"/><h2>"p" - Creates a point object</h2>
<keyword name="p"/>
<p>Usage:</p>
<ul>
<li><tt>p(x, y)</tt></li>
</ul>
<p>
A point is not a valid object by itself, but it is useful for creating 
paths for polygons:
</p><p>
<pre>
x = polygon_layer
x.insert(polygon([ p(0, 0), p(16.0, 0), p(8.0, 8.0) ]))
</pre>
</p>
<a name="path"/><h2>"path" - Creates a path object</h2>
<keyword name="path"/>
<p>Usage:</p>
<ul>
<li><tt>path(...)</tt></li>
</ul>
<p>
This function creates a path object. The arguments are the same than for the 
<class_doc href="DPath">DPath</class_doc> constructors.
</p>
<a name="polygon"/><h2>"polygon" - Creates a polygon object</h2>
<keyword name="polygon"/>
<p>Usage:</p>
<ul>
<li><tt>polygon(...)</tt></li>
</ul>
<p>
This function creates a polygon object. The arguments are the same than for the 
<class_doc href="DPolygon">DPolygon</class_doc> constructors.
</p>
<a name="polygon_layer"/><h2>"polygon_layer" - Creates an empty polygon layer</h2>
<keyword name="polygon_layer"/>
<p>Usage:</p>
<ul>
<li><tt>polygon_layer</tt></li>
</ul>
<p>
The intention of that method is to create an empty layer which can be 
filled with polygon-like objects using <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
A similar method which creates a hierarchical layer in deep mode is 
<a href="#make_layer">make_layer</a>. This other layer is better suited for use with device extraction.
</p>
<a name="polygons"/><h2>"polygons" - Fetches the polygons (or shapes that can be converted to polygons) from the specified input from the default source</h2>
<keyword name="polygons"/>
<p>Usage:</p>
<ul>
<li><tt>polygons(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#polygons">Source#polygons</a> for a description of that function.
</p>
<a name="report"/><h2>"report" - Specifies a report database for output</h2>
<keyword name="report"/>
<p>Usage:</p>
<ul>
<li><tt>report(description [, filename [, cellname ] ])</tt></li>
</ul>
<p>
After specifying a report database for output, <a href="#output">output</a> method calls are redirected to
the report database. The format of the <a href="#output">output</a> calls changes and a category name plus
description can be specified rather than a layer/datatype number of layer name.
See the description of the output method for details.
</p><p>
If a filename is given, the report database will be written to the specified file name.
Otherwise it will be shown but not written.
</p><p>
If external input is specified with <a href="#source">source</a>, 
"report" must be called after "source".
</p><p>
The cellname specifies the top cell used for the report file.
By default this is the cell name of the default source. If there
is no source layout you'll need to give the cell name in the 
third parameter.
</p>
<a name="report_netlist"/><h2>"report_netlist" - Specifies an extracted netlist report for output</h2>
<keyword name="report_netlist"/>
<p>Usage:</p>
<ul>
<li><tt>report_netlist([ filename [, long ] ])</tt></li>
</ul>
<p>
This method applies to runsets creating a netlist through
extraction. Extraction happens when connections and/or device
extractions are made. If this statement is used, the extracted
netlist plus the net and device shapes are turned into a 
layout-to-netlist report (L2N database) and shown in the 
netlist browser window. If a file name is given, the report
will also be written to the given file.
If a file name is given and "long" is true, a verbose 
version of the L2N DB format will be used.
</p>
<a name="resistor"/><h2>"resistor" - Supplies the resistor extractor class</h2>
<keyword name="resistor"/>
<p>Usage:</p>
<ul>
<li><tt>resistor(name, sheet_rho)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a resistor.
</p><p>
The sheet_rho value is the sheet resistance in ohms/square. It is used
to compute the resistance from the geometry.
</p><p>
See <class_doc href="DeviceExtractorResistor">DeviceExtractorResistor</class_doc> for more details
about this extractor.
</p>
<a name="resistor_with_bulk"/><h2>"resistor_with_bulk" - Supplies the resistor extractor class that includes a bulk terminal</h2>
<keyword name="resistor_with_bulk"/>
<p>Usage:</p>
<ul>
<li><tt>resistor_with_bulk(name, sheet_rho)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a resistor 
with a bulk terminal.
The sheet_rho value is the sheet resistance in ohms/square.
</p><p>
See <class_doc href="DeviceExtractorResistorWithBulk">DeviceExtractorResistorWithBulk</class_doc> for more details
about this extractor.
</p>
<a name="select"/><h2>"select" - Specifies cell filters on the default source</h2>
<keyword name="select"/>
<p>Usage:</p>
<ul>
<li><tt>select(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#select">Source#select</a> for a description of that function.
</p>
<a name="silent"/><h2>"silent" - Resets verbose mode</h2>
<keyword name="silent"/>
<p>Usage:</p>
<ul>
<li><tt>silent</tt></li>
</ul>
<p>
This function is equivalent to "verbose(false)" (see <a href="#verbose">verbose</a>)
</p>
<a name="source"/><h2>"source" - Specifies a source layout</h2>
<keyword name="source"/>
<p>Usage:</p>
<ul>
<li><tt>source</tt></li>
<li><tt>source(what)</tt></li>
</ul>
<p>
This function replaces the default source layout by the specified
file. If this function is not used, the currently active layout 
is used as input. 
</p><p>
<a href="#layout">layout</a> is a similar method which specifies <i>a additional </i>input layout.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" specifying input from a layout in the current panel </li>
<li>A layout filename plus an optional cell name</li>
<li>A <class_doc href="Layout">Layout</class_doc> object plus an optional cell name</li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Without any arguments the default layout is returned. If a filename is given, a cell name
can be specified as the second argument. If none is specified, the top cell is taken which
must be unique in that case.
</p><p>
<pre>
# XOR between layers 1 of "first_layout.gds" and "second_layout.gds" and sends the results to "xor_layout.gds":
target("xor_layout.gds")
source("first_layout.gds")
l2 = layout("second_layout.gds")
(input(1, 0) ^ l2.input(1, 0)).output(100, 0)
</pre>
</p><p>
For further methods on the source object see <a href="#Source">Source</a>.
</p>
<a name="target"/><h2>"target" - Specify the target layout</h2>
<keyword name="target"/>
<p>Usage:</p>
<ul>
<li><tt>target(what [, cellname])</tt></li>
</ul>
<p>
This function can be used to specify a target layout for output.
Subsequent calls of "output" will send their results to that target
layout. Using "target" will disable output to a report database.
If any target was specified before, that target will be closed and 
a new target will be set up.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" (n is an integer) specifying output to a layout in the current panel </li>
<li>A string "@+" specifying output to a new layout in the current panel </li>
<li>A layout filename </li>
<li>A <class_doc href="Layout">Layout</class_doc> object </li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Except if the argument is a <class_doc href="Cell">Cell</class_doc> object, a cellname can be specified 
stating the cell name under which the results are saved. If no cellname is 
specified, either the current cell or "TOP" is used.
</p>
<a name="target_netlist"/><h2>"target_netlist" - With this statement, an extracted netlist is finally written to a file</h2>
<keyword name="target_netlist"/>
<p>Usage:</p>
<ul>
<li><tt>target_netlist(filename [, format [, comment ] ])</tt></li>
</ul>
<p>
This method applies to runsets creating a netlist through
extraction. Extraction happens when connections and/or device
extractions are made. If this statement is used, the extracted
netlist is written to the given file.
</p><p>
The format parameter specifies the writer to use. You can use nil
to use the standard format or produce a SPICE writer with <a href="#write_spice">write_spice</a>.
See <a href="#write_spice">write_spice</a> for more details.
</p>
<a name="threads"/><h2>"threads" - Specifies the number of CPU cores to use in tiling mode</h2>
<keyword name="threads"/>
<p>Usage:</p>
<ul>
<li><tt>threads(n)</tt></li>
</ul>
<p>
If using threads, tiles are distributed on multiple CPU cores for
parallelization. Still, all tiles must be processed before the 
operation proceeds with the next statement.
</p>
<a name="tile_borders"/><h2>"tile_borders" - Specifies a minimum tile border</h2>
<keyword name="tile_borders"/>
<p>Usage:</p>
<ul>
<li><tt>tile_border(b)</tt></li>
<li><tt>tile_border(bx, by)</tt></li>
</ul>
<p>
The tile border specifies the distance to which shapes are collected into the 
tile. In order words, when processing a tile, shapes within the border distance
participate in the operations.
</p><p>
For some operations such as booleans (<a href="#and">and</a>, <a href="#or">or</a>, ...), <a href="#size">size</a> and the DRC functions (<a href="#width">width</a>, <a href="#space">space</a>, ...)
a tile border is automatically established. For other operations such as <a href="#with_area">with_area</a>
or <a href="#edges">edges</a>, the exact distance is unknown, because such operations may have a long range.
In that cases, no border is used. The tile_borders function may be used to specify a minimum border
which is used in that case. That allows taking into account at least shapes within the 
given range, although not necessarily all.
</p><p>
To reset the tile borders, use <a href="#no_borders">no_borders</a> or "tile_borders(nil)".
</p>
<a name="tiles"/><h2>"tiles" - Specifies tiling</h2>
<keyword name="tiles"/>
<p>Usage:</p>
<ul>
<li><tt>tiles(t)</tt></li>
<li><tt>tiles(w, h)</tt></li>
</ul>
<p>
Specifies tiling mode. In tiling mode, the DRC operations are evaluated in tiles
with width w and height h. With one argument, square tiles with width and height
t are used.
</p><p>
Special care must be taken when using tiling mode, since some operations may not
behave as expected at the borders of the tile. Tiles can be made overlapping by
specifying a tile border dimension with <a href="#tile_borders">tile_borders</a>. Some operations like sizing,
the DRC functions specify a tile border implicitly. Other operations without a
defined range won't do so and the consequences of tiling mode can be difficult to
predict.
</p><p>
In tiling mode, the memory requirements are usually smaller (depending on the 
choice of the tile size) and multi-CPU support is enabled (see <a href="#threads">threads</a>).
To disable tiling mode use <a href="#flat">flat</a> or <a href="#deep">deep</a>. 
</p><p>
Tiling mode will disable deep mode (see <a href="#deep">deep</a>).
</p>
<a name="verbose"/><h2>"verbose" - Sets or resets verbose mode</h2>
<keyword name="verbose"/>
<p>Usage:</p>
<ul>
<li><tt>verbose</tt></li>
<li><tt>verbose(m)</tt></li>
</ul>
<p>
In verbose mode, more output is generated in the log file
</p>
<a name="verbose?"/><h2>"verbose?" - Returns true, if verbose mode is enabled</h2>
<keyword name="verbose?"/>
<p>Usage:</p>
<ul>
<li><tt>verbose?</tt></li>
</ul>
<p>
In verbose mode, more output is generated in the log file
</p>
<a name="write_spice"/><h2>"write_spice" - Defines SPICE output format (with options)</h2>
<keyword name="write_spice"/>
<p>Usage:</p>
<ul>
<li><tt>write_spice([ use_net_names [, with_comments ] ])</tt></li>
</ul>
<p>
Use this option in <a href="#target_netlist">target_netlist</a> for the format parameter to 
specify SPICE format.
"use_net_names" and "with_comments" are boolean parameters indicating
whether to use named nets (numbers if false) and whether to add 
information comments such as instance coordinates or pin names.
</p>
</doc>
