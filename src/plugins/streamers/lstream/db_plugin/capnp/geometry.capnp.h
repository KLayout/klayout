// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: geometry.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(cca8143497519117);
enum class FixPointTransformation_cca8143497519117: uint16_t {
  R0,
  R90,
  R180,
  R270,
  M0,
  M45,
  M90,
  M135,
};
CAPNP_DECLARE_ENUM(FixPointTransformation, cca8143497519117);
CAPNP_DECLARE_SCHEMA(c3ea9d0d831017a9);
CAPNP_DECLARE_SCHEMA(a216252a878a7c50);
CAPNP_DECLARE_SCHEMA(b07a0bb15b04919e);
CAPNP_DECLARE_SCHEMA(d3ad7560ad4c7c5a);
CAPNP_DECLARE_SCHEMA(dc8843c995bed8b6);
CAPNP_DECLARE_SCHEMA(8566986b2d886668);
CAPNP_DECLARE_SCHEMA(818abff899400735);
CAPNP_DECLARE_SCHEMA(87a09f9a2b840501);
CAPNP_DECLARE_SCHEMA(c9439219800da364);
CAPNP_DECLARE_SCHEMA(ad1ff7a5ee171f7d);
enum class ExtensionType_ad1ff7a5ee171f7d: uint16_t {
  FLUSH,
  SQUARE,
  ROUND,
  VARIABLE,
};
CAPNP_DECLARE_ENUM(ExtensionType, ad1ff7a5ee171f7d);
CAPNP_DECLARE_SCHEMA(c8862d8266738466);
CAPNP_DECLARE_SCHEMA(945ce57d8c1d17c9);
enum class HAlignment_945ce57d8c1d17c9: uint16_t {
  LEFT,
  CENTER,
  RIGHT,
};
CAPNP_DECLARE_ENUM(HAlignment, 945ce57d8c1d17c9);
CAPNP_DECLARE_SCHEMA(9ca475dd52948aa1);
enum class VAlignment_9ca475dd52948aa1: uint16_t {
  BOTTOM,
  CENTER,
  TOP,
};
CAPNP_DECLARE_ENUM(VAlignment, 9ca475dd52948aa1);

}  // namespace schemas
}  // namespace capnp

namespace stream {
namespace geometry {

typedef ::capnp::schemas::FixPointTransformation_cca8143497519117 FixPointTransformation;

struct Vector {
  Vector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3ea9d0d831017a9, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point {
  Point() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a216252a878a7c50, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Box {
  Box() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b07a0bb15b04919e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Edge {
  Edge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d3ad7560ad4c7c5a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct EdgePair {
  EdgePair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc8843c995bed8b6, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Contour {
  Contour() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8566986b2d886668, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SimplePolygon {
  SimplePolygon() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(818abff899400735, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Polygon {
  Polygon() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(87a09f9a2b840501, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Path {
  Path() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::ExtensionType_ad1ff7a5ee171f7d ExtensionType;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9439219800da364, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Label {
  Label() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::HAlignment_945ce57d8c1d17c9 HAlignment;

  typedef ::capnp::schemas::VAlignment_9ca475dd52948aa1 VAlignment;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8862d8266738466, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Vector::Reader {
public:
  typedef Vector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getDx() const;

  inline  ::int64_t getDy() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector::Builder {
public:
  typedef Vector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getDx();
  inline void setDx( ::int64_t value);

  inline  ::int64_t getDy();
  inline void setDy( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector::Pipeline {
public:
  typedef Vector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point::Reader {
public:
  typedef Point Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getX() const;

  inline  ::int64_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point::Builder {
public:
  typedef Point Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getX();
  inline void setX( ::int64_t value);

  inline  ::int64_t getY();
  inline void setY( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point::Pipeline {
public:
  typedef Point Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Box::Reader {
public:
  typedef Box Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP1() const;
  inline  ::stream::geometry::Point::Reader getP1() const;

  inline bool hasDelta() const;
  inline  ::stream::geometry::Vector::Reader getDelta() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Box::Builder {
public:
  typedef Box Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP1();
  inline  ::stream::geometry::Point::Builder getP1();
  inline void setP1( ::stream::geometry::Point::Reader value);
  inline  ::stream::geometry::Point::Builder initP1();
  inline void adoptP1(::capnp::Orphan< ::stream::geometry::Point>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Point> disownP1();

  inline bool hasDelta();
  inline  ::stream::geometry::Vector::Builder getDelta();
  inline void setDelta( ::stream::geometry::Vector::Reader value);
  inline  ::stream::geometry::Vector::Builder initDelta();
  inline void adoptDelta(::capnp::Orphan< ::stream::geometry::Vector>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Vector> disownDelta();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Box::Pipeline {
public:
  typedef Box Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Point::Pipeline getP1();
  inline  ::stream::geometry::Vector::Pipeline getDelta();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Edge::Reader {
public:
  typedef Edge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP1() const;
  inline  ::stream::geometry::Point::Reader getP1() const;

  inline bool hasDelta() const;
  inline  ::stream::geometry::Vector::Reader getDelta() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Edge::Builder {
public:
  typedef Edge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP1();
  inline  ::stream::geometry::Point::Builder getP1();
  inline void setP1( ::stream::geometry::Point::Reader value);
  inline  ::stream::geometry::Point::Builder initP1();
  inline void adoptP1(::capnp::Orphan< ::stream::geometry::Point>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Point> disownP1();

  inline bool hasDelta();
  inline  ::stream::geometry::Vector::Builder getDelta();
  inline void setDelta( ::stream::geometry::Vector::Reader value);
  inline  ::stream::geometry::Vector::Builder initDelta();
  inline void adoptDelta(::capnp::Orphan< ::stream::geometry::Vector>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Vector> disownDelta();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Edge::Pipeline {
public:
  typedef Edge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Point::Pipeline getP1();
  inline  ::stream::geometry::Vector::Pipeline getDelta();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class EdgePair::Reader {
public:
  typedef EdgePair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasE1() const;
  inline  ::stream::geometry::Edge::Reader getE1() const;

  inline bool hasE2() const;
  inline  ::stream::geometry::Edge::Reader getE2() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class EdgePair::Builder {
public:
  typedef EdgePair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasE1();
  inline  ::stream::geometry::Edge::Builder getE1();
  inline void setE1( ::stream::geometry::Edge::Reader value);
  inline  ::stream::geometry::Edge::Builder initE1();
  inline void adoptE1(::capnp::Orphan< ::stream::geometry::Edge>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Edge> disownE1();

  inline bool hasE2();
  inline  ::stream::geometry::Edge::Builder getE2();
  inline void setE2( ::stream::geometry::Edge::Reader value);
  inline  ::stream::geometry::Edge::Builder initE2();
  inline void adoptE2(::capnp::Orphan< ::stream::geometry::Edge>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Edge> disownE2();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class EdgePair::Pipeline {
public:
  typedef EdgePair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Edge::Pipeline getE1();
  inline  ::stream::geometry::Edge::Pipeline getE2();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Contour::Reader {
public:
  typedef Contour Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP1() const;
  inline  ::stream::geometry::Point::Reader getP1() const;

  inline bool hasDeltas() const;
  inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Reader getDeltas() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Contour::Builder {
public:
  typedef Contour Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP1();
  inline  ::stream::geometry::Point::Builder getP1();
  inline void setP1( ::stream::geometry::Point::Reader value);
  inline  ::stream::geometry::Point::Builder initP1();
  inline void adoptP1(::capnp::Orphan< ::stream::geometry::Point>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Point> disownP1();

  inline bool hasDeltas();
  inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Builder getDeltas();
  inline void setDeltas( ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Builder initDeltas(unsigned int size);
  inline void adoptDeltas(::capnp::Orphan< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>> disownDeltas();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Contour::Pipeline {
public:
  typedef Contour Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Point::Pipeline getP1();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SimplePolygon::Reader {
public:
  typedef SimplePolygon Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHull() const;
  inline  ::stream::geometry::Contour::Reader getHull() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SimplePolygon::Builder {
public:
  typedef SimplePolygon Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHull();
  inline  ::stream::geometry::Contour::Builder getHull();
  inline void setHull( ::stream::geometry::Contour::Reader value);
  inline  ::stream::geometry::Contour::Builder initHull();
  inline void adoptHull(::capnp::Orphan< ::stream::geometry::Contour>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Contour> disownHull();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SimplePolygon::Pipeline {
public:
  typedef SimplePolygon Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Contour::Pipeline getHull();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Polygon::Reader {
public:
  typedef Polygon Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHull() const;
  inline  ::stream::geometry::Contour::Reader getHull() const;

  inline bool hasHoles() const;
  inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Reader getHoles() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Polygon::Builder {
public:
  typedef Polygon Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHull();
  inline  ::stream::geometry::Contour::Builder getHull();
  inline void setHull( ::stream::geometry::Contour::Reader value);
  inline  ::stream::geometry::Contour::Builder initHull();
  inline void adoptHull(::capnp::Orphan< ::stream::geometry::Contour>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Contour> disownHull();

  inline bool hasHoles();
  inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Builder getHoles();
  inline void setHoles( ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Builder initHoles(unsigned int size);
  inline void adoptHoles(::capnp::Orphan< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>> disownHoles();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Polygon::Pipeline {
public:
  typedef Polygon Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Contour::Pipeline getHull();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Path::Reader {
public:
  typedef Path Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSpine() const;
  inline  ::stream::geometry::Contour::Reader getSpine() const;

  inline  ::uint64_t getHalfWidth() const;

  inline  ::int64_t getBeginExtension() const;

  inline  ::int64_t getEndExtension() const;

  inline  ::stream::geometry::Path::ExtensionType getExtensionType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Path::Builder {
public:
  typedef Path Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSpine();
  inline  ::stream::geometry::Contour::Builder getSpine();
  inline void setSpine( ::stream::geometry::Contour::Reader value);
  inline  ::stream::geometry::Contour::Builder initSpine();
  inline void adoptSpine(::capnp::Orphan< ::stream::geometry::Contour>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Contour> disownSpine();

  inline  ::uint64_t getHalfWidth();
  inline void setHalfWidth( ::uint64_t value);

  inline  ::int64_t getBeginExtension();
  inline void setBeginExtension( ::int64_t value);

  inline  ::int64_t getEndExtension();
  inline void setEndExtension( ::int64_t value);

  inline  ::stream::geometry::Path::ExtensionType getExtensionType();
  inline void setExtensionType( ::stream::geometry::Path::ExtensionType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Path::Pipeline {
public:
  typedef Path Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Contour::Pipeline getSpine();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Label::Reader {
public:
  typedef Label Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::stream::geometry::Point::Reader getPosition() const;

  inline  ::stream::geometry::FixPointTransformation getOrientation() const;

  inline  ::uint64_t getStringId() const;

  inline  ::stream::geometry::Label::HAlignment getHorizontalAlign() const;

  inline  ::stream::geometry::Label::VAlignment getVerticalAlign() const;

  inline bool hasDisplayOffset() const;
  inline  ::stream::geometry::Vector::Reader getDisplayOffset() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Label::Builder {
public:
  typedef Label Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::stream::geometry::Point::Builder getPosition();
  inline void setPosition( ::stream::geometry::Point::Reader value);
  inline  ::stream::geometry::Point::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::stream::geometry::Point>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Point> disownPosition();

  inline  ::stream::geometry::FixPointTransformation getOrientation();
  inline void setOrientation( ::stream::geometry::FixPointTransformation value);

  inline  ::uint64_t getStringId();
  inline void setStringId( ::uint64_t value);

  inline  ::stream::geometry::Label::HAlignment getHorizontalAlign();
  inline void setHorizontalAlign( ::stream::geometry::Label::HAlignment value);

  inline  ::stream::geometry::Label::VAlignment getVerticalAlign();
  inline void setVerticalAlign( ::stream::geometry::Label::VAlignment value);

  inline bool hasDisplayOffset();
  inline  ::stream::geometry::Vector::Builder getDisplayOffset();
  inline void setDisplayOffset( ::stream::geometry::Vector::Reader value);
  inline  ::stream::geometry::Vector::Builder initDisplayOffset();
  inline void adoptDisplayOffset(::capnp::Orphan< ::stream::geometry::Vector>&& value);
  inline ::capnp::Orphan< ::stream::geometry::Vector> disownDisplayOffset();

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Label::Pipeline {
public:
  typedef Label Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stream::geometry::Point::Pipeline getPosition();
  inline  ::stream::geometry::Vector::Pipeline getDisplayOffset();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int64_t Vector::Reader::getDx() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Vector::Builder::getDx() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector::Builder::setDx( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Vector::Reader::getDy() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Vector::Builder::getDy() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector::Builder::setDy( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Point::Reader::getX() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Point::Builder::getX() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setX( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Point::Reader::getY() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Point::Builder::getY() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setY( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Box::Reader::hasP1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Box::Builder::hasP1() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Point::Reader Box::Reader::getP1() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Point::Builder Box::Builder::getP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Point::Pipeline Box::Pipeline::getP1() {
  return  ::stream::geometry::Point::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Box::Builder::setP1( ::stream::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Point::Builder Box::Builder::initP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Box::Builder::adoptP1(
    ::capnp::Orphan< ::stream::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Point> Box::Builder::disownP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Box::Reader::hasDelta() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Box::Builder::hasDelta() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Vector::Reader Box::Reader::getDelta() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Vector::Builder Box::Builder::getDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Vector::Pipeline Box::Pipeline::getDelta() {
  return  ::stream::geometry::Vector::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Box::Builder::setDelta( ::stream::geometry::Vector::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Vector::Builder Box::Builder::initDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Box::Builder::adoptDelta(
    ::capnp::Orphan< ::stream::geometry::Vector>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Vector> Box::Builder::disownDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Edge::Reader::hasP1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasP1() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Point::Reader Edge::Reader::getP1() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Point::Builder Edge::Builder::getP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Point::Pipeline Edge::Pipeline::getP1() {
  return  ::stream::geometry::Point::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setP1( ::stream::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Point::Builder Edge::Builder::initP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptP1(
    ::capnp::Orphan< ::stream::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Point> Edge::Builder::disownP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Edge::Reader::hasDelta() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasDelta() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Vector::Reader Edge::Reader::getDelta() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Vector::Builder Edge::Builder::getDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Vector::Pipeline Edge::Pipeline::getDelta() {
  return  ::stream::geometry::Vector::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setDelta( ::stream::geometry::Vector::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Vector::Builder Edge::Builder::initDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptDelta(
    ::capnp::Orphan< ::stream::geometry::Vector>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Vector> Edge::Builder::disownDelta() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool EdgePair::Reader::hasE1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool EdgePair::Builder::hasE1() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Edge::Reader EdgePair::Reader::getE1() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Edge::Builder EdgePair::Builder::getE1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Edge::Pipeline EdgePair::Pipeline::getE1() {
  return  ::stream::geometry::Edge::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void EdgePair::Builder::setE1( ::stream::geometry::Edge::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Edge::Builder EdgePair::Builder::initE1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void EdgePair::Builder::adoptE1(
    ::capnp::Orphan< ::stream::geometry::Edge>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Edge> EdgePair::Builder::disownE1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool EdgePair::Reader::hasE2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool EdgePair::Builder::hasE2() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Edge::Reader EdgePair::Reader::getE2() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Edge::Builder EdgePair::Builder::getE2() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Edge::Pipeline EdgePair::Pipeline::getE2() {
  return  ::stream::geometry::Edge::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void EdgePair::Builder::setE2( ::stream::geometry::Edge::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Edge::Builder EdgePair::Builder::initE2() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void EdgePair::Builder::adoptE2(
    ::capnp::Orphan< ::stream::geometry::Edge>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Edge> EdgePair::Builder::disownE2() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Edge>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Contour::Reader::hasP1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Contour::Builder::hasP1() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Point::Reader Contour::Reader::getP1() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Point::Builder Contour::Builder::getP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Point::Pipeline Contour::Pipeline::getP1() {
  return  ::stream::geometry::Point::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Contour::Builder::setP1( ::stream::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Point::Builder Contour::Builder::initP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Contour::Builder::adoptP1(
    ::capnp::Orphan< ::stream::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Point> Contour::Builder::disownP1() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Contour::Reader::hasDeltas() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Contour::Builder::hasDeltas() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Reader Contour::Reader::getDeltas() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Builder Contour::Builder::getDeltas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Contour::Builder::setDeltas( ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>::Builder Contour::Builder::initDeltas(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Contour::Builder::adoptDeltas(
    ::capnp::Orphan< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>> Contour::Builder::disownDeltas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Vector,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SimplePolygon::Reader::hasHull() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SimplePolygon::Builder::hasHull() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Contour::Reader SimplePolygon::Reader::getHull() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Contour::Builder SimplePolygon::Builder::getHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Contour::Pipeline SimplePolygon::Pipeline::getHull() {
  return  ::stream::geometry::Contour::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SimplePolygon::Builder::setHull( ::stream::geometry::Contour::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Contour::Builder SimplePolygon::Builder::initHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SimplePolygon::Builder::adoptHull(
    ::capnp::Orphan< ::stream::geometry::Contour>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Contour> SimplePolygon::Builder::disownHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Polygon::Reader::hasHull() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Polygon::Builder::hasHull() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Contour::Reader Polygon::Reader::getHull() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Contour::Builder Polygon::Builder::getHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Contour::Pipeline Polygon::Pipeline::getHull() {
  return  ::stream::geometry::Contour::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Polygon::Builder::setHull( ::stream::geometry::Contour::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Contour::Builder Polygon::Builder::initHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Polygon::Builder::adoptHull(
    ::capnp::Orphan< ::stream::geometry::Contour>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Contour> Polygon::Builder::disownHull() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Polygon::Reader::hasHoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Polygon::Builder::hasHoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Reader Polygon::Reader::getHoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Builder Polygon::Builder::getHoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Polygon::Builder::setHoles( ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>::Builder Polygon::Builder::initHoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Polygon::Builder::adoptHoles(
    ::capnp::Orphan< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>> Polygon::Builder::disownHoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stream::geometry::Contour,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Path::Reader::hasSpine() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Path::Builder::hasSpine() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Contour::Reader Path::Reader::getSpine() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Contour::Builder Path::Builder::getSpine() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Contour::Pipeline Path::Pipeline::getSpine() {
  return  ::stream::geometry::Contour::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Path::Builder::setSpine( ::stream::geometry::Contour::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Contour::Builder Path::Builder::initSpine() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Path::Builder::adoptSpine(
    ::capnp::Orphan< ::stream::geometry::Contour>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Contour> Path::Builder::disownSpine() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Contour>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Path::Reader::getHalfWidth() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Path::Builder::getHalfWidth() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Path::Builder::setHalfWidth( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Path::Reader::getBeginExtension() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Path::Builder::getBeginExtension() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Path::Builder::setBeginExtension( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Path::Reader::getEndExtension() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Path::Builder::getEndExtension() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Path::Builder::setEndExtension( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::stream::geometry::Path::ExtensionType Path::Reader::getExtensionType() const {
  return _reader.getDataField< ::stream::geometry::Path::ExtensionType>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::stream::geometry::Path::ExtensionType Path::Builder::getExtensionType() {
  return _builder.getDataField< ::stream::geometry::Path::ExtensionType>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void Path::Builder::setExtensionType( ::stream::geometry::Path::ExtensionType value) {
  _builder.setDataField< ::stream::geometry::Path::ExtensionType>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool Label::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Label::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Point::Reader Label::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Point::Builder Label::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Point::Pipeline Label::Pipeline::getPosition() {
  return  ::stream::geometry::Point::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Label::Builder::setPosition( ::stream::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Point::Builder Label::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Label::Builder::adoptPosition(
    ::capnp::Orphan< ::stream::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Point> Label::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stream::geometry::FixPointTransformation Label::Reader::getOrientation() const {
  return _reader.getDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stream::geometry::FixPointTransformation Label::Builder::getOrientation() {
  return _builder.getDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Label::Builder::setOrientation( ::stream::geometry::FixPointTransformation value) {
  _builder.setDataField< ::stream::geometry::FixPointTransformation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Label::Reader::getStringId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Label::Builder::getStringId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Label::Builder::setStringId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::stream::geometry::Label::HAlignment Label::Reader::getHorizontalAlign() const {
  return _reader.getDataField< ::stream::geometry::Label::HAlignment>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::stream::geometry::Label::HAlignment Label::Builder::getHorizontalAlign() {
  return _builder.getDataField< ::stream::geometry::Label::HAlignment>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Label::Builder::setHorizontalAlign( ::stream::geometry::Label::HAlignment value) {
  _builder.setDataField< ::stream::geometry::Label::HAlignment>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::stream::geometry::Label::VAlignment Label::Reader::getVerticalAlign() const {
  return _reader.getDataField< ::stream::geometry::Label::VAlignment>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::stream::geometry::Label::VAlignment Label::Builder::getVerticalAlign() {
  return _builder.getDataField< ::stream::geometry::Label::VAlignment>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Label::Builder::setVerticalAlign( ::stream::geometry::Label::VAlignment value) {
  _builder.setDataField< ::stream::geometry::Label::VAlignment>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Label::Reader::hasDisplayOffset() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Label::Builder::hasDisplayOffset() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stream::geometry::Vector::Reader Label::Reader::getDisplayOffset() const {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stream::geometry::Vector::Builder Label::Builder::getDisplayOffset() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stream::geometry::Vector::Pipeline Label::Pipeline::getDisplayOffset() {
  return  ::stream::geometry::Vector::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Label::Builder::setDisplayOffset( ::stream::geometry::Vector::Reader value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stream::geometry::Vector::Builder Label::Builder::initDisplayOffset() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Label::Builder::adoptDisplayOffset(
    ::capnp::Orphan< ::stream::geometry::Vector>&& value) {
  ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stream::geometry::Vector> Label::Builder::disownDisplayOffset() {
  return ::capnp::_::PointerHelpers< ::stream::geometry::Vector>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t Label::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Label::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Label::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

