
/*

  KLayout Layout Viewer
  Copyright (C) 2006-2020 Matthias Koefferlein

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/

/**
*  @file gsiDeclQSysInfo.cc 
*
*  DO NOT EDIT THIS FILE. 
*  This file has been created automatically
*/

#include <QSysInfo>
#include "gsiQt.h"
#include "gsiQtCoreCommon.h"
#include "gsiDeclQtCoreTypeTraits.h"
#include <memory>

// -----------------------------------------------------------------------
// class QSysInfo

//  Constructor QSysInfo::QSysInfo()


static void _init_ctor_QSysInfo_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return_new<QSysInfo> ();
}

static void _call_ctor_QSysInfo_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QSysInfo *> (new QSysInfo ());
}


// static QString QSysInfo::buildAbi()


static void _init_f_buildAbi_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_buildAbi_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::buildAbi ());
}


// static QString QSysInfo::buildCpuArchitecture()


static void _init_f_buildCpuArchitecture_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_buildCpuArchitecture_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::buildCpuArchitecture ());
}


// static QString QSysInfo::currentCpuArchitecture()


static void _init_f_currentCpuArchitecture_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_currentCpuArchitecture_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::currentCpuArchitecture ());
}


// static QString QSysInfo::kernelType()


static void _init_f_kernelType_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_kernelType_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::kernelType ());
}


// static QString QSysInfo::kernelVersion()


static void _init_f_kernelVersion_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_kernelVersion_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::kernelVersion ());
}


// static QSysInfo::MacVersion QSysInfo::macVersion()


static void _init_f_macVersion_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QSysInfo::MacVersion>::target_type > ();
}

static void _call_f_macVersion_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<qt_gsi::Converter<QSysInfo::MacVersion>::target_type > ((qt_gsi::Converter<QSysInfo::MacVersion>::target_type)qt_gsi::CppToQtAdaptor<QSysInfo::MacVersion>(QSysInfo::macVersion ()));
}


// static QString QSysInfo::prettyProductName()


static void _init_f_prettyProductName_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_prettyProductName_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::prettyProductName ());
}


// static QString QSysInfo::productType()


static void _init_f_productType_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_productType_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::productType ());
}


// static QString QSysInfo::productVersion()


static void _init_f_productVersion_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_productVersion_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QString > ((QString)QSysInfo::productVersion ());
}


// static QSysInfo::WinVersion QSysInfo::windowsVersion()


static void _init_f_windowsVersion_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QSysInfo::WinVersion>::target_type > ();
}

static void _call_f_windowsVersion_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<qt_gsi::Converter<QSysInfo::WinVersion>::target_type > ((qt_gsi::Converter<QSysInfo::WinVersion>::target_type)qt_gsi::CppToQtAdaptor<QSysInfo::WinVersion>(QSysInfo::windowsVersion ()));
}



namespace gsi
{

static gsi::Methods methods_QSysInfo () {
  gsi::Methods methods;
  methods += new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QSysInfo::QSysInfo()\nThis method creates an object of class QSysInfo.", &_init_ctor_QSysInfo_0, &_call_ctor_QSysInfo_0);
  methods += new qt_gsi::GenericStaticMethod ("buildAbi", "@brief Static method QString QSysInfo::buildAbi()\nThis method is static and can be called without an instance.", &_init_f_buildAbi_0, &_call_f_buildAbi_0);
  methods += new qt_gsi::GenericStaticMethod ("buildCpuArchitecture", "@brief Static method QString QSysInfo::buildCpuArchitecture()\nThis method is static and can be called without an instance.", &_init_f_buildCpuArchitecture_0, &_call_f_buildCpuArchitecture_0);
  methods += new qt_gsi::GenericStaticMethod ("currentCpuArchitecture", "@brief Static method QString QSysInfo::currentCpuArchitecture()\nThis method is static and can be called without an instance.", &_init_f_currentCpuArchitecture_0, &_call_f_currentCpuArchitecture_0);
  methods += new qt_gsi::GenericStaticMethod ("kernelType", "@brief Static method QString QSysInfo::kernelType()\nThis method is static and can be called without an instance.", &_init_f_kernelType_0, &_call_f_kernelType_0);
  methods += new qt_gsi::GenericStaticMethod ("kernelVersion", "@brief Static method QString QSysInfo::kernelVersion()\nThis method is static and can be called without an instance.", &_init_f_kernelVersion_0, &_call_f_kernelVersion_0);
  methods += new qt_gsi::GenericStaticMethod ("macVersion", "@brief Static method QSysInfo::MacVersion QSysInfo::macVersion()\nThis method is static and can be called without an instance.", &_init_f_macVersion_0, &_call_f_macVersion_0);
  methods += new qt_gsi::GenericStaticMethod ("prettyProductName", "@brief Static method QString QSysInfo::prettyProductName()\nThis method is static and can be called without an instance.", &_init_f_prettyProductName_0, &_call_f_prettyProductName_0);
  methods += new qt_gsi::GenericStaticMethod ("productType", "@brief Static method QString QSysInfo::productType()\nThis method is static and can be called without an instance.", &_init_f_productType_0, &_call_f_productType_0);
  methods += new qt_gsi::GenericStaticMethod ("productVersion", "@brief Static method QString QSysInfo::productVersion()\nThis method is static and can be called without an instance.", &_init_f_productVersion_0, &_call_f_productVersion_0);
  methods += new qt_gsi::GenericStaticMethod ("windowsVersion", "@brief Static method QSysInfo::WinVersion QSysInfo::windowsVersion()\nThis method is static and can be called without an instance.", &_init_f_windowsVersion_0, &_call_f_windowsVersion_0);
  return methods;
}

gsi::Class<QSysInfo> decl_QSysInfo ("QtCore", "QSysInfo",
  methods_QSysInfo (),
  "@qt\n@brief Binding of QSysInfo");


GSI_QTCORE_PUBLIC gsi::Class<QSysInfo> &qtdecl_QSysInfo () { return decl_QSysInfo; }

}


//  Implementation of the enum wrapper class for QSysInfo::MacVersion
namespace qt_gsi
{

static gsi::Enum<QSysInfo::MacVersion> decl_QSysInfo_MacVersion_Enum ("QtCore", "QSysInfo_MacVersion",
    gsi::enum_const ("MV_None", QSysInfo::MV_None, "@brief Enum constant QSysInfo::MV_None") +
    gsi::enum_const ("MV_Unknown", QSysInfo::MV_Unknown, "@brief Enum constant QSysInfo::MV_Unknown") +
    gsi::enum_const ("MV_9", QSysInfo::MV_9, "@brief Enum constant QSysInfo::MV_9") +
    gsi::enum_const ("MV_10_0", QSysInfo::MV_10_0, "@brief Enum constant QSysInfo::MV_10_0") +
    gsi::enum_const ("MV_10_1", QSysInfo::MV_10_1, "@brief Enum constant QSysInfo::MV_10_1") +
    gsi::enum_const ("MV_10_2", QSysInfo::MV_10_2, "@brief Enum constant QSysInfo::MV_10_2") +
    gsi::enum_const ("MV_10_3", QSysInfo::MV_10_3, "@brief Enum constant QSysInfo::MV_10_3") +
    gsi::enum_const ("MV_10_4", QSysInfo::MV_10_4, "@brief Enum constant QSysInfo::MV_10_4") +
    gsi::enum_const ("MV_10_5", QSysInfo::MV_10_5, "@brief Enum constant QSysInfo::MV_10_5") +
    gsi::enum_const ("MV_10_6", QSysInfo::MV_10_6, "@brief Enum constant QSysInfo::MV_10_6") +
    gsi::enum_const ("MV_10_7", QSysInfo::MV_10_7, "@brief Enum constant QSysInfo::MV_10_7") +
    gsi::enum_const ("MV_10_8", QSysInfo::MV_10_8, "@brief Enum constant QSysInfo::MV_10_8") +
    gsi::enum_const ("MV_10_9", QSysInfo::MV_10_9, "@brief Enum constant QSysInfo::MV_10_9") +
    gsi::enum_const ("MV_10_10", QSysInfo::MV_10_10, "@brief Enum constant QSysInfo::MV_10_10") +
    gsi::enum_const ("MV_10_11", QSysInfo::MV_10_11, "@brief Enum constant QSysInfo::MV_10_11") +
    gsi::enum_const ("MV_CHEETAH", QSysInfo::MV_CHEETAH, "@brief Enum constant QSysInfo::MV_CHEETAH") +
    gsi::enum_const ("MV_PUMA", QSysInfo::MV_PUMA, "@brief Enum constant QSysInfo::MV_PUMA") +
    gsi::enum_const ("MV_JAGUAR", QSysInfo::MV_JAGUAR, "@brief Enum constant QSysInfo::MV_JAGUAR") +
    gsi::enum_const ("MV_PANTHER", QSysInfo::MV_PANTHER, "@brief Enum constant QSysInfo::MV_PANTHER") +
    gsi::enum_const ("MV_TIGER", QSysInfo::MV_TIGER, "@brief Enum constant QSysInfo::MV_TIGER") +
    gsi::enum_const ("MV_LEOPARD", QSysInfo::MV_LEOPARD, "@brief Enum constant QSysInfo::MV_LEOPARD") +
    gsi::enum_const ("MV_SNOWLEOPARD", QSysInfo::MV_SNOWLEOPARD, "@brief Enum constant QSysInfo::MV_SNOWLEOPARD") +
    gsi::enum_const ("MV_LION", QSysInfo::MV_LION, "@brief Enum constant QSysInfo::MV_LION") +
    gsi::enum_const ("MV_MOUNTAINLION", QSysInfo::MV_MOUNTAINLION, "@brief Enum constant QSysInfo::MV_MOUNTAINLION") +
    gsi::enum_const ("MV_MAVERICKS", QSysInfo::MV_MAVERICKS, "@brief Enum constant QSysInfo::MV_MAVERICKS") +
    gsi::enum_const ("MV_YOSEMITE", QSysInfo::MV_YOSEMITE, "@brief Enum constant QSysInfo::MV_YOSEMITE") +
    gsi::enum_const ("MV_ELCAPITAN", QSysInfo::MV_ELCAPITAN, "@brief Enum constant QSysInfo::MV_ELCAPITAN") +
    gsi::enum_const ("MV_IOS", QSysInfo::MV_IOS, "@brief Enum constant QSysInfo::MV_IOS") +
    gsi::enum_const ("MV_IOS_4_3", QSysInfo::MV_IOS_4_3, "@brief Enum constant QSysInfo::MV_IOS_4_3") +
    gsi::enum_const ("MV_IOS_5_0", QSysInfo::MV_IOS_5_0, "@brief Enum constant QSysInfo::MV_IOS_5_0") +
    gsi::enum_const ("MV_IOS_5_1", QSysInfo::MV_IOS_5_1, "@brief Enum constant QSysInfo::MV_IOS_5_1") +
    gsi::enum_const ("MV_IOS_6_0", QSysInfo::MV_IOS_6_0, "@brief Enum constant QSysInfo::MV_IOS_6_0") +
    gsi::enum_const ("MV_IOS_6_1", QSysInfo::MV_IOS_6_1, "@brief Enum constant QSysInfo::MV_IOS_6_1") +
    gsi::enum_const ("MV_IOS_7_0", QSysInfo::MV_IOS_7_0, "@brief Enum constant QSysInfo::MV_IOS_7_0") +
    gsi::enum_const ("MV_IOS_7_1", QSysInfo::MV_IOS_7_1, "@brief Enum constant QSysInfo::MV_IOS_7_1") +
    gsi::enum_const ("MV_IOS_8_0", QSysInfo::MV_IOS_8_0, "@brief Enum constant QSysInfo::MV_IOS_8_0") +
    gsi::enum_const ("MV_IOS_8_1", QSysInfo::MV_IOS_8_1, "@brief Enum constant QSysInfo::MV_IOS_8_1") +
    gsi::enum_const ("MV_IOS_8_2", QSysInfo::MV_IOS_8_2, "@brief Enum constant QSysInfo::MV_IOS_8_2") +
    gsi::enum_const ("MV_IOS_8_3", QSysInfo::MV_IOS_8_3, "@brief Enum constant QSysInfo::MV_IOS_8_3") +
    gsi::enum_const ("MV_IOS_8_4", QSysInfo::MV_IOS_8_4, "@brief Enum constant QSysInfo::MV_IOS_8_4") +
    gsi::enum_const ("MV_IOS_9_0", QSysInfo::MV_IOS_9_0, "@brief Enum constant QSysInfo::MV_IOS_9_0"),
  "@qt\n@brief This class represents the QSysInfo::MacVersion enum");

static gsi::QFlagsClass<QSysInfo::MacVersion > decl_QSysInfo_MacVersion_Enums ("QtCore", "QSysInfo_QFlags_MacVersion",
  "@qt\n@brief This class represents the QFlags<QSysInfo::MacVersion> flag set");

//  Inject the declarations into the parent
static gsi::ClassExt<QSysInfo> inject_QSysInfo_MacVersion_Enum_in_parent (decl_QSysInfo_MacVersion_Enum.defs ());
static gsi::ClassExt<QSysInfo> decl_QSysInfo_MacVersion_Enum_as_child (decl_QSysInfo_MacVersion_Enum, "MacVersion");
static gsi::ClassExt<QSysInfo> decl_QSysInfo_MacVersion_Enums_as_child (decl_QSysInfo_MacVersion_Enums, "QFlags_MacVersion");

}


//  Implementation of the enum wrapper class for QSysInfo::WinVersion
namespace qt_gsi
{

static gsi::Enum<QSysInfo::WinVersion> decl_QSysInfo_WinVersion_Enum ("QtCore", "QSysInfo_WinVersion",
    gsi::enum_const ("WV_None", QSysInfo::WV_None, "@brief Enum constant QSysInfo::WV_None") +
    gsi::enum_const ("WV_32s", QSysInfo::WV_32s, "@brief Enum constant QSysInfo::WV_32s") +
    gsi::enum_const ("WV_95", QSysInfo::WV_95, "@brief Enum constant QSysInfo::WV_95") +
    gsi::enum_const ("WV_98", QSysInfo::WV_98, "@brief Enum constant QSysInfo::WV_98") +
    gsi::enum_const ("WV_Me", QSysInfo::WV_Me, "@brief Enum constant QSysInfo::WV_Me") +
    gsi::enum_const ("WV_DOS_based", QSysInfo::WV_DOS_based, "@brief Enum constant QSysInfo::WV_DOS_based") +
    gsi::enum_const ("WV_NT", QSysInfo::WV_NT, "@brief Enum constant QSysInfo::WV_NT") +
    gsi::enum_const ("WV_2000", QSysInfo::WV_2000, "@brief Enum constant QSysInfo::WV_2000") +
    gsi::enum_const ("WV_XP", QSysInfo::WV_XP, "@brief Enum constant QSysInfo::WV_XP") +
    gsi::enum_const ("WV_2003", QSysInfo::WV_2003, "@brief Enum constant QSysInfo::WV_2003") +
    gsi::enum_const ("WV_VISTA", QSysInfo::WV_VISTA, "@brief Enum constant QSysInfo::WV_VISTA") +
    gsi::enum_const ("WV_WINDOWS7", QSysInfo::WV_WINDOWS7, "@brief Enum constant QSysInfo::WV_WINDOWS7") +
    gsi::enum_const ("WV_WINDOWS8", QSysInfo::WV_WINDOWS8, "@brief Enum constant QSysInfo::WV_WINDOWS8") +
    gsi::enum_const ("WV_WINDOWS8_1", QSysInfo::WV_WINDOWS8_1, "@brief Enum constant QSysInfo::WV_WINDOWS8_1") +
    gsi::enum_const ("WV_WINDOWS10", QSysInfo::WV_WINDOWS10, "@brief Enum constant QSysInfo::WV_WINDOWS10") +
    gsi::enum_const ("WV_NT_based", QSysInfo::WV_NT_based, "@brief Enum constant QSysInfo::WV_NT_based") +
    gsi::enum_const ("WV_4_0", QSysInfo::WV_4_0, "@brief Enum constant QSysInfo::WV_4_0") +
    gsi::enum_const ("WV_5_0", QSysInfo::WV_5_0, "@brief Enum constant QSysInfo::WV_5_0") +
    gsi::enum_const ("WV_5_1", QSysInfo::WV_5_1, "@brief Enum constant QSysInfo::WV_5_1") +
    gsi::enum_const ("WV_5_2", QSysInfo::WV_5_2, "@brief Enum constant QSysInfo::WV_5_2") +
    gsi::enum_const ("WV_6_0", QSysInfo::WV_6_0, "@brief Enum constant QSysInfo::WV_6_0") +
    gsi::enum_const ("WV_6_1", QSysInfo::WV_6_1, "@brief Enum constant QSysInfo::WV_6_1") +
    gsi::enum_const ("WV_6_2", QSysInfo::WV_6_2, "@brief Enum constant QSysInfo::WV_6_2") +
    gsi::enum_const ("WV_6_3", QSysInfo::WV_6_3, "@brief Enum constant QSysInfo::WV_6_3") +
    gsi::enum_const ("WV_10_0", QSysInfo::WV_10_0, "@brief Enum constant QSysInfo::WV_10_0") +
    gsi::enum_const ("WV_CE", QSysInfo::WV_CE, "@brief Enum constant QSysInfo::WV_CE") +
    gsi::enum_const ("WV_CENET", QSysInfo::WV_CENET, "@brief Enum constant QSysInfo::WV_CENET") +
    gsi::enum_const ("WV_CE_5", QSysInfo::WV_CE_5, "@brief Enum constant QSysInfo::WV_CE_5") +
    gsi::enum_const ("WV_CE_6", QSysInfo::WV_CE_6, "@brief Enum constant QSysInfo::WV_CE_6") +
    gsi::enum_const ("WV_CE_based", QSysInfo::WV_CE_based, "@brief Enum constant QSysInfo::WV_CE_based"),
  "@qt\n@brief This class represents the QSysInfo::WinVersion enum");

static gsi::QFlagsClass<QSysInfo::WinVersion > decl_QSysInfo_WinVersion_Enums ("QtCore", "QSysInfo_QFlags_WinVersion",
  "@qt\n@brief This class represents the QFlags<QSysInfo::WinVersion> flag set");

//  Inject the declarations into the parent
static gsi::ClassExt<QSysInfo> inject_QSysInfo_WinVersion_Enum_in_parent (decl_QSysInfo_WinVersion_Enum.defs ());
static gsi::ClassExt<QSysInfo> decl_QSysInfo_WinVersion_Enum_as_child (decl_QSysInfo_WinVersion_Enum, "WinVersion");
static gsi::ClassExt<QSysInfo> decl_QSysInfo_WinVersion_Enums_as_child (decl_QSysInfo_WinVersion_Enums, "QFlags_WinVersion");

}

