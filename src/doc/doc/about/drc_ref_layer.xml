<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/drc_lvs_doc/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Layer Object</title>
<keyword name="Layer"/>
<h2-index/>
<a name="&amp;"/><h2>"&amp;" - Boolean AND operation</h2>
<keyword name="&amp;"/>
<p>Usage:</p>
<ul>
<li><tt>self &amp; other</tt></li>
</ul>
<p>
The method computes a boolean AND between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#and">and</a>". See there for a description of the function.
</p>
<a name="+"/><h2>"+" - Join layers</h2>
<keyword name="+"/>
<p>Usage:</p>
<ul>
<li><tt>self + other</tt></li>
</ul>
<p>
The method includes the edges or polygons from the other layer into this layer.
The "+" operator is an alias for the <a href="#join">join</a> method.
</p><p>
This method is available for polygon, edge and edge pair layers. An alias
is "<a href="#join">join</a>". See there for a description of the function.
</p>
<a name="-"/><h2>"-" - Boolean NOT operation</h2>
<keyword name="-"/>
<p>Usage:</p>
<ul>
<li><tt>self - other</tt></li>
</ul>
<p>
The method computes a boolean NOT between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#not">not</a>". See there for a description of the function.
</p>
<a name="^"/><h2>"^" - Boolean XOR operation</h2>
<keyword name="^"/>
<p>Usage:</p>
<ul>
<li><tt>self ^ other</tt></li>
</ul>
<p>
The method computes a boolean XOR between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#xor">xor</a>". See there for a description of the function.
</p>
<a name="and"/><h2>"and" - Boolean AND operation</h2>
<keyword name="and"/>
<p>Usage:</p>
<ul>
<li><tt>layer.and(other [, prop_constraint ])</tt></li>
</ul>
<p>
The method computes a boolean AND between self and other.
It is an alias for the "&amp;" operator which lacks the ability
to specify a properties constraint.
</p><p>
This method is available for polygon and edge layers.
If the first operand is an edge layer and the second is a polygon layer, the
result will be the edges of the first operand which are inside or on the
borders of the polygons of the second operand.
</p><p>
The following images show the effect of the "and" method
on polygons and edges (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_and1.png"/></td>
<td><img src="/images/drc_and2.png"/></td>
<td><img src="/images/drc_and3.png"/></td>
</tr>
</table>
</p><p>
The AND operation can be applied between a text and a polygon
layer. In this case, the texts inside or at the border of the 
polygons will be written to the output (labels: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_textpoly1.png"/></td>
</tr>
</table>
</p><p>
When a properties constraint is given, the operation is performed
only between shapes with the given relation. Together with the 
ability to provide net-annotated shapes through the <a href="#nets">nets</a> method, this
allows constraining the boolean operation to shapes from the same or
from different nets.
</p><p>
See <a href="/about/drc_ref_global.xml#prop_eq">prop_eq</a>, <a href="/about/drc_ref_global.xml#prop_ne">prop_ne</a> and <a href="/about/drc_ref_global.xml#prop_copy">prop_copy</a> for details.
</p>
<a name="andnot"/><h2>"andnot" - Computes Boolean AND and NOT results at the same time</h2>
<keyword name="andnot"/>
<p>Usage:</p>
<ul>
<li><tt>layer.andnot(other)</tt></li>
</ul>
<p>
This method returns a two-element array containing one layer for the
AND result and one for the NOT result.
</p><p>
This method is available for polygon and edge layers.
For polygon layers, the other input must be a polygon layer too.
For edge layers, the other input can be polygon or edge.
</p><p>
It can be used to initialize two variables with the AND and NOT results:
</p><p>
<pre>
(and_result, not_result) = l1.andnot(l2)
</pre>
</p><p>
As the AND and NOT results are computed in the same sweep, calling this
method is faster than calling AND and NOT separately.
</p>
<a name="area"/><h2>"area" - Returns the total area of the polygons in the region</h2>
<keyword name="area"/>
<p>Usage:</p>
<ul>
<li><tt>layer.area</tt></li>
</ul>
<p>
This method requires a polygon layer. It returns the total
area of all polygons in square micron. Merged semantics applies, 
i.e. before computing the area, the polygons are merged unless
raw mode is chosen (see <a href="#raw">raw</a>). Hence, in clean mode, overlapping
polygons are not counted twice.
</p><p>
The returned value gives the area in square micrometer units.
</p>
<a name="bbox"/><h2>"bbox" - Returns the overall bounding box of the layer</h2>
<keyword name="bbox"/>
<p>Usage:</p>
<ul>
<li><tt>layer.bbox</tt></li>
</ul>
<p>
The return value is a <class_doc href="DBox">DBox</class_doc> object giving the bounding box in 
micrometer units. 
</p>
<a name="centers"/><h2>"centers" - Returns the center parts of the edges</h2>
<keyword name="centers"/>
<p>Usage:</p>
<ul>
<li><tt>layer.centers(length)</tt></li>
<li><tt>layer.centers(length, fraction)</tt></li>
</ul>
<p>
Similar to <a href="#start_segments">start_segments</a> and <a href="#end_segments">end_segments</a>, this method will return partial
edges for each given edge in the input. For the description of the parameters see
<a href="#start_segments">start_segments</a> or <a href="#end_segments">end_segments</a>.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_centers1.png"/></td>
<td><img src="/images/drc_centers2.png"/></td>
</tr>
</table>
</p>
<a name="clean"/><h2>"clean" - Marks a layer as clean</h2>
<keyword name="clean"/>
<p>Usage:</p>
<ul>
<li><tt>layer.clean</tt></li>
</ul>
<p>
A layer marked as clean will provide "merged" semantics, i.e.
overlapping or touching polygons are considered as single
polygons. Inner edges are removed and collinear edges are 
connected. 
Clean state is the default.
</p><p>
See <a href="#raw">raw</a> for some remarks about how this state is 
propagated.
</p>
<a name="collect"/><h2>"collect" - Transforms a layer</h2>
<keyword name="collect"/>
<p>Usage:</p>
<ul>
<li><tt>layer.collect { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block for each object in the layer and returns a new layer with the objects
returned from the block. It is available for edge, polygon and edge pair layers.
The corresponding objects are <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc>.
</p><p>
If the block evaluates to nil, no object is added to the output layer. If it returns an array, each of
the objects in the array is added.
The returned layer is of the original type and will only accept objects of the respective type. Hence,
for polygon layers, <class_doc href="DPolygon">DPolygon</class_doc> objects need to be returned. For edge layers those need to be <class_doc href="DEdge">DEdge</class_doc>
and for edge pair layers, they need to be <class_doc href="DEdgePair">DEdgePair</class_doc> objects. For convenience, <class_doc href="Polygon">Polygon</class_doc>, <class_doc href="Edge">Edge</class_doc>
and <class_doc href="EdgePair">EdgePair</class_doc> objects are accepted too and are scaled by the database unit to render micrometer-unit
objects. <class_doc href="Region">Region</class_doc>, <class_doc href="Edges">Edges</class_doc> and <class_doc href="EdgePair">EdgePair</class_doc> objects are accepted as well and the corresponding 
content of that collections is inserted into the output layer.
</p><p>
Other versions are available that allow translation of objects into other types (<a href="#collect_to_region">collect_to_region</a>, 
<a href="#collect_to_edges">collect_to_edges</a> and <a href="#collect_to_edge_pairs">collect_to_edge_pairs</a>).
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p><p>
Here is a slow equivalent of the rotated method
</p><p>
<pre>
# Rotates by 45 degree
t = <class_doc href="DCplxTrans">DCplxTrans</class_doc>(1.0, 45.0, false, <class_doc href="DVector">DVector</class_doc>::new)
new_layer = layer.collect { |polygon| polygon.transformed(t) }
</pre>
</p>
<a name="collect_to_edge_pairs"/><h2>"collect_to_edge_pairs" - Transforms a layer into edge pair objects</h2>
<keyword name="collect_to_edge_pairs"/>
<p>Usage:</p>
<ul>
<li><tt>layer.collect_to_edge_pairs { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates an edge pair layer. It expects the block to 
deliver <class_doc href="EdgePair">EdgePair</class_doc>, <class_doc href="DEdgePair">DEdgePair</class_doc> or <class_doc href="EdgePairs">EdgePairs</class_doc> objects.
</p>
<a name="collect_to_edges"/><h2>"collect_to_edges" - Transforms a layer into edge objects</h2>
<keyword name="collect_to_edges"/>
<p>Usage:</p>
<ul>
<li><tt>layer.collect_to_edges { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates an edge layer. It expects the block to 
deliver objects that can be converted into edges. If polygon-like objects are returned, their
contours will be turned into edge sequences.
</p>
<a name="collect_to_region"/><h2>"collect_to_region" - Transforms a layer into polygon objects</h2>
<keyword name="collect_to_region"/>
<p>Usage:</p>
<ul>
<li><tt>layer.collect_to_region { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates a polygon layer. It expects the block to 
deliver objects that can be converted into polygons. Such objects are of class <class_doc href="DPolygon">DPolygon</class_doc>,
<class_doc href="DBox">DBox</class_doc>, <class_doc href="DPath">DPath</class_doc>, <class_doc href="Polygon">Polygon</class_doc>, <class_doc href="Path">Path</class_doc>, <class_doc href="Box">Box</class_doc> and <class_doc href="Region">Region</class_doc>.
</p>
<a name="corners"/><h2>"corners" - Selects corners of polygons</h2>
<keyword name="corners"/>
<p>Usage:</p>
<ul>
<li><tt>layer.corners([ options ])</tt></li>
<li><tt>layer.corners(angle [, options ])</tt></li>
<li><tt>layer.corners(amin .. amax [, options ])</tt></li>
</ul>
<p>
This method produces markers on the corners of the polygons. An angle criterion can be given which
selects corners based on the angle of the connecting edges. Positive angles indicate a left turn
while negative angles indicate a right turn. 
Since polygons are oriented clockwise, positive angles
indicate concave (inner) corners while negative ones indicate convex (outer) corners
The 'absolute' option allows turning this off and considering both left and right turns 
positive angles.
</p><p>
The markers generated can be point-like edges or small 2x2 DBU boxes. The latter is the default.
</p><p>
The options available are:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
<li><b>as_edge_pairs </b>: with this option, an edge pair is produced for each corner selected. The first edge 
is the incoming edge to the corner, the second edge the outgoing edge. </li>
<li><b>absolute </b>: with this option, left and right turns will both be considered positive angles </li>
<li><b>negative </b>: with this option, all corners <b>not </b>matching the angle criterion are selected </li>
</ul>
</p><p>
The following images show the effect of this method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_corners1.png"/></td>
<td><img src="/images/drc_corners2.png"/></td>
<td><img src="/images/drc_corners3.png"/></td>
</tr>
</table>
</p>
<a name="count"/><h2>"count" - Returns the number of objects on the layer</h2>
<keyword name="count"/>
<p>Usage:</p>
<ul>
<li><tt>layer.count</tt></li>
</ul>
<p>
The count is the number of raw objects, not merged
regions or edges. This is the flat count - the number of polygons,
edges or edge pairs seen from the top cell.
"count" can be computationally expensive for original layers with
clip regions or cell tree filters.
</p><p>
See <a href="#hier_count">hier_count</a> for a hierarchical (each cell counts once) count.
</p>
<a name="covering"/><h2>"covering" - Selects shapes or regions of self which completely cover (enclose) one or more shapes from the other region</h2>
<keyword name="covering"/>
<p>Usage:</p>
<ul>
<li><tt>layer.covering(other)</tt></li>
<li><tt>layer.covering(other, min_count)</tt></li>
<li><tt>layer.covering(other, min_count, max_count)</tt></li>
<li><tt>layer.covering(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which completly cover shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_covering">select_covering</a>.
</p><p>
This method is available for polygons only.
</p><p>
The following image shows the effect of the "covering" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_covering.png"/></td>
</tr>
</table>
</p><p>
A range of counts can be specified. If so, the shape from the primary layer is 
only selected when covering a given number of shapes from the other layer.
For the interpretation of the count see <a href="#interacting">interacting</a>.
</p><p>
The "covering" attribute is sometimes called "enclosing", but this name is
used for the respective DRC function (see <a href="#enclosing">enclosing</a>).
</p>
<a name="data"/><h2>"data" - Gets the low-level data object</h2>
<keyword name="data"/>
<p>Usage:</p>
<ul>
<li><tt>layer.data</tt></li>
</ul>
<p>
This method returns a <class_doc href="Region">Region</class_doc>, <class_doc href="Edges">Edges</class_doc> or <class_doc href="EdgePairs">EdgePairs</class_doc> object
representing the underlying RBA object for the data.
Access to these objects is provided to support low-level iteration and manipulation
of the layer's data. 
</p>
<a name="drc"/><h2>"drc" - Provides a generic DRC function for use with <a href="/about/drc_ref_drc.xml">DRC</a> expressions</h2>
<keyword name="drc"/>
<p>Usage:</p>
<ul>
<li><tt>layer.drc(expression [, prop_constraint ])</tt></li>
</ul>
<p>
This method implements the universal DRC which offers enhanced abilities,
improved performance in some applications and better readability.
</p><p>
The key concept for this method are DRC expressions. DRC expressions
are formed by using predefined keywords like "width", operators like "&amp;" 
and methods to build an abstract definition of the operations to perform
within the DRC.
</p><p>
When the DRC function is executed, it will basically visit all shapes
from the input layer (the layer, the "drc" method is called on)).
While it does, it collects the neighbor shapes from all involved other inputs 
and runs the requested operations on each cluster. 
Currently, "drc" is only available for polygon layers.
</p><p>
This way, the nature of the "drc" operation is that of the loop over all (merged) input
polygons. Within the operation executed on each shape, it's possible to make
decisions such as "if the shape has an area larger than something, apply this
operation" or similar. This often can be achieved with conventional DRC functions too,
but involves potentially complex and heavy operations such as booleans, interact
etc. For this reason, the "drc" function may provide a better performance.
</p><p>
In addition, within the loop a single shape from the input layer is presented to the
execution engine which runs the operations.
This allows using operations such as "size" without having to consider 
neighbor polygons growing into the area of the initial shape. In this sense,
the "drc" function sees the layer as individual polygons rather than
a global "sea of polygons". This enables new applications which are otherwise
difficult to implement.
</p><p>
<h3>Primaries and secondaries </h3>
</p><p>
An important concept in "drc" expressions is the "primary".
The primary represents a single shape from the input layer. "Secondaries" are shapes
from other inputs. Primaries guide the operation - secondaries without
primaries are not seen. The "drc" operation will look for secondaries within
a certain distance which is determined from the operations from the 
expression to execute. The secondaries collected in this step will not be
merged, so the secondary polygons may be partial. This is important when
using measurement operations like "area" on secondary polygons.
</p><p>
<h3>Checks </h3>
</p><p>
Here is an example for a generic DRC operation which performs a width
check for less than 0.5.um on the primary shapes. It uses the "<a href="/about/drc_ref_global.xml#width">width</a>" operator:
</p><p>
<pre>
out = in.drc(width &lt; 0.5.um)
</pre>
</p><p>
Other single or double-bounded conditions are available too, for example:
</p><p>
<pre>
out = in.drc(width &lt;= 0.5.um)
out = in.drc(width &gt; 0.5.um)
out = in.drc(width == 0.5.um)
out = in.drc(width != 0.5.um)
out = in.drc(0.2.um &lt; width &lt; 0.5.um)
</pre>
</p><p>
To specify the second input for a two-layer check, add it to 
the check function. This example shows how to use a two-layer separation check ("<a href="/about/drc_ref_global.xml#separation">separation</a>"):
</p><p>
<pre>
l1 = input(1, 0)
l2 = input(2, 0)
out = l1.drc(separation(l2) &lt; 0.5.um)
</pre>
</p><p>
The second input of this check function can be a computed expression. In this
case the local loop will first evaluate the expression for the second input and
then use the result as second input in the check. Note that this computation is
performed locally and separately for each primary and its context.
</p><p>
Options for the checks are also specified inside the brackets. For example,
to select projection metrics ("projection") for the "width" check use:
</p><p>
<pre>
out = in.drc(width(projection) &lt; 0.5.um)
</pre>
</p><p>
<h3>Edges and edge pairs </h3>
</p><p>
Although the "drc" function operates on polygon layers, internally it is 
able to handle edge and edge pair types too. Some operations generate edge pairs,
some other generate edges. As results from one operation can be processed further
in the DRC expressions, methods are available to filter, process and convert
these types.
</p><p>
For example, all checks produce edge pairs which can be converted into polygons
using the "polygons" method:
</p><p>
<pre>
out = in.drc((width(projection) &lt; 0.5.um).polygons)
</pre>
</p><p>
Note a subtle detail: when putting the "polygons" method inside the "drc"
brackets, it is executed locally on every visited primary polygon. The result
in this case is identical to the global conversion:
</p><p>
<pre>
# same, but with "global" conversion:
out = in.drc(width(projection) &lt; 0.5.um).polygons
</pre>
</p><p>
But having the check polygons inside the loop opens new opportunities and 
is more efficient in general. In the previous example, the local conversion
will keep a few edge pairs after having converted them to polygons. In
the global case, all edge pairs are collected first and then converted.
If there are many edge pairs, this requires more memory and a larger computing
overhead for managing the bigger number of shapes.
</p><p>
For the conversion of edges, edge pairs and polygons into other types, these
methods are provided:
</p><p>
<ul>
<li>"<a href="/about/drc_ref_drc.xml#polygons">DRC#polygons</a>": converts edge pairs to polygons </li>
<li>"<a href="/about/drc_ref_drc.xml#extended">DRC#extended</a>", "<a href="/about/drc_ref_drc.xml#extended_in">DRC#extended_in</a>", "<a href="/about/drc_ref_drc.xml#extended_out">DRC#extended_out</a>": converts edges to polygons </li>
<li>"<a href="/about/drc_ref_drc.xml#first_edges">DRC#first_edges</a>", <a href="/about/drc_ref_drc.xml#second_edges">DRC#second_edges</a>": extracts edges from edge pairs </li>
<li>"<a href="/about/drc_ref_drc.xml#edges">DRC#edges</a>": decomposes edge pairs and polygons into edges </li>
<li>"<a href="/about/drc_ref_drc.xml#corners">DRC#corners</a>": can extract corners from polygons </li>
</ul>
</p><p>
The following example decomposes the primary polygons into edges:
</p><p>
<pre>
out = in.drc(primary.edges)
</pre>
</p><p>
(for backward compatibility you cannot abbreviate "primary.edges" simply as "edges" like
other functions). 
</p><p>
The previous example isn't quite exciting as it is equivalent to 
</p><p>
<pre>
# Same as above
out = in.edges
</pre>
</p><p>
But it gets more interesting, as within the loop, "edges" delivers the edge set for
each individual polygon. It's possible to work with this distinct set, so for example
this will give you the edges of polygons with more than four corners:
</p><p>
<pre>
out = in.drc(primary.edges.count &gt; 4)
</pre>
</p><p>
Explanation: "count" is a "quantifier" which takes any kind of set (edges, edge pairs, polygons)
and returns the set if the number of inhabitants meets the given condition. Otherwise the set
is skipped. So it will look at the edges and if there are more than four (per primary shape),
it will forward this set. 
</p><p>
The same result can be achieved with classic DRC with "interact" and a figure count, but
at a much higher computation cost.
</p><p>
<h3>Edge and edge/polygon operations </h3>
</p><p>
The "drc" framework supports the following edge and edge/polygon operations:
</p><p>
<ul>
<li>Edge vs. edge and edge vs. polygon booleans </li>
<li>Edge vs. polygon interactions ("<a href="/about/drc_ref_drc.xml#interacting">DRC#interacting</a>", "<a href="/about/drc_ref_drc.xml#overlapping">DRC#overlapping</a>") </li>
<li>Edge sampling ("<a href="/about/drc_ref_drc.xml#start_segments">DRC#start_segments</a>", "<a href="/about/drc_ref_drc.xml#centers">DRC#centers</a>", "<a href="/about/drc_ref_drc.xml#end_segments">DRC#end_segments</a>") </li>
</ul>
</p><p>
<h3>Filters </h3>
</p><p>
Filter operators select input polygons or edges based on their properties. These filters are provided:
</p><p>
<ul>
<li>"<a href="/about/drc_ref_drc.xml#area">DRC#area</a>": selects polygons based on their area </li>
<li>"<a href="/about/drc_ref_drc.xml#perimeter">DRC#perimeter</a>": selects polygons based on their perimeter </li>
<li>"<a href="/about/drc_ref_drc.xml#area_ratio">DRC#area_ratio</a>": selects polygons based on their bounding box to polygon area ratio </li>
<li>"<a href="/about/drc_ref_drc.xml#bbox_aspect_ratio">DRC#bbox_aspect_ratio</a>": selects polygons based on their bounding box aspect ratio </li>
<li>"<a href="/about/drc_ref_drc.xml#relative_height">DRC#relative_height</a>": selects polygons based on their relative height </li>
<li>"<a href="/about/drc_ref_drc.xml#bbox_min">DRC#bbox_min</a>", "<a href="/about/drc_ref_drc.xml#bbox_max">DRC#bbox_max</a>", "<a href="/about/drc_ref_drc.xml#bbox_width">DRC#bbox_width</a>", "<a href="/about/drc_ref_drc.xml#bbox_height">DRC#bbox_height</a>": selects polygons based on their bounding box properties </li>
<li>"<a href="/about/drc_ref_drc.xml#length">DRC#length</a>": selects edges based on their length </li>
<li>"<a href="/about/drc_ref_drc.xml#angle">DRC#angle</a>": selects edges based on their orientation </li>
</ul>
</p><p>
For example, to select polygons with an area larger than one square micrometer, use:
</p><p>
<pre>
out = in.drc(area &gt; 1.0)
</pre>
</p><p>
For the condition, use the usual numerical bounds like:
</p><p>
<pre>
out = in.drc(area == 1.0)
out = in.drc(area &lt;= 1.0)
out = in.drc(0.2 &lt; area &lt; 1.0)
</pre>
</p><p>
The result of the area operation is the input polygon if the area condition is met.
</p><p>
In the same fashion, "perimeter" applies to the perimeter of the polygon.
"bbox_min" etc. will evaluate a particular dimensions of the polygon's bounding box and
use the respective dimension for filtering the polygon.
</p><p>
Note that it's basically possible to use the polygon filters on any input - computed and secondaries.
In fact, plain "area" for example is a shortcut for "<a href="/about/drc_ref_global.xml#primary">primary</a>.area" indicating that
the area of primary shapes are supposed to be computed.
However, any input other than the primary is not necessarily complete or it may 
consist of multiple polygons. Hence the computed values may be too big or too small.
It's recommended therefore to use the measurement functions on primary polygons
unless you know what you're doing.
</p><p>
<h3>Filter predicates </h3>
</p><p>
The "drc" feature also supports some predicates. "predicates" are boolean values
indicating a certain condition. A predicate filter works in a way that it only
passes the polygons if the condition is met.
</p><p>
The predicates available currently are:
</p><p>
<ul>
<li>"<a href="/about/drc_ref_drc.xml#rectangles">DRC#rectangles</a>": Filters rectangles </li>
<li>"<a href="/about/drc_ref_drc.xml#squares">DRC#squares</a>": Filters squares </li>
<li>"<a href="/about/drc_ref_drc.xml#rectilinear">DRC#rectilinear</a>": Filters rectilinear ("Manhattan") polygons </li>
</ul>
</p><p>
For the same reason as explained above, it's recommended to use these predicates
standalone, so they act on primary shapes. It's possible to use the predicates
on computed shapes or secondaries, but that may not render the desired results.
</p><p>
<h3>Logical NOT operator </h3>
</p><p>
The "!" operator will evaluate the expression behind it and return the 
current primary shape if the input is empty and return an empty polygon set 
if not. Hence the following filter will deliver all polygons which are 
not rectangles:
</p><p>
<pre>
out = in.drc(! rectangles)
</pre>
</p><p>
<h3>Logical combination operators </h3>
</p><p>
The logical "if_any" or "if_all" functions allow connecting multiple
conditions and evaluate to "true" (means: a non-empty shape set) if either
one input is a non-empty shape set ("if_any") or if all inputs are non-empty
("if_all"). 
</p><p>
For example, this will select all polygons which are rectangles
and whose area is larger than 20 square micrometers:
</p><p>
<pre>
out = in.drc(if_all(rectangles, area &gt; 20.0))
</pre>
</p><p>
"if_all" delivers the primary shape if all of the input expressions
render a non-empty result.
</p><p>
In contrast to this, the "if_any" operation will deliver the primary shape
if one of the input expressions renders a non-empty result.
</p><p>
The "<a href="/about/drc_ref_global.xml#switch">switch</a>" function allows selecting one input based on the results of an
expression. In the two-input form it's equivalent to "if". The first expression
is the condition. If it evaluates to a non-empty shape set, the result of the
second expression is taken. Otherwise, the result is empty. 
</p><p>
Hence the following code delivers all rectangles sized by 100 nm. All
other shapes are skipped:
</p><p>
<pre>
out = in.drc(switch(rectangles, primary.sized(100.nm)))
</pre>
</p><p>
A third expression will be considered the "else" branch: the result of
this expression will be taken if the first one is not taken. So this
example will size all rectangles and leave other shapes untouched:
</p><p>
<pre>
out = in.drc(switch(rectangles, primary.sized(100.nm), primary))
</pre>
</p><p>
If more expressions are given, they are considered as a sequence of condition/result
chain (c1, e1, c2, e2, ...) in the sense of "if(c1) return(e1) else if(c2) return(e2) ...".
So the e1 is taken if c1 is met, e2 is taken when c1 is not met, but c2 is and so forth.
If there is an odd number of expressions, the last one will be the default expression
which is taken if none of the conditions is met.
</p><p>
<h3>Polygon manipulations </h3>
</p><p>
The "drc" operations feature polygon manipulations where the input is
either the primary, secondaries or derived shapes.
Manipulations include sizing ("<a href="/about/drc_ref_global.xml#sized">sized</a>"), corner rounding ("<a href="/about/drc_ref_global.xml#rounded_corners">rounded_corners</a>"), smoothing ("<a href="/about/drc_ref_global.xml#smoothed">smoothed</a>")
and boolean operations.
</p><p>
This example computes a boolean AND between two layers before selecting
the result polygons with an area larger than 1 square micrometer. Note that
"primary" is a placeholder for the primary shape:
</p><p>
<pre>
l1 = input(1, 0)
l2 = input(2, 0)
out = l1.drc((primary &amp; l2).area &gt; 1.0)
</pre>
</p><p>
This example demonstrates how the "drc" operation can improve performance: as the
boolean operation is computed locally and the result is discarded when no longer required,
less shapes need to be stored hence reducing the memory overhead and CPU time required
to manage these shapes.
</p><p>
Note that the precise form of the example above is
</p><p>
<pre>
out = l1.drc((primary &amp; secondary(l2)).area &gt; 1.0)
</pre>
</p><p>
The "<a href="/about/drc_ref_global.xml#secondary">secondary</a>" operator indicates that "l2" is to be used as secondary input to the "drc" function. Only
in this form, the operators of the boolean AND can be reversed:
</p><p>
<pre>
out = l1.drc((secondary(l2) &amp; primary).area &gt; 1.0)
</pre>
</p><p>
<h3>Quantifiers </h3>
</p><p>
Some filters operate on properties of the full, local, per-primary shape set. 
While the loop is executed, the DRC expressions will collect shapes, either
from the primary, its neighborhood (secondaries) or from deriving shape sets.
</p><p>
Obviously the primary is a simple one: it consists of a single shape, because
this is how the loop operates. Derived shape sets however can be more complex.
"Quantifiers" allow assessing properties of the complete, per-primary shape
set. A simple one is "<a href="/about/drc_ref_drc.xml#count">DRC#count</a>" which checks if the number of shapes within
a shape set is within a given range.
</p><p>
Obviously, "primary.count == 1" is always true. So using "count" primaries isn't
much fun. So it's better to use it on derived sets.
The following condition will select all primary shapes which have more than 13 corners:
</p><p>
<pre>
out = in.drc(if_any(primary.corners.count &gt; 13))
</pre>
</p><p>
Note an important detail here: the "if_any" function will make this statement render primary
polygons, if the expression inside gives a non-empty result. Without
"if_any", the result would be the output of "count" which is the set of all
corners where the corner count is larger than 13.
</p><p>
<h3>Expressions as objects </h3>
</p><p>
The expression inside the "drc" function is a Ruby object and can be 
stored in variables. If you need the same expression multiple times, it can be 
more efficient to use the same Ruby object. In this example, the same expression
is used two times. Hence it's computed two times:
</p><p>
<pre>
out = l1.drc(((primary &amp; l2).area == 1.0) + ((primary &amp; l2).area == 2.0))
</pre>
</p><p>
A more efficient version is:
</p><p>
<pre>
overlap_area = (primary &amp; l2).area
out = l1.drc((overlap_area == 1.0) + (overlap_area == 2.0))
</pre>
</p><p>
Note that the first line prepares the operation, but does not execute the area computation
or the boolean operation. But when the "drc" function executes the loop over the primaries it will 
only compute the area once per primary as it is represented by the same Ruby object.
</p><p>
<h3>Properties constraints </h3>
</p><p>
The method can be given a properties constraint so that it is only performed
between shapes with the same or different user properties. Note that properties
have to be enabled or generated (e.g. through the <a href="/about/drc_ref_drclayer.xml#nets">DRCLayer#nets</a> method) before they can
be used.
</p><p>
Example:
</p><p>
<pre>
connect(metal1, via1)
... 

space_not_connected = metal1.nets.drc(space &lt; 0.4.um, props_ne)
</pre>
</p><p>
See <a href="/about/drc_ref_global.xml#props_eq">props_eq</a>, <a href="/about/drc_ref_global.xml#props_ne">props_ne</a> and <a href="/about/drc_ref_global.xml#props_copy">props_copy</a> for details.
</p><p>
<h3>Outlook </h3>
</p><p>
DRC expressions are quite rich and powerful. They provide a more intuitive way of
writing DRC expressions, are more efficient and open new opportunities. DRC
development is likely to focus on this scheme in the future.
</p><p>
More formal details about the bits and pieces can be found in the "<a href="/about/drc_ref_drc.xml">DRC</a>" class documentation.
</p>
<a name="dup"/><h2>"dup" - Duplicates a layer</h2>
<keyword name="dup"/>
<p>Usage:</p>
<ul>
<li><tt>layer.dup</tt></li>
</ul>
<p>
Duplicates the layer. This basically will create a copy and
modifications of the original layer will not affect the duplicate.
Please note that just assigning the layer to another variable will
not create a copy but rather a pointer to the original layer. Hence
modifications will then be visible on the original and derived 
layer. Using the dup method will avoid that.
</p><p>
However, dup will double the memory required to hold the data 
and performing the deep copy may be expensive in terms of CPU time.
</p>
<a name="each"/><h2>"each" - Iterates over the objects from the layer</h2>
<keyword name="each"/>
<p>Usage:</p>
<ul>
<li><tt>layer.each { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block on each object of the layer. Depending on the
layer type, these objects are of <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc> type.
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p>
<a name="edge_pairs?"/><h2>"edge_pairs?" - Returns true, if the layer is an edge pair collection</h2>
<keyword name="edge_pairs?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.edge_pairs?</tt></li>
</ul>
<a name="edges"/><h2>"edges" - Decomposes the layer into single edges</h2>
<keyword name="edges"/>
<p>Usage:</p>
<ul>
<li><tt>layer.edges</tt></li>
<li><tt>layer.edges(mode)</tt></li>
</ul>
<p>
Edge pair collections are decomposed into the individual edges that make up
the edge pairs. Polygon layers are decomposed into the edges making up the 
polygons. This method returns an edge layer but will not modify the layer it 
is called on.
</p><p>
Merged semantics applies, i.e. the result reflects merged polygons rather than
individual ones unless raw mode is chosen.
</p><p>
The "mode" argument allows selecting specific edges from polygons.
Allowed values are: "convex", "concave", "step", "step_in" and "step_out".
"step" generates edges only if they provide a step between two other
edges. "step_in" creates edges that make a step towards the inside of
the polygon and "step_out" creates edges that make a step towards the
outside:
</p><p>
<pre>
out = in.edges(convex)
</pre>
</p><p>
In addition, "not_.." variants are available which selects edges
not qualifying for the specific mode:
</p><p>
<pre>
out = in.edges(not_convex)
</pre>
</p><p>
The mode argument is only available for polygon layers.
</p><p>
The following images show the effect of the mode argument:
</p><p>
<table>
<tr>
<td><img src="/images/drc_edge_modes1.png"/></td>
<td><img src="/images/drc_edge_modes2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_edge_modes3.png"/></td>
<td><img src="/images/drc_edge_modes4.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_edge_modes5.png"/></td>
<td><img src="/images/drc_edge_modes6.png"/></td>
</tr>
</table>
</p>
<a name="edges?"/><h2>"edges?" - Returns true, if the layer is an edge layer</h2>
<keyword name="edges?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.edges?</tt></li>
</ul>
<a name="enc"/><h2>"enc" - An alias for "enclosing"</h2>
<keyword name="enc"/>
<p>Usage:</p>
<ul>
<li><tt>layer.enc(value [, options])</tt></li>
</ul>
<p>
See <a href="#enclosing">enclosing</a> for a description of that method
</p>
<a name="enclosed"/><h2>"enclosed" - An enclosing check (other_layer enclosing layer)</h2>
<keyword name="enclosed"/>
<p>Usage:</p>
<ul>
<li><tt>layer.enclosed(other_layer, value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"enclosed" is available as operators for the "universal DRC" function <a href="#drc">drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. These variants have more options and are more intuitive to use. 
See <a href="/about/drc_ref_global.xml#enclosed">enclosed</a> for more details.
</p><p>
This method checks whether layer is enclosed by (is inside of) other_layer by not less than the
given distance value. Locations, where the distance is less will be reported in form
of edge pair error markers.
Locations, where both edges coincide will be reported as errors as well. Formally
such locations form an enclosure with a distance of 0. Locations, where other_layer
is inside layer will not be reported as errors. Such regions can be detected
by <a href="#inside">inside</a> or a boolean "not" operation.
</p><p>
The options are the same as for <a href="#separation">separation</a>.
</p><p>
This method is available for edge and polygon layers.
</p><p>
As for the other DRC methods, merged semantics applies.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of two enclosed checks (red: input1, blue: input2):
</p><p>
<table>
<tr>
<td><img src="/images/drc_encd1.png"/></td>
<td><img src="/images/drc_encd2.png"/></td>
</tr>
</table>
</p>
<a name="enclosing"/><h2>"enclosing" - An enclosing check (layer enclosing other_layer)</h2>
<keyword name="enclosing"/>
<p>Usage:</p>
<ul>
<li><tt>layer.enclosing(other_layer, value [, options])</tt></li>
<li><tt>layer.enc(other_layer, value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"enclosing" and "enc" are available as operators for the "universal DRC" function <a href="#drc">drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. These variants have more options and are more intuitive to use. 
See <a href="/about/drc_ref_global.xml#enclosing">enclosing</a> for more details.
</p><p>
This method checks whether layer encloses (is bigger than) other_layer by not less than the
given distance value. Locations, where the distance is less will be reported in form
of edge pair error markers.
Locations, where both edges coincide will be reported as errors as well. Formally
such locations form an enclosure with a distance of 0. Locations, where other_layer
extends outside layer will not be reported as errors. Such regions can be detected
by <a href="#not_inside">not_inside</a> or a boolean "not" operation.
</p><p>
"enc" is the short form of this method.
</p><p>
The options are the same as for <a href="#separation">separation</a>.
</p><p>
The enclosing method can be applied to both edge or polygon layers. On edge layers 
the orientation of the edges matters and only edges looking into the same direction
are checked.
</p><p>
As for the other DRC methods, merged semantics applies.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of two enclosing checks (red: input1, blue: input2):
</p><p>
<table>
<tr>
<td><img src="/images/drc_enc1.png"/></td>
<td><img src="/images/drc_enc2.png"/></td>
</tr>
</table>
</p>
<a name="end_segments"/><h2>"end_segments" - Returns the part at the end of each edge</h2>
<keyword name="end_segments"/>
<p>Usage:</p>
<ul>
<li><tt>layer.end_segments(length)</tt></li>
<li><tt>layer.end_segments(length, fraction)</tt></li>
</ul>
<p>
This method will return a partial edge for each edge in the input, 
located and the end of the original edge.
The new edges will share the end point with the original edges, but not necessarily
their start point. This method applies to edge layers only. 
The direction of edges is defined by the clockwise orientation of a polygon: the 
end point of the edges will be the terminal point of each edge when walking a polygon
in clockwise direction. Or in other words: when looking from start to the end point
of an edge, the filled part of the polygon is to the right.
</p><p>
The length of the new edge can be given in two ways: as a fixed length, or a fraction, or
both. In the latter case, the length of the resulting edge will be either the fraction or
the fixed length, whichever is larger.
To specify a length only, omit the fraction argument or leave it at 0. To specify
a fraction only, pass 0 to the length argument and specify the fraction in the second
parameter. A fraction of 0.5 will result in edges which cover the end half of the 
edge.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_end_segments1.png"/></td>
<td><img src="/images/drc_end_segments2.png"/></td>
</tr>
</table>
</p>
<a name="extended"/><h2>"extended" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended"/>
<p>Usage:</p>
<ul>
<li><tt>layer.extended([:begin =&gt; b,] [:end =&gt; e,] [:out =&gt; o,] [:in =&gt; i], [:joined =&gt; true])</tt></li>
<li><tt>layer.extended(b, e, o, i)</tt></li>
<li><tt>layer.extended(b, e, o, i, joined)</tt></li>
</ul>
<p>
This method is available for edge layers only. It will create a polygon for each edge
tracing the edge with certain offsets to the edge. "o" is the offset applied to the 
outer side of the edge, "i" is the offset applied to the inner side of the edge.
"b" is the offset applied at the beginning and "e" is the offset applied at the end.
</p><p>
When looking from start to end point, the "inside" side is to the right, while the "outside"
side is to the left.
</p><p>
"joined" is a flag, which, if present, will make connected edges behave as a continuous
line. Start and end offsets are applied to the first and last unconnected point respectively.
Please note that in order to specify joined mode, you'll need to specify "joined" as 
a keyword in the third form of the method.
</p><p>
The following images show the effects of some parameters:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extended1.png"/></td>
<td><img src="/images/drc_extended2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extended3.png"/></td>
<td><img src="/images/drc_extended4.png"/></td>
</tr>
</table>
</p>
<a name="extended_in"/><h2>"extended_in" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended_in"/>
<p>Usage:</p>
<ul>
<li><tt>layer.extended_in(d)</tt></li>
</ul>
<p>
This method applies to edge layers only. Polygons are generated for 
each edge describing the edge drawn with a certain width extending into
the "inside" (the right side when looking from start to end).
This method is basically equivalent to the <a href="#extended">extended</a> method:
"extended(0, 0, 0, dist)".
A version extending to the outside is <a href="#extended_out">extended_out</a>.
</p>
<a name="extended_out"/><h2>"extended_out" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended_out"/>
<p>Usage:</p>
<ul>
<li><tt>layer.extended_out(d)</tt></li>
</ul>
<p>
This method applies to edge layers only. Polygons are generated for 
each edge describing the edge drawn with a certain width extending into
the "outside" (the left side when looking from start to end).
This method is basically equivalent to the <a href="#extended">extended</a> method:
"extended(0, 0, dist, 0)".
A version extending to the inside is <a href="#extended_in">extended_in</a>.
</p>
<a name="extent_refs"/><h2>"extent_refs" - Returns partial references to the boundings boxes of the polygons</h2>
<keyword name="extent_refs"/>
<p>Usage:</p>
<ul>
<li><tt>layer.extent_refs(fx, fy [, options ])</tt></li>
<li><tt>layer.extent_refs(fx1, fy1, fx2, fx2 [, options ])</tt></li>
<li><tt>layer.extent_refs(ref_spec [, options ])</tt></li>
</ul>
<p>
This method produces parts of the bounding box of the polygons. It can select 
either edges, certain points or partial boxes. It can be used the following
ways:
</p><p>
<ul>
<li><b>With a formal specification </b>: This is an identifier like
":center" or ":left" to indicate which part will be produced. </li>
<li><b>With two floating-point arguments </b>: These arguments specify
a point relative to the bounding box. The first argument is a relative
x coordinate where 0.0 means "left side of the bounding box" and 1.0
is the right side. The second argument is a relative y coordinate where
0.0 means "bottom" and 1.0 means "top". The results will be small 
(2x2 DBU) boxes or point-like edges for edge output </li>
<li><b>With four floating-point arguments </b>: These arguments specify
a box in relative coordinates: a pair of x/y relative coordinate for
the first point and another pair for the second point. The results will
be boxes or a tilted edge in case of edge output. If the range specifies
a finite-area box (height and width are not zero), no adjustment of 
the boxes will happen for polygon output - i.e. the additional enlargement 
by 1 DBU which is applied for zero-area boxes does not happen.</li>
</ul>
</p><p>
The formal specifiers are for points:
</p><p>
<ul>
<li><b>:center </b>or <b>:c </b>: the center point </li>
<li><b>:bottom_center </b>or <b>:bc </b>: the bottom center point </li>
<li><b>:bottom_left </b>or <b>:bl </b>: the bottom left point </li>
<li><b>:bottom_right </b>or <b>:br </b>: the bottom right point </li>
<li><b>:left </b>or <b>:l </b>: the left point </li>
<li><b>:right </b>or <b>:r </b>: the right point </li>
<li><b>:top_center </b>or <b>:tc </b>: the top center point </li>
<li><b>:top_left </b>or <b>:tl </b>: the top left point </li>
<li><b>:top_right </b>or <b>:tr </b>: the top right point </li>
</ul>
</p><p>
The formal specifiers for lines are:
</p><p>
<ul>
<li><b>:bottom </b>or <b>:b </b>: the bottom line </li>
<li><b>:top </b>or <b>:t </b>: the top line </li>
<li><b>:left </b>or <b>:l </b>: the left line </li>
<li><b>:right </b>or <b>:r </b>: the right line </li>
</ul>
</p><p>
Dots are represented by small (2x2 DBU) boxes or point-like
edges with edge output. Lines are represented by narrow or 
flat (2 DBU) boxes or edges for edge output. Edges will follow
the orientation convention for the corresponding edges - i.e.
"inside" of the bounding box is on the right side of the edge.
</p><p>
The following additional option controls the output format:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>or <b>as_edges </b>: with this option, point-like edges will be produced for dots
and edges will be produced for line-like selections </li>
</ul>
</p><p>
The following table shows a few applications:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extent_refs1.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs10.png"/></td>
<td><img src="/images/drc_extent_refs11.png"/></td>
<td><img src="/images/drc_extent_refs12.png"/></td>
<td><img src="/images/drc_extent_refs13.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs20.png"/></td>
<td><img src="/images/drc_extent_refs21.png"/></td>
<td><img src="/images/drc_extent_refs22.png"/></td>
<td><img src="/images/drc_extent_refs23.png"/></td>
<td><img src="/images/drc_extent_refs24.png"/></td>
<td><img src="/images/drc_extent_refs25.png"/></td>
<td><img src="/images/drc_extent_refs26.png"/></td>
<td><img src="/images/drc_extent_refs27.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs30.png"/></td>
<td><img src="/images/drc_extent_refs31.png"/></td>
</tr>
</table>
</p>
<a name="extents"/><h2>"extents" - Returns the bounding box of each input object</h2>
<keyword name="extents"/>
<p>Usage:</p>
<ul>
<li><tt>layer.extents([ enlargement ])</tt></li>
</ul>
<p>
Applies to edge layers, polygon layers on edge pair collections.
Returns a polygon layer consisting of boxes for each input object.
The boxes enclose the original object. 
</p><p>
Merged semantics applies, so the box encloses the merged polygons
or edges unless raw mode is chosen (see <a href="#raw">raw</a>).
</p><p>
The enlargement parameter specifies an optional enlargement which 
will make zero width/zero height object render valid polygons 
(i.e. horizontal/vertical edges).
</p><p>
The following images show the effect of the extents method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extents1.png"/></td>
<td><img src="/images/drc_extents2.png"/></td>
</tr>
</table>
</p>
<a name="fill"/><h2>"fill" - Fills the region with regular pattern of shapes</h2>
<keyword name="fill"/>
<p>Usage:</p>
<ul>
<li><tt>layer.fill([ options ])</tt></li>
</ul>
<p>
This method will attempt to fill the polygons of the layer with a regular pattern
of shapes.
</p><p>
The fill function currently is not available in deep mode.
</p><p>
Options are:
<ul>
<li><b>hstep(x) </b>or <b>hstep(x, y) </b>: specifies the horizontal step pitch of the pattern. x must be 
a positive value. A vertical displacement component can be specified too, which results in a skewed pattern. </li>
<li><b>vstep(y) </b>or <b>vstep(x, y) </b>: specifies the vertical step pitch of the pattern. y must be 
a positive value. A horizontal displacement component can be specified too, which results in a skewed pattern. </li>
<li><b>origin(x, y) </b>: specifies a fixed point to align the pattern with. This point specifies the location
of the reference point for one pattern cell. </li>
<li><b>auto_origin </b>: lets the algorithm choose the origin. This may result is a slightly better fill coverage
as the algorithm is able to determine a pattern origin per island to fill. </li>
<li><b>multi_origin </b>: lets the algorithm choose the origin and repeats the fill with different origins
until no further fill cell can be fitted. </li>
<li><b>fill_pattern(..) </b>: specifies the fill pattern. </li>
</ul>
</p><p>
"fill_pattern" generates a fill pattern object. This object is used for configuring the fill pattern
content. Fill pattern need to be named. The name will be used for generating the fill cell.
</p><p>
To provide a fill pattern, create a fill pattern object and add shapes to it. The following example creates
a fill pattern named "FILL_CELL" and adds a 1x1 micron box on layer 1/0:
</p><p>
<pre>
p = fill_pattern("FILL_CELL")
p.shape(1, 0, box(0.0, 0.0, 1.0, 1.0))
</pre>
</p><p>
See <a href="/about/drc_ref_global.xml#box">box</a> for details about the box specification. You can also add paths or polygons with <a href="/about/drc_ref_global.xml#path">path</a> or <a href="/about/drc_ref_global.xml#polygon">polygon</a>.
</p><p>
A more compact way of writing this is:
</p><p>
<pre>
p = fill_pattern("FILL_CELL").shape(1, 0, box(0.0, 0.0, 1.0, 1.0))
</pre>
</p><p>
The "shape" method takes several forms:
</p><p>
<ul>
<li><tt>shape(layer, object, object ...) </tt>(1) </li>
<li><tt>shape(layer, datatype, object, object ...) </tt>(2) </li>
<li><tt>shape(name, object, object ...) </tt>(3) </li>
<li><tt>shape(layer_info, object, object ...) </tt>(4) </li>
</ul>
</p><p>
The first form takes a GDS2 layer number. The datatype is assumed to be 0.
The second form takes a GDS layer and datatype number.
The third form takes a layer name for layout systems with named layers
(like Magic, CIF or DXF).
The forth form takes a <class_doc href="LayerInfo">LayerInfo</class_doc> object to specify the layer. 
All forms take one to many geometry objects which are written to the respective layer.
Geometry objects can either be created using the generator functions
(<a href="/about/drc_ref_global.xml#box">box</a>, <a href="/about/drc_ref_global.xml#polygon">polygon</a>, <a href="/about/drc_ref_global.xml#path">path</a>). The core classes <class_doc href="DBox">DBox</class_doc>, <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DPath">DPath</class_doc> or
<class_doc href="DText">DText</class_doc> are also accepted as geometry objects.
</p><p>
The fill pattern can be given a reference point which is used for placing the pattern. The reference point
is the one which is aligned with the pattern origin. The following code will assign (-0.5, -0.5) as the reference
point for the 1x1 micron rectangle. Hence the reference point is a little below and left of the rectangle which 
in turn shifts the rectangle fill pattern to the right and up:
</p><p>
<pre>
p = fill_pattern("FILL_CELL")
p.shape(1, 0, box(0.0, 0.0, 1.0, 1.0))
p.origin(-0.5, -0.5)
</pre>
</p><p>
Without a reference point given, the lower left corner of the fill pattern's bounding box will be used
as the reference point. The reference point will also defined the footprint of the fill cell - more precisely
the lower left corner. When step vectors are given, the fill cell's footprint is taken to be a rectangle
having the horizontal and vertical step pitch for width and height respectively. This way the fill cells 
will be arrange seamlessly. However, the cell's dimensions can be changed, so that the fill cells
can overlap or there is a space between the cells. To change the dimensions use the "dim" method.
</p><p>
The following example specifies a fill cell with an active area of -0.5 .. 1.5 in both directions
(2 micron width and height). With these dimensions the fill cell's footprint is independent of the
step pitch:
</p><p>
<pre>
p = fill_pattern("FILL_CELL")
p.shape(1, 0, box(0.0, 0.0, 1.0, 1.0))
p.origin(-0.5, -0.5)
p.dim(2.0, 2.0)
</pre>
</p><p>
With these ingredients will can use the fill function. The first example fills the polygons
of "to_fill" with an orthogonal pattern of 1x1 micron rectangles with a pitch of 2 microns:
</p><p>
<pre>
pattern = fill_pattern("FILL_CELL").shape(1, 0, box(0.0, 0.0, 1.0, 1.0)).origin(-0.5, -0.5)
to_fill.fill(pattern, hstep(2.0), vstep(2.0))
</pre>
</p><p>
This second example will create a skewed fill pattern in auto-origin mode:
</p><p>
<pre>
pattern = fill_pattern("FILL_CELL").shape(1, 0, box(0.0, 0.0, 1.0, 1.0)).origin(-0.5, -0.5)
to_fill.fill(pattern, hstep(2.0, 1.0), vstep(-1.0, 2.0), auto_origin)
</pre>
</p><p>
The fill function can only work with a target layout for output. 
It will not work for report output.
</p><p>
The layers generated by the fill cells is only available for input later in the 
script if the output layout is identical to the input layouts.
If you need the area missed by the fill function, try <a href="#fill_with_left">fill_with_left</a>.
</p>
<a name="fill_with_left"/><h2>"fill_with_left" - Fills the region with regular pattern of shapes</h2>
<keyword name="fill_with_left"/>
<p>Usage:</p>
<ul>
<li><tt>layer.fill_with_left([ options ])</tt></li>
</ul>
<p>
This method has the same call syntax and functionality than <a href="#fill">fill</a>. Other than this method
it will return the area not covered by fill cells as a DRC layer.
</p>
<a name="first_edges"/><h2>"first_edges" - Returns the first edges of an edge pair collection</h2>
<keyword name="first_edges"/>
<p>Usage:</p>
<ul>
<li><tt>layer.first_edges</tt></li>
</ul>
<p>
Applies to edge pair collections only.
Returns the first edges of the edge pairs in the collection.
</p><p>
Some checks deliver symmetric edge pairs (e.g. space, width, etc.) for which the
edges are commutable. "first_edges" will deliver both edges for such edge pairs.
</p>
<a name="flatten"/><h2>"flatten" - Flattens the layer</h2>
<keyword name="flatten"/>
<p>Usage:</p>
<ul>
<li><tt>layer.flatten</tt></li>
</ul>
<p>
If the layer already is a flat one, this method does nothing.
If the layer is a hierarchical layer (an original layer or
a derived layer in deep mode), this method will convert it
to a flat collection of texts, polygons, edges or edge pairs.
</p>
<a name="forget"/><h2>"forget" - Cleans up memory for this layer</h2>
<keyword name="forget"/>
<p>Usage:</p>
<ul>
<li><tt>forget</tt></li>
</ul>
<p>
KLayout's DRC engine is imperative. This means, every command is executed immediately
rather than being compiled and executed later. The advantage of this approach is that
it allows decisions to be taken depending on the content of a layer and to code 
functions that operate directly on the layer's content.
</p><p>
However, one drawback is that the engine cannot decide when a layer is no longer 
required - it may still be used later in the script. So a layer's data is not cleaned
up automatically.
</p><p>
In order to save memory for DRC scripts intended for bigger layouts, the DRC script
should clean up layers as soon as they are no longer required. The "forget" method
will free the memory used for the layer's information.
</p><p>
The recommended approach is:
</p><p>
<pre>
l = ... # compute some layer
...
# once you're done with l:
l.forget
l = nil
</pre>
</p><p>
By setting the layer to nil, it is ensured that it can no longer be accessed.
</p>
<a name="hier_count"/><h2>"hier_count" - Returns the hierarchical number of objects on the layer</h2>
<keyword name="hier_count"/>
<p>Usage:</p>
<ul>
<li><tt>layer.hier_count</tt></li>
</ul>
<p>
The hier_count is the number of raw objects, not merged
regions or edges, with each cell counting once. 
A high <a href="#count">count</a> to hier_count (flat to hierarchical) ratio is an indication
of a good hierarchical compression.
"hier_count" applies only to original layers without clip regions or
cell filters and to layers in <a href="/about/drc_ref_global.xml#deep">deep</a> mode. Otherwise, hier_count gives 
the same value than <a href="#count">count</a>.
</p>
<a name="holes"/><h2>"holes" - Selects all polygon holes from the input</h2>
<keyword name="holes"/>
<p>Usage:</p>
<ul>
<li><tt>layer.holes</tt></li>
</ul>
<p>
This method is available for polygon layers. It will create polygons from all holes inside 
polygons of the input. Although it is possible, running this method on raw polygon layers will
usually not render the expected result, since raw layers do not contain polygons with holes in
most cases.
</p><p>
The following image shows the effects of the holes method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_holes.png"/></td>
</tr>
</table>
</p>
<a name="hulls"/><h2>"hulls" - Selects all polygon hulls from the input</h2>
<keyword name="hulls"/>
<p>Usage:</p>
<ul>
<li><tt>layer.hulls</tt></li>
</ul>
<p>
This method is available for polygon layers. It will remove all holes from the input and 
render the hull polygons only. Although it is possible, running this method on raw polygon layers will
usually not render the expected result, since raw layers do not contain polygons with holes in
most cases.
</p><p>
The following image shows the effects of the hulls method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_hulls.png"/></td>
</tr>
</table>
</p>
<a name="in"/><h2>"in" - Selects shapes or regions of self which are contained in the other layer</h2>
<keyword name="in"/>
<p>Usage:</p>
<ul>
<li><tt>layer.in(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are contained  
the other region exactly. It will use individual shapes from self or other if
the respective region is in raw mode. If not, it will use coherent regions or combined edges from
self or other.
</p><p>
It will return a new layer containing the selected shapes.
A method which selects all shapes not contained in the other layer is <a href="#not_in">not_in</a>.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following image shows the effect of the "in" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_in.png"/></td>
</tr>
</table>
</p>
<a name="in_and_out"/><h2>"in_and_out" - Selects shapes or regions of self which are and which are not contained in the other layer</h2>
<keyword name="in_and_out"/>
<p>Usage:</p>
<ul>
<li><tt>(in, not_in) = layer.in_and_out(other)</tt></li>
</ul>
<p>
This method is equivalent to calling <a href="#in">in</a> and <a href="#not_in">not_in</a>, but more
efficient as it delivers both results in a single call.
</p>
<a name="insert"/><h2>"insert" - Inserts one or many objects into the layer</h2>
<keyword name="insert"/>
<p>Usage:</p>
<ul>
<li><tt>insert(object, object ...)</tt></li>
</ul>
<p>
Objects that can be inserted are <class_doc href="Edge">Edge</class_doc> objects (into edge layers) or 
<class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DSimplePolygon">DSimplePolygon</class_doc>, <class_doc href="Path">Path</class_doc>, <class_doc href="DBox">DBox</class_doc> (into polygon layers).
Convenience methods exist to create such objects (<a href="/about/drc_ref_global.xml#edge">edge</a>, <a href="/about/drc_ref_global.xml#polygon">polygon</a>, <a href="/about/drc_ref_global.xml#box">box</a> and <a href="/about/drc_ref_global.xml#path">path</a>).
However, RBA constructors can used as well.
</p><p>
The insert method is useful in combination with the <a href="/about/drc_ref_global.xml#polygon_layer">polygon_layer</a> or <a href="/about/drc_ref_global.xml#edge_layer">edge_layer</a> functions: 
</p><p>
<pre>
el = edge_layer
el.insert(edge(0.0, 0.0, 100.0, 0.0)

pl = polygon_layer
pl.insert(box(0.0, 0.0, 100.0, 200.0)
</pre>
</p>
<a name="inside"/><h2>"inside" - Selects edges, edge pairs or polygons of self which are inside edges or polygons from the other layer</h2>
<keyword name="inside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.inside(other)</tt></li>
</ul>
<p>
If layer is a polygon layer, the other layer needs to be a polygon layer too.
In this case, this method selects all polygons which are completely inside 
polygons from the other layer.
</p><p>
If layer is an edge pair layer, the other layer needs to be a polygon layer.
In this case, this method selects all edge pairs which are completely inside 
polygons from the other layer.
</p><p>
If layer is an edge layer, the other layer can be polygon or edge layer. In the
first case, all edges completely inside the polygons from the other layer are
selected. If the other layer is an edge layer, all edges completely contained 
in edges from the other layer are selected.
</p><p>
Merged semantics applies - i.e. edges or polygons are joined before the 
result is computed, unless the layers are in <a href="#raw">raw</a> mode.
</p><p>
This method returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_inside">select_inside</a>. <a href="#not_inside">not_inside</a> is a function computing the inverse of <a href="#inside">inside</a>.
<a href="#split_inside">split_inside</a> is a function computing both results in a single call. <a href="#outside">outside</a>
is a similar function selecting edges or polygons outside other edges or polygons.
</p><p>
The following image shows the effect of the "inside" method for polygons (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside.png"/></td>
</tr>
</table>
</p><p>
The following images show the effect of the "inside" method for edge layers and edge or polygon layers
the second input. Note that the edges are computed from the polygons in this example 
(input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside_ee.png"/></td>
</tr>
</table>
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside_ep.png"/></td>
</tr>
</table>
</p>
<a name="inside_outside_part"/><h2>"inside_outside_part" - Returns the parts of the edges inside and outside the given region</h2>
<keyword name="inside_outside_part"/>
<p>Usage:</p>
<ul>
<li><tt>(inside_part, outside_part) = layer.inside_outside_part(region)</tt></li>
</ul>
<p>
The method is available for edge layers. The argument must be a polygon layer.
</p><p>
This method returns two layers: the first with the edge parts inside the given region
and the second with the parts outside the given region. It is equivalent 
to calling <a href="#inside_part">inside_part</a> and <a href="#outside_part">outside_part</a>, but more efficient if both parts
need to be computed.
</p>
<a name="inside_part"/><h2>"inside_part" - Returns the parts of the edges inside the given region</h2>
<keyword name="inside_part"/>
<p>Usage:</p>
<ul>
<li><tt>layer.inside_part(region)</tt></li>
</ul>
<p>
This method returns the parts of the edges which are inside the given region. This is similar to the
"&amp;" operator, but this method does not return edges that are exactly on the boundaries
of the polygons of the region.
</p><p>
This method is available for edge layers. The argument must be a polygon layer.
</p><p>
<a href="#outside_part">outside_part</a> is a method computing the opposite part. <a href="#inside_outside_part">inside_outside_part</a> is a
method computing both inside and outside part in a single call.
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside_part.png"/></td>
</tr>
</table>
</p>
<a name="interacting"/><h2>"interacting" - Selects shapes or regions of self which touch or overlap shapes from the other region</h2>
<keyword name="interacting"/>
<p>Usage:</p>
<ul>
<li><tt>layer.interacting(other)</tt></li>
<li><tt>layer.interacting(other, min_count)</tt></li>
<li><tt>layer.interacting(other, min_count, max_count)</tt></li>
<li><tt>layer.interacting(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which touch or overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_interacting">select_interacting</a>.
</p><p>
This method is available for polygon, text, edge and edge pair layers. Edges and edge pairs can be selected
with respect to other edges or polygons. Texts can be selected with respect to 
polygons. Polygons can be selected with respect to edges, texts and other polygons.
</p><p>
The following image shows the effect of the "interacting" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_interacting.png"/></td>
</tr>
</table>
</p><p>
If a single count is given, shapes from self are selected only if they do interact at least with the given
number of (different) shapes from the other layer. If a min and max count is given, shapes from  
self are selected only if they interact with min_count or more, but a maximum of max_count different shapes
from the other layer. Two polygons overlapping or touching at two locations are counted as single interactions.
</p><p>
<table>
<tr>
<td><img src="/images/drc_interacting2.png"/></td>
<td><img src="/images/drc_interacting3.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_interacting4.png"/></td>
<td><img src="/images/drc_interacting5.png"/></td>
</tr>
</table>
</p>
<a name="intersections"/><h2>"intersections" - Returns the intersection points of intersecting edge segments for two edge collections</h2>
<keyword name="intersections"/>
<p>Usage:</p>
<ul>
<li><tt>layer.intersections(edges)</tt></li>
</ul>
<p>
This operation is similar to the "&amp;" operator, but it does also report intersection points
between non-colinear, but intersecting edges. Such points are reported as point-like,
degenerated edge objects.
</p><p>
This method is available for edge layers. The argument must be an edge layer.
</p>
<a name="is_box?"/><h2>"is_box?" - Returns true, if the region contains a single box</h2>
<keyword name="is_box?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_box?</tt></li>
</ul>
<p>
The method returns true, if the region consists of a single box
only. Merged semantics does not apply - if the region forms a box which
is composed of multiple pieces, this method will not return true.
</p>
<a name="is_clean?"/><h2>"is_clean?" - Returns true, if the layer is clean state</h2>
<keyword name="is_clean?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_clean?</tt></li>
</ul>
<p>
See <a href="#clean">clean</a> for a discussion of the clean state.
</p>
<a name="is_deep?"/><h2>"is_deep?" - Returns true, if the layer is a deep (hierarchical) layer</h2>
<keyword name="is_deep?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_deep?</tt></li>
</ul>
<a name="is_empty?"/><h2>"is_empty?" - Returns true, if the layer is empty</h2>
<keyword name="is_empty?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_empty?</tt></li>
</ul>
<a name="is_merged?"/><h2>"is_merged?" - Returns true, if the polygons of the layer are merged</h2>
<keyword name="is_merged?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_merged?</tt></li>
</ul>
<p>
This method will return true, if the polygons of this layer are
merged, i.e. they don't overlap and form single continuous polygons.
In clean mode, this is ensured implicitly. In raw mode (see <a href="#raw">raw</a>),
merging can be achieved by using the <a href="#merge">merge</a> method. <a href="#is_merged?">is_merged?</a>
tells, whether calling <a href="#merge">merge</a> is necessary.
</p>
<a name="is_raw?"/><h2>"is_raw?" - Returns true, if the layer is raw state</h2>
<keyword name="is_raw?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_raw?</tt></li>
</ul>
<p>
See <a href="#clean">clean</a> for a discussion of the raw state.
</p>
<a name="iso"/><h2>"iso" - An alias for "isolated"</h2>
<keyword name="iso"/>
<p>Usage:</p>
<ul>
<li><tt>layer.iso(value [, options])</tt></li>
</ul>
<p>
See <a href="#isolated">isolated</a> for a description of that method
</p>
<a name="isolated"/><h2>"isolated" - An inter-polygon isolation check</h2>
<keyword name="isolated"/>
<p>Usage:</p>
<ul>
<li><tt>layer.isolated(value [, options])</tt></li>
<li><tt>layer.iso(value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"isolated" and "iso" are available as operators for the "universal DRC" function <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. These variants have more options and are more intuitive to use. See <a href="/about/drc_ref_global.xml#isolated">isolated</a> for more details.
</p><p>
See <a href="#space">space</a> for a description of this method. "isolated" is the space check variant which checks different polygons only.
In contrast to <a href="#space">space</a>, the "isolated"
method is available for polygon layers only, since only on such layers 
different polygons can be identified.
</p><p>
"iso" is the short form of this method.
</p><p>
The following image shows the effect of the isolated check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space3.png"/></td>
</tr>
</table>
</p>
<a name="join"/><h2>"join" - Joins the layer with another layer</h2>
<keyword name="join"/>
<p>Usage:</p>
<ul>
<li><tt>layer.join(other)</tt></li>
</ul>
<p>
The method includes the edges or polygons from the other layer into this layer.
It is an alias for the "+" operator.
</p><p>
This method is available for polygon, edge and edge pair layers.
</p><p>
The following images show the effect of the "join" method
on polygons and edges (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_join1.png"/></td>
<td><img src="/images/drc_join2.png"/></td>
</tr>
</table>
</p>
<a name="length"/><h2>"length" - Returns the total length of the edges in the edge layer</h2>
<keyword name="length"/>
<p>Usage:</p>
<ul>
<li><tt>layer.length</tt></li>
</ul>
<p>
This method requires an edge layer. It returns the total
length of all edges in micron. Merged semantics applies, 
i.e. before computing the length, the edges are merged unless
raw mode is chosen (see <a href="#raw">raw</a>). Hence in clean mode (see <a href="#clean">clean</a>), overlapping
edges are not counted twice.
</p>
<a name="map_props"/><h2>"map_props" - Selects properties with certain keys and allows key mapping</h2>
<keyword name="map_props"/>
<p>Usage:</p>
<ul>
<li><tt>layer.map_props({ key =&gt; key_new, .. })</tt></li>
</ul>
<p>
Similar to <a href="#select_props">select_props</a>, this method will map or filter properties and
and take the values from certain keys. In addition, this method allows
mapping keys to new keys. Specify a hash argument with old to new keys.
</p><p>
Property values with keys not listed in the hash are removed.
</p><p>
Note that this method returns a new layer with the new properties. The
original layer will not be touched. 
</p><p>
For example to map key 2 to 1 (integer name keys) and ignore other keys,
use:
</p><p>
<pre>
layer1 = input(1, 0, enable_properties)
layer1_mapped = layer1.map_props({ 2 =&gt; 1 })
</pre>
</p><p>
See also <a href="#select_props">select_props</a> and <a href="#remove_props">remove_props</a>.
</p>
<a name="merge"/><h2>"merge" - Merges the layer (modifies the layer)</h2>
<keyword name="merge"/>
<p>Usage:</p>
<ul>
<li><tt>layer.merge([overlap_count])</tt></li>
</ul>
<p>
Like <a href="#merged">merged</a>, but modifies the input and returns a reference to the 
new layer.
</p>
<a name="merged"/><h2>"merged" - Returns the merged layer</h2>
<keyword name="merged"/>
<p>Usage:</p>
<ul>
<li><tt>layer.merged([overlap_count])</tt></li>
</ul>
<p>
Returns the merged input. Usually, merging is done implicitly using the
<a href="#clean">clean</a> state (which is default). However, in raw state, merging can be 
enforced by using this method. In addition, this method allows specification
of a minimum overlap count, i.e. only where at least the given number of polygons
overlap, output is produced. See <a href="#sized">sized</a> for an application of that.
</p><p>
This method works both on edge or polygon layers. Edge merging forms
single, continuous edges from coincident and connected individual edges.
</p><p>
A version that modifies the input layer is <a href="#merge">merge</a>.
</p><p>
The following images show the effect of various forms of the "merged" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_merged1.png"/></td>
<td><img src="/images/drc_merged2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_merged3.png"/></td>
<td><img src="/images/drc_merged4.png"/></td>
</tr>
</table>
</p>
<a name="middle"/><h2>"middle" - Returns the center points of the bounding boxes of the polygons</h2>
<keyword name="middle"/>
<p>Usage:</p>
<ul>
<li><tt>layer.middle([ options ])</tt></li>
</ul>
<p>
This method produces markers on the centers of the polygon's bounding box centers. 
These markers can be point-like edges or small 2x2 DBU boxes. The latter is the default.
A more generic function is <a href="#extent_refs">extent_refs</a>. "middle" is basically a synonym for "extent_refs(:center)".
</p><p>
The options available are:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
</ul>
</p><p>
The following image shows the effect of this method
</p><p>
<table>
<tr>
<td><img src="/images/drc_middle1.png"/></td>
</tr>
</table>
</p>
<a name="move"/><h2>"move" - Moves (shifts, translates) a layer (modifies the layer)</h2>
<keyword name="move"/>
<p>Usage:</p>
<ul>
<li><tt>layer.move(dx, dy)</tt></li>
</ul>
<p>
Moved the input by the given distance. The layer that this method is called 
upon is modified and the modified version is returned for further processing.
</p><p>
Shift distances can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p>
<a name="moved"/><h2>"moved" - Moves (shifts, translates) a layer</h2>
<keyword name="moved"/>
<p>Usage:</p>
<ul>
<li><tt>layer.moved(dx, dy)</tt></li>
</ul>
<p>
Moves the input layer by the given distance (x, y) and returns
the moved layer. The layer that this method is called upon is not modified.
</p><p>
Shift distances can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images shows the effect of the "moved" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_moved1.png"/></td>
</tr>
</table>
</p>
<a name="nets"/><h2>"nets" - Pulls net shapes from selected or all nets, optionally annotating nets with properties</h2>
<keyword name="nets"/>
<p>Usage:</p>
<ul>
<li><tt>layer.nets</tt></li>
<li><tt>layer.nets(net_filter)</tt></li>
<li><tt>layer.nets(net_object)</tt></li>
<li><tt>layer.nets(circuit_filter, net_filter)</tt></li>
<li><tt>layer.nets(netter, ...)</tt></li>
<li><tt>layer.nets(prop(key), ...)</tt></li>
<li><tt>layer.nets(prop(key), ...)</tt></li>
</ul>
<p>
This method needs a layer that has been used in a connect statement.
It will take the shapes corresponding to this layer for all or selected nets
and attach the net identity in form of a user property.
</p><p>
This way, the resulting shapes can be used in property-constrained boolean operations
or DRC checks to implement operations in connected or non-connected mode.
</p><p>
A glob-style name pattern can be supplied to filter nets. Nets are always
complete - subnets from subcircuits are not selected. The net name is taken from
the net's home circuit (to topmost location where all net connections are formed).
You can specify a circuit filter to select nets from certain circuits only or
give a <class_doc href="Circuit">Circuit</class_doc> object explicitly. You can also specify <class_doc href="Net">Net</class_doc> objects directly.
</p><p>
<pre>
connect(metal1, via1)
connect(via1, metal2)

metal1_all_nets = metal1.nets
metal1_vdd      = metal1.nets("VDD")
metal1_vdd      = metal1.nets("TOPLEVEL", "VDD")
</pre>
</p><p>
By default, the property key used for the net identity is numerical 0 (integer). You
can change the key by giving a property key with the "prop" qualifier. Using "nil" for the key
will disable properties:
</p><p>
<pre>
metal1_vdd = metal1.nets("VDD", prop(1))
# disables properties:
metal1_vdd = metal1.nets("VDD", prop(nil))
</pre>
</p><p>
If a custom netter object has been used for the construction of the 
connectivity, pass it to the "nets" method among the other arguments.
</p>
<a name="non_rectangles"/><h2>"non_rectangles" - Selects all polygons from the input which are not rectangles</h2>
<keyword name="non_rectangles"/>
<p>Usage:</p>
<ul>
<li><tt>layer.non_rectangles</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before non-rectangles are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
</p>
<a name="non_rectilinear"/><h2>"non_rectilinear" - Selects all non-rectilinear polygons from the input</h2>
<keyword name="non_rectilinear"/>
<p>Usage:</p>
<ul>
<li><tt>layer.non_rectilinear</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before non-rectilinear polygons are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
</p>
<a name="non_squares"/><h2>"non_squares" - Selects all polygons from the input which are not squares</h2>
<keyword name="non_squares"/>
<p>Usage:</p>
<ul>
<li><tt>layer.non_rectangles</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before non-squares are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
</p>
<a name="non_strict"/><h2>"non_strict" - Marks a layer for non-strict handling</h2>
<keyword name="non_strict"/>
<p>Usage:</p>
<ul>
<li><tt>layer.non_strict</tt></li>
</ul>
<p>
See <a href="#strict">strict</a> for details about this option.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<a name="not"/><h2>"not" - Boolean NOT operation</h2>
<keyword name="not"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not(other [, prop_constraint ])</tt></li>
</ul>
<p>
The method computes a boolean NOT between self and other.
It is an alias for the "-" operator.
</p><p>
This method is available for polygon and edge layers.
If the first operand is an edge layer and the second is an edge layer, the
result will be the edges of the first operand which are outside the polygons
of the second operand.
</p><p>
The following images show the effect of the "not" method
on polygons and edges (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not1.png"/></td>
<td><img src="/images/drc_not2.png"/></td>
<td><img src="/images/drc_not3.png"/></td>
</tr>
</table>
</p><p>
The NOT operation can be applied between a text and a polygon
layer. In this case, the texts outside the polygons will be 
written to the output (labels: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_textpoly2.png"/></td>
</tr>
</table>
</p><p>
When a properties constraint is given, the operation is performed
only between shapes with the given relation. Together with the 
ability to provide net-annotated shapes through the <a href="#nets">nets</a> method, this
allows constraining the boolean operation to shapes from the same or
from different nets.
</p><p>
See <a href="/about/drc_ref_global.xml#prop_eq">prop_eq</a>, <a href="/about/drc_ref_global.xml#prop_ne">prop_ne</a> and <a href="/about/drc_ref_global.xml#prop_copy">prop_copy</a> for details.
</p>
<a name="not_covering"/><h2>"not_covering" - Selects shapes or regions of self which do not cover (enclose) one or more shapes from the other region</h2>
<keyword name="not_covering"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_covering(other)</tt></li>
<li><tt>layer.not_covering(other, min_count)</tt></li>
<li><tt>layer.not_covering(other, min_count, max_count)</tt></li>
<li><tt>layer.not_covering(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not cover shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected. This method returns the inverse of <a href="#covering">covering</a>
and provides the same options.
</p><p>
The following image shows the effect of the "not_covering" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_covering.png"/></td>
</tr>
</table>
</p><p>
This method is available for polygons only.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_covering">select_not_covering</a>.
</p>
<a name="not_in"/><h2>"not_in" - Selects shapes or regions of self which are not contained in the other layer</h2>
<keyword name="not_in"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_in(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not contained  
the other region exactly. It will use individual shapes from self or other if
the respective region is in raw mode. If not, it will use coherent regions or combined edges from
self or other.
</p><p>
It will return a new layer containing the selected shapes.
A method which selects all shapes contained in the other layer is <a href="#in">in</a>.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following image shows the effect of the "not_in" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_in.png"/></td>
</tr>
</table>
</p>
<a name="not_inside"/><h2>"not_inside" - Selects edges, edge pairs or polygons of self which are not inside edges or polygons from the other layer</h2>
<keyword name="not_inside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_inside(other)</tt></li>
</ul>
<p>
This method computes the inverse of <a href="#inside">inside</a> - i.e. edge, edge pairs or polygons from the layer
not being inside polygons or edges from the other layer. 
</p><p>
This method returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_inside">select_not_inside</a>.
<a href="#split_inside">split_inside</a> is a function computing both results of <a href="#inside">inside</a> and <a href="#not_inside">not_inside</a> in a single call. <a href="#outside">outside</a>
is a similar function selecting edges or polygons outside other edges or polygons. Note
that "outside" is not the same than "not inside".
</p><p>
The following image shows the effect of the "not_inside" method for polygon layers (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_inside.png"/></td>
</tr>
</table>
</p><p>
The following images show the effect of the "not_inside" method for edge layers and edge or polygon layers
the second input. Note that the edges are computed from the polygons in this example 
(input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_inside_ee.png"/></td>
</tr>
</table>
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_inside_ep.png"/></td>
</tr>
</table>
</p>
<a name="not_interacting"/><h2>"not_interacting" - Selects shapes or regions of self which do not touch or overlap shapes from the other region</h2>
<keyword name="not_interacting"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_interacting(other)</tt></li>
<li><tt>layer.not_interacting(other, min_count)</tt></li>
<li><tt>layer.not_interacting(other, min_count, max_count)</tt></li>
<li><tt>layer.not_interacting(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not touch or overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_interacting">select_not_interacting</a>.
</p><p>
This method is available for polygon, text, edge and edge pair layers. Edges and edge pairs can be selected
with respect to other edges or polygons. Texts can be selected with respect to 
polygons. Polygons can be selected with respect to edges, texts and other polygons.
</p><p>
The following image shows the effect of the "not_interacting" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_interacting.png"/></td>
</tr>
</table>
</p><p>
If a single count is given, shapes from self are selected only if they interact with less than the given
number of (different) shapes from the other layer. If a min and max count is given, shapes from  
self are selected only if they interact with less than min_count or more than max_count different shapes
from the other layer. Two polygons overlapping or touching at two locations are counted as single interactions.
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_interacting2.png"/></td>
<td><img src="/images/drc_not_interacting3.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_not_interacting4.png"/></td>
<td><img src="/images/drc_not_interacting5.png"/></td>
</tr>
</table>
</p>
<a name="not_outside"/><h2>"not_outside" - Selects edges, edge pairs or polygons of self which are not outside edges or polygons from the other layer</h2>
<keyword name="not_outside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_outside(other)</tt></li>
</ul>
<p>
This method computes the inverse of <a href="#outside">outside</a> - i.e. edges, edge pairs or polygons from the layer
not being outside polygons or edges from the other layer. 
</p><p>
This method returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_outside">select_not_outside</a>.
<a href="#split_outside">split_outside</a> is a function computing both results of <a href="#outside">outside</a> and <a href="#not_outside">not_outside</a> in a single call. <a href="#outside">outside</a>
is a similar function selecting edges or polygons outside other edges or polygons. Note
that "outside" is not the same than "not outside".
</p><p>
The following image shows the effect of the "not_outside" method for polygon layers (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_outside.png"/></td>
</tr>
</table>
</p><p>
The following images show the effect of the "not_outside" method for edge layers and edge or polygon layers
the second input. Note that the edges are computed from the polygons in this example 
(input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_outside_ee.png"/></td>
</tr>
</table>
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_outside_ep.png"/></td>
</tr>
</table>
</p>
<a name="not_overlapping"/><h2>"not_overlapping" - Selects shapes or regions of self which do not overlap shapes from the other region</h2>
<keyword name="not_overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>layer.not_overlapping(other)</tt></li>
<li><tt>layer.not_overlapping(other, min_count)</tt></li>
<li><tt>layer.not_overlapping(other, min_count, max_count)</tt></li>
<li><tt>layer.not_overlapping(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected. This method will return the inverse of <a href="#overlapping">overlapping</a>
and provides the same options.
</p><p>
The "not_overlapping" method is similar to the <a href="#outside">outside</a> method. However, "outside" does 
not provide the option to specify counts.
</p><p>
This method is available for polygons only.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_overlapping">select_not_overlapping</a>.
</p>
<a name="notch"/><h2>"notch" - An intra-polygon spacing check</h2>
<keyword name="notch"/>
<p>Usage:</p>
<ul>
<li><tt>layer.notch(value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"notch" is available as an operator for the "universal DRC" function <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. This variant has more options and is more intuitive to use. See <a href="/about/drc_ref_global.xml#notch">notch</a> for more details.
</p><p>
See <a href="#space">space</a> for a description of this method. 
"notch" is the space check variant which finds space violations within a single polygon, but not against other polygons.
In contrast to <a href="#space">space</a>, the "notch"
method is available for polygon layers only, since only on such layers 
different polygons can be identified. Also, opposite and rectangle error
filtering is not available for this method.
</p><p>
The following image shows the effect of the notch check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space2.png"/></td>
</tr>
</table>
</p>
<a name="odd_polygons"/><h2>"odd_polygons" - Checks for odd polygons (self-overlapping, non-orientable)</h2>
<keyword name="odd_polygons"/>
<p>Usage:</p>
<ul>
<li><tt>layer.odd_polygons</tt></li>
</ul>
<p>
Returns the parts of the polygons which are not orientable (i.e. "8" configuration) or self-overlapping.
Merged semantics does not apply for this method. Always the raw polygons are taken (see <a href="#raw">raw</a>).
</p><p>
The odd_polygons check is not available in deep mode currently. See <a href="/about/drc_ref_global.xml#deep_reject_odd_polygons">deep_reject_odd_polygons</a> for
an alternative.
</p>
<a name="ongrid"/><h2>"ongrid" - Checks for on-grid vertices</h2>
<keyword name="ongrid"/>
<p>Usage:</p>
<ul>
<li><tt>layer.ongrid(g)</tt></li>
<li><tt>layer.ongrid(gx, gy)</tt></li>
</ul>
<p>
Returns a single-vertex marker for each vertex whose x coordinate is not a
multiple of g or gx or whose y coordinate is not a multiple of g or gy.
The single-vertex markers are edge pair objects which describe a single point.
When setting the grid to 0, no grid check is performed in that specific direction.
</p><p>
This method requires a polygon layer. Merged semantics applies (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<a name="or"/><h2>"or" - Boolean OR operation</h2>
<keyword name="or"/>
<p>Usage:</p>
<ul>
<li><tt>layer.or(other)</tt></li>
</ul>
<p>
The method computes a boolean OR between self and other.
It is an alias for the "|" operator.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following images show the effect of the "or" method
on polygons and edges (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_or1.png"/></td>
<td><img src="/images/drc_or2.png"/></td>
</tr>
</table>
</p>
<a name="output"/><h2>"output" - Outputs the content of the layer</h2>
<keyword name="output"/>
<p>Usage:</p>
<ul>
<li><tt>layer.output(specs)</tt></li>
</ul>
<p>
This method will copy the content of the layer to the specified output.
</p><p>
If a report database is selected for the output, the specification has to include a 
category name and optionally a category description. The category name can be an 
array of strings - in that case, a hierarchy of categories is created
with the first array item being the top level category name.
Shapes are added to an existing category, if a category with the given
name already exists.
</p><p>
If the layout is selected for the output, the specification can consist of
one to three parameters: a layer number, a data type (optional, default is 0)
and a layer name (optional). Alternatively, the output can be specified by 
a single <class_doc href="LayerInfo">LayerInfo</class_doc> object.
</p><p>
See <a href="/about/drc_ref_global.xml#report">report</a> and <a href="/about/drc_ref_global.xml#target">target</a> on how to configure output to a target layout
or report database. 
</p><p>
See also <a href="/about/drc_ref_global.xml#new_target">new_target</a> and <a href="/about/drc_ref_global.xml#new_report">new_report</a> on how to create additional 
targets for output. This allows saving certain layers to different files than
the standard target or report. To do so, create a new target or report using one
of these functions and pass that object to the corresponding "output" call as
an additional argument.
</p><p>
Example:
</p><p>
<pre>
check1 = ...
check2 = ...
check3 = ...

second_report = new_report("Only for check2", "check2.lyrdb")

check1.output("Check 1")
check2.output("Check 2", second_report)
check3.output("Check 3")
</pre>
</p>
<a name="outside"/><h2>"outside" - Selects edges, edge pairs or polygons of self which are outside edges or polygons from the other layer</h2>
<keyword name="outside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.outside(other)</tt></li>
</ul>
<p>
If layer is a polygon layer, the other layer needs to be a polygon layer too.
In this case, this method selects all polygons which are entirely outside 
polygons from the other layer.
</p><p>
If layer is an edge pair layer, the other layer needs to be a polygon layer.
In this case, this method selects all edge pairs which are entirely outside 
polygons from the other layer.
</p><p>
If layer is an edge layer, the other layer can be polygon or edge layer. In the
first case, all edges entirely outside the polygons from the other layer are
selected. If the other layer is an edge layer, all edges entirely outside
of edges from the other layer are selected.
</p><p>
Merged semantics applies - i.e. edges or polygons are joined before the 
result is computed, unless the layers are in <a href="#raw">raw</a> mode.
</p><p>
This method returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_outside">select_outside</a>. <a href="#not_outside">not_outside</a> is a function computing the inverse of <a href="#outside">outside</a>.
<a href="#split_outside">split_outside</a> is a function computing both results in a single call. <a href="#outside">outside</a>
is a similar function selecting edges or polygons outside other edges or polygons.
</p><p>
The following image shows the effect of the "outside" method for polygons (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside.png"/></td>
</tr>
</table>
</p><p>
The following images show the effect of the "outside" method for edge layers and edge or polygon layers
the second input. Note that the edges are computed from the polygons in this example 
(input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside_ee.png"/></td>
</tr>
</table>
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside_ep.png"/></td>
</tr>
</table>
</p>
<a name="outside_part"/><h2>"outside_part" - Returns the parts of the edges outside the given region</h2>
<keyword name="outside_part"/>
<p>Usage:</p>
<ul>
<li><tt>layer.outside_part(region)</tt></li>
</ul>
<p>
This method returns the parts of the edges which are outside the given region. This is similar to the
"&amp;" operator, but this method does not remove edges that are exactly on the boundaries
of the polygons of the region.
</p><p>
This method is available for edge layers. The argument must be a polygon layer.
</p><p>
<a href="#inside_part">inside_part</a> is a method computing the opposite part. <a href="#inside_outside_part">inside_outside_part</a> is a
method computing both inside and outside part in a single call.
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside_part.png"/></td>
</tr>
</table>
</p>
<a name="overlap"/><h2>"overlap" - An overlap check</h2>
<keyword name="overlap"/>
<p>Usage:</p>
<ul>
<li><tt>layer.overlap(other_layer, value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"overlap" is available as an operator for the "universal DRC" function <a href="#drc">drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. This variant has more options and is more intuitive to use. 
See <a href="/about/drc_ref_global.xml#overlap">overlap</a> for more details.
</p><p>
This method checks whether layer and other_layer overlap by at least the
given length. Locations, where this is not the case will be reported in form
of edge pair error markers.
Locations, where both layers touch will be reported as errors as well. Formally
such locations form an overlap with a value of 0. Locations, where both regions 
do not overlap or touch will not be reported. Such regions can be detected 
with <a href="#outside">outside</a> or by a boolean "not".
</p><p>
The options are the same as for <a href="#separation">separation</a>.
</p><p>
Formally, the overlap method is a two-layer width check. In contrast to the single-
layer width method (<a href="#width">width</a>), the zero value also triggers an error and separate
polygons are checked against each other, while for the single-layer width, only 
single polygons are considered.
</p><p>
The overlap method can be applied to both edge or polygon layers. On edge layers 
the orientation of the edges matters: only edges which run back to back with their
inside side pointing towards each other are checked for distance.
</p><p>
As for the other DRC methods, merged semantics applies. 
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of the overlap check (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_overlap1.png"/></td>
<td><img src="/images/drc_overlap2.png"/></td>
</tr>
</table>
</p>
<a name="overlapping"/><h2>"overlapping" - Selects shapes or regions of self which overlap shapes from the other region</h2>
<keyword name="overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>layer.overlapping(other)</tt></li>
<li><tt>layer.overlapping(other, min_count)</tt></li>
<li><tt>layer.overlapping(other, min_count, max_count)</tt></li>
<li><tt>layer.overlapping(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_overlapping">select_overlapping</a>.
</p><p>
This method is available for polygons only.
</p><p>
The following image shows the effect of the "overlapping" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_overlapping.png"/></td>
</tr>
</table>
</p><p>
A range of counts can be specified. If so, the shape from the primary layer is 
only selected when overlapping a given number of shapes from the other layer.
For the interpretation of the count see <a href="#interacting">interacting</a>.
</p>
<a name="perimeter"/><h2>"perimeter" - Returns the total perimeter of the polygons in the region</h2>
<keyword name="perimeter"/>
<p>Usage:</p>
<ul>
<li><tt>layer.perimeter</tt></li>
</ul>
<p>
This method requires a polygon layer. It returns the total
perimeter of all polygons in micron. Merged semantics applies, 
i.e. before computing the perimeter, the polygons are merged unless
raw mode is chosen (see <a href="#raw">raw</a>).
</p><p>
The returned value gives the perimeter in micrometer units.
</p>
<a name="polygons"/><h2>"polygons" - Returns polygons from edge pairs</h2>
<keyword name="polygons"/>
<p>Usage:</p>
<ul>
<li><tt>layer.polygons([ enlargement ])</tt></li>
</ul>
<p>
This method applies to edge pair collections. The edge pairs will be
converted into polygons connecting the edges the edge pairs are made of.
In order to properly handle special edge pairs (coincident edges, point-like
edges etc.) an enlargement parameter can be specified which will make the 
resulting polygon somewhat larger than the original edge pair. If the enlargement
parameter is 0, special edge pairs with an area of 0 will be dropped.
</p>
<a name="polygons?"/><h2>"polygons?" - Returns true, if the layer is a polygon layer</h2>
<keyword name="polygons?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.polygons?</tt></li>
</ul>
<a name="pull_inside"/><h2>"pull_inside" - Selects shapes or regions of other which are inside polygons from the this region</h2>
<keyword name="pull_inside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.pull_inside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from other which are inside polygons from this
region. Unless other is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from other, 
otherwise individual shapes are selected.
</p><p>
The functionality is similar to select_inside, but chosing shapes from other rather
than from self. Because in deep mode the hierarchy reference comes from self, this method
provides a way to pull shapes from other to the hierarchy to self.
</p><p>
This method is available for polygon layers. Other needs to be a polygon layer too.
</p>
<a name="pull_interacting"/><h2>"pull_interacting" - Selects shapes or edges of other which touch or overlap shapes from the this region</h2>
<keyword name="pull_interacting"/>
<p>Usage:</p>
<ul>
<li><tt>layer.pull_interacting(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from other which touch or overlap shapes from this
region. Unless other is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from other, 
otherwise individual shapes are selected.
</p><p>
The functionality is similar to select_interacting, but chosing shapes from other rather
than from self. Because in deep mode the hierarchy reference comes from self, this method
provides a way to pull shapes from other to the hierarchy to self.
</p><p>
This method will neither modify self nor other.
</p><p>
This method is available for polygon, edge, edge pair and text layers, similar to interacting.
</p>
<a name="pull_overlapping"/><h2>"pull_overlapping" - Selects shapes or regions of other which overlap shapes from the this region</h2>
<keyword name="pull_overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>layer.pull_overlapping(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from other which overlap shapes from this
region. Unless other is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from other, 
otherwise individual shapes are selected.
</p><p>
The functionality is similar to select_overlapping, but chosing shapes from other rather
than from self. Because in deep mode the hierarchy reference comes from self, this method
provides a way to pull shapes from other to the hierarchy to self.
</p><p>
This method is available for polygon layers. Other needs to be a polygon layer too.
</p>
<a name="raw"/><h2>"raw" - Marks a layer as raw</h2>
<keyword name="raw"/>
<p>Usage:</p>
<ul>
<li><tt>layer.raw</tt></li>
</ul>
<p>
A raw layer basically is the opposite of a "clean" layer
(see <a href="#clean">clean</a>). Polygons on a raw layer are considered "as is", i.e.
overlapping polygons are not connected and inner edges may occur
due to cut lines. Holes may not exists if the polygons are derived
from a representation that does not allow holes (i.e. GDS2 files).
</p><p>
Note that this method will set the state of the layer. In combination
with the fact, that copied layers are references to the original layer,
this may lead to unexpected results:
</p><p>
<pre>
l = ...
l2 = l1
... do something
l.raw
# now l2 is also a raw layer
</pre>
</p><p>
To avoid that, use the <a href="#dup">dup</a> method to create a real (deep) copy.
</p>
<a name="rectangles"/><h2>"rectangles" - Selects all rectangles from the input</h2>
<keyword name="rectangles"/>
<p>Usage:</p>
<ul>
<li><tt>layer.rectangles</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before rectangles are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
<a href="#non_rectangles">non_rectangles</a> will select all non-rectangles.
</p>
<a name="rectilinear"/><h2>"rectilinear" - Selects all rectilinear polygons from the input</h2>
<keyword name="rectilinear"/>
<p>Usage:</p>
<ul>
<li><tt>layer.rectilinear</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before rectilinear polygons are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
<a href="#non_rectilinear">non_rectilinear</a> will select all non-rectangles.
</p>
<a name="remove_props"/><h2>"remove_props" - Returns a new layer with all properties removed</h2>
<keyword name="remove_props"/>
<p>Usage:</p>
<ul>
<li><tt>layer.remove_props</tt></li>
</ul>
<p>
This method will drop all user properties from the layer.
Note that a new layer without properties is returned. The
original layer stays untouched.
</p><p>
See also <a href="#select_props">select_props</a> and <a href="#map_props">map_props</a>.
</p>
<a name="rotate"/><h2>"rotate" - Rotates a layer (modifies the layer)</h2>
<keyword name="rotate"/>
<p>Usage:</p>
<ul>
<li><tt>layer.rotate(a)</tt></li>
</ul>
<p>
Rotates the input by the given angle (in degree). The layer that this method is called 
upon is modified and the modified version is returned for further processing.
</p>
<a name="rotated"/><h2>"rotated" - Rotates a layer</h2>
<keyword name="rotated"/>
<p>Usage:</p>
<ul>
<li><tt>layer.rotated(a)</tt></li>
</ul>
<p>
Rotates the input layer by the given angle (in degree) and returns
the rotated layer. The layer that this method is called upon is not modified.
</p><p>
The following image shows the effect of the "rotated" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_rotated1.png"/></td>
</tr>
</table>
</p>
<a name="rounded_corners"/><h2>"rounded_corners" - Applies corner rounding to each corner of the polygon</h2>
<keyword name="rounded_corners"/>
<p>Usage:</p>
<ul>
<li><tt>layer.rounded_corners(inner, outer, n)</tt></li>
</ul>
<p>
Inner (concave) corners are replaced by circle segments with a radius given by the 
"inner" parameter. Outer (convex) corners are relaced by circle segments with a radius
given by the "outer" parameter. 
</p><p>
The circles are approximated by polygons. "n" segments are used to approximate a full circle.
</p><p>
This method return a layer wit the modified polygons. Merged semantics applies for this
method (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
If used with tiling, the rounded_corners function may render invalid results because
in tiling mode, not the whole merged region may be captured. In that case, inner
edges may appear as outer ones and their corners will receive rounding.
</p><p>
The following image shows the effect of the "rounded_corners" method. The upper ends of 
the vertical bars are rounded with a smaller radius automatically because their width does not allow
a larger radius.
</p><p>
<table>
<tr>
<td><img src="/images/drc_rounded_corners.png"/></td>
</tr>
</table>
</p>
<a name="scale"/><h2>"scale" - Scales a layer (modifies the layer)</h2>
<keyword name="scale"/>
<p>Usage:</p>
<ul>
<li><tt>layer.scale(f)</tt></li>
</ul>
<p>
Scales the input. After scaling, features have a f times
bigger dimension. The layer that this method is called upon is modified and
the modified version is returned for further processing.
</p>
<a name="scaled"/><h2>"scaled" - Scales a layer</h2>
<keyword name="scaled"/>
<p>Usage:</p>
<ul>
<li><tt>layer.scaled(f)</tt></li>
</ul>
<p>
Scales the input layer and returns a new layer whose features have a f times
bigger dimension. The layer that this method is called upon is not modified.
</p><p>
The following images shows the effect of the "scaled" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_scaled1.png"/></td>
</tr>
</table>
</p>
<a name="second_edges"/><h2>"second_edges" - Returns the second edges of an edge pair collection</h2>
<keyword name="second_edges"/>
<p>Usage:</p>
<ul>
<li><tt>layer.second_edges</tt></li>
</ul>
<p>
Applies to edge pair collections only.
Returns the second edges of the edge pairs in the collection.
</p><p>
Some checks deliver symmetric edge pairs (e.g. space, width, etc.) for which the
edges are commutable. "second_edges" will not deliver edges for such edge pairs.
Instead, "first_edges" will deliver both.
</p>
<a name="select"/><h2>"select" - Selects edges, edge pairs or polygons based on evaluation of a block</h2>
<keyword name="select"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block and returns a new container with those objects for which
the block evaluates to true. It is available for edge, polygon and edge pair layers.
The corresponding objects are <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc>.
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p><p>
Here is a (slow) equivalent of the area selection method:
</p><p>
<pre>
new_layer = layer.select { |polygon| polygon.area &gt;= 10.0 }
</pre>
</p>
<a name="select_covering"/><h2>"select_covering" - Selects shapes or regions of self which completely cover (enclose) one or more shapes from the other region</h2>
<keyword name="select_covering"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_covering(other)</tt></li>
<li><tt>layer.select_covering(other, min_count)</tt></li>
<li><tt>layer.select_covering(other, min_count, max_count)</tt></li>
<li><tt>layer.select_covering(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which cover shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#covering">covering</a>.
</p><p>
This method is available for polygons only.
</p>
<a name="select_inside"/><h2>"select_inside" - Selects edges, edge pairs or polygons of self which are inside edges or polygons from the other layer</h2>
<keyword name="select_inside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_inside(other)</tt></li>
</ul>
<p>
This method is the in-place version of <a href="#inside">inside</a> - i.e. it modifies the layer instead
of returning a new layer and leaving the original layer untouched.
</p>
<a name="select_interacting"/><h2>"select_interacting" - Selects shapes or regions of self which touch or overlap shapes from the other region</h2>
<keyword name="select_interacting"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_interacting(other)</tt></li>
<li><tt>layer.select_interacting(other, min_count)</tt></li>
<li><tt>layer.select_interacting(other, min_count, max_count)</tt></li>
<li><tt>layer.select_interacting(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which touch or overlap shapes from the other
layer. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#interacting">interacting</a>.
</p><p>
This method is available for polygon, text, edge and edge pair layers. Edges and edge pairs can be selected
with respect to other edges or polygons. Texts can be selected with respect to 
polygons. Polygons can be selected with respect to edges, texts and other polygons.
</p><p>
If a single count is given, shapes from self are selected only if they do interact at least with the given
number of (different) shapes from the other layer. If a min and max count is given, shapes from  
self are selected only if they interact with min_count or more, but a maximum of max_count different shapes
from the other layer. Two polygons overlapping or touching at two locations are counted as single interactions.
</p>
<a name="select_not_covering"/><h2>"select_not_covering" - Selects shapes or regions of self which do not cover (enclose) one or more shapes from the other region</h2>
<keyword name="select_not_covering"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_not_covering(other)</tt></li>
<li><tt>layer.select_not_covering(other, min_count)</tt></li>
<li><tt>layer.select_not_covering(other, min_count, max_count)</tt></li>
<li><tt>layer.select_not_covering(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not cover shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected. 
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_covering">not_covering</a>.
</p><p>
This method is available for polygons only.
</p>
<a name="select_not_inside"/><h2>"select_not_inside" - Selects edges, edge pairs or polygons of self which are not inside edges or polygons from the other layer</h2>
<keyword name="select_not_inside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_not_inside(other)</tt></li>
</ul>
<p>
This method is the in-place version of <a href="#inside">inside</a> - i.e. it modifies the layer instead
of returning a new layer and leaving the original layer untouched.
</p>
<a name="select_not_interacting"/><h2>"select_not_interacting" - Selects shapes or regions of self which do not touch or overlap shapes from the other region</h2>
<keyword name="select_not_interacting"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_not_interacting(other)</tt></li>
<li><tt>layer.select_not_interacting(other, min_count)</tt></li>
<li><tt>layer.select_not_interacting(other, min_count, max_count)</tt></li>
<li><tt>layer.select_not_interacting(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not touch or overlap shapes from the other
layer. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_interacting">not_interacting</a>.
</p><p>
This method is available for polygon, text, edge and edge pair layers. Edges or edge pairs can be selected
with respect to other edges or polygons. Texts can be selected with respect to 
polygons. Polygons can be selected with respect to edges, texts and other polygons.
</p><p>
If a single count is given, shapes from self are selected only if they interact with less than the given
number of (different) shapes from the other layer. If a min and max count is given, shapes from  
self are selected only if they interact with less than min_count or more than max_count different shapes
from the other layer. Two polygons overlapping or touching at two locations are counted as single interactions.
</p>
<a name="select_not_outside"/><h2>"select_not_outside" - Selects edges, edge pairs or polygons of self which are not outside edges or polygons from the other layer</h2>
<keyword name="select_not_outside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_not_outside(other)</tt></li>
</ul>
<p>
This method is the in-place version of <a href="#outside">outside</a> - i.e. it modifies the layer instead
of returning a new layer and leaving the original layer untouched.
</p>
<a name="select_not_overlapping"/><h2>"select_not_overlapping" - Selects shapes or regions of self which do not overlap shapes from the other region</h2>
<keyword name="select_not_overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_not_overlapping(other)</tt></li>
<li><tt>layer.select_not_overlapping(other, min_count)</tt></li>
<li><tt>layer.select_not_overlapping(other, min_count, max_count)</tt></li>
<li><tt>layer.select_not_overlapping(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected. 
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_overlapping">not_overlapping</a>.
</p><p>
This method is available for polygons only.
</p>
<a name="select_outside"/><h2>"select_outside" - Selects edges, edge pairs or polygons of self which are outside edges or polygons from the other layer</h2>
<keyword name="select_outside"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_outside(other)</tt></li>
</ul>
<p>
This method is the in-place version of <a href="#outside">outside</a> - i.e. it modifies the layer instead
of returning a new layer and leaving the original layer untouched.
</p>
<a name="select_overlapping"/><h2>"select_overlapping" - Selects shapes or regions of self which overlap shapes from the other region</h2>
<keyword name="select_overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_overlapping(other)</tt></li>
<li><tt>layer.select_overlapping(other, min_count)</tt></li>
<li><tt>layer.select_overlapping(other, min_count, max_count)</tt></li>
<li><tt>layer.select_overlapping(other, min_count .. max_count)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which overlap shapes from the other
region. Unless self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#overlapping">overlapping</a>.
</p><p>
This method is available for polygons only.
</p>
<a name="select_props"/><h2>"select_props" - Enables or selects properties from a property-annotated layer</h2>
<keyword name="select_props"/>
<p>Usage:</p>
<ul>
<li><tt>layer.select_props(keys)</tt></li>
</ul>
<p>
This method will select specific property keys
from layers. It returns a new layer with the new properties. The
original layer is not modified.
</p><p>
You can specify the user property keys (names) to use. As user properties
in general are a set of key/value pairs and may carry multiple values
under different keys, this feature can be handy to filter out a specific 
aspect. To get only the values from key 1 (integer), use:
</p><p>
<pre>
layer1 = input(1, 0, enable_properties)
layer1_filtered = layer1.select_props(1)
</pre>
</p><p>
To get the combined key 1 and 2 properties, use:
</p><p>
<pre>
layer1 = input(1, 0, enable_properties)
layer1_filtered = layer1.select_props(1, 2)
</pre>
</p><p>
Without any arguments, this method will remove all properties.
Note that you can directly filter or map properties on input
which is more efficient than first loading all and then selecting some
properties. See <a href="/about/drc_ref_drcsource.xml#input">DRCSource#input</a> for details.
</p><p>
<a href="#map_props">map_props</a> is a way to change property keys and <a href="#remove_props">remove_props</a>
will entirely remove all user properties.
</p>
<a name="sep"/><h2>"sep" - An alias for "separation"</h2>
<keyword name="sep"/>
<p>Usage:</p>
<ul>
<li><tt>layer.sep(value [, options])</tt></li>
</ul>
<p>
See <a href="#separation">separation</a> for a description of that method
</p>
<a name="separation"/><h2>"separation" - A two-layer spacing check</h2>
<keyword name="separation"/>
<p>Usage:</p>
<ul>
<li><tt>layer.separation(other_layer, value [, options])</tt></li>
<li><tt>layer.sep(other_layer, value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"separation" and "sep" are available as operators for the "universal DRC" function <a href="#drc">drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. These variants have more options and are more intuitive to use. 
See <a href="/about/drc_ref_global.xml#separation">separation</a> for more details.
</p><p>
This method performs a two-layer spacing check. Like <a href="#space">space</a>, this method
can be applied to edge or polygon layers. Locations where edges of the layer
are closer than the specified distance to the other layer are reported
as edge pair error markers.
</p><p>
"sep" is the short form of this method.
</p><p>
In contrast to the <a href="#space">space</a> and related methods, locations where both 
layers touch are also reported. More specifically, the case of zero spacing
will also trigger an error while for <a href="#space">space</a> it will not.
</p><p>
As for the other DRC methods, merged semantics applies.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following image shows the effect of the separation check (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation1.png"/></td>
</tr>
</table>
</p><p>
<h3>Touching shapes </h3>
</p><p>
Like <a href="#width">width</a> and <a href="#space">space</a>, the separation check also supports the "without_touching_corners" option.
</p><p>
This option will turn off errors that arise due to 
edges touching in one corner (the "kissing corners" configuration). 
By default, such edges will yield an error, as they
form a zero-distance situation. With this option in place, no errors will be reported.
</p><p>
The following images illustrate the effect of the "without_touching_corners" option.
The white line at the top of the bottom red shape is actually an edge pair indicating 
the zero-distance violation of the separation check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation12.png"/></td>
<td><img src="/images/drc_separation13.png"/></td>
</tr>
</table>
</p><p>
Another option is "without_touching_edges" which turns off errors that arise
at coincident edges. Formally such edges represent a zero-distance situation, hence
are flagged by default. Turning off the check in this case can be helpful when
separating a layer into two parts (e.g. thin/wide metal separation) and an error
between touching regions is not desired.
</p><p>
The "without_touching_edges" option is a stronger version of "without_touching_corners" and 
makes sense only for two-layer checks.
</p><p>
The following images illustrate the effect of the "without_touching_edges" option:
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation12.png"/></td>
<td><img src="/images/drc_separation14.png"/></td>
</tr>
</table>
</p><p>
<h3>Opposite and rectangle error filtering </h3>
</p><p>
The options for the separation check are those available for the <a href="#width">width</a> or <a href="#space">space</a>
method plus opposite and rectangle error filtering. 
</p><p>
Opposite error filtering will waive errors that are on opposite sides of the original
figure. The inverse is selection of errors only when there is an error present on
the opposite side of the original figure. Opposite error waiving or selection is achieved
through these options inside the DRC function call:
</p><p>
<ul>
<li><b>not_opposite </b>will waive opposite errors </li>
<li><b>only_opposite </b>will select errors only if there is an opposite one </li>
</ul>
</p><p>
These modes imply partial waiving or selection if "opposite" only applies to a section
of an error.
</p><p>
The following images shows the effect of these options:
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_separation3.png"/></td>
<td><img src="/images/drc_separation4.png"/></td>
</tr>
</table>
</p><p>
Rectangle error filtering allows waiving errors based on how they cover the
sides of an original rectangular figure. This selection only applies to errors
covering the full edge of the rectangle. Errors covering parts of the rectangle
edges are not considered in this scheme.
</p><p>
The rectangle filter option is enabled by these modes:
</p><p>
<ul>
<li><b>one_side_allowed </b>will waive errors when they appear on one side of the rectangle only </li>
<li><b>two_sides_allowed </b>will waive errors when they appear on two sides of the rectangle </li>
<li><b>two_connected_sides_allowed </b>will waive errors when they appear on two connected sides of the rectangle ("L" configuration) </li>
<li><b>two_opposite_sides_allowed </b>will waive errors when they appear on two opposite sides of the rectangle </li>
<li><b>three_sides_allowed </b>will waive errors when they appear on three sides of the rectangle </li>
<li><b>four_sides_allowed </b>will waive errors when they appear on four sides of the rectangle </li>
</ul>
</p><p>
Multiple of these options can be given, which will make errors waived if one of these conditions is met.
</p><p>
The following images shows the effect of some rectangle filter modes:
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation5.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_separation6.png"/></td>
<td><img src="/images/drc_separation7.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_separation8.png"/></td>
<td><img src="/images/drc_separation9.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_separation10.png"/></td>
<td><img src="/images/drc_separation11.png"/></td>
</tr>
</table>
</p>
<a name="size"/><h2>"size" - Polygon sizing (per-edge biasing, modifies the layer)</h2>
<keyword name="size"/>
<p>Usage:</p>
<ul>
<li><tt>layer.size(d [, mode])</tt></li>
<li><tt>layer.size(d, size_inside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.size(d, size_outside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.size(dx, dy [, mode])</tt></li>
<li><tt>layer.size(dx, dy, size_inside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.size(dx, dy, size_outside(l) [, steps(n)] [, mode])</tt></li>
</ul>
<p>
See <a href="#sized">sized</a> for a description of the options.
The size method basically does the same but modifies the layer
it is called on. The input layer is returned and available for further processing.
</p>
<a name="sized"/><h2>"sized" - Polygon sizing (per-edge biasing)</h2>
<keyword name="sized"/>
<p>Usage:</p>
<ul>
<li><tt>layer.sized(d [, mode] [, size_inside(l) [, steps(n)]])</tt></li>
<li><tt>layer.sized(d, size_inside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.sized(d, size_outside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.sized(dx, dy [, mode])</tt></li>
<li><tt>layer.sized(dx, dy, size_inside(l) [, steps(n)] [, mode])</tt></li>
<li><tt>layer.sized(dx, dy, size_outside(l) [, steps(n)] [, mode])</tt></li>
</ul>
<p>
This method requires a polygon layer. It will apply a bias per edge of the polygons 
and return the biased layer. The layer that this method is called on is not modified.
</p><p>
The alternative method <a href="#size">size</a> works like <a href="#sized">sized</a> but modifies the layer it is called on.
</p><p>
In the single-value form, that bias is applied both in horizontal or vertical direction.
In the two-value form, the horizontal and vertical bias can be specified separately.
</p><p>
The mode defines how to handle corners. The following modes are available:
</p><p>
<ul>
<li><b>diamond_limit </b>: This mode will connect the shifted edges without corner interpolation </li>
<li><b>octagon_limit </b>: This mode will create octagon-shaped corners </li>
<li><b>square_limit </b>: This mode will leave 90 degree corners untouched but 
cut off corners with a sharper angle. This is the default mode. </li>
<li><b>acute_limit </b>: This mode will leave 45 degree corners untouched but
cut off corners with a sharper angle </li>
<li><b>no_limit </b>: This mode will not cut off (only at extremely sharp angles </li>
</ul>
</p><p>
Merged semantics applies, i.e. polygons will be merged before the sizing is applied 
unless the layer was put into raw mode (see <a href="#raw">raw</a>). On output, the polygons are not
merged immediately, so it is possible to detect overlapping regions after a positive 
sizing using <a href="#raw">raw</a> and <a href="#merged">merged</a> with an overlap count, for example:
</p><p>
<pre>
layer.sized(300.nm).raw.merged(2)
</pre>
</p><p>
Bias values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of various forms of the "sized" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_sized1.png"/></td>
<td><img src="/images/drc_sized2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_sized3.png"/></td>
<td><img src="/images/drc_sized4.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_sized5.png"/></td>
<td><img src="/images/drc_sized6.png"/></td>
</tr>
</table>
</p><p>
The "size_inside" option and the "steps" option implement incremental size. Incremental
size means that the sizing value is applied in n steps. Between the steps, the sized
shape is confined to the "size_inside" layer by means of a boolean "AND" operation.
</p><p>
This scheme is used to implement latch-up rules where a device active region has to 
be close to a well tap. By using the well layer as the "size_inside" layer, the size function
follows the well contours. The steps have to selected such that the per-step size value
is smaller than the minimum space of the well shapes. With that, the sized shapes will
not cross over to neighbor well regions. Specifically, the per-step size has to be less
than about 70% of the minimum space to account for the minimum corner-to-corner case
with Euclidian space measurements.
</p><p>
"size_inside" and "steps" can be used with positive sizing values only.
A steps value of 0 will not execute any sizing at all.
</p><p>
"size_outside" acts like "size_inside", but instead of confining the sized region to the
inside of the given layer, it is confined to be outside of that layer. Technically,
a boolean "NOT" is performed instead of a boolean "AND".
</p><p>
An example for the "size_inside" option is this:
</p><p>
<pre>
ntap.sized(30.um, size_inside(nwell), steps(100))
</pre>
</p><p>
The effect of the "size_inside" option is shown here:
</p><p>
<table>
<tr>
<td><img src="/images/drc_sized_inside1.png"/></td>
<td><img src="/images/drc_sized_inside2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_sized_inside3.png"/></td>
<td><img src="/images/drc_sized_inside4.png"/></td>
</tr>
</table>
</p>
<a name="smoothed"/><h2>"smoothed" - Smoothes the polygons of the region</h2>
<keyword name="smoothed"/>
<p>Usage:</p>
<ul>
<li><tt>layer.smoothed(d)</tt></li>
<li><tt>layer.smoothed(d, hv_keep)</tt></li>
</ul>
<p>
"Smoothing" returns a simplified version of the polygons. Simplification is 
achieved by removing vertices unless the resulting polygon deviates by more
than the given distance d from the original polygon.
</p><p>
"hv_keep" is a boolean parameter which makes the smoothing function maintain
horizontal or vertical edges. The default is false, meaning horizontal or
vertical edges may be changed into tilted ones.
</p><p>
This method return a layer wit the modified polygons. Merged semantics applies for this
method (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<a name="snap"/><h2>"snap" - Brings each vertex on the given grid (g or gx/gy for x or y direction)</h2>
<keyword name="snap"/>
<p>Usage:</p>
<ul>
<li><tt>layer.snap(g)</tt></li>
<li><tt>layer.snap(gx, gy)</tt></li>
</ul>
<p>
Shifts each off-grid vertex to the nearest on-grid location. If one grid is given, this
grid is applied to x and y coordinates. If two grids are given, gx is applied to the x
coordinates and gy is applied to the y coordinates. If 0 is given as a grid, no snapping
is performed in that direction. 
</p><p>
This method modifies the layer. A version that returns a snapped version of the layer
without modifying the layer is <a href="#snapped">snapped</a>.
</p><p>
This method requires a polygon layer. Merged semantics applies (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<a name="snapped"/><h2>"snapped" - Returns a snapped version of the layer</h2>
<keyword name="snapped"/>
<p>Usage:</p>
<ul>
<li><tt>layer.snapped(g)</tt></li>
<li><tt>layer.snapped(gx, gy)</tt></li>
</ul>
<p>
See <a href="#snap">snap</a> for a description of the functionality. In contrast to <a href="#snap">snap</a>, this method does
not modify the layer but returns a snapped copy.
</p>
<a name="space"/><h2>"space" - A space check</h2>
<keyword name="space"/>
<p>Usage:</p>
<ul>
<li><tt>layer.space(value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"space" is available as an operator for the "universal DRC" function <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. This variant has more options and is more intuitive to use. See <a href="/about/drc_ref_global.xml#space">space</a> for more details.
</p><p>
This method performs a space check and returns a collection of edge pairs.
A space check can be performed on polygon and edge layers. On edge layers, all
edges are checked against all other edges. If two edges form a "face to face" relation
(i.e. their outer sides face each other) and their distance is less than the specified
value, an error shape is generated for that edge pair. 
On polygon layers, the polygons on each layer are checked for space against other polygons 
for locations where their space is less than the specified value. In that case, an edge 
pair error shape is generated.
The space check will also check the polygons for space violations against themselves, i.e.
notches violating the space condition are reported.
</p><p>
The <a href="#notch">notch</a> method is similar, but will only report self-space violations. The <a href="#isolated">isolated</a>
method will only report space violations to other polygons. <a href="#separation">separation</a> is a two-layer 
space check where space is checked against polygons of another layer.
</p><p>
As for the other DRC methods, merged semantics applies.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
For the manifold options of this function see the <a href="#width">width</a> method description.
</p><p>
The following image shows the effect of the space check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space1.png"/></td>
</tr>
</table>
</p>
<a name="split_covering"/><h2>"split_covering" - Returns the results of <a href="#covering">covering</a> and <a href="#not_covering">not_covering</a> at the same time</h2>
<keyword name="split_covering"/>
<p>Usage:</p>
<ul>
<li><tt>(a, b) = layer.split_covering(other [, options ])</tt></li>
</ul>
<p>
This method returns the polygons covering polygons from the other layer in 
one layer and all others in a second layer. This method is equivalent to calling 
<a href="#covering">covering</a> and <a href="#not_covering">not_covering</a>, but is faster than doing this in separate steps:
</p><p>
<pre>
(covering, not_covering) = l1.split_covering(l2)
</pre>
</p><p>
The options of this method are the same than <a href="#covering">covering</a>.
</p>
<a name="split_inside"/><h2>"split_inside" - Returns the results of <a href="#inside">inside</a> and <a href="#not_inside">not_inside</a> at the same time</h2>
<keyword name="split_inside"/>
<p>Usage:</p>
<ul>
<li><tt>(a, b) = layer.split_inside(other)</tt></li>
</ul>
<p>
This method returns the polygons, edge pairs or edges inside of polygons or edges from the other layer in 
one layer and all others in a second layer. This method is equivalent to calling 
<a href="#inside">inside</a> and <a href="#not_inside">not_inside</a>, but is faster than doing this in separate steps:
</p><p>
<pre>
(inside, not_inside) = l1.split_inside(l2)
</pre>
</p>
<a name="split_interacting"/><h2>"split_interacting" - Returns the results of <a href="#interacting">interacting</a> and <a href="#not_interacting">not_interacting</a> at the same time</h2>
<keyword name="split_interacting"/>
<p>Usage:</p>
<ul>
<li><tt>(a, b) = layer.split_interacting(other [, options ])</tt></li>
</ul>
<p>
This method returns the polygons or edges interacting with objects from the other container in 
one layer and all others in a second layer. This method is equivalent to calling 
<a href="#interacting">interacting</a> and <a href="#not_interacting">not_interacting</a>, but is faster than doing this in separate steps:
</p><p>
<pre>
(interacting, not_interacting) = l1.split_interacting(l2)
</pre>
</p><p>
The options of this method are the same than <a href="#interacting">interacting</a>.
</p>
<a name="split_outside"/><h2>"split_outside" - Returns the results of <a href="#outside">outside</a> and <a href="#not_outside">not_outside</a> at the same time</h2>
<keyword name="split_outside"/>
<p>Usage:</p>
<ul>
<li><tt>(a, b) = layer.split_outside(other)</tt></li>
</ul>
<p>
This method returns the polygons, edge pairs or edges outside of polygons or edges from the other layer in 
one layer and all others in a second layer. This method is equivalent to calling 
<a href="#outside">outside</a> and <a href="#not_outside">not_outside</a>, but is faster than doing this in separate steps:
</p><p>
<pre>
(outside, not_outside) = l1.split_outside(l2)
</pre>
</p>
<a name="split_overlapping"/><h2>"split_overlapping" - Returns the results of <a href="#overlapping">overlapping</a> and <a href="#not_overlapping">not_overlapping</a> at the same time</h2>
<keyword name="split_overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>(a, b) = layer.split_overlapping(other [, options ])</tt></li>
</ul>
<p>
This method returns the polygons overlapping polygons from the other layer in 
one layer and all others in a second layer. This method is equivalent to calling 
<a href="#overlapping">overlapping</a> and <a href="#not_overlapping">not_overlapping</a>, but is faster than doing this in separate steps:
</p><p>
<pre>
(overlapping, not_overlapping) = l1.split_overlapping(l2)
</pre>
</p><p>
The options of this method are the same than <a href="#overlapping">overlapping</a>.
</p>
<a name="squares"/><h2>"squares" - Selects all squares from the input</h2>
<keyword name="squares"/>
<p>Usage:</p>
<ul>
<li><tt>layer.squares</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before squares are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
<a href="#non_squares">non_squares</a> will select all non-rectangles.
</p>
<a name="start_segments"/><h2>"start_segments" - Returns the part at the beginning of each edge</h2>
<keyword name="start_segments"/>
<p>Usage:</p>
<ul>
<li><tt>layer.start_segments(length)</tt></li>
<li><tt>layer.start_segments(length, fraction)</tt></li>
</ul>
<p>
This method will return a partial edge for each edge in the input, 
located and the end of the original edge.
The new edges will share the start point with the original edges, but not necessarily
their end points. For further details about the orientation of edges and the parameters
of this method, see <a href="#end_segments">end_segments</a>.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_start_segments1.png"/></td>
<td><img src="/images/drc_start_segments2.png"/></td>
</tr>
</table>
</p>
<a name="strict"/><h2>"strict" - Marks a layer for strict handling</h2>
<keyword name="strict"/>
<p>Usage:</p>
<ul>
<li><tt>layer.strict</tt></li>
</ul>
<p>
If a layer is marked for strict handling, some optimizations 
are disabled. Specifically for boolean operations, the results
will also be merged if one input is empty. 
For boolean operations, strict handling should be enabled for both inputs.
Strict handling is disabled by default.
</p><p>
See <a href="#non_strict">non_strict</a> about how to reset this mode.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<a name="strict?"/><h2>"strict?" - Returns true, if strict handling is enabled for this layer</h2>
<keyword name="strict?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.is_strict?</tt></li>
</ul>
<p>
See <a href="#strict">strict</a> for a discussion of strict handling.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<a name="texts"/><h2>"texts" - Selects texts from an original layer</h2>
<keyword name="texts"/>
<p>Usage:</p>
<ul>
<li><tt>layer.texts</tt></li>
<li><tt>layer.texts(p)</tt></li>
<li><tt>layer.texts([ options ])</tt></li>
</ul>
<p>
This method can be applied to original layers - i.e. ones that have
been created with <a href="/about/drc_ref_global.xml#input">input</a>. By default, a small box (2x2 DBU) will be produced on each
selected text. By using the "as_dots" option, degenerated point-like edges will be
produced.
</p><p>
The preferred method however is to use true text layers created with <a href="/about/drc_ref_global.xml#labels">labels</a>.
In this case, without specifying "as_dots" or "as_boxes" retains the text
objects as such a text filtering is applied. In contrast to this, layers generated
with <a href="/about/drc_ref_global.xml#input">input</a> cannot maintain the text nature of the selected objects and 
produce dots or small polygon boxes in the <a href="#texts">texts</a> method.
</p><p>
Texts can be selected either by exact match string or a pattern match with a 
glob-style pattern. By default, glob-style pattern are used. 
The options available are:
</p><p>
<ul>
<li><b>pattern(p) </b>: Use a pattern to match the string (this is the default) </li>
<li><b>text(s) </b>: Select the texts that exactly match the given string </li>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
</ul>
</p><p>
Here are some examples:
</p><p>
<pre>
# Selects all texts
t = labels(1, 0).texts
# Selects all texts beginning with an "A"
t = labels(1, 0).texts("A*")
t = labels(1, 0).texts(pattern("A*"))
# Selects all texts whose string is "ABC"
t = labels(1, 0).texts(text("ABC"))
</pre>
</p><p>
The effect of the operation is shown in these examples:
</p><p>
<table>
<tr>
<td><img src="/images/drc_texts1.png"/></td>
<td><img src="/images/drc_texts2.png"/></td>
</tr>
</table>
</p>
<a name="texts?"/><h2>"texts?" - Returns true, if the layer is a text collection</h2>
<keyword name="texts?"/>
<p>Usage:</p>
<ul>
<li><tt>layer.texts?</tt></li>
</ul>
<a name="texts_not"/><h2>"texts_not" - Selects texts from an original layer not matching a specific selection</h2>
<keyword name="texts_not"/>
<p>Usage:</p>
<ul>
<li><tt>layer.texts_not</tt></li>
<li><tt>layer.texts_not(p)</tt></li>
<li><tt>layer.texts_not([ options ])</tt></li>
</ul>
<p>
This method can be applied to true text layers obtained with <a href="/about/drc_ref_global.xml#labels">labels</a>.
In this case, without specifying "as_dots" or "as_boxes" retains the text
objects as such. Only text filtering is applied.
</p><p>
Beside that this method acts like <a href="#texts">texts</a>, but will select the text objects
not matching the filter.
</p>
<a name="transform"/><h2>"transform" - Transforms a layer (modifies the layer)</h2>
<keyword name="transform"/>
<p>Usage:</p>
<ul>
<li><tt>layer.transform(t)</tt></li>
</ul>
<p>
Like <a href="#transform">transform</a>, but modifies the input and returns a reference to it for
further processing.
</p>
<a name="transformed"/><h2>"transformed" - Transforms a layer</h2>
<keyword name="transformed"/>
<p>Usage:</p>
<ul>
<li><tt>layer.transformed(t)</tt></li>
</ul>
<p>
Transforms the input layer by the given transformation and returns
the moved layer. The layer that this method is called upon is not modified.
This is the most generic method is transform a layer. The transformation
is a <class_doc href="DCplxTrans">DCplxTrans</class_doc> object which describes many different kinds of affine transformations
except shear and anisotropic magnification.
</p><p>
The following image shows the effect of the "moved" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_moved1.png"/></td>
</tr>
</table>
</p>
<a name="width"/><h2>"width" - A width check</h2>
<keyword name="width"/>
<p>Usage:</p>
<ul>
<li><tt>layer.width(value [, options])</tt></li>
</ul>
<p>
<b>Note: </b>"width" is available as an operator for the "universal DRC" function <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> within
the <a href="/about/drc_ref_drc.xml">DRC</a> framework. This variant has more options and is more intuitive to use. See <a href="/about/drc_ref_global.xml#width">width</a> for more details.
</p><p>
This method performs a width check and returns a collection of edge pairs.
A width check can be performed on polygon and edge layers. On edge layers, all
edges are checked against all other edges. If two edges form a "back to back" relation
(i.e. their inner sides face each other) and their distance is less than the specified
value, an error shape is generated for that edge pair. 
On polygon layers, the polygons on each layer are checked for locations where their
width is less than the specified value. In that case, an edge pair error shape is generated.
</p><p>
<h3>Options </h3>
</p><p>
The options available are:
</p><p>
<ul>
<li><b>euclidian </b>: perform the check using Euclidian metrics (this is the default) </li>
<li><b>square </b>: perform the check using Square metrics </li>
<li><b>projection </b>: perform the check using projection metrics </li>
<li><b>whole_edges </b>: With this option, the check will return all of the edges,
even if the criterion is violated only over a part of the edge </li>
<li><b>angle_limit(a) </b>: Specifies the angle above or equal to which no 
check is performed. The default value is 90, which means that for edges having 
an angle of 90 degree or more, no check is performed. Setting this value to 45 will
make the check only consider edges enclosing angles of less than 45 degree. </li>
<li><b>projection_limits(min, max) or projection_limits(min .. max) </b>:
this option makes the check only consider edge pairs whose projected length on
each other is more or equal than min and less than max </li>
<li><b>projecting (in condition) </b>: This specification is equivalent to "projection_limits"
but is more intuitive, as "projecting" is written with a condition, like
"projecting &lt; 2.um". Available operators are: "==", "&lt;", "&lt;=", "&gt;" and "&gt;=". 
Double-bounded ranges are also available, like: "0.5 &lt;= projecting &lt; 2.0". </li>
<li><b>without_touching_corners </b>: With this option present, touching corners (aka "kissing
corners") will not yield errors. The default is to produce errors in these cases. </li>
<li><b>without_touching_edges </b>: With this option present, coincident edges will not yield errors.
This is a stronger version of "without_touching_corners" and makes sense only for two-layer checks
or raw-mode input layers. It is listed here for completeness. </li>
<li><b>transparent </b>: Performs the check without shielding (polygon layers only) </li>
<li><b>shielded </b>: Performs the check with shielding (polygon layers only) </li>
<li><b>props_eq </b>, <b>props_ne </b>, <b>props_copy </b>: (only props_copy applies to width check) -
See "Properties constraints" below. </li>
</ul>
</p><p>
Note that without the angle_limit, acute corners will always be reported, since two 
connected edges always violate the width in the corner. By adjusting the angle_limit, an 
acute corner check can be implemented.
</p><p>
Merge semantics applies to this method, i.e. disconnected polygons are merged before the 
width is checked unless "raw" mode is chosen.
</p><p>
The resulting edge pairs can be converted to polygons using the <a href="#polygons">polygons</a> method.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators, i.e.
</p><p>
<pre>
# width check for 1.5 micron:
markers = in.width(1.5)
# width check for 2 database units:
markers = in.width(2)
# width check for 2 micron:
markers = in.width(2.um)
# width check for 20 nanometers:
markers = in.width(20.nm)
</pre>
</p><p>
<h3>Examples </h3>
</p><p>
The following images show the effect of various forms of the width check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_width1.png"/></td>
<td><img src="/images/drc_width2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_width3.png"/></td>
<td><img src="/images/drc_width4.png"/></td>
</tr>
</table>
</p><p>
<h3>Universal DRC function </h3>
</p><p>
There is an alternative notation for the check using the "universal DRC" function ("<a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>"). 
This notation is more intuitive and allows checking for widths bigger than a certain value 
or within a certain range. See "<a href="/about/drc_ref_global.xml#width">width</a>" for details.
</p><p>
Apart from that it provides the same options than the plain width check. 
Follow this link for the documentation of this feature: <a href="/about/drc_ref_global.xml#width">width</a>.
</p><p>
<h3>Shielding </h3>
</p><p>
"shielding" is a concept where an internal or external distance is measured only 
if the opposite edge is not blocked by other edges between. Shielded mode makes 
a difference if very large distances are to be checked and the minimum distance
is much smaller: in this case, a large distance violation may be blocked by features
located between the edges which are checked. With shielding, large distance violations
are not reported in this case. Shielding is also effective at zero distance which has
an adverse effect: Consider a case, where one layer A is a subset of another layer B. If 
you try to check the distance between features of B vs. A, you cannot use shielding, 
because B features which are identical to A features will shield those entirely. 
</p><p>
Shielding is enabled by default, but can be switched off with the "transparent" option.
</p><p>
<h3>Properties constraints (available on intra-polygon checks such as <a href="#space">space</a>, <a href="#sep">sep</a> etc.) </h3>
</p><p>
This feature is listed here, because this documentation is generic and used for other checks
as well. <a href="#props_eq">props_eq</a> and <a href="#props_ne">props_ne</a> are not available on 'width' or 'notch' as these apply to intra-polygon checks - when
pairs of different polygons are involved - something that 'width' or 'notch' does need.
</p><p>
With properties constraints, the check is performed between shapes with the same
or different properties. "properties" refers to the full set of key/value pairs 
attached to a shape.
</p><p>
Property constraints are specified by adding <a href="#props_eq">props_eq</a> or <a href="#props_ne">props_ne</a> to the arguments.
If these literals are present, only shapes with same of different properties are
involved in the check. In connection with the net annotation feature this allows
checking space between connected or disconnected shapes for example:
</p><p>
<pre>
connect(metal1, via1)
... 

# attaches net identity as properties
metal1_nets = metal1.nets

space_not_connected = metal1_nets.space(0.4.um, props_ne)
space_connected     = metal1_nets.space(0.4.um, props_eq)
</pre>
</p><p>
<a href="#props_copy">props_copy</a> is a special properties constraint that does not alter the behaviour of
the checks, but copies the primary shape's properties to the output markers.
This constraint is applicable to <a href="#width">width</a> and <a href="#notch">notch</a> checks too. The effect is that
the original polygon's properties are copied to the error markers.
<a href="#props_copy">props_copy</a> can be combined with <a href="#props_eq">props_eq</a> and <a href="#props_ne">props_ne</a> to copy the original
shape's properties to the output too:
</p><p>
<pre>
space_not_connected = metal1_nets.space(0.4.um, props_ne + props_copy)
space_connected     = metal1_nets.space(0.4.um, props_eq + props_copy)
</pre>
</p><p>
<h3>Touching shapes </h3>
</p><p>
The "without_touching_corners" option will turn off errors that arise due to 
the "kissing corner" configuration (or "checkerboard pattern"). Formally
this is a width violation across the diagonal, but when considering this
configuration as disconnected boxes, no error should be reported.
</p><p>
The following images illustrate the effect of the "without_touching_corners" option:
</p><p>
<table>
<tr>
<td><img src="/images/drc_width5.png"/></td>
<td><img src="/images/drc_width6.png"/></td>
</tr>
</table>
</p>
<a name="with_angle"/><h2>"with_angle" - Selects edges by their angle</h2>
<keyword name="with_angle"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_angle(min .. max [, absolute])</tt></li>
<li><tt>layer.with_angle(value [, absolute])</tt></li>
<li><tt>layer.with_angle(min, max [, absolute])</tt></li>
<li><tt>layer.with_angle(ortho)</tt></li>
<li><tt>layer.with_angle(diagonal)</tt></li>
<li><tt>layer.with_angle(diagonal_only)</tt></li>
<li><tt>edge_pair_layer.with_angle(... [, both] [, absolute])</tt></li>
</ul>
<p>
When called on an edge layer, the method selects edges by their angle, 
measured against the horizontal axis in the mathematical sense. 
</p><p>
For this measurement edges are considered without their direction and straight lines. 
A horizontal edge has an angle of zero degree. A vertical one has
an angle of 90 degee. The angle range is from -90 (exclusive) to 90 degree (inclusive).
</p><p>
The first version of this method selects
edges with a angle larger or equal to min and less than max (but not equal).
The second version selects edges with exactly the given angle. The third
version is identical to the first one.
</p><p>
When called on an edge pair layer, this method selects edge pairs with one or both edges
meeting the angle criterion. In this case an additional argument is accepted which can be
either "both" (plain word) to indicate that both edges have to be within the given interval.
Without this argument, it is sufficient for one edge to meet the criterion.
</p><p>
The "absolute" option is available for edge or edge pair layers.
Without the "absolute" option, edges sloping down are assigned a negative angle while edges sloping up are assigned
a positive angle (vertical edges are always 90 degree). With the "absolute" option,
edges sloping down also have a positive angle which is the one enclosed with the horizontal axis.
</p><p>
Here are examples for "with_angle" on edge pair layers:
</p><p>
<pre>
# at least one edge needs to be horizontal
ep1 = edge_pairs.with_angle(0)
# both edges need to vertical
ep2 = edge_pairs.with_angle(90, both)
</pre>
</p><p>
A method delivering all objects not matching the angle criterion is <a href="#without_angle">without_angle</a>.
Note that for edge pairs, in order to get the inverse result, you have to add or drop "both"
on <a href="#without_angle">without_angle</a>. This is because <a href="#without_angle">without_angle</a> without both returns edge pairs where
one edge does not match the criterion. The logical opposite of "one edge matches" however is 
"both edges do not match".
</p><p>
The following images demonstrate some use cases of <a href="#with_angle">with_angle</a> and <a href="#without_angle">without_angle</a> :
</p><p>
<table>
<tr>
<td><img src="/images/drc_with_angle1.png"/></td>
<td><img src="/images/drc_with_angle2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_with_angle3.png"/></td>
<td><img src="/images/drc_with_angle4.png"/></td>
</tr>
</table>
</p><p>
Specifying "ortho", "diagonal" or "diagonal_only" instead of the angle values will select
0 and 90 degree edges (ortho), -45 and 45 degree edges (diagonal_only) and both types (diagonal).
This simplifies the implementation of selectors for manhattan or half-manhattan features:
</p><p>
<pre>
ortho_edges = edges.with_angle(ortho)

# which is equivalent to, but more efficient as:
ortho_edges = edges.with_angle(0) + edges.with_angle(90)
</pre>
</p><p>
Note that in former versions, with_angle could be used on polygon layers selecting corners with specific angles.
This feature has been deprecated. Use <a href="#corners">corners</a> instead.
</p>
<a name="with_area"/><h2>"with_area" - Selects polygons or edge pairs by area</h2>
<keyword name="with_area"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_area(min .. max)</tt></li>
<li><tt>layer.with_area(value)</tt></li>
<li><tt>layer.with_area(min, max)</tt></li>
</ul>
<p>
The first form will select all polygons or edge pairs with an area larger or
equal to min and less (but not equal to) max. The second form
will select the polygons or edge pairs with exactly the given area.
The third form basically is equivalent to the first form, but
allows specification of nil for min or max indicating no lower or 
upper limit.
</p><p>
This method is available for polygon or edge pair layers.
</p>
<a name="with_area_ratio"/><h2>"with_area_ratio" - Selects polygons by the ratio of the bounding box area vs. polygon area</h2>
<keyword name="with_area_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_area_ratio(min .. max)</tt></li>
<li><tt>layer.with_area_ratio(value)</tt></li>
<li><tt>layer.with_area_ratio(min, max)</tt></li>
</ul>
<p>
The area ratio is a measure how far a polygon is approximated by its
bounding box. The value is always larger or equal to 1. Boxes have a 
area ratio of 1. Larger values mean more empty area inside the bounding box.
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_bbox_aspect_ratio"/><h2>"with_bbox_aspect_ratio" - Selects polygons by the aspect ratio of their bounding box</h2>
<keyword name="with_bbox_aspect_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_aspect_ratio(min .. max)</tt></li>
<li><tt>layer.with_bbox_aspect_ratio(value)</tt></li>
<li><tt>layer.with_bbox_aspect_ratio(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured value is the aspect ratio of the bounding 
box. It is the larger dimensions divided by the smaller one.
The "thinner" the polygon, the larger the aspect ratio. A square
bounding box gives an aspect ratio of 1. 
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_bbox_height"/><h2>"with_bbox_height" - Selects polygons by the height of the bounding box</h2>
<keyword name="with_bbox_height"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_height(min .. max)</tt></li>
<li><tt>layer.with_bbox_height(value)</tt></li>
<li><tt>layer.with_bbox_height(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the width of the
bounding box. 
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_bbox_max"/><h2>"with_bbox_max" - Selects polygons by the maximum dimension of the bounding box</h2>
<keyword name="with_bbox_max"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_max(min .. max)</tt></li>
<li><tt>layer.with_bbox_max(value)</tt></li>
<li><tt>layer.with_bbox_max(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the maximum dimension of the
bounding box. The maximum dimension is either the width or height of 
the bounding box, whichever is larger.
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_bbox_min"/><h2>"with_bbox_min" - Selects polygons by the minimum dimension of the bounding box</h2>
<keyword name="with_bbox_min"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_min(min .. max)</tt></li>
<li><tt>layer.with_bbox_min(value)</tt></li>
<li><tt>layer.with_bbox_min(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the minimum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is smaller.
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_bbox_width"/><h2>"with_bbox_width" - Selects polygons by the width of the bounding box</h2>
<keyword name="with_bbox_width"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_width(min .. max)</tt></li>
<li><tt>layer.with_bbox_width(value)</tt></li>
<li><tt>layer.with_bbox_width(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the width of the
bounding box. 
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_density"/><h2>"with_density" - Returns tiles whose density is within a given range</h2>
<keyword name="with_density"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_density(min_value, max_value [, options ])</tt></li>
<li><tt>layer.with_density(min_value .. max_value [, options ])</tt></li>
</ul>
<p>
This method runs a tiled analysis over the current layout. It reports the tiles whose density
is between "min_value" and "max_value". "min_value" and "max_value" are given in
relative units, i.e. within the range of 0 to 1.0 corresponding to a density of 0 to 100%.
</p><p>
"min_value" or "max_value" can be nil or omitted in the ".." range notation.
In this case, they are taken as "0" and "100%".
</p><p>
The tile size must be specified with the "tile_size" option:
</p><p>
<pre>
# reports areas where layer 1/0 density is below 10% on 20x20 um tiles
low_density = input(1, 0).with_density(0.0 .. 0.1, tile_size(20.um))
</pre>
</p><p>
Anisotropic tiles can be specified by giving two values, like "tile_size(10.um, 20.um)".
The first value is the horizontal tile dimension, the second value is the vertical tile
dimension.
</p><p>
A tile overlap can be specified using "tile_step". If the tile step is less than the
tile size, the tiles will overlap. The layout window given by "tile_size" is moved
in increments of the tile step:
</p><p>
<pre>
# reports areas where layer 1/0 density is below 10% on 30x30 um tiles
# with a tile step of 20x20 um:
low_density = input(1, 0).with_density(0.0 .. 0.1, tile_size(30.um), tile_step(20.um))
</pre>
</p><p>
For "tile_step", anisotropic values can be given as well by using two values: the first for the
horizontal and the second for the vertical tile step.
</p><p>
Another option is "tile_origin" which specifies the location of the first tile's position. 
This is the lower left tile's lower left corner. If no origin is given, the tiles are centered over the 
area investigated.
</p><p>
By default, the tiles will cover the bounding box of the input layer. A separate layer
can be used in addition. This way, the layout's dimensions can be derived from some 
drawn boundary layer. To specify a separate, additional layer included in the bounding box, use the "tile_boundary" option:
</p><p>
<pre>
# reports density of layer 1/0 below 10% on 20x20 um tiles. The layout's boundary is taken from
# layer 0/0:
cell_frame = input(0, 0)
low_density = input(1, 0).with_density(0.0 .. 0.1, tile_size(20.um), tile_boundary(cell_frame))
</pre>
</p><p>
Note that the layer given in "tile_boundary" adds to the input layer for computing the bounding box.
The computed area is at least the area of the input layer.
</p><p>
Computation of the area can be skipped by explicitly giving a tile count in horizontal and vertical
direction. With the "tile_origin" option this allows full control over the area covered:
</p><p>
<pre>
# reports density of layer 1/0 below 10% on 20x20 um tiles in the region 0,0 .. 2000,3000
# (100 and 150 tiles of 20 um each are used in horizontal and vertical direction):
low_density = input(1, 0).with_density(0.0 .. 0.1, tile_size(20.um), tile_origin(0.0, 0.0), tile_count(100, 150))
</pre>
</p><p>
The "padding mode" indicates how the area outside the layout's bounding box is considered.
There are two modes:
</p><p>
<ul>
<li><b>padding_zero </b>: the outside area is considered zero density. This is the default mode. </li>
<li><b>padding_ignore </b>: the outside area is ignored for the density computation. </li>
</ul>
</p><p>
Example:
</p><p>
<pre>
low_density = input(1, 0).with_density(0.0 .. 0.1, tile_size(20.um), padding_ignore)
</pre>
</p><p>
The complementary version of "with_density" is <a href="#without_density">without_density</a>.
</p>
<a name="with_distance"/><h2>"with_distance" - Selects edge pairs by the distance of the edges</h2>
<keyword name="with_distance"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_distance(min .. max)</tt></li>
<li><tt>layer.with_distance(value)</tt></li>
<li><tt>layer.with_distance(min, max)</tt></li>
</ul>
<p>
The method selects edge pairs by the distance of their edges. The first version selects
edge pairs with a distance larger or equal to min and less than max (but not equal).
The second version selects edge pairs with exactly the given distance. The third
version is similar to the first one, but allows specification of nil for min or
max indicating that there is no lower or upper limit. 
</p><p>
The distance of the edges is defined by the minimum distance of all points from the 
edges involved. For edge pairs generated in geometrical checks this is equivalent
to the actual distance of the original edges.
</p><p>
This method is available for edge pair layers only.
</p>
<a name="with_holes"/><h2>"with_holes" - Selects all polygons with the specified number of holes</h2>
<keyword name="with_holes"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_holes</tt></li>
<li><tt>layer.with_holes(count)</tt></li>
<li><tt>layer.with_holes(min_count, max_count)</tt></li>
<li><tt>layer.with_holes(min_count .. max_count)</tt></li>
</ul>
<p>
This method is available for polygon layers. It will select all polygons from the input layer
which have the specified number of holes. Without any argument, all polygons with holes are selected.
</p>
<a name="with_internal_angle"/><h2>"with_internal_angle" - Selects edge pairs by their internal angle</h2>
<keyword name="with_internal_angle"/>
<p>Usage:</p>
<ul>
<li><tt>edge_pair_layer.with_internal_angle(min .. max)</tt></li>
<li><tt>edge_pair_layer.with_internal_angle(value)</tt></li>
<li><tt>edge_pair_layer.with_internal_angle(min, max)</tt></li>
</ul>
<p>
This method selects edge pairs by the angle enclosed by their edges.
The angle is between 0 (parallel or anti-parallel edges) and 90 degree (perpendicular edges).
If an interval or two values are given, the angle is checked to be within the given
range.
</p><p>
Here are examples for "with_internal_angle" on edge pair layers:
</p><p>
<pre>
# selects edge pairs with parallel edges
ep1 = edge_pairs.with_internal_angle(0)
# selects edge pairs with perpendicular edges
ep2 = edge_pairs.with_internal_angle(90)
</pre>
</p>
<a name="with_length"/><h2>"with_length" - Selects edges by their length</h2>
<keyword name="with_length"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_length(min .. max)</tt></li>
<li><tt>layer.with_length(value)</tt></li>
<li><tt>layer.with_length(min, max)</tt></li>
<li><tt>edge_pairlayer.with_length(min, max [, both])</tt></li>
</ul>
<p>
The method selects edges by their length. The first version selects
edges with a length larger or equal to min and less than max (but not equal).
The second version selects edges with exactly the given length. The third
version is similar to the first one, but allows specification of nil for min or
max indicating that there is no lower or upper limit. 
</p><p>
This method is available for edge and edge pair layers.
</p><p>
When called on an edge pair layer, this method will select edge pairs if one 
or both of the edges meet the length criterion. Use the additional argument 
and pass "both" (plain word) to specify that both edges need to be within the given interval.
By default, it's sufficient for one edge to meet the criterion.
</p><p>
Here are examples for "with_length" on edge pair layers:
</p><p>
<pre>
# at least one edge needs to have a length of 1.0 &lt;= l &lt; 2.0
ep1 = edge_pairs.with_length(1.um .. 2.um)
# both edges need to have a length of exactly 2 um
ep2 = edge_pairs.with_length(2.um, both)
</pre>
</p>
<a name="with_perimeter"/><h2>"with_perimeter" - Selects polygons by perimeter</h2>
<keyword name="with_perimeter"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_perimeter(min .. max)</tt></li>
<li><tt>layer.with_perimeter(value)</tt></li>
<li><tt>layer.with_perimeter(min, max)</tt></li>
</ul>
<p>
The first form will select all polygons with an perimeter larger or
equal to min and less (but not equal to) max. The second form
will select the polygons with exactly the given perimeter.
The third form basically is equivalent to the first form, but
allows specification of nil for min or max indicating no lower or 
upper limit.
</p><p>
This method is available for polygon layers only.
</p>
<a name="with_relative_height"/><h2>"with_relative_height" - Selects polygons by the ratio of the height vs. width of its bounding box</h2>
<keyword name="with_relative_height"/>
<p>Usage:</p>
<ul>
<li><tt>layer.with_relative_height(min .. max)</tt></li>
<li><tt>layer.with_relative_height(value)</tt></li>
<li><tt>layer.with_relative_height(min, max)</tt></li>
</ul>
<p>
The relative height is a measure how tall a polygon is. Tall polygons
have values larger than 1, wide polygons have a value smaller than 1.
Squares have a value of 1.
</p><p>
Don't use this method when you can use <a href="#with_area_ratio">with_area_ratio</a>, which provides a 
similar measure but is isotropic. 
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_angle"/><h2>"without_angle" - Selects edges by the their angle</h2>
<keyword name="without_angle"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_angle(min .. max [, absolute])</tt></li>
<li><tt>layer.without_angle(value [, absolute])</tt></li>
<li><tt>layer.without_angle(min, max [, absolute])</tt></li>
<li><tt>layer.without_angle(ortho)</tt></li>
<li><tt>layer.without_angle(diagonal)</tt></li>
<li><tt>layer.without_angle(diagonal_only)</tt></li>
<li><tt>edge_pair_layer.without_angle(... [, both] [, absolute])</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_angle">with_angle</a>. It selects all edges
of the edge layer or corners of the polygons which do not have the given angle (second form) or whose angle
is not inside the given interval (first and third form) or of the given type (other forms).
</p><p>
When called on edge pairs, it selects edge pairs by the angles of their edges.
</p><p>
The "absolute" option is available for edge or edge pair layers. Without the "absolute" option,
edges sloping down are assigned a negative angle while edges sloping up are assigned
a positive angle (vertical edges are always 90 degree). With the "absolute" option,
edges sloping down also have a positive angle which is the one enclosed with the horizontal axis.
</p><p>
A note on the "both" modifier (without_angle called on edge pairs): "both" means that
both edges need to be "without_angle". For example
</p><p>
<pre>
# both edges are not horizontal or:
# the edge pair is skipped if one edge is horizontal
ep = edge_pairs.without_angle(0, both)
</pre>
</p><p>
See <a href="#with_internal_angle">with_internal_angle</a> and <a href="#without_internal_angle">without_internal_angle</a> to select edge pairs by the
angle between the edges.
</p>
<a name="without_area"/><h2>"without_area" - Selects polygons or edge pairs by area</h2>
<keyword name="without_area"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_area(min .. max)</tt></li>
<li><tt>layer.without_area(value)</tt></li>
<li><tt>layer.without_area(min, max)</tt></li>
</ul>
<p>
This method is the inverse of "with_area". It will select 
polygons or edge pairs without an area equal to the given one or outside
the given interval.
</p><p>
This method is available for polygon or edge pair layers.
</p>
<a name="without_area_ratio"/><h2>"without_area_ratio" - Selects polygons by the aspect ratio of their bounding box</h2>
<keyword name="without_area_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_area_ratio(min .. max)</tt></li>
<li><tt>layer.without_area_ratio(value)</tt></li>
<li><tt>layer.without_area_ratio(min, max)</tt></li>
</ul>
<p>
The method provides the opposite filter for <a href="#with_area_ratio">with_area_ratio</a>.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_bbox_height"/><h2>"without_bbox_height" - Selects polygons by the aspect ratio of their bounding box</h2>
<keyword name="without_bbox_height"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_aspect_ratio(min .. max)</tt></li>
<li><tt>layer.without_bbox_aspect_ratio(value)</tt></li>
<li><tt>layer.without_bbox_aspect_ratio(min, max)</tt></li>
</ul>
<p>
The method provides the opposite filter for <a href="#with_bbox_aspect_ratio">with_bbox_aspect_ratio</a>.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_bbox_max"/><h2>"without_bbox_max" - Selects polygons by the maximum dimension of the bounding box</h2>
<keyword name="without_bbox_max"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_max(min .. max)</tt></li>
<li><tt>layer.without_bbox_max(value)</tt></li>
<li><tt>layer.without_bbox_max(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the maximum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is larger.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_bbox_min"/><h2>"without_bbox_min" - Selects polygons by the minimum dimension of the bounding box</h2>
<keyword name="without_bbox_min"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_min(min .. max)</tt></li>
<li><tt>layer.without_bbox_min(value)</tt></li>
<li><tt>layer.without_bbox_min(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the minimum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is smaller.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_bbox_width"/><h2>"without_bbox_width" - Selects polygons by the width of the bounding box</h2>
<keyword name="without_bbox_width"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_width(min .. max)</tt></li>
<li><tt>layer.without_bbox_width(value)</tt></li>
<li><tt>layer.without_bbox_width(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the width of the
bounding box.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_density"/><h2>"without_density" - Returns tiles whose density is not within a given range</h2>
<keyword name="without_density"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_density(min_value, max_value [, options ])</tt></li>
<li><tt>layer.without_density(min_value .. max_value [, options ])</tt></li>
</ul>
<p>
For details about the operations and the operation see <a href="#with_density">with_density</a>. This version will return the
tiles where the density is not within the given range.
</p>
<a name="without_distance"/><h2>"without_distance" - Selects edge pairs by the distance of the edges</h2>
<keyword name="without_distance"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_distance(min .. max)</tt></li>
<li><tt>layer.without_distance(value)</tt></li>
<li><tt>layer.without_distance(min, max)</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_distance">with_distance</a>. It selects all edge pairs
of the edge pair layer which do not have the given distance (second form) or are
not inside the given interval (first and third form).
</p><p>
This method is available for edge pair layers only.
</p>
<a name="without_holes"/><h2>"without_holes" - Selects all polygons with the specified number of holes</h2>
<keyword name="without_holes"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_holes</tt></li>
<li><tt>layer.without_holes(count)</tt></li>
<li><tt>layer.without_holes(min_count, max_count)</tt></li>
<li><tt>layer.without_holes(min_count .. max_count)</tt></li>
</ul>
<p>
This method is available for polygon layers. It will select all polygons from the input layer
which do not have the specified number of holes. Without any arguments, all polygons without holes are selected.
</p>
<a name="without_internal_angle"/><h2>"without_internal_angle" - Selects edge pairs by their internal angle</h2>
<keyword name="without_internal_angle"/>
<p>Usage:</p>
<ul>
<li><tt>edge_pair_layer.without_internal_angle(min .. max)</tt></li>
<li><tt>edge_pair_layer.without_internal_angle(value)</tt></li>
<li><tt>edge_pair_layer.without_internal_angle(min, max)</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_internal_angle">with_internal_angle</a>. It selects all 
edge pairs by the angle enclosed by their edges, applying the opposite criterion than <a href="#with_internal_angle">with_internal_angle</a>.
</p>
<a name="without_length"/><h2>"without_length" - Selects edges by the their length</h2>
<keyword name="without_length"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_length(min .. max)</tt></li>
<li><tt>layer.without_length(value)</tt></li>
<li><tt>layer.without_length(min, max)</tt></li>
<li><tt>edge_pairlayer.with_length(min, max [, both])</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_length">with_length</a>. It selects all edges
of the edge layer which do not have the given length (second form) or are
not inside the given interval (first and third form).
</p><p>
This method is available for edge and edge pair layers.
</p><p>
A note on the "both" modifier (without_length called on edge pairs): "both" means that
both edges need to be "without_length". For example
</p><p>
<pre>
# both edges are not exactly 1 um in length, or:
# the edge pair is skipped if one edge has a length of exactly 1 um
ep = edge_pairs.without_length(1.um, both)
</pre>
</p>
<a name="without_perimeter"/><h2>"without_perimeter" - Selects polygons by perimeter</h2>
<keyword name="without_perimeter"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_perimeter(min .. max)</tt></li>
<li><tt>layer.without_perimeter(value)</tt></li>
<li><tt>layer.without_perimeter(min, max)</tt></li>
</ul>
<p>
This method is the inverse of "with_perimeter". It will select 
polygons without a perimeter equal to the given one or outside
the given interval.
</p><p>
This method is available for polygon layers only.
</p>
<a name="without_relative_height"/><h2>"without_relative_height" - Selects polygons by the ratio of the height vs. width</h2>
<keyword name="without_relative_height"/>
<p>Usage:</p>
<ul>
<li><tt>layer.without_relative_height(min .. max)</tt></li>
<li><tt>layer.without_relative_height(value)</tt></li>
<li><tt>layer.without_relative_height(min, max)</tt></li>
</ul>
<p>
The method provides the opposite filter for <a href="#with_relative_height">with_relative_height</a>.
</p><p>
This method is available for polygon layers only.
</p>
<a name="xor"/><h2>"xor" - Boolean XOR operation</h2>
<keyword name="xor"/>
<p>Usage:</p>
<ul>
<li><tt>layer.xor(other)</tt></li>
</ul>
<p>
The method computes a boolean XOR between self and other.
It is an alias for the "^" operator.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following images show the effect of the "xor" method
on polygons and edges (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_xor1.png"/></td>
<td><img src="/images/drc_xor2.png"/></td>
</tr>
</table>
</p>
<a name="|"/><h2>"|" - Boolean OR operation</h2>
<keyword name="|"/>
<p>Usage:</p>
<ul>
<li><tt>self | other</tt></li>
</ul>
<p>
The method computes a boolean OR between self and other. A similar
operation is <a href="#join">join</a> which will basically gives the same result but
won't merge the shapes.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#or">or</a>". See there for a description of the function.
</p>
</doc>
