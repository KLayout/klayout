<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Global Functions</title>
<keyword name="global"/>
<h2-index/>
<a name="angle (in condition)"/><h2>"angle (in condition)" - In universal DRC context: selects edges based on their orientation</h2>
<keyword name="angle (in condition)"/>
<p>Usage:</p>
<ul>
<li><tt>angle (in condition)</tt></li>
</ul>
<p>
"angle" represents the edge orientation filter on the primary shape edges in
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#angle">DRC#angle</a> for more details). In this context,
the operation acts similar to <a href="/about/drc_ref_layer.xml#with_angle">Layer#with_angle</a>.
</p>
<a name="antenna_check"/><h2>"antenna_check" - Performs an antenna check</h2>
<keyword name="antenna_check"/>
<p>Usage:</p>
<ul>
<li><tt>antenna_check(gate, metal, ratio, [ diode_specs ... ])</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#antenna_check">Netter#antenna_check</a> for a description of that function.
</p>
<a name="area"/><h2>"area" - Computes the total area or in universal DRC context: selects the primary shape if the area is meeting the condition</h2>
<keyword name="area"/>
<p>Usage:</p>
<ul>
<li><tt>area (in condition)</tt></li>
<li><tt>area(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.area" (see <a href="/about/drc_ref_layer.xml#area">Layer#area</a>) and returns the total area of the 
polygons in the layer. 
</p><p>
Without a layer argument, "area" represents an area filter for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#area">DRC#area</a> for more details).
</p>
<a name="area_ratio"/><h2>"area_ratio" - Selects primary shapes based on the ratio of bounding box and polygon area</h2>
<keyword name="area_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>area_ratio (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#area_ratio">area_ratio</a> and <a href="/about/drc_ref_drc.xml#area_ratio">DRC#area_ratio</a> for more details.
</p>
<a name="bbox_aspect_ratio"/><h2>"bbox_aspect_ratio" - Selects primary shapes based on the aspect ratio of their bounding boxes</h2>
<keyword name="bbox_aspect_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>bbox_aspect_ratio (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#bbox_aspect_ratio">bbox_aspect_ratio</a> and <a href="/about/drc_ref_drc.xml#bbox_aspect_ratio">DRC#bbox_aspect_ratio</a> for more details.
</p>
<a name="bbox_height"/><h2>"bbox_height" - Selects primary shapes based on their bounding box height</h2>
<keyword name="bbox_height"/>
<p>Usage:</p>
<ul>
<li><tt>bbox_height (in condition)</tt></li>
</ul>
<p>
This method creates a universal DRC expression (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>) to select primary shapes whose
bounding box height satisfies the condition. Conditions may be written as arithmetic comparisons
against numeric values. For example, "bbox_height &lt; 2.0" will select all primary shapes whose
bounding box height is less than 2 micrometers. See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> for more details about comparison 
specs. Plain "bbox_min" is equivalent to "primary.bbox_min" - i.e. it is used on the primary
shape. Also see <a href="/about/drc_ref_drc.xml#bbox_min">DRC#bbox_min</a>.
</p>
<a name="bbox_max"/><h2>"bbox_max" - Selects primary shapes based on their bounding box height or width, whichever is larger</h2>
<keyword name="bbox_max"/>
<p>Usage:</p>
<ul>
<li><tt>bbox_max (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#bbox_max">bbox_max</a> and <a href="/about/drc_ref_drc.xml#bbox_max">DRC#bbox_max</a> for more details.
</p>
<a name="bbox_min"/><h2>"bbox_min" - Selects primary shapes based on their bounding box height or width, whichever is smaller</h2>
<keyword name="bbox_min"/>
<p>Usage:</p>
<ul>
<li><tt>bbox_max (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#bbox_min">bbox_min</a> and <a href="/about/drc_ref_drc.xml#bbox_min">DRC#bbox_min</a> for more details.
</p>
<a name="bbox_width"/><h2>"bbox_width" - Selects primary shapes based on their bounding box width</h2>
<keyword name="bbox_width"/>
<p>Usage:</p>
<ul>
<li><tt>bbox_max (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#bbox_height">bbox_height</a> and <a href="/about/drc_ref_drc.xml#bbox_height">DRC#bbox_height</a> for more details.
</p>
<a name="bjt3"/><h2>"bjt3" - Supplies the BJT3 transistor extractor class</h2>
<keyword name="bjt3"/>
<p>Usage:</p>
<ul>
<li><tt>bjt3(name)</tt></li>
<li><tt>bjt3(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
bipolar junction transistor
</p><p>
See <class_doc href="DeviceExtractorBJT3Transistor">DeviceExtractorBJT3Transistor</class_doc> for more details
about this extractor.
</p>
<a name="bjt4"/><h2>"bjt4" - Supplies the BJT4 transistor extractor class</h2>
<keyword name="bjt4"/>
<p>Usage:</p>
<ul>
<li><tt>bjt4(name)</tt></li>
<li><tt>bjt4(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
bipolar junction transistor with a substrate terminal
</p><p>
See <class_doc href="DeviceExtractorBJT4Transistor">DeviceExtractorBJT4Transistor</class_doc> for more details
about this extractor.
</p>
<a name="box"/><h2>"box" - Creates a box object</h2>
<keyword name="box"/>
<p>Usage:</p>
<ul>
<li><tt>box(...)</tt></li>
</ul>
<p>
This function creates a box object. The arguments are the same than for the 
<class_doc href="DBox">DBox</class_doc> constructors.
</p>
<a name="capacitor"/><h2>"capacitor" - Supplies the capacitor extractor class</h2>
<keyword name="capacitor"/>
<p>Usage:</p>
<ul>
<li><tt>capacitor(name, area_cap)</tt></li>
<li><tt>capacitor(name, area_cap, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a capacitor.
The area_cap argument is the capacitance in Farad per square micrometer.
</p><p>
See <class_doc href="DeviceExtractorCapacitor">DeviceExtractorCapacitor</class_doc> for more details
about this extractor.
</p>
<a name="capacitor_with_bulk"/><h2>"capacitor_with_bulk" - Supplies the capacitor extractor class that includes a bulk terminal</h2>
<keyword name="capacitor_with_bulk"/>
<p>Usage:</p>
<ul>
<li><tt>capacitor_with_bulk(name, area_cap)</tt></li>
<li><tt>capacitor_with_bulk(name, area_cap, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a capacitor 
with a bulk terminal.
The area_cap argument is the capacitance in Farad per square micrometer.
</p><p>
See <class_doc href="DeviceExtractorCapacitorWithBulk">DeviceExtractorCapacitorWithBulk</class_doc> for more details
about this extractor.
</p>
<a name="cell"/><h2>"cell" - Selects a cell for input on the default source</h2>
<keyword name="cell"/>
<p>Usage:</p>
<ul>
<li><tt>cell(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#cell">Source#cell</a> for a description of that function.
In addition to the functionality described there, the global function will also send the output
to the specified cell.
</p><p>
The following code will select cell "MACRO" from the input layout:
</p><p>
<pre>
cell("MACRO")
# shapes now will be taken from cell "MACRO"
l1 = input(1, 0)
</pre>
</p>
<a name="cheat"/><h2>"cheat" - Hierarchy cheats</h2>
<keyword name="cheat"/>
<p>Usage:</p>
<ul>
<li><tt>cheat(args) { block }</tt></li>
</ul>
<p>
Hierarchy cheats can be used in deep mode to shortcut hierarchy evaluation
for certain cells and consider their local configuration only.
Cheats are useful for example when dealing with memory arrays. Often
such arrays are build from unit cells and those often overlap with their
neighbors. Now, if the hierarchical engine encounters such a situation, it
will first analyse all these interactions (which can be expensive) and then
it may come to the conclusion that boundary instances need to be handled
differently than inside instances. This in turn might lead to propagation of
shapes and in an LVS context to device externalisation: because some devices
might have different parameters for boundary cells than for inside cells, the
device instances can no longer be kept inside the unit cell. Specifically for
memory arrays, this is not desired as eventually this leads to flattening
of the whole array. 
</p><p>
The solution is to cheat: provided the unit cell is fully fledged and neighbors
do not disturb the unit cell's configuration in critical ways, the unit cell 
can be treated as being isolated and results are put together in the usual way.
</p><p>
Cheats can be applied on layout operations - specifically booleans - and device
extraction operations. Cheats are only effective in <a href="#deep">deep</a> mode.
</p><p>
For booleans, a cheat means that the cheating cell's boolean results are computed
locally and are combined afterwards. A cheat is introduced this way:
</p><p>
<pre>
deep

l1 = input(1, 0)
l2 = input(2, 0)

# usual booleans
l1and2 = l1 &amp; l2

# will compute "UNIT_CELL" isolated and everything else in normal hierarchical mode:
l1minus2 = cheat("UNIT_CELL) { l1 - l2 }
</pre>
</p><p>
The cheat block can also be wrapped in do .. end statements and can return multiple
layer objects:
</p><p>
<pre>
deep

l1 = input(1, 0)
l2 = input(2, 0)

# computes both AND and NOT of l1 and l2 with cheating for "UNIT_CELL"
l1and2, l1minus2 = cheat("UNIT_CELL) do
[ l1 &amp; l2, l1 - l2 ]
end
</pre>
</p><p>
(Technically, the cheat code block is a Ruby Proc and cannot create variables
outside its scope. Hence the results of this code block have to be passed
through the "cheat" method).
</p><p>
To apply cheats for device extraction, use the following scheme:
</p><p>
<pre>
deep

poly = input(1, 0)
active = input(2, 0)

sd = active - poly
gate = active &amp; poly

# device extraction with cheating for "UNIT_CELL":
cheat("UNIT_CELL") do
extract_devices(mos3("NMOS"), { "SD" =&gt; sd, "G" =&gt; gate, "tS" =&gt; sd, "tD" =&gt; sd, "tG" =&gt; poly }
end
</pre>
</p><p>
The argument to the cheat method is a list of cell name pattern (glob-style
pattern). For example:
</p><p>
<pre>
cheat("UNIT_CELL*") { ... }
cheat("UNIT_CELL1", "UNIT_CELL2") { ... }
cheat("UNIT_CELL{1,2}") { ... }
</pre>
</p><p>
For LVS applications, it's usually sufficient to cheat in the device extraction step. 
Cheats have been introduced in version 0.26.1.
</p>
<a name="clear_connections"/><h2>"clear_connections" - Clears all connections stored so far</h2>
<keyword name="clear_connections"/>
<p>Usage:</p>
<ul>
<li><tt>clear_connections</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#clear_connections">Netter#clear_connections</a> for a description of that function.
</p>
<a name="clip"/><h2>"clip" - Specifies clipped input on the default source</h2>
<keyword name="clip"/>
<p>Usage:</p>
<ul>
<li><tt>clip(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#clip">Source#clip</a> for a description of that function.
</p><p>
The following code will select shapes within a 500x600 micron rectangle (lower left corner at 0,0) 
from the input layout. The shapes will be clipped to that rectangle:
</p><p>
<pre>
clip(0.mm, 0.mm, 0.5.mm, 0.6.mm)
# shapes now will be taken from the given rectangle and clipped to it
l1 = input(1, 0)
</pre>
</p><p>
To remove the clip condition, call "clip" without any arguments.
</p>
<a name="connect"/><h2>"connect" - Specifies a connection between two layers</h2>
<keyword name="connect"/>
<p>Usage:</p>
<ul>
<li><tt>connect(a, b)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect">Netter#connect</a> for a description of that function.
</p>
<a name="connect_explicit"/><h2>"connect_explicit" - Specifies explicit net connections</h2>
<keyword name="connect_explicit"/>
<p>Usage:</p>
<ul>
<li><tt>connect_explicit(net_names)</tt></li>
<li><tt>connect_explicit(cell_pattern, net_names)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect_explicit">Netter#connect_explicit</a> for a description of that function.
Net names is an array (use square brackets to list the net names).
</p>
<a name="connect_global"/><h2>"connect_global" - Specifies a connection to a global net</h2>
<keyword name="connect_global"/>
<p>Usage:</p>
<ul>
<li><tt>connect_global(l, name)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect_global">Netter#connect_global</a> for a description of that function.
</p>
<a name="connect_implicit"/><h2>"connect_implicit" - Specifies a label pattern for implicit net connections</h2>
<keyword name="connect_implicit"/>
<p>Usage:</p>
<ul>
<li><tt>connect_implicit(label_pattern)</tt></li>
<li><tt>connect_implicit(cell_pattern, label_pattern)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#connect_implicit">Netter#connect_implicit</a> for a description of that function.
</p>
<a name="corners"/><h2>"corners" - Selects corners of polygons</h2>
<keyword name="corners"/>
<p>Usage:</p>
<ul>
<li><tt>corners([ options ]) (in condition)</tt></li>
<li><tt>corners(layer [, options ])</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.corners" (see <a href="/about/drc_ref_layer.xml#corners">Layer#corners</a>). Without a layer
argument, "corners" represents the corner generator/filter in primary shapes for
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#corners">DRC#corners</a> for more details).
</p><p>
Like the layer-based version, the "corners" operator accepts the 
output type option: "as_dots" for dot-like edges, "as_boxes" for
small (2x2 DBU) box markers and "as_edge_pairs" for edge pairs.
The default output type is "as_boxes".
</p><p>
The "corners" operator can be put into a condition which means it's
applied to corners meeting a particular angle constraint.
</p>
<a name="covering"/><h2>"covering" - Selects shapes entirely covering other shapes</h2>
<keyword name="covering"/>
<p>Usage:</p>
<ul>
<li><tt>covering(other) (optionally in condition)</tt></li>
</ul>
<p>
This operator represents the selector of primary shapes
which entirely cover shapes from the other layer. This version can be put into
a condition indicating how many shapes of the other layer need to be covered.
Use this operator within <a href="/about/drc_ref_drc.xml">DRC</a> expressions (also see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>). If can be used
as method to an expression. See there for more details: <a href="/about/drc_ref_drc.xml#covering">DRC#covering</a>.
</p>
<a name="dbu"/><h2>"dbu" - Gets or sets the database unit to use</h2>
<keyword name="dbu"/>
<p>Usage:</p>
<ul>
<li><tt>dbu(dbu_value)</tt></li>
<li><tt>dbu</tt></li>
</ul>
<p>
Without any argument, this method gets the database unit
used inside the DRC engine. 
</p><p>
With an argument, sets the database unit used internally in the DRC engine.
Without using that method, the database unit is automatically
taken as the database unit of the last input. 
A specific database unit can be set in order to optimize
for two layouts (i.e. take the largest common denominator).
When the database unit is set, it must be set at the beginning
of the script and before any operation that uses it.
</p>
<a name="deep"/><h2>"deep" - Enters deep (hierarchical) mode</h2>
<keyword name="deep"/>
<p>Usage:</p>
<ul>
<li><tt>deep</tt></li>
</ul>
<p>
In deep mode, the operations will be performed in a hierarchical fashion. 
Sometimes this reduces the time and memory required for an operation, but this
will also add some overhead for the hierarchical analysis.
</p><p>
"deepness" is a property of layers. Layers created with "input" while in 
deep mode carry hierarchy. Operations involving such layers at the only
or the first argument are carried out in hierarchical mode. 
</p><p>
Hierarchical mode has some more implications, like "merged_semantics" being
implied always. Sometimes cell variants will be created.
</p><p>
Deep mode can be cancelled with <a href="#tiles">tiles</a> or <a href="#flat">flat</a>.
</p>
<a name="deep_reject_odd_polygons"/><h2>"deep_reject_odd_polygons" - Gets or sets a value indicating whether the reject odd polygons in deep mode</h2>
<keyword name="deep_reject_odd_polygons"/>
<p>Usage:</p>
<ul>
<li><tt>deep_reject_odd_polygons(flag)</tt></li>
<li><tt>deep_reject_odd_polygons</tt></li>
</ul>
<p>
In deep mode, non-orientable (e.g. "8"-shaped) polygons may not be resolved properly.
By default the interpretation of such polygons is undefined - they may even vanish entirely.
By setting this flag to true, the deep mode layout processor will reject such polygons with 
an error. 
</p>
<a name="device_scaling"/><h2>"device_scaling" - Specifies a dimension scale factor for the geometrical device properties</h2>
<keyword name="device_scaling"/>
<p>Usage:</p>
<ul>
<li><tt>device_scaling(factor)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#device_scaling">Netter#device_scaling</a> for a description of that function.
</p>
<a name="diode"/><h2>"diode" - Supplies the diode extractor class</h2>
<keyword name="diode"/>
<p>Usage:</p>
<ul>
<li><tt>diode(name)</tt></li>
<li><tt>diode(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
planar diode 
</p><p>
See <class_doc href="DeviceExtractorDiode">DeviceExtractorDiode</class_doc> for more details
about this extractor.
</p>
<a name="dmos3"/><h2>"dmos3" - Supplies the DMOS3 transistor extractor class</h2>
<keyword name="dmos3"/>
<p>Usage:</p>
<ul>
<li><tt>dmos3(name)</tt></li>
<li><tt>dmos3(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
three-terminal DMOS transistor. A DMOS transistor is essentially
the same than a MOS transistor, but source and drain are 
separated.
</p><p>
See <class_doc href="DeviceExtractorMOS3Transistor">DeviceExtractorMOS3Transistor</class_doc> for more details
about this extractor (strict mode applies for 'dmos3').
</p>
<a name="dmos4"/><h2>"dmos4" - Supplies the MOS4 transistor extractor class</h2>
<keyword name="dmos4"/>
<p>Usage:</p>
<ul>
<li><tt>dmos4(name)</tt></li>
<li><tt>dmos4(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
four-terminal DMOS transistor. A DMOS transistor is essentially
the same than a MOS transistor, but source and drain are 
separated.
</p><p>
See <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc> for more details
about this extractor (strict mode applies for 'dmos4').
</p>
<a name="edge"/><h2>"edge" - Creates an edge object</h2>
<keyword name="edge"/>
<p>Usage:</p>
<ul>
<li><tt>edge(...)</tt></li>
</ul>
<p>
This function creates an edge object. The arguments are the same than for the 
<class_doc href="DEdge">DEdge</class_doc> constructors.
</p>
<a name="edge_layer"/><h2>"edge_layer" - Creates an empty edge layer</h2>
<keyword name="edge_layer"/>
<p>Usage:</p>
<ul>
<li><tt>edge_layer</tt></li>
</ul>
<p>
The intention of that method is to create an empty layer which can be 
filled with edge objects using <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
</p>
<a name="edge_pairs"/><h2>"edge_pairs" - Gets the edges from an original layer</h2>
<keyword name="edge_pairs"/>
<p>Usage:</p>
<ul>
<li><tt>edge_pairs(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#edge_pairs">Source#edge_pairs</a> for a description of that function.
</p>
<a name="edges"/><h2>"edges" - Gets the edges from an original layer</h2>
<keyword name="edges"/>
<p>Usage:</p>
<ul>
<li><tt>edges(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#edges">Source#edges</a> for a description of that function.
</p>
<a name="enc"/><h2>"enc" - Synonym for "enclosing"</h2>
<keyword name="enc"/>
<p>Usage:</p>
<ul>
<li><tt>enc(...)</tt></li>
</ul>
<p>
"enc" is the short form for <a href="#enclosing">enclosing</a>.
</p>
<a name="enclosed"/><h2>"enclosed" - Performs an enclosing check (other enclosing layer)</h2>
<keyword name="enclosed"/>
<p>Usage:</p>
<ul>
<li><tt>enclosed(other [, options ]) (in conditions)</tt></li>
<li><tt>enclosed(layer, other [, options ])</tt></li>
</ul>
<p>
This check verifies if the polygons of the input layer are enclosed by shapes
of the other input layer by a certain distance.
It has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc. This check also features
opposite and rectangle filtering. See <a href="/about/drc_ref_layer.xml#separation">Layer#separation</a> for details about opposite and
rectangle error filtering.
</p><p>
This function is essentially the reverse of <a href="#enclosing">enclosing</a>. In case of
"enclosed", the other layer must be bigger than the primary layer.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.enclosed" (see <a href="/about/drc_ref_layer.xml#enclosed">Layer#enclosed</a>). 
</p><p>
<pre>
# classic "enclosed" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = enclosed(in, other, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a first layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#enclosed">Layer#enclosed</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC "enclosed" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = in.drc(enclosed(other) &lt; 0.2.um)
</pre>
</p><p>
The conditions may involve an upper and lower limit. The following examples
illustrate the use of this function with conditions:
</p><p>
<pre>
out = in.drc(enclosed(other) &lt; 0.2.um)
out = in.drc(enclosed(other) &lt;= 0.2.um)
out = in.drc(enclosed(other) &gt; 0.2.um)
out = in.drc(enclosed(other) &gt;= 0.2.um)
out = in.drc(enclosed(other) == 0.2.um)
out = in.drc(enclosed(other) != 0.2.um)
out = in.drc(0.1.um &lt;= enclosed(other) &lt; 0.2.um)
</pre>
</p><p>
The result of the enclosed check are edges or edge pairs forming the markers.
These markers indicate the presence of the specified condition.
</p><p>
With a lower and upper limit, the results are edges marking the positions on the 
primary shape where the condition is met.
With a lower limit alone, the results are edge pairs which are formed by two identical, but opposite edges attached to 
the primary shape. Without an upper limit only, the first edge of the marker is attached to the 
primary shape while the second edge is attached to the shape of the "other" layer.
</p><p>
<table>
<tr>
<td><img src="/images/drc_encd1u.png"/></td>
<td><img src="/images/drc_encd2u.png"/></td>
</tr>
</table>
</p><p>
When "larger than" constraints are used, this function will produce the edges from the
first layer only. The result will still be edge pairs for consistency, but each edge pair holds one edge from
the original polygon plus a reverse copy of that edge in the second member. Use "first_edges" to extract the 
actual edges from the first input (see <a href="#separation">separation</a> for an example).
</p>
<a name="enclosing"/><h2>"enclosing" - Performs an enclosing check</h2>
<keyword name="enclosing"/>
<p>Usage:</p>
<ul>
<li><tt>enclosing(other [, options ]) (in conditions)</tt></li>
<li><tt>enclosing(layer, other [, options ])</tt></li>
</ul>
<p>
This check verifies if the polygons of the input layer are enclosing the shapes
of the other input layer by a certain distance.
It has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc. This check also features
opposite and rectangle filtering. See <a href="/about/drc_ref_layer.xml#separation">Layer#separation</a> for details about opposite and
rectangle error filtering.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.enclosing" (see <a href="/about/drc_ref_layer.xml#enclosing">Layer#enclosing</a>). 
</p><p>
<pre>
# classic "enclosing" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = enclosing(in, other, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a first layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#enclosing">Layer#enclosing</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC "enclosing" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = in.drc(enclosing(other) &lt; 0.2.um)
</pre>
</p><p>
The conditions may involve an upper and lower limit. The following examples
illustrate the use of this function with conditions:
</p><p>
<pre>
out = in.drc(enclosing(other) &lt; 0.2.um)
out = in.drc(enclosing(other) &lt;= 0.2.um)
out = in.drc(enclosing(other) &gt; 0.2.um)
out = in.drc(enclosing(other) &gt;= 0.2.um)
out = in.drc(enclosing(other) == 0.2.um)
out = in.drc(enclosing(other) != 0.2.um)
out = in.drc(0.1.um &lt;= enclosing(other) &lt; 0.2.um)
</pre>
</p><p>
The result of the enclosing check are edges or edge pairs forming the markers.
These markers indicate the presence of the specified condition.
</p><p>
With a lower and upper limit, the results are edges marking the positions on the 
primary shape where the condition is met.
With a lower limit alone, the results are edge pairs which are formed by two identical, but opposite edges attached to 
the primary shape. Without an upper limit only, the first edge of the marker is attached to the 
primary shape while the second edge is attached to the shape of the "other" layer.
</p><p>
<table>
<tr>
<td><img src="/images/drc_enc1u.png"/></td>
<td><img src="/images/drc_enc2u.png"/></td>
</tr>
</table>
</p><p>
When "larger than" constraints are used, this function will produce the edges from the
first layer only. The result will still be edge pairs for consistency, but each edge pair holds one edge from
the original polygon plus a reverse copy of that edge in the second member. Use "first_edges" to extract the 
actual edges from the first input (see <a href="#separation">separation</a> for an example).
</p>
<a name="error"/><h2>"error" - Prints an error</h2>
<keyword name="error"/>
<p>Usage:</p>
<ul>
<li><tt>error(message)</tt></li>
</ul>
<p>
Similar to <a href="#log">log</a>, but the message is printed formatted as an error
</p>
<a name="extent"/><h2>"extent" - Creates a new layer with the bounding box of the default source or cell bounding boxes</h2>
<keyword name="extent"/>
<p>Usage:</p>
<ul>
<li><tt>extent</tt></li>
<li><tt>extent(cell_filter)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#extent">Source#extent</a> for a description of that function.
</p>
<a name="extent_refs"/><h2>"extent_refs" - Returns partial references to the boundings boxes of the polygons</h2>
<keyword name="extent_refs"/>
<p>Usage:</p>
<ul>
<li><tt>extent_refs([ options ])</tt></li>
<li><tt>extent_refs(layer, [ options ])</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.extent_refs" (see <a href="/about/drc_ref_layer.xml#extent_refs">Layer#extent_refs</a>). Without a layer
argument, "extent_refs" represents the partial extents extractor on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#extent_refs">DRC#extent_refs</a> for more details).
</p>
<a name="extents"/><h2>"extents" - Returns the bounding box of each input object</h2>
<keyword name="extents"/>
<p>Usage:</p>
<ul>
<li><tt>extents([ enlargement ])</tt></li>
<li><tt>extents(layer, [ enlargement ])</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.extents" (see <a href="/about/drc_ref_layer.xml#extents">Layer#extents</a>). Without a layer
argument, "extents" represents the extents generator on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#extents">DRC#extents</a> for more details).
</p>
<a name="extract_devices"/><h2>"extract_devices" - Extracts devices for a given device extractor and device layer selection</h2>
<keyword name="extract_devices"/>
<p>Usage:</p>
<ul>
<li><tt>extract_devices(extractor, layer_hash)</tt></li>
<li><tt>extract_devices(extractor_class, name, layer_hash)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#extract_devices">Netter#extract_devices</a> for a description of that function.
</p>
<a name="flat"/><h2>"flat" - Disables tiling mode</h2>
<keyword name="flat"/>
<p>Usage:</p>
<ul>
<li><tt>flat</tt></li>
</ul>
<p>
Disables tiling mode. Tiling mode can be enabled again with <a href="#tiles">tiles</a> later.
</p>
<a name="foreign"/><h2>"foreign" - Represents all other polygons from primary except the current one</h2>
<keyword name="foreign"/>
<p>Usage:</p>
<ul>
<li><tt>foreign</tt></li>
</ul>
<p>
The primary input of the universal DRC function is the layer the <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> function
is called on. This operation represents all "other" primary polygons while
<a href="#primary">primary</a> represents the current polygon.
</p><p>
This feature opens new options for processing layouts beyond the 
abilities of the classical DRC concept. For classic DRC, intra-layer interactions
are always symmetric: a polygon cannot be considered separated from it's neighbors
on the same layer.
</p><p>
The following example computes every part of the input which is closer than
0.5 micrometers to other (disconnected) polygons on the same layer:
</p><p>
<pre>
out = in.drc(primary &amp; foreign.sized(0.5.um))
</pre>
</p>
<a name="global_transform"/><h2>"global_transform" - Gets or sets a global transformation</h2>
<keyword name="global_transform"/>
<p>Usage:</p>
<ul>
<li><tt>global_transform</tt></li>
<li><tt>global_transform([ transformations ])</tt></li>
</ul>
<p>
Applies a global transformation to the default source layout.
See <a href="/about/drc_ref_source.xml#global_transform">Source#global_transform</a> for a description of this feature.
</p>
<a name="holes"/><h2>"holes" - Selects all holes from the input polygons</h2>
<keyword name="holes"/>
<p>Usage:</p>
<ul>
<li><tt>holes</tt></li>
<li><tt>holes(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.holes" (see <a href="/about/drc_ref_layer.xml#hulls">Layer#hulls</a>). Without a layer
argument, "holes" represents a hole extractor for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#hulls">DRC#hulls</a> for more details).
</p>
<a name="hulls"/><h2>"hulls" - Selects all hulls from the input polygons</h2>
<keyword name="hulls"/>
<p>Usage:</p>
<ul>
<li><tt>hulls</tt></li>
<li><tt>hulls(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.hulls" (see <a href="/about/drc_ref_layer.xml#hulls">Layer#hulls</a>). Without a layer
argument, "hulls" represents a hull contour extractor for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#hulls">DRC#hulls</a> for more details).
</p>
<a name="if_all"/><h2>"if_all" - Evaluates to the primary shape when all condition expression results are non-empty</h2>
<keyword name="if_all"/>
<p>Usage:</p>
<ul>
<li><tt>if_all(c1, ... cn)</tt></li>
</ul>
<p>
This function will evaluate the conditions c1 to cn and return the 
current primary shape if all conditions render a non-empty result.
The following example selects all shapes which are rectangles and 
whose area is larger than 0.5 square micrometers:
</p><p>
<pre>
out = in.drc(if_all(area &gt; 0.5, rectangle))
</pre>
</p><p>
The condition expressions may be of any type (edges, edge pairs and polygons).
</p>
<a name="if_any"/><h2>"if_any" - Evaluates to the primary shape when any condition expression results is non-empty</h2>
<keyword name="if_any"/>
<p>Usage:</p>
<ul>
<li><tt>if_any(c1, ... cn)</tt></li>
</ul>
<p>
This function will evaluate the conditions c1 to cn and return the 
current primary shape if at least one condition renders a non-empty result.
See <a href="#if_all">if_all</a> for an example how to use the if_... functions.
</p>
<a name="if_none"/><h2>"if_none" - Evaluates to the primary shape when all of the condition expression results are empty</h2>
<keyword name="if_none"/>
<p>Usage:</p>
<ul>
<li><tt>if_none(c1, ... cn)</tt></li>
</ul>
<p>
This function will evaluate the conditions c1 to cn and return the 
current primary shape if all conditions renders an empty result.
See <a href="#if_all">if_all</a> for an example how to use the if_... functions.
</p>
<a name="info"/><h2>"info" - Outputs as message to the logger or progress window</h2>
<keyword name="info"/>
<p>Usage:</p>
<ul>
<li><tt>info(message)</tt></li>
<li><tt>info(message, indent)</tt></li>
</ul>
<p>
Prints the message to the log window in verbose mode.
In non-verbose more, nothing is printed but a statement is put into the progress window.
<a href="#log">log</a> is a function that always prints a message.
</p>
<a name="input"/><h2>"input" - Fetches the shapes from the specified input from the default source</h2>
<keyword name="input"/>
<p>Usage:</p>
<ul>
<li><tt>input(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#input">Source#input</a> for a description of that function. This method will fetch
polygons and labels. See <a href="#polygons">polygons</a> and <a href="#labels">labels</a> for more specific versions of
this method.
</p>
<a name="inside"/><h2>"inside" - Selects shapes entirely inside other shapes</h2>
<keyword name="inside"/>
<p>Usage:</p>
<ul>
<li><tt>inside(other)</tt></li>
</ul>
<p>
This operator represents the selector of primary shapes
which are inside shapes from the other layer. 
Use this operator within <a href="/about/drc_ref_drc.xml">DRC</a> expressions (also see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>). If can be used
as method to an expression. See there for more details: <a href="/about/drc_ref_drc.xml#inside">DRC#inside</a>.
</p>
<a name="interacting"/><h2>"interacting" - Selects shapes interacting with other shapes</h2>
<keyword name="interacting"/>
<p>Usage:</p>
<ul>
<li><tt>interacting(other) (optionally in condition)</tt></li>
</ul>
<p>
This operator represents the selector of primary shapes
which interact with shapes from the other layer. This version can be put into
a condition indicating how many shapes of the other layer need to be covered.
Use this operator within <a href="/about/drc_ref_drc.xml">DRC</a> expressions (also see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>). If can be used
as method to an expression. See there for more details: <a href="/about/drc_ref_drc.xml#interacting">DRC#interacting</a>.
</p>
<a name="is_deep?"/><h2>"is_deep?" - Returns true, if in deep mode</h2>
<keyword name="is_deep?"/>
<p>Usage:</p>
<ul>
<li><tt>is_deep?</tt></li>
</ul>
<a name="is_tiled?"/><h2>"is_tiled?" - Returns true, if in tiled mode</h2>
<keyword name="is_tiled?"/>
<p>Usage:</p>
<ul>
<li><tt>is_tiled?</tt></li>
</ul>
<a name="iso"/><h2>"iso" - Synonym for "isolated"</h2>
<keyword name="iso"/>
<p>Usage:</p>
<ul>
<li><tt>iso(...)</tt></li>
</ul>
<p>
"iso" is the short form for <a href="#isolated">isolated</a>.
</p>
<a name="isolated"/><h2>"isolated" - Performs an isolation (inter-polygon space) check</h2>
<keyword name="isolated"/>
<p>Usage:</p>
<ul>
<li><tt>isolated([ options ]) (in conditions)</tt></li>
<li><tt>iso([ options ]) (in conditions)</tt></li>
<li><tt>isolated(layer [, options ])</tt></li>
<li><tt>iso(layer [, options ])</tt></li>
</ul>
<p>
Provides a intra-polygon space check for polygons. It is similar to
<a href="#space">space</a>, but checks inter-polygon space only. "iso" is a synonym for "isolated".
This check has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc. This check also features
opposite and rectangle filtering. See <a href="/about/drc_ref_layer.xml#separation">Layer#separation</a> for details about opposite and
rectangle error filtering.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.isolated" (see <a href="/about/drc_ref_layer.xml#isolated">Layer#isolated</a>). 
</p><p>
<pre>
# classic "isolated" check for space &lt; 1.2 um
in = layer(1, 0)
errors = isolated(in, 1.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#isolated">Layer#isolated</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC "isolated" check for space &lt; 1.2.um
in = layer(1, 0)
errors = in.drc(isolated &lt; 1.2.um)
</pre>
</p><p>
See <a href="#enclosing">enclosing</a> for more details about the various ways to specify conditions.
</p><p>
<table>
<tr>
<td><img src="/images/drc_space3u.png"/></td>
</tr>
</table>
</p>
<a name="l2n_data"/><h2>"l2n_data" - Gets the internal <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object for the default <a href="/about/drc_ref_netter.xml">Netter</a></h2>
<keyword name="l2n_data"/>
<p>Usage:</p>
<ul>
<li><tt>l2n_data</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml#l2n_data">Netter#l2n_data</a> for a description of that function.
</p>
<a name="labels"/><h2>"labels" - Gets the labels (text) from an original layer</h2>
<keyword name="labels"/>
<p>Usage:</p>
<ul>
<li><tt>labels(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#labels">Source#labels</a> for a description of that function.
</p>
<a name="layers"/><h2>"layers" - Gets the layers contained in the default source</h2>
<keyword name="layers"/>
<p>Usage:</p>
<ul>
<li><tt>layers</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#layers">Source#layers</a> for a description of that function.
</p>
<a name="layout"/><h2>"layout" - Specifies an additional layout for the input source.</h2>
<keyword name="layout"/>
<p>Usage:</p>
<ul>
<li><tt>layout</tt></li>
<li><tt>layout(what)</tt></li>
</ul>
<p>
This function can be used to specify a new layout for input.
It returns an Source object representing that layout. The "input" method
of that object can be used to get input layers for that layout.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" specifying input from a cellview in the current view </li>
<li>A layout filename plus an optional cell name </li>
<li>A <class_doc href="Layout">Layout</class_doc> object </li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Without any arguments the default layout is returned.
</p><p>
If a file name is given, a cell name can be specified as the second argument.
If not, the top cell is taken which must be unique in that case.
</p><p>
Having specified a layout for input enables to use the input method
for getting input:
</p><p>
<pre>
# XOR between layers 1 or the default input and "second_layout.gds":
l2 = layout("second_layout.gds")
(input(1, 0) ^ l2.input(1, 0)).output(100, 0)
</pre>
</p><p>
For further methods on the source object see <a href="/about/drc_ref_source.xml">Source</a>.
</p>
<a name="length (in condition)"/><h2>"length (in condition)" - Computes the total edge length of an edge layer or in universal DRC context: selects edges based on a length condition</h2>
<keyword name="length (in condition)"/>
<p>Usage:</p>
<ul>
<li><tt>length (in condition)</tt></li>
<li><tt>length(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.length" (see <a href="/about/drc_ref_layer.xml#length">Layer#length</a>). Without a layer
argument, "length" represents the edge length filter on the primary shape edges in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#length">DRC#length</a> for more details). In this context,
the operation acts similar to <a href="/about/drc_ref_layer.xml#with_length">Layer#with_length</a>.
</p>
<a name="log"/><h2>"log" - Outputs as message to the logger window</h2>
<keyword name="log"/>
<p>Usage:</p>
<ul>
<li><tt>log(message)</tt></li>
<li><tt>log(message, indent)</tt></li>
</ul>
<p>
Prints the message to the log window.
<a href="#info">info</a> is a function that prints a message only if 
verbose mode is enabled.
</p>
<a name="log_file"/><h2>"log_file" - Specify the log file where to send to log to</h2>
<keyword name="log_file"/>
<p>Usage:</p>
<ul>
<li><tt>log_file(filename)</tt></li>
</ul>
<p>
After using that method, the log output is sent to the 
given file instead of the logger window or the terminal.
</p>
<a name="make_layer"/><h2>"make_layer" - Creates an empty polygon layer based on the hierarchical scheme selected</h2>
<keyword name="make_layer"/>
<p>Usage:</p>
<ul>
<li><tt>make_layer</tt></li>
</ul>
<p>
The intention of this method is to provide an empty polygon layer based on the
hierarchical scheme selected. This will create a new layer with the hierarchy
of the current layout in deep mode and a flat layer in flat mode.
This method is similar to <a href="#polygon_layer">polygon_layer</a>, but the latter does not create
a hierarchical layer. Hence the layer created by <a href="#make_layer">make_layer</a> is suitable
for use in device extraction for example, while the one
delivered by <a href="#polygon_layer">polygon_layer</a> is not.
</p><p>
On the other hand, a layer created by the <a href="#make_layer">make_layer</a> method is not intended to be
filled with <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
</p>
<a name="max_area_ratio"/><h2>"max_area_ratio" - Gets or sets the maximum bounding box to polygon area ratio for deep mode fragmentation</h2>
<keyword name="max_area_ratio"/>
<p>Usage:</p>
<ul>
<li><tt>max_area_ratio(ratio)</tt></li>
<li><tt>max_area_ratio</tt></li>
</ul>
<p>
In deep mode, polygons with a bounding box to polygon area ratio bigger than the given number
will be split into smaller chunks to optimize performance (which gets better if the polygon's
bounding boxes do not cover a lot of empty space).
The default threshold is 3.0 which means fairly compact polygons. Use this method with a numeric 
argument to set the value and without an argument to get the current maximum area ratio.
Set the value to zero to disable splitting by area ratio.
</p><p>
See also <a href="#max_vertex_count">max_vertex_count</a> for the other option affecting polygon splitting.
</p>
<a name="max_vertex_count"/><h2>"max_vertex_count" - Gets or sets the maximum vertex count for deep mode fragmentation</h2>
<keyword name="max_vertex_count"/>
<p>Usage:</p>
<ul>
<li><tt>max_vertex_count(count)</tt></li>
<li><tt>max_vertex_count</tt></li>
</ul>
<p>
In deep mode, polygons with more than the given number of vertexes will be split into
smaller chunks to optimize performance (which is better or less complex polygons).
The default threshold is 16 vertexes. Use this method with a vertex count to set the
value and without an argument to get the current maximum vertex count.
Set the value to zero to disable splitting by vertex count.
</p><p>
See also <a href="#max_area_ratio">max_area_ratio</a> for the other option affecting polygon splitting.
</p>
<a name="middle"/><h2>"middle" - Returns the centers of polygon bounding boxes</h2>
<keyword name="middle"/>
<p>Usage:</p>
<ul>
<li><tt>middle([ options ])</tt></li>
<li><tt>middle(layer, [ options ])</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.middle" (see <a href="/about/drc_ref_layer.xml#middle">Layer#middle</a>). Without a layer
argument, "middle" represents the bounding box center marker generator on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#middle">DRC#middle</a> for more details).
</p>
<a name="mos3"/><h2>"mos3" - Supplies the MOS3 transistor extractor class</h2>
<keyword name="mos3"/>
<p>Usage:</p>
<ul>
<li><tt>mos3(name)</tt></li>
<li><tt>mos3(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
three-terminal MOS transistor.
</p><p>
See <class_doc href="DeviceExtractorMOS3Transistor">DeviceExtractorMOS3Transistor</class_doc> for more details
about this extractor (non-strict mode applies for 'mos3').
</p>
<a name="mos4"/><h2>"mos4" - Supplies the MOS4 transistor extractor class</h2>
<keyword name="mos4"/>
<p>Usage:</p>
<ul>
<li><tt>mos4(name)</tt></li>
<li><tt>mos4(name, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a 
four-terminal MOS transistor.
</p><p>
See <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc> for more details
about this extractor (non-strict mode applies for 'mos4').
</p>
<a name="netlist"/><h2>"netlist" - Obtains the extracted netlist from the default <a href="/about/drc_ref_netter.xml">Netter</a></h2>
<keyword name="netlist"/>
<p>
The netlist is a <class_doc href="Netlist">Netlist</class_doc> object. If no netlist is extracted 
yet, this method will trigger the extraction process.
See <a href="/about/drc_ref_netter.xml#netlist">Netter#netlist</a> for a description of this function.
</p>
<a name="netter"/><h2>"netter" - Creates a new netter object</h2>
<keyword name="netter"/>
<p>Usage:</p>
<ul>
<li><tt>netter</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_netter.xml">Netter</a> for more details
</p>
<a name="no_borders"/><h2>"no_borders" - Reset the tile borders</h2>
<keyword name="no_borders"/>
<p>Usage:</p>
<ul>
<li><tt>no_borders</tt></li>
</ul>
<p>
Resets the tile borders - see <a href="#tile_borders">tile_borders</a> for a description of tile borders.
</p>
<a name="notch"/><h2>"notch" - Performs a notch (intra-polygon space) check</h2>
<keyword name="notch"/>
<p>Usage:</p>
<ul>
<li><tt>notch([ options ]) (in conditions)</tt></li>
<li><tt>notch(layer [, options ])</tt></li>
</ul>
<p>
Provides a intra-polygon space check for polygons. It is similar to
<a href="#space">space</a>, but checks intra-polygon space only.
It has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.notch" (see <a href="/about/drc_ref_layer.xml#notch">Layer#notch</a>). 
</p><p>
<pre>
# classic "notch" check for space &lt; 1.2 um
in = layer(1, 0)
errors = notch(in, 1.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#notch">Layer#notch</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC "notch" check for space &lt; 1.2.um
in = layer(1, 0)
errors = in.drc(notch &lt; 1.2.um)
</pre>
</p><p>
See <a href="#enclosing">enclosing</a> for more details about the various ways to specify conditions.
</p><p>
<table>
<tr>
<td><img src="/images/drc_space2u.png"/></td>
</tr>
</table>
</p>
<a name="output"/><h2>"output" - Outputs a layer to the report database or output layout</h2>
<keyword name="output"/>
<p>Usage:</p>
<ul>
<li><tt>output(layer, args)</tt></li>
</ul>
<p>
This function is equivalent to "layer.output(args)". See <a href="/about/drc_ref_layer.xml#output">Layer#output</a> for details about this function.
</p>
<a name="output_cell"/><h2>"output_cell" - Specifies a target cell, but does not change the target layout</h2>
<keyword name="output_cell"/>
<p>Usage:</p>
<ul>
<li><tt>output_cell(cellname)</tt></li>
</ul>
<p>
This method switches output to the specified cell, but does not
change the target layout nor does it switch the output channel to
layout if is report database. 
</p>
<a name="outside"/><h2>"outside" - Selects shapes entirely outside other shapes</h2>
<keyword name="outside"/>
<p>Usage:</p>
<ul>
<li><tt>outside(other)</tt></li>
</ul>
<p>
This operator represents the selector of primary shapes
which are outside shapes from the other layer. 
Use this operator within <a href="/about/drc_ref_drc.xml">DRC</a> expressions (also see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>). If can be used
as method to an expression. See there for more details: <a href="/about/drc_ref_drc.xml#outside">DRC#outside</a>.
</p>
<a name="overlap"/><h2>"overlap" - Performs an overlap check</h2>
<keyword name="overlap"/>
<p>Usage:</p>
<ul>
<li><tt>overlap(other [, options ]) (in conditions)</tt></li>
<li><tt>overlap(layer, other [, options ])</tt></li>
</ul>
<p>
Provides an overlap check (primary layer vs. another layer). 
This check has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc. This check also features
opposite and rectangle filtering. See <a href="/about/drc_ref_layer.xml#separation">Layer#separation</a> for details about opposite and
rectangle error filtering.
</p><p>
<h3>Classic mode </h3>
</p><p>
Like other checks, this function is available as a classic DRC function with a layer as the first
argument and as an <a href="/about/drc_ref_drc.xml">DRC</a> expression operator for use with <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>.
</p><p>
<pre>
# classic "overlap" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = overlap(in, other, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
For use with the "unversal DRC" put the separation expression into the "drc"
function call and use a condition to specify the constraint:
</p><p>
<pre>
# universal DRC "overlap" check for &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = in.drc(overlap(other) &lt; 0.2.um)
</pre>
</p><p>
<table>
<tr>
<td><img src="/images/drc_overlap1u.png"/></td>
<td><img src="/images/drc_overlap2u.png"/></td>
</tr>
</table>
</p><p>
When "larger than" constraints are used, this function will produce the edges from the
first layer only. The result will still be edge pairs for consistency, but each edge pair holds one edge from
the original polygon plus a reverse copy of that edge in the second member. Use "first_edges" to extract the 
actual edges from the first input (see <a href="#separation">separation</a> for an example).
</p>
<a name="overlapping"/><h2>"overlapping" - Selects shapes overlapping with other shapes</h2>
<keyword name="overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>overlapping(other) (optionally in condition)</tt></li>
</ul>
<p>
This operator represents the selector of primary shapes
which overlap shapes from the other layer. This version can be put into
a condition indicating how many shapes of the other layer need to be covered.
Use this operator within <a href="/about/drc_ref_drc.xml">DRC</a> expressions (also see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>). If can be used
as method to an expression. See there for more details: <a href="/about/drc_ref_drc.xml#overlapping">DRC#overlapping</a>.
</p>
<a name="p"/><h2>"p" - Creates a point object</h2>
<keyword name="p"/>
<p>Usage:</p>
<ul>
<li><tt>p(x, y)</tt></li>
</ul>
<p>
A point is not a valid object by itself, but it is useful for creating 
paths for polygons:
</p><p>
<pre>
x = polygon_layer
x.insert(polygon([ p(0, 0), p(16.0, 0), p(8.0, 8.0) ]))
</pre>
</p>
<a name="path"/><h2>"path" - Creates a path object</h2>
<keyword name="path"/>
<p>Usage:</p>
<ul>
<li><tt>path(...)</tt></li>
</ul>
<p>
This function creates a path object. The arguments are the same than for the 
<class_doc href="DPath">DPath</class_doc> constructors.
</p>
<a name="perimeter"/><h2>"perimeter" - Computes the total perimeter or in universal DRC context: selects the primary shape if the perimeter is meeting the condition</h2>
<keyword name="perimeter"/>
<p>Usage:</p>
<ul>
<li><tt>perimeter (in condition)</tt></li>
<li><tt>perimeter(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.perimeter" (see <a href="/about/drc_ref_layer.xml#perimeter">Layer#perimeter</a>) and returns the
total perimeter of all polygons in the layer.
</p><p>
Without a layer argument, "perimeter" represents a perimeter filter for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#perimeter">DRC#perimeter</a> for more details).
</p>
<a name="polygon"/><h2>"polygon" - Creates a polygon object</h2>
<keyword name="polygon"/>
<p>Usage:</p>
<ul>
<li><tt>polygon(...)</tt></li>
</ul>
<p>
This function creates a polygon object. The arguments are the same than for the 
<class_doc href="DPolygon">DPolygon</class_doc> constructors.
</p>
<a name="polygon_layer"/><h2>"polygon_layer" - Creates an empty polygon layer</h2>
<keyword name="polygon_layer"/>
<p>Usage:</p>
<ul>
<li><tt>polygon_layer</tt></li>
</ul>
<p>
The intention of that method is to create an empty layer which can be 
filled with polygon-like objects using <a href="/about/drc_ref_layer.xml#insert">Layer#insert</a>.
A similar method which creates a hierarchical layer in deep mode is 
<a href="#make_layer">make_layer</a>. This other layer is better suited for use with device extraction.
</p>
<a name="polygons"/><h2>"polygons" - Fetches the polygons (or shapes that can be converted to polygons) from the specified input from the default source</h2>
<keyword name="polygons"/>
<p>Usage:</p>
<ul>
<li><tt>polygons(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#polygons">Source#polygons</a> for a description of that function.
</p>
<a name="primary"/><h2>"primary" - Represents the primary input of the universal DRC function</h2>
<keyword name="primary"/>
<p>Usage:</p>
<ul>
<li><tt>primary</tt></li>
</ul>
<p>
The primary input of the universal DRC function is the layer the <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> function
is called on.
</p>
<a name="rectangles"/><h2>"rectangles" - Selects all polygons which are rectangles</h2>
<keyword name="rectangles"/>
<p>Usage:</p>
<ul>
<li><tt>rectangles</tt></li>
<li><tt>rectangles(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.rectangles" (see <a href="/about/drc_ref_layer.xml#rectangles">Layer#rectangles</a>). Without a layer
argument, "rectangles" represents the rectangles filter for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#rectangles">DRC#rectangles</a> for more details).
</p>
<a name="rectilinear"/><h2>"rectilinear" - Selects all polygons which are rectilinear</h2>
<keyword name="rectilinear"/>
<p>Usage:</p>
<ul>
<li><tt>rectilinear</tt></li>
<li><tt>rectilinear(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.rectilinear" (see <a href="/about/drc_ref_layer.xml#rectilinear">Layer#rectilinear</a>). Without a layer
argument, "rectilinear" represents the rectilinear polygons filter for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#rectilinear">DRC#rectilinear</a> for more details).
</p>
<a name="region_overlap"/><h2>"region_overlap" - Specifies region selected input in "overlap mode"</h2>
<keyword name="region_overlap"/>
<p>Usage:</p>
<ul>
<li><tt>region_overlap(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#overlapping">Source#overlapping</a> for a description of that function.
</p><p>
The following code will select shapes overlapping a 500x600 micron rectangle (lower left corner at 0,0) 
from the input layout. The shapes will not be clipped:
</p><p>
<pre>
region_overlapping(0.mm, 0.mm, 0.5.mm, 0.6.mm)
# shapes will now be the ones overlapping the rectangular region
l1 = input(1, 0)
</pre>
</p><p>
To remove this condition, call "region_overlapping" without any arguments.
</p>
<a name="region_touch"/><h2>"region_touch" - Specifies region selected input in "touch mode"</h2>
<keyword name="region_touch"/>
<p>Usage:</p>
<ul>
<li><tt>region_touch(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#touching">Source#touching</a> for a description of that function.
</p><p>
The following code will select shapes touching a 500x600 micron rectangle (lower left corner at 0,0) 
from the input layout. The shapes will not be clipped:
</p><p>
<pre>
region_touch(0.mm, 0.mm, 0.5.mm, 0.6.mm)
# shapes will now be the ones touching the rectangular region
l1 = input(1, 0)
</pre>
</p><p>
To remove this condition, call "region_touch" without any arguments.
</p>
<a name="relative_height"/><h2>"relative_height" - Selects primary shapes based on the ratio of height and width of their bounding boxes</h2>
<keyword name="relative_height"/>
<p>Usage:</p>
<ul>
<li><tt>relative_height (in condition)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>, <a href="#relative_height">relative_height</a> and <a href="/about/drc_ref_drc.xml#relative_height">DRC#relative_height</a> for more details.
</p>
<a name="report"/><h2>"report" - Specifies a report database for output</h2>
<keyword name="report"/>
<p>Usage:</p>
<ul>
<li><tt>report(description [, filename [, cellname ] ])</tt></li>
</ul>
<p>
After specifying a report database for output, <a href="#output">output</a> method calls are redirected to
the report database. The format of the <a href="#output">output</a> calls changes and a category name plus
description can be specified rather than a layer/datatype number of layer name.
See the description of the output method for details.
</p><p>
If a filename is given, the report database will be written to the specified file name.
Otherwise it will be shown but not written.
</p><p>
If external input is specified with <a href="#source">source</a>, 
"report" must be called after "source".
</p><p>
The cellname specifies the top cell used for the report file.
By default this is the cell name of the default source. If there
is no source layout you'll need to give the cell name in the 
third parameter.
</p>
<a name="report_netlist"/><h2>"report_netlist" - Specifies an extracted netlist report for output</h2>
<keyword name="report_netlist"/>
<p>Usage:</p>
<ul>
<li><tt>report_netlist([ filename [, long ] ])</tt></li>
</ul>
<p>
This method applies to runsets creating a netlist through
extraction. Extraction happens when connections and/or device
extractions are made. If this statement is used, the extracted
netlist plus the net and device shapes are turned into a 
layout-to-netlist report (L2N database) and shown in the 
netlist browser window. If a file name is given, the report
will also be written to the given file.
If a file name is given and "long" is true, a verbose 
version of the L2N DB format will be used.
</p>
<a name="resistor"/><h2>"resistor" - Supplies the resistor extractor class</h2>
<keyword name="resistor"/>
<p>Usage:</p>
<ul>
<li><tt>resistor(name, sheet_rho)</tt></li>
<li><tt>resistor(name, sheet_rho, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a resistor.
</p><p>
The sheet_rho value is the sheet resistance in ohms/square. It is used
to compute the resistance from the geometry.
</p><p>
See <class_doc href="DeviceExtractorResistor">DeviceExtractorResistor</class_doc> for more details
about this extractor.
</p>
<a name="resistor_with_bulk"/><h2>"resistor_with_bulk" - Supplies the resistor extractor class that includes a bulk terminal</h2>
<keyword name="resistor_with_bulk"/>
<p>Usage:</p>
<ul>
<li><tt>resistor_with_bulk(name, sheet_rho)</tt></li>
<li><tt>resistor_with_bulk(name, sheet_rho, class)</tt></li>
</ul>
<p>
Use this class with <a href="#extract_devices">extract_devices</a> to specify extraction of a resistor 
with a bulk terminal.
The sheet_rho value is the sheet resistance in ohms/square.
</p><p>
See <class_doc href="DeviceExtractorResistorWithBulk">DeviceExtractorResistorWithBulk</class_doc> for more details
about this extractor.
</p>
<a name="rounded_corners"/><h2>"rounded_corners" - Applies corner rounding</h2>
<keyword name="rounded_corners"/>
<p>Usage:</p>
<ul>
<li><tt>rounded_corners(inner, outer, n)</tt></li>
<li><tt>rounded_corners(layer, inner, outer, n)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.rounded_corners" (see <a href="/about/drc_ref_layer.xml#rounded_corners">Layer#rounded_corners</a>). Without a layer
argument, "rounded_corners" represents the corner rounding algorithm on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#rounded_corners">DRC#rounded_corners</a> for more details).
</p>
<a name="secondary"/><h2>"secondary" - Provides secondary input for the "drc" universal DRC function</h2>
<keyword name="secondary"/>
<p>Usage:</p>
<ul>
<li><tt>secondary(layer)</tt></li>
</ul>
<p>
To supply additional input for the universal DRC expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>), use
"secondary" with a layer argument. This example provides a boolean AND
between l1 and l2:
</p><p>
<pre>
l1 = layer(1, 0)
l2 = layer(2, 0)
out = l1.drc(primary &amp; secondary(l2))
</pre>
</p>
<a name="select"/><h2>"select" - Specifies cell filters on the default source</h2>
<keyword name="select"/>
<p>Usage:</p>
<ul>
<li><tt>select(args)</tt></li>
</ul>
<p>
See <a href="/about/drc_ref_source.xml#select">Source#select</a> for a description of that function.
</p>
<a name="sep"/><h2>"sep" - Synonym for "separation"</h2>
<keyword name="sep"/>
<p>Usage:</p>
<ul>
<li><tt>sep(...)</tt></li>
</ul>
<p>
"sep" is the short form for <a href="#separation">separation</a>.
</p>
<a name="separation"/><h2>"separation" - Performs a separation check</h2>
<keyword name="separation"/>
<p>Usage:</p>
<ul>
<li><tt>separation(other [, options ]) (in conditions)</tt></li>
<li><tt>separation(layer, other [, options ])</tt></li>
</ul>
<p>
Provides a separation check (primary layer vs. another layer). Like <a href="#enclosing">enclosing</a> this 
function provides a two-layer check, but checking the distance rather than the 
overlap. 
This check has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc. This check also features
opposite and rectangle filtering. See <a href="/about/drc_ref_layer.xml#separation">Layer#separation</a> for details about opposite and
rectangle error filtering.
</p><p>
<h3>Classic mode </h3>
</p><p>
Like <a href="#enclosing">enclosing</a>, this function is available as a classic DRC function with a layer as the first
argument and as an <a href="/about/drc_ref_drc.xml">DRC</a> expression operator for use with <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>.
</p><p>
<pre>
# classic "separation" check for distance &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = separation(in, other, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
For use with the "universal DRC" put the separation expression into the "drc"
function call and use a condition to specify the constraint:
</p><p>
<pre>
# universal DRC "separation" check for distance &lt; 0.2 um
in = layer(1, 0)
other = layer(2, 0)
errors = in.drc(separation(other) &lt; 0.2.um)
</pre>
</p><p>
<a href="#enclosing">enclosing</a> explains the constraints and how the
work in generating error markers.
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation1u.png"/></td>
</tr>
</table>
</p><p>
When "larger than" constraints are used, this function will produce the edges from the
first layer only. The result will still be edge pairs for consistency, but each edge pair holds one edge from
the original polygon plus a reverse copy of that edge in the second member. Use "first_edges" to extract the 
actual edges from the first input:
</p><p>
<pre>
l1_edges_without_l2 = l1.drc((separation(l2) &gt;= 1.0).first_edges)
</pre>
</p><p>
The following image shows the effect of such a negative-output separation check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation1un.png"/></td>
</tr>
</table>
</p>
<a name="silent"/><h2>"silent" - Resets verbose mode</h2>
<keyword name="silent"/>
<p>Usage:</p>
<ul>
<li><tt>silent</tt></li>
</ul>
<p>
This function is equivalent to "verbose(false)" (see <a href="#verbose">verbose</a>)
</p>
<a name="sized"/><h2>"sized" - Returns the sized version of the input</h2>
<keyword name="sized"/>
<p>Usage:</p>
<ul>
<li><tt>sized(d [, mode])</tt></li>
<li><tt>sized(dx, dy [, mode]))</tt></li>
<li><tt>sized(layer, d [, mode])</tt></li>
<li><tt>sized(layer, dx, dy [, mode]))</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.sized" (see <a href="/about/drc_ref_layer.xml#sized">Layer#sized</a>). Without a layer
argument, "sized" represents the polygon sizer on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#sized">DRC#sized</a> for more details).
</p>
<a name="smoothed"/><h2>"smoothed" - Applies smoothing</h2>
<keyword name="smoothed"/>
<p>Usage:</p>
<ul>
<li><tt>smoothed(d)</tt></li>
<li><tt>smoothed(layer, d)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.smoothed" (see <a href="/about/drc_ref_layer.xml#smoothed">Layer#smoothed</a>). Without a layer
argument, "smoothed" represents the polygon smoother on primary shapes within
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#smoothed">DRC#smoothed</a> for more details).
</p>
<a name="source"/><h2>"source" - Specifies a source layout</h2>
<keyword name="source"/>
<p>Usage:</p>
<ul>
<li><tt>source</tt></li>
<li><tt>source(what)</tt></li>
</ul>
<p>
This function replaces the default source layout by the specified
file. If this function is not used, the currently active layout 
is used as input. 
</p><p>
<a href="#layout">layout</a> is a similar method which specifies <i>an additional </i>input layout.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" specifying input from a layout in the current panel </li>
<li>A layout filename plus an optional cell name</li>
<li>A <class_doc href="Layout">Layout</class_doc> object plus an optional cell name</li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Without any arguments the default layout is returned. If a filename is given, a cell name
can be specified as the second argument. If none is specified, the top cell is taken which
must be unique in that case.
</p><p>
<pre>
# XOR between layers 1 of "first_layout.gds" and "second_layout.gds" and sends the results to "xor_layout.gds":
target("xor_layout.gds")
source("first_layout.gds")
l2 = layout("second_layout.gds")
(input(1, 0) ^ l2.input(1, 0)).output(100, 0)
</pre>
</p><p>
For further methods on the source object see <a href="/about/drc_ref_source.xml">Source</a>.
</p>
<a name="space"/><h2>"space" - Performs a space check</h2>
<keyword name="space"/>
<p>Usage:</p>
<ul>
<li><tt>space([ options ]) (in conditions)</tt></li>
<li><tt>space(layer [, options ])</tt></li>
</ul>
<p>
"space" looks for spacing violations between edges of the same polygon (intra-polygon checks)
and between different polygons (inter-polygon checks).
<a href="#notch">notch</a> is similar function that provides only intra-polygon space checks. <a href="#isolated">isolated</a>
is the version checking inter-polygon distance only.
The check has manifold options. See <a href="/about/drc_ref_layer.xml#width">Layer#width</a> for the basic options such
as metrics, projection and angle constraints etc.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.space" (see <a href="/about/drc_ref_layer.xml#space">Layer#space</a>). In this mode, "space" is applicable to edge 
layers too. 
</p><p>
<pre>
# classic "space" check for space &lt; 0.2 um
in = layer(1, 0)
errors = space(in, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#space">Layer#space</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC check for space &lt; 0.2.um
in = layer(1, 0)
errors = in.drc(space &lt; 0.2.um)
</pre>
</p><p>
See <a href="#enclosing">enclosing</a> for more details about the various ways to specify conditions.
</p><p>
<table>
<tr>
<td><img src="/images/drc_space1u.png"/></td>
</tr>
</table>
</p>
<a name="squares"/><h2>"squares" - Selects all polygons which are squares</h2>
<keyword name="squares"/>
<p>Usage:</p>
<ul>
<li><tt>squares</tt></li>
<li><tt>squares(layer)</tt></li>
</ul>
<p>
This function can be used with a layer argument. In this case it
is equivalent to "layer.squares" (see <a href="/about/drc_ref_layer.xml#squares">Layer#squares</a>). Without a layer
argument, "squares" represents the rectangles filter for primary shapes in 
<a href="/about/drc_ref_drc.xml">DRC</a> expressions (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#squares">DRC#squares</a> for more details).
</p>
<a name="switch"/><h2>"switch" - A conditional selector for the "drc" universal DRC function</h2>
<keyword name="switch"/>
<p>Usage:</p>
<ul>
<li><tt>switch(...)</tt></li>
</ul>
<p>
This function provides a conditional selector for the "drc" function.
It is used this way:
</p><p>
<pre>
out = in.drc(switch(c1, r1, c2, r2, ..., cn, rn)
out = in.drc(switch(c1, r1, c2, r2, ..., cn, rn, rdef)
</pre>
</p><p>
This function will evaluate c1 which is a universal DRC expression (see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>).
If the result is not empty, "switch" will evaluate and return r1. Otherwise it
will continue with c2 and the result of this expression is not empty it will
return r2. Otherwise it will continue with c3/r3 etc. 
</p><p>
If an odd number of arguments is given, the last expression is evaluated if
none of the conditions c1..cn gives a non-empty result.
</p><p>
As a requirement, the result types of all r1..rn expressions and the rdef
needs to be the same - i.e. all need to render polygons or edges or edge pairs.
</p>
<a name="target"/><h2>"target" - Specify the target layout</h2>
<keyword name="target"/>
<p>Usage:</p>
<ul>
<li><tt>target(what [, cellname])</tt></li>
</ul>
<p>
This function can be used to specify a target layout for output.
Subsequent calls of "output" will send their results to that target
layout. Using "target" will disable output to a report database.
If any target was specified before, that target will be closed and 
a new target will be set up.
</p><p>
"what" specifies what input to use. "what" be either
</p><p>
<ul>
<li>A string "@n" (n is an integer) specifying output to a layout in the current panel </li>
<li>A string "@+" specifying output to a new layout in the current panel </li>
<li>A layout filename </li>
<li>A <class_doc href="Layout">Layout</class_doc> object </li>
<li>A <class_doc href="Cell">Cell</class_doc> object </li>
</ul>
</p><p>
Except if the argument is a <class_doc href="Cell">Cell</class_doc> object, a cellname can be specified 
stating the cell name under which the results are saved. If no cellname is 
specified, either the current cell or "TOP" is used.
</p>
<a name="target_netlist"/><h2>"target_netlist" - With this statement, an extracted netlist is finally written to a file</h2>
<keyword name="target_netlist"/>
<p>Usage:</p>
<ul>
<li><tt>target_netlist(filename [, format [, comment ] ])</tt></li>
</ul>
<p>
This method applies to runsets creating a netlist through
extraction. Extraction happens when connections and/or device
extractions are made. If this statement is used, the extracted
netlist is written to the given file.
</p><p>
The format parameter specifies the writer to use. You can use nil
to use the standard format or produce a SPICE writer with <a href="#write_spice">write_spice</a>.
See <a href="#write_spice">write_spice</a> for more details.
</p>
<a name="threads"/><h2>"threads" - Specifies the number of CPU cores to use in tiling mode</h2>
<keyword name="threads"/>
<p>Usage:</p>
<ul>
<li><tt>threads(n)</tt></li>
<li><tt>threads</tt></li>
</ul>
<p>
If using threads, tiles are distributed on multiple CPU cores for
parallelization. Still, all tiles must be processed before the 
operation proceeds with the next statement. 
</p><p>
Without an argument, "threads" will return the current number of 
threads
</p>
<a name="tile_borders"/><h2>"tile_borders" - Specifies a minimum tile border</h2>
<keyword name="tile_borders"/>
<p>Usage:</p>
<ul>
<li><tt>tile_borders(b)</tt></li>
<li><tt>tile_borders(bx, by)</tt></li>
</ul>
<p>
The tile border specifies the distance to which shapes are collected into the 
tile. In order words, when processing a tile, shapes within the border distance
participate in the operations.
</p><p>
For some operations such as booleans (<a href="#and">and</a>, <a href="#or">or</a>, ...), <a href="#size">size</a> and the DRC functions (<a href="#width">width</a>, <a href="#space">space</a>, ...)
a tile border is automatically established. For other operations such as <a href="#with_area">with_area</a>
or <a href="#edges">edges</a>, the exact distance is unknown, because such operations may have a long range.
In that cases, no border is used. The tile_borders function may be used to specify a minimum border
which is used in that case. That allows taking into account at least shapes within the 
given range, although not necessarily all.
</p><p>
To reset the tile borders, use <a href="#no_borders">no_borders</a> or "tile_borders(nil)".
</p>
<a name="tiles"/><h2>"tiles" - Specifies tiling</h2>
<keyword name="tiles"/>
<p>Usage:</p>
<ul>
<li><tt>tiles(t)</tt></li>
<li><tt>tiles(w, h)</tt></li>
</ul>
<p>
Specifies tiling mode. In tiling mode, the DRC operations are evaluated in tiles
with width w and height h. With one argument, square tiles with width and height
t are used.
</p><p>
Special care must be taken when using tiling mode, since some operations may not
behave as expected at the borders of the tile. Tiles can be made overlapping by
specifying a tile border dimension with <a href="#tile_borders">tile_borders</a>. Some operations like sizing,
the DRC functions specify a tile border implicitly. Other operations without a
defined range won't do so and the consequences of tiling mode can be difficult to
predict.
</p><p>
In tiling mode, the memory requirements are usually smaller (depending on the 
choice of the tile size) and multi-CPU support is enabled (see <a href="#threads">threads</a>).
To disable tiling mode use <a href="#flat">flat</a> or <a href="#deep">deep</a>. 
</p><p>
Tiling mode will disable deep mode (see <a href="#deep">deep</a>).
</p>
<a name="verbose"/><h2>"verbose" - Sets or resets verbose mode</h2>
<keyword name="verbose"/>
<p>Usage:</p>
<ul>
<li><tt>verbose</tt></li>
<li><tt>verbose(m)</tt></li>
</ul>
<p>
In verbose mode, more output is generated in the log file
</p>
<a name="verbose?"/><h2>"verbose?" - Returns true, if verbose mode is enabled</h2>
<keyword name="verbose?"/>
<p>Usage:</p>
<ul>
<li><tt>verbose?</tt></li>
</ul>
<p>
In verbose mode, more output is generated in the log file
</p>
<a name="warn"/><h2>"warn" - Prints a warning</h2>
<keyword name="warn"/>
<p>Usage:</p>
<ul>
<li><tt>warn(message)</tt></li>
</ul>
<p>
Similar to <a href="#log">log</a>, but the message is printed formatted as a warning
</p>
<a name="width"/><h2>"width" - Performs a width check</h2>
<keyword name="width"/>
<p>Usage:</p>
<ul>
<li><tt>width([ options ]) (in conditions)</tt></li>
<li><tt>width(layer [, options ])</tt></li>
</ul>
<p>
A width check is a check for the distance of edges of the same polygon.
</p><p>
<h3>Classic mode </h3>
</p><p>
This function can be used in classic mode with a layer argument. In this case it
is equivalent to "layer.width" (see <a href="/about/drc_ref_layer.xml#width">Layer#width</a>). 
</p><p>
<pre>
# classic "width" check for width &lt; 2 um
in = layer(1, 0)
errors = width(in, 0.2.um)
</pre>
</p><p>
<h3>Universal DRC </h3>
</p><p>
The version without a layer is intended for use within <a href="/about/drc_ref_drc.xml">DRC</a> expressions
together with the "universal DRC" method <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a>. In this case, this function needs to be 
put into a condition to specify the check constraints. The other options
of <a href="/about/drc_ref_layer.xml#width">Layer#width</a> (e.g. metrics, projection constraints, angle limits etc.)
apply to this version too:
</p><p>
<pre>
# universal DRC check for width &lt; 2 um
in = layer(1, 0)
errors = in.drc(width &lt; 0.2.um)
</pre>
</p><p>
The conditions may involve an upper and lower limit. The following examples
illustrate the use of this function with conditions:
</p><p>
<pre>
errors = in.drc(width &lt; 0.2.um)
errors = in.drc(width &lt;= 0.2.um)
errors = in.drc(width &gt; 0.2.um)
errors = in.drc(width &gt;= 0.2.um)
errors = in.drc(width == 0.2.um)
errors = in.drc(width != 0.2.um)
errors = in.drc(0.1.um &lt;= width &lt; 0.2.um)
</pre>
</p><p>
<table>
<tr>
<td><img src="/images/drc_width1u.png"/></td>
<td><img src="/images/drc_width2u.png"/></td>
</tr>
</table>
</p><p>
With a lower and upper limit or with the "equal" condition, the results are edges marking the positions on the 
primary shape where the condition is met.
With a lower limit alone, the results are edge pairs which are formed by two identical, but opposite edges attached to 
the primary shape. Without an upper limit only, both edges are attached to different sides of the primary
shape.
</p><p>
<table>
<tr>
<td><img src="/images/drc_width3u.png"/></td>
<td><img src="/images/drc_width4u.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_width5u.png"/></td>
<td><img src="/images/drc_width6u.png"/></td>
</tr>
</table>
</p>
<a name="with_holes"/><h2>"with_holes" - Selects all input polygons according to their number of holes in DRC expressions</h2>
<keyword name="with_holes"/>
<p>Usage:</p>
<ul>
<li><tt>with_holes (in condition)</tt></li>
</ul>
<p>
"with_holes" represents a polygon selector for
<a href="/about/drc_ref_drc.xml">DRC</a> expressions selecting polygons of the primary by their number of holes
(see <a href="/about/drc_ref_layer.xml#drc">Layer#drc</a> and <a href="/about/drc_ref_drc.xml#with_holes">DRC#with_holes</a> for more details).
</p>
<a name="write_spice"/><h2>"write_spice" - Defines SPICE output format (with options)</h2>
<keyword name="write_spice"/>
<p>Usage:</p>
<ul>
<li><tt>write_spice([ use_net_names [, with_comments ] ])</tt></li>
<li><tt>write_spice(writer_delegate [, use_net_names [, with_comments ] ])</tt></li>
</ul>
<p>
Use this option in <a href="#target_netlist">target_netlist</a> for the format parameter to 
specify SPICE format.
"use_net_names" and "with_comments" are boolean parameters indicating
whether to use named nets (numbers if false) and whether to add 
information comments such as instance coordinates or pin names.
</p><p>
"writer_delegate" allows using a <class_doc href="NetlistSpiceWriterDelegate">NetlistSpiceWriterDelegate</class_doc> object to 
control the actual writing.
</p>
</doc>
