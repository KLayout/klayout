<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Layer Object</title>
<keyword name="Layer"/>
<p>
The layer object represents a collection of polygons, edges or edge pairs.
</p>
<h2-index/>
<h2>"&amp;" - Boolean AND operation</h2>
<keyword name="&amp;"/>
<a name="&amp;"/><p>Usage:</p>
<ul>
<li><tt>self &amp; other</tt></li>
</ul>
<p>
The method computes a boolean AND between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#and">and</a>". See there for a description of the function.
</p>
<h2>"+" - Join layers</h2>
<keyword name="+"/>
<a name="+"/><p>Usage:</p>
<ul>
<li><tt>self + other</tt></li>
</ul>
<p>
The method includes the edges or polygons from the other layer into this layer.
The "+" operator is an alias for the <a href="#join">join</a> method.
</p><p>
This method is available for polygon, edge and edge pair layers. An alias
is "<a href="#join">join</a>". See there for a description of the function.
</p>
<h2>"-" - Boolean NOT operation</h2>
<keyword name="-"/>
<a name="-"/><p>Usage:</p>
<ul>
<li><tt>self - other</tt></li>
</ul>
<p>
The method computes a boolean NOT between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#not">not</a>". See there for a description of the function.
</p>
<h2>"^" - Boolean XOR operation</h2>
<keyword name="^"/>
<a name="^"/><p>Usage:</p>
<ul>
<li><tt>self ^ other</tt></li>
</ul>
<p>
The method computes a boolean XOR between self and other.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#xor">xor</a>". See there for a description of the function.
</p>
<h2>"and" - Boolean AND operation</h2>
<keyword name="and"/>
<a name="and"/><p>Usage:</p>
<ul>
<li><tt>layer.and(other)</tt></li>
</ul>
<p>
The method computes a boolean AND between self and other.
It is an alias for the "&amp;" operator.
</p><p>
This method is available for polygon and edge layers.
If the first operand is an edge layer and the second is a polygon layer, the
result will be the edges of the first operand which are inside or on the
borders of the polygons of the second operand.
</p><p>
The following images show the effect of the "and" method
on polygons and edges (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_and1.png"/></td>
<td><img src="/images/drc_and2.png"/></td>
<td><img src="/images/drc_and3.png"/></td>
</tr>
</table>
</p>
<h2>"area" - Returns the total area of the polygons in the region</h2>
<keyword name="area"/>
<a name="area"/><p>Usage:</p>
<ul>
<li><tt>layer.area</tt></li>
</ul>
<p>
This method requires a polygon layer. It returns the total
area of all polygons in square micron. Merged semantics applies, 
i.e. before computing the area, the polygons are merged unless
raw mode is chosen (see <a href="#raw">raw</a>). Hence, in clean mode, overlapping
polygons are not counted twice.
</p><p>
The returned value gives the area in square micrometer units.
</p>
<h2>"bbox" - Returns the overall bounding box of the layer</h2>
<keyword name="bbox"/>
<a name="bbox"/><p>Usage:</p>
<ul>
<li><tt>layer.bbox</tt></li>
</ul>
<p>
The return value is a <class_doc href="DBox">DBox</class_doc> object giving the bounding box in 
micrometer units. 
</p>
<h2>"centers" - Returns the center parts of the edges</h2>
<keyword name="centers"/>
<a name="centers"/><p>Usage:</p>
<ul>
<li><tt>layer.centers(length)</tt></li>
<li><tt>layer.centers(length, fraction)</tt></li>
</ul>
<p>
Similar to <a href="#start_segments">start_segments</a> and <a href="#end_segments">end_segments</a>, this method will return partial
edges for each given edge in the input. For the description of the parameters see
<a href="#start_segments">start_segments</a> or <a href="#end_segments">end_segments</a>.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_centers1.png"/></td>
<td><img src="/images/drc_centers2.png"/></td>
</tr>
</table>
</p>
<h2>"clean" - Marks a layer as clean</h2>
<keyword name="clean"/>
<a name="clean"/><p>Usage:</p>
<ul>
<li><tt>layer.clean</tt></li>
</ul>
<p>
A layer marked as clean will provide "merged" semantics, i.e.
overlapping or touching polygons are considered as single
polygons. Inner edges are removed and collinear edges are 
connected. 
Clean state is the default.
</p><p>
See <a href="#raw">raw</a> for some remarks about how this state is 
propagated.
</p>
<h2>"collect" - Transforms a layer</h2>
<keyword name="collect"/>
<a name="collect"/><p>Usage:</p>
<ul>
<li><tt>layer.collect { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block for each object in the layer and returns a new layer with the objects
returned from the block. It is available for edge, polygon and edge pair layers.
The corresponding objects are <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc>.
</p><p>
If the block evaluates to nil, no object is added to the output layer. If it returns an array, each of
the objects in the array is added.
The returned layer is of the original type and will only accept objects of the respective type. Hence,
for polygon layers, <class_doc href="DPolygon">DPolygon</class_doc> objects need to be returned. For edge layers those need to be <class_doc href="DEdge">DEdge</class_doc>
and for edge pair layers, they need to be <class_doc href="DEdgePair">DEdgePair</class_doc> objects. For convenience, <class_doc href="Polygon">Polygon</class_doc>, <class_doc href="Edge">Edge</class_doc>
and <class_doc href="EdgePair">EdgePair</class_doc> objects are accepted too and are scaled by the database unit to render micrometer-unit
objects. <class_doc href="Region">Region</class_doc>, <class_doc href="Edges">Edges</class_doc> and <class_doc href="EdgePair">EdgePair</class_doc> objects are accepted as well and the corresponding 
content of that collections is inserted into the output layer.
</p><p>
Other versions are available that allow translation of objects into other types (<a href="#collect_to_polygons">collect_to_polygons</a>, 
<a href="#collect_to_edges">collect_to_edges</a> and <a href="#collect_to_edge_pairs">collect_to_edge_pairs</a>).
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p><p>
Here is a slow equivalent of the rotated method
</p><p>
<pre>
# Rotates by 45 degree
t = <class_doc href="DCplxTrans">DCplxTrans</class_doc>(1.0, 45.0, false, <class_doc href="DVector">DVector</class_doc>::new)
new_layer = layer.collect { |polygon| polygon.transformed(t) }
</pre>
</p>
<h2>"collect_to_edge_pairs" - Transforms a layer into edge pair objects</h2>
<keyword name="collect_to_edge_pairs"/>
<a name="collect_to_edge_pairs"/><p>Usage:</p>
<ul>
<li><tt>layer.collect { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates an edge pair layer. It expects the block to 
deliver <class_doc href="EdgePair">EdgePair</class_doc>, <class_doc href="DEdgePair">DEdgePair</class_doc> or <class_doc href="EdgePairs">EdgePairs</class_doc> objects.
</p>
<h2>"collect_to_edges" - Transforms a layer into edge objects</h2>
<keyword name="collect_to_edges"/>
<a name="collect_to_edges"/><p>Usage:</p>
<ul>
<li><tt>layer.collect { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates an edge layer. It expects the block to 
deliver objects that can be converted into edges. If polygon-like objects are returned, their
contours will be turned into edge sequences.
</p>
<h2>"collect_to_region" - Transforms a layer into polygon objects</h2>
<keyword name="collect_to_region"/>
<a name="collect_to_region"/><p>Usage:</p>
<ul>
<li><tt>layer.collect { |object| ... }</tt></li>
</ul>
<p>
This method is similar to <a href="#collect">collect</a>, but creates a polygon layer. It expects the block to 
deliver objects that can be converted into polygons. Such objects are of class <class_doc href="DPolygon">DPolygon</class_doc>,
<class_doc href="DBox">DBox</class_doc>, <class_doc href="DPath">DPath</class_doc>, <class_doc href="Polygon">Polygon</class_doc>, <class_doc href="Path">Path</class_doc>, <class_doc href="Box">Box</class_doc> and <class_doc href="Region">Region</class_doc>.
</p>
<h2>"corners" - Selects corners of polygons</h2>
<keyword name="corners"/>
<a name="corners"/><p>Usage:</p>
<ul>
<li><tt>layer.corners([ options ])</tt></li>
<li><tt>layer.corners(angle, [ options ])</tt></li>
<li><tt>layer.corners(amin .. amax, [ options ])</tt></li>
</ul>
<p>
This method produces markers on the corners of the polygons. An angle criterion can be given which
selects corners based on the angle of the connecting edges. Positive angles indicate a left turn
while negative angles indicate a right turn. Since polygons are oriented clockwise, positive angles
indicate concave corners while negative ones indicate convex corners.
</p><p>
The markers generated can be point-like edges or small 2x2 DBU boxes. The latter is the default.
</p><p>
The options available are:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
</ul>
</p><p>
The following images show the effect of this method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_corners1.png"/></td>
<td><img src="/images/drc_corners2.png"/></td>
<td><img src="/images/drc_corners3.png"/></td>
</tr>
</table>
</p>
<h2>"data" - Gets the low-level data object</h2>
<keyword name="data"/>
<a name="data"/><p>Usage:</p>
<ul>
<li><tt>layer.data</tt></li>
</ul>
<p>
This method returns a <class_doc href="Region">Region</class_doc>, <class_doc href="Edges">Edges</class_doc> or <class_doc href="EdgePairs">EdgePairs</class_doc> object
representing the underlying RBA object for the data.
Access to these objects is provided to support low-level iteration and manipulation
of the layer's data. 
</p>
<h2>"dup" - Duplicates a layer</h2>
<keyword name="dup"/>
<a name="dup"/><p>Usage:</p>
<ul>
<li><tt>layer.dup</tt></li>
</ul>
<p>
Duplicates the layer. This basically will create a copy and
modifications of the original layer will not affect the duplicate.
Please note that just assigning the layer to another variable will
not create a copy but rather a pointer to the original layer. Hence
modifications will then be visible on the original and derived 
layer. Using the dup method will avoid that.
</p><p>
However, dup will double the memory required to hold the data 
and performing the deep copy may be expensive in terms of CPU time.
</p>
<h2>"each" - Iterates over the objects from the layer</h2>
<keyword name="each"/>
<a name="each"/><p>Usage:</p>
<ul>
<li><tt>layer.each { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block on each object of the layer. Depending on the
layer type, these objects are of <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc> type.
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p>
<h2>"edge_pairs?" - Returns true, if the layer is an edge pair collection</h2>
<keyword name="edge_pairs?"/>
<a name="edge_pairs?"/><p>Usage:</p>
<ul>
<li><tt>layer.edge_pairs?</tt></li>
</ul>
<h2>"edges" - Decomposes the layer into single edges</h2>
<keyword name="edges"/>
<a name="edges"/><p>
Edge pair collections are decomposed into the individual edges that make up
the edge pairs. Polygon layers are decomposed into the edges making up the 
polygons. This method returns an edge layer but will not modify the layer it 
is called on.
</p><p>
Merged semantics applies, i.e. the result reflects merged polygons rather than
individual ones unless raw mode is chosen.
</p>
<h2>"edges?" - Returns true, if the layer is an edge layer</h2>
<keyword name="edges?"/>
<a name="edges?"/><p>Usage:</p>
<ul>
<li><tt>layer.edges?</tt></li>
</ul>
<h2>"enc" - An alias for "enclosing"</h2>
<keyword name="enc"/>
<a name="enc"/><p>Usage:</p>
<ul>
<li><tt>layer.enc(value [, options])</tt></li>
</ul>
<p>
See <a href="#enclosing">enclosing</a> for a description of that method
</p>
<h2>"enclosing" - An enclosing check</h2>
<keyword name="enclosing"/>
<a name="enclosing"/><p>Usage:</p>
<ul>
<li><tt>layer.enclosing(other_layer, value [, options])</tt></li>
</ul>
<p>
This method checks whether layer encloses (is bigger than) other_layer by the
given dimension. Locations, where this is not the case will be reported in form
of edge pair error markers.
Locations, where both edges coincide will be reported as errors as well. Formally
such locations form an enclosure with a distance of 0. Locations, where other_layer
extends outside layer will not be reported as errors. Such regions can be detected
by <a href="#not_inside">not_inside</a> or a boolean "not" operation.
</p><p>
The enclosing method can be applied to both edge or polygon layers. On edge layers 
the orientation of the edges matters and only edges looking into the same direction
are checked.
</p><p>
As for the other DRC methods, merged semantics applies. The options available 
are the same than for <a href="#width">width</a>.  
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of two enclosing checks (red: input1, blue: input2):
</p><p>
<table>
<tr>
<td><img src="/images/drc_enc1.png"/></td>
<td><img src="/images/drc_enc2.png"/></td>
</tr>
</table>
</p>
<h2>"end_segments" - Returns the part at the end of each edge</h2>
<keyword name="end_segments"/>
<a name="end_segments"/><p>Usage:</p>
<ul>
<li><tt>layer.end_segments(length)</tt></li>
<li><tt>layer.end_segments(length, fraction)</tt></li>
</ul>
<p>
This method will return a partial edge for each edge in the input, 
located and the end of the original edge.
The new edges will share the end point with the original edges, but not necessarily
their start point. This method applies to edge layers only. 
The direction of edges is defined by the clockwise orientation of a polygon: the 
end point of the edges will be the terminal point of each edge when walking a polygon
in clockwise direction. Or in other words: when looking from start to the end point
of an edge, the filled part of the polygon is to the right.
</p><p>
The length of the new edge can be given in two ways: as a fixed length, or a fraction, or
both. In the latter case, the length of the resulting edge will be either the fraction or
the fixed length, whichever is larger.
To specify a length only, omit the fraction argument or leave it at 0. To specify
a fraction only, pass 0 to the length argument and specify the fraction in the second
parameter. A fraction of 0.5 will result in edges which cover the end half of the 
edge.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_end_segments1.png"/></td>
<td><img src="/images/drc_end_segments2.png"/></td>
</tr>
</table>
</p>
<h2>"extended" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended"/>
<a name="extended"/><p>Usage:</p>
<ul>
<li><tt>layer.extended([:begin =&gt; b,] [:end =&gt; e,] [:out =&gt; o,] [:in =&gt; i], [:joined =&gt; true])</tt></li>
<li><tt>layer.extended(b, e, o, i)</tt></li>
<li><tt>layer.extended(b, e, o, i, joined)</tt></li>
</ul>
<p>
This method is available for edge layers only. It will create a polygon for each edge
tracing the edge with certain offsets to the edge. "o" is the offset applied to the 
outer side of the edge, "i" is the offset applied to the inner side of the edge.
"b" is the offset applied at the beginning and "e" is the offset applied at the end.
</p><p>
When looking from start to end point, the "inside" side is to the right, while the "outside"
side is to the left.
</p><p>
"joined" is a flag, which, if present, will make connected edges behave as a continuous
line. Start and end offsets are applied to the first and last unconnected point respectively.
Please note that in order to specify joined mode, you'll need to specify "joined" as 
a keyword in the third form of the method.
</p><p>
The following images show the effects of some parameters:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extended1.png"/></td>
<td><img src="/images/drc_extended2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extended3.png"/></td>
<td><img src="/images/drc_extended4.png"/></td>
</tr>
</table>
</p>
<h2>"extended_in" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended_in"/>
<a name="extended_in"/><p>Usage:</p>
<ul>
<li><tt>layer.extended_in(d)</tt></li>
</ul>
<p>
This method applies to edge layers only. Polygons are generated for 
each edge describing the edge drawn with a certain width extending into
the "inside" (the right side when looking from start to end).
This method is basically equivalent to the <a href="#extended">extended</a> method:
"extended(0, 0, 0, dist)".
A version extending to the outside is <a href="#extended_out">extended_out</a>.
</p>
<h2>"extended_out" - Returns polygons describing an area along the edges of the input</h2>
<keyword name="extended_out"/>
<a name="extended_out"/><p>Usage:</p>
<ul>
<li><tt>layer.extended_out(d)</tt></li>
</ul>
<p>
This method applies to edge layers only. Polygons are generated for 
each edge describing the edge drawn with a certain width extending into
the "outside" (the left side when looking from start to end).
This method is basically equivalent to the <a href="#extended">extended</a> method:
"extended(0, 0, dist, 0)".
A version extending to the inside is <a href="#extended_in">extended_in</a>.
</p>
<h2>"extent_refs" - Returns partial references to the boundings boxes of the polygons</h2>
<keyword name="extent_refs"/>
<a name="extent_refs"/><p>Usage:</p>
<ul>
<li><tt>layer.extent_refs(fx, fy [, options ])</tt></li>
<li><tt>layer.extent_refs(fx1, fy1, fx2, fx2 [, options ])</tt></li>
<li><tt>layer.extent_refs(ref_spec [, options ])</tt></li>
</ul>
<p>
This method produces parts of the bounding box of the polygons. It can select 
either edges, certain points or partial boxes. It can be used the following
ways:
</p><p>
<ul>
<li><b>With a formal specification </b>: This is an identifier like
":center" or ":left" to indicate which part will be produced. </li>
<li><b>With two floating-point arguments </b>: These arguments specify
a point relative to the bounding box. The first argument is a relative
x coordinate where 0.0 means "left side of the bounding box" and 1.0
is the right side. The second argument is a relative y coordinate where
0.0 means "bottom" and 1.0 means "top". The results will be small 
(2x2 DBU) boxes or point-like edges for edge output </li>
<li><b>With four floating-point arguments </b>: These arguments specify
a box in relative coordinates: a pair of x/y relative coordinate for
the first point and another pair for the second point. The results will
be boxes or a tilted edge in case of edge output. If the range specifies
a finite-area box (height and width are not zero), no adjustment of 
the boxes will happen for polygon output - i.e. the additional enlargement 
by 1 DBU which is applied for zero-area boxes does not happen.</li>
</ul>
</p><p>
The formal specifiers are for points:
</p><p>
<ul>
<li><b>:center </b>or <b>:c </b>: the center point </li>
<li><b>:bottom_center </b>or <b>:bc </b>: the bottom center point </li>
<li><b>:bottom_left </b>or <b>:bl </b>: the bottom left point </li>
<li><b>:bottom_right </b>or <b>:br </b>: the bottom right point </li>
<li><b>:left </b>or <b>:l </b>: the left point </li>
<li><b>:right </b>or <b>:r </b>: the right point </li>
<li><b>:top_center </b>or <b>:tc </b>: the top center point </li>
<li><b>:top_left </b>or <b>:tl </b>: the top left point </li>
<li><b>:top_right </b>or <b>:tr </b>: the top right point </li>
</ul>
</p><p>
The formal specifiers for lines are:
</p><p>
<ul>
<li><b>:bottom </b>or <b>:b </b>: the bottom line </li>
<li><b>:top </b>or <b>:t </b>: the top line </li>
<li><b>:left </b>or <b>:l </b>: the left line </li>
<li><b>:right </b>or <b>:r </b>: the right line </li>
</ul>
</p><p>
Dots are represented by small (2x2 DBU) boxes or point-like
edges with edge output. Lines are represented by narrow or 
flat (2 DBU) boxes or edges for edge output. Edges will follow
the orientation convention for the corresponding edges - i.e.
"inside" of the bounding box is on the right side of the edge.
</p><p>
The following additional option controls the output format:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>or <b>as_edges </b>: with this option, point-like edges will be produced for dots
and edges will be produced for line-like selections </li>
</ul>
</p><p>
The following table shows a few applications:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extent_refs1.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs10.png"/></td>
<td><img src="/images/drc_extent_refs11.png"/></td>
<td><img src="/images/drc_extent_refs12.png"/></td>
<td><img src="/images/drc_extent_refs13.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs20.png"/></td>
<td><img src="/images/drc_extent_refs21.png"/></td>
<td><img src="/images/drc_extent_refs22.png"/></td>
<td><img src="/images/drc_extent_refs23.png"/></td>
<td><img src="/images/drc_extent_refs24.png"/></td>
<td><img src="/images/drc_extent_refs25.png"/></td>
<td><img src="/images/drc_extent_refs26.png"/></td>
<td><img src="/images/drc_extent_refs27.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_extent_refs30.png"/></td>
<td><img src="/images/drc_extent_refs31.png"/></td>
</tr>
</table>
</p>
<h2>"extents" - Returns the bounding box of each input object</h2>
<keyword name="extents"/>
<a name="extents"/><p>Usage:</p>
<ul>
<li><tt>layer.extents([ enlargement ])</tt></li>
</ul>
<p>
Applies to edge layers, polygon layers on edge pair collections.
Returns a polygon layer consisting of boxes for each input object.
The boxes enclose the original object. 
</p><p>
Merged semantics applies, so the box encloses the merged polygons
or edges unless raw mode is chosen (see <a href="#raw">raw</a>).
</p><p>
The enlargement parameter specifies an optional enlargement which 
will make zero width/zero height object render valid polygons 
(i.e. horizontal/vertical edges).
</p><p>
The following images show the effect of the extents method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_extents1.png"/></td>
<td><img src="/images/drc_extents2.png"/></td>
</tr>
</table>
</p>
<h2>"first_edges" - Returns the first edges of an edge pair collection</h2>
<keyword name="first_edges"/>
<a name="first_edges"/><p>Usage:</p>
<ul>
<li><tt>layer.first_edges</tt></li>
</ul>
<p>
Applies to edge pair collections only.
Returns the first edges of the edge pairs in the collection.
</p>
<h2>"flatten" - Flattens the layer</h2>
<keyword name="flatten"/>
<a name="flatten"/><p>Usage:</p>
<ul>
<li><tt>layer.flatten</tt></li>
</ul>
<p>
If the layer already is a flat one, this method does nothing.
If the layer is a hierarchical layer (an original layer or
a derived layer in deep mode), this method will convert it
to a flat collection of polygons, edges or edge pairs.
</p>
<h2>"holes" - Selects all polygon holes from the input</h2>
<keyword name="holes"/>
<a name="holes"/><p>Usage:</p>
<ul>
<li><tt>layer.holes</tt></li>
</ul>
<p>
This method is available for polygon layers. It will create polygons from all holes inside 
polygons of the input. Although it is possible, running this method on raw polygon layers will
usually not render the expected result, since raw layers do not contain polygons with holes in
most cases.
</p><p>
The following image shows the effects of the holes method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_holes.png"/></td>
</tr>
</table>
</p>
<h2>"hulls" - Selects all polygon hulls from the input</h2>
<keyword name="hulls"/>
<a name="hulls"/><p>Usage:</p>
<ul>
<li><tt>layer.hulls</tt></li>
</ul>
<p>
This method is available for polygon layers. It will remove all holes from the input and 
render the hull polygons only. Although it is possible, running this method on raw polygon layers will
usually not render the expected result, since raw layers do not contain polygons with holes in
most cases.
</p><p>
The following image shows the effects of the hulls method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_hulls.png"/></td>
</tr>
</table>
</p>
<h2>"in" - Selects shapes or regions of self which are contained in the other layer</h2>
<keyword name="in"/>
<a name="in"/><p>Usage:</p>
<ul>
<li><tt>layer.in(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are contained  
the other region exactly. It will use individual shapes from self or other if
the respective region is in raw mode. If not, it will use coherent regions or combined edges from
self or other.
</p><p>
It will return a new layer containing the selected shapes.
A method which selects all shapes not contained in the other layer is <a href="#not_in">not_in</a>.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following image shows the effect of the "in" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_in.png"/></td>
</tr>
</table>
</p>
<h2>"insert" - Inserts one or many objects into the layer</h2>
<keyword name="insert"/>
<a name="insert"/><p>Usage:</p>
<ul>
<li><tt>insert(object, object ...)</tt></li>
</ul>
<p>
Objects that can be inserted are <class_doc href="Edge">Edge</class_doc> objects (into edge layers) or 
<class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DSimplePolygon">DSimplePolygon</class_doc>, <class_doc href="Path">Path</class_doc>, <class_doc href="DBox">DBox</class_doc> (into polygon layers).
Convenience methods exist to create such objects (<a href="/about/drc_ref_global.xml#edge">global#edge</a>, <a href="/about/drc_ref_global.xml#polygon">global#polygon</a>, <a href="/about/drc_ref_global.xml#box">global#box</a> and <a href="/about/drc_ref_#global.xml#path">#global#path</a>).
However, RBA constructors can used as well.
</p><p>
The insert method is useful in combination with the <a href="/about/drc_ref_global.xml#polygon_layer">global#polygon_layer</a> or <a href="/about/drc_ref_global.xml#edge_layer">global#edge_layer</a> functions: 
</p><p>
<pre>
el = edge_layer
el.insert(edge(0.0, 0.0, 100.0, 0.0)

pl = polygon_layer
pl.insert(box(0.0, 0.0, 100.0, 200.0)
</pre>
</p>
<h2>"inside" - Selects shapes or regions of self which are inside the other region</h2>
<keyword name="inside"/>
<a name="inside"/><p>Usage:</p>
<ul>
<li><tt>layer.inside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are inside the other region.
completely (completely covered by polygons from the other region). If self is
in raw mode, this method will select individual shapes. Otherwise, this method
will select coherent regions and no part of these regions may be outside the 
other region.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_inside">select_inside</a>.
</p><p>
This method is available for polygon layers.
</p><p>
The following image shows the effect of the "inside" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside.png"/></td>
</tr>
</table>
</p>
<h2>"inside_part" - Returns the parts of the edges inside the given region</h2>
<keyword name="inside_part"/>
<a name="inside_part"/><p>Usage:</p>
<ul>
<li><tt>layer.inside_part(region)</tt></li>
</ul>
<p>
This method returns the parts of the edges which are inside the given region. This is similar to the
"&amp;" operator, but this method does not return edges that are exactly on the boundaries
of the polygons of the region.
</p><p>
This method is available for edge layers. The argument must be a polygon layer.
</p><p>
<table>
<tr>
<td><img src="/images/drc_inside_part.png"/></td>
</tr>
</table>
</p>
<h2>"interacting" - Selects shapes or regions of self which touch or overlap shapes from the other region</h2>
<keyword name="interacting"/>
<a name="interacting"/><p>Usage:</p>
<ul>
<li><tt>layer.interacting(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which touch or overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_interacting">select_interacting</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p><p>
The following image shows the effect of the "interacting" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_interacting.png"/></td>
</tr>
</table>
</p>
<h2>"is_box?" - Returns true, if the region contains a single box</h2>
<keyword name="is_box?"/>
<a name="is_box?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_box?</tt></li>
</ul>
<p>
The method returns true, if the region consists of a single box
only. Merged semantics does not apply - if the region forms a box which
is composed of multiple pieces, this method will not return true.
</p>
<h2>"is_clean?" - Returns true, if the layer is clean state</h2>
<keyword name="is_clean?"/>
<a name="is_clean?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_clean?</tt></li>
</ul>
<p>
See <a href="#clean">clean</a> for a discussion of the clean state.
</p>
<h2>"is_deep?" - Returns true, if the layer is a deep (hierarchical) layer</h2>
<keyword name="is_deep?"/>
<a name="is_deep?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_deep?</tt></li>
</ul>
<h2>"is_empty?" - Returns true, if the layer is empty</h2>
<keyword name="is_empty?"/>
<a name="is_empty?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_empty?</tt></li>
</ul>
<h2>"is_merged?" - Returns true, if the polygons of the layer are merged</h2>
<keyword name="is_merged?"/>
<a name="is_merged?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_merged?</tt></li>
</ul>
<p>
This method will return true, if the polygons of this layer are
merged, i.e. they don't overlap and form single continuous polygons.
In clean mode, this is ensured implicitly. In raw mode (see <a href="#raw">raw</a>),
merging can be achieved by using the <a href="#merge">merge</a> method. <a href="#is_merged">is_merged</a>?
tells, whether calling <a href="#merge">merge</a> is necessary.
</p>
<h2>"is_raw?" - Returns true, if the layer is raw state</h2>
<keyword name="is_raw?"/>
<a name="is_raw?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_raw?</tt></li>
</ul>
<p>
See <a href="#clean">clean</a> for a discussion of the raw state.
</p>
<h2>"iso" - An alias for "isolated"</h2>
<keyword name="iso"/>
<a name="iso"/><p>Usage:</p>
<ul>
<li><tt>layer.iso(value [, options])</tt></li>
</ul>
<p>
See <a href="#isolated">isolated</a> for a description of that method
</p>
<h2>"isolated" - An isolation check</h2>
<keyword name="isolated"/>
<a name="isolated"/><p>Usage:</p>
<ul>
<li><tt>layer.isolated(value [, options])</tt></li>
</ul>
<p>
See <a href="#space">space</a> for a description of this method. 
In contrast to <a href="#space">space</a>, this
method is available for polygon layers only, since only on such layers 
different polygons can be identified.
</p><p>
The following image shows the effect of the isolated check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space3.png"/></td>
</tr>
</table>
</p>
<h2>"join" - Joins the layer with another layer</h2>
<keyword name="join"/>
<a name="join"/><p>Usage:</p>
<ul>
<li><tt>layer.join(other)</tt></li>
</ul>
<p>
The method includes the edges or polygons from the other layer into this layer.
It is an alias for the "+" operator.
</p><p>
This method is available for polygon, edge and edge pair layers.
</p><p>
The following images show the effect of the "join" method
on polygons and edges (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_join1.png"/></td>
<td><img src="/images/drc_join2.png"/></td>
</tr>
</table>
</p>
<h2>"length" - Returns the total length of the edges in the edge layer</h2>
<keyword name="length"/>
<a name="length"/><p>Usage:</p>
<ul>
<li><tt>layer.length</tt></li>
</ul>
<p>
This method requires an edge layer. It returns the total
length of all edges in micron. Merged semantics applies, 
i.e. before computing the length, the edges are merged unless
raw mode is chosen (see <a href="#raw">raw</a>). Hence in clean mode (see <a href="#clean">clean</a>), overlapping
edges are not counted twice.
</p>
<h2>"merge" - Merges the layer (modifies the layer)</h2>
<keyword name="merge"/>
<a name="merge"/><p>Usage:</p>
<ul>
<li><tt>layer.merge([overlap_count])</tt></li>
</ul>
<p>
Like <a href="#merged">merged</a>, but modifies the input and returns a reference to the 
new layer.
</p>
<h2>"merged" - Returns the merged layer</h2>
<keyword name="merged"/>
<a name="merged"/><p>Usage:</p>
<ul>
<li><tt>layer.merged([overlap_count])</tt></li>
</ul>
<p>
Returns the merged input. Usually, merging is done implicitly using the
<a href="#clean">clean</a> state (which is default). However, in raw state, merging can be 
enforced by using this method. In addition, this method allows specification
of a minimum overlap count, i.e. only where at least the given number of polygons
overlap, output is produced. See <a href="#sized">sized</a> for an application of that.
</p><p>
This method works both on edge or polygon layers. Edge merging forms
single, continuous edges from coincident and connected individual edges.
</p><p>
A version that modifies the input layer is <a href="#merge">merge</a>.
</p><p>
The following images show the effect of various forms of the "merged" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_merged1.png"/></td>
<td><img src="/images/drc_merged2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_merged3.png"/></td>
<td><img src="/images/drc_merged4.png"/></td>
</tr>
</table>
</p>
<h2>"middle" - Returns the center points of the bounding boxes of the polygons</h2>
<keyword name="middle"/>
<a name="middle"/><p>Usage:</p>
<ul>
<li><tt>layer.middle([ options ])</tt></li>
</ul>
<p>
This method produces markers on the centers of the polygon's bounding box centers. 
These markers can be point-like edges or small 2x2 DBU boxes. The latter is the default.
A more generic function is <a href="#extent_refs">extent_refs</a>. "middle" is basically a synonym for "extent_refs(:center)".
</p><p>
The options available are:
</p><p>
<ul>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
</ul>
</p><p>
The following image shows the effect of this method
</p><p>
<table>
<tr>
<td><img src="/images/drc_middle1.png"/></td>
</tr>
</table>
</p>
<h2>"move" - Moves (shifts, translates) a layer (modifies the layer)</h2>
<keyword name="move"/>
<a name="move"/><p>Usage:</p>
<ul>
<li><tt>layer.move(dx, dy)</tt></li>
</ul>
<p>
Moved the input by the given distance. The layer that this method is called 
upon is modified and the modified version is returned for further processing.
</p><p>
Shift distances can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p>
<h2>"moved" - Moves (shifts, translates) a layer</h2>
<keyword name="moved"/>
<a name="moved"/><p>Usage:</p>
<ul>
<li><tt>layer.moved(dx, dy)</tt></li>
</ul>
<p>
Moves the input layer by the given distance (x, y) and returns
the moved layer. The layer that this method is called upon is not modified.
</p><p>
Shift distances can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images shows the effect of the "moved" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_moved1.png"/></td>
</tr>
</table>
</p>
<h2>"non_rectangles" - Selects all polygons from the input which are not rectangles</h2>
<keyword name="non_rectangles"/>
<a name="non_rectangles"/><p>Usage:</p>
<ul>
<li><tt>layer.non_rectangles</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before non-rectangles are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
</p>
<h2>"non_rectilinear" - Selects all non-rectilinear polygons from the input</h2>
<keyword name="non_rectilinear"/>
<a name="non_rectilinear"/><p>Usage:</p>
<ul>
<li><tt>layer.non_rectilinear</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before non-rectilinear polygons are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
</p>
<h2>"non_strict" - Marks a layer for non-strict handling</h2>
<keyword name="non_strict"/>
<a name="non_strict"/><p>Usage:</p>
<ul>
<li><tt>layer.non_strict</tt></li>
</ul>
<p>
See <a href="#strict">strict</a> for details about this option.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<h2>"not" - Boolean NOT operation</h2>
<keyword name="not"/>
<a name="not"/><p>Usage:</p>
<ul>
<li><tt>layer.not(other)</tt></li>
</ul>
<p>
The method computes a boolean NOT between self and other.
It is an alias for the "-" operator.
</p><p>
This method is available for polygon and edge layers.
If the first operand is an edge layer and the second is an edge layer, the
result will be the edges of the first operand which are outside the polygons
of the second operand.
</p><p>
The following images show the effect of the "not" method
on polygons and edges (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not1.png"/></td>
<td><img src="/images/drc_not2.png"/></td>
<td><img src="/images/drc_not3.png"/></td>
</tr>
</table>
</p>
<h2>"not_in" - Selects shapes or regions of self which are not contained in the other layer</h2>
<keyword name="not_in"/>
<a name="not_in"/><p>Usage:</p>
<ul>
<li><tt>layer.not_in(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not contained  
the other region exactly. It will use individual shapes from self or other if
the respective region is in raw mode. If not, it will use coherent regions or combined edges from
self or other.
</p><p>
It will return a new layer containing the selected shapes.
A method which selects all shapes contained in the other layer is <a href="#in">in</a>.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following image shows the effect of the "not_in" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_in.png"/></td>
</tr>
</table>
</p>
<h2>"not_inside" - Selects shapes or regions of self which are not inside the other region</h2>
<keyword name="not_inside"/>
<a name="not_inside"/><p>Usage:</p>
<ul>
<li><tt>layer.not_inside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not inside the other region.
completely (completely covered by polygons from the other region). If self is
in raw mode, this method will select individual shapes. Otherwise, this method
will select coherent regions and no part of these regions may be outside the 
other region.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_inside">select_not_inside</a>.
</p><p>
This method is available for polygon layers.
</p><p>
The following image shows the effect of the "not_inside" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_inside.png"/></td>
</tr>
</table>
</p>
<h2>"not_interacting" - Selects shapes or regions of self which do not touch or overlap shapes from the other region</h2>
<keyword name="not_interacting"/>
<a name="not_interacting"/><p>Usage:</p>
<ul>
<li><tt>layer.not_interacting(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not touch or overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_interacting">select_not_interacting</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p><p>
The following image shows the effect of the "not_interacting" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_interacting.png"/></td>
</tr>
</table>
</p>
<h2>"not_outside" - Selects shapes or regions of self which are not outside the other region</h2>
<keyword name="not_outside"/>
<a name="not_outside"/><p>Usage:</p>
<ul>
<li><tt>layer.not_outside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not completely outside 
the other region (part of these shapes or regions may be covered by shapes from
the other region). If self is in raw mode, this method will select individual 
shapes. Otherwise, this method will select coherent regions and no part of these 
regions may overlap with shapes from the other region.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_outside">select_not_outside</a>.
</p><p>
This method is available for polygon layers.
</p><p>
The following image shows the effect of the "not_outside" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_not_outside.png"/></td>
</tr>
</table>
</p>
<h2>"not_overlapping" - Selects shapes or regions of self which do not overlap shapes from the other region</h2>
<keyword name="not_overlapping"/>
<a name="not_overlapping"/><p>Usage:</p>
<ul>
<li><tt>layer.not_overlapping(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
</p><p>
The "not_overlapping" method is equivalent to the <a href="#outside">outside</a> method. It is provided
as an alias for consistency.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_not_overlapping">select_not_overlapping</a>.
</p>
<h2>"notch" - An intra-region spacing check</h2>
<keyword name="notch"/>
<a name="notch"/><p>Usage:</p>
<ul>
<li><tt>layer.notch(value [, options])</tt></li>
</ul>
<p>
See <a href="#space">space</a> for a description of this method.
In contrast to <a href="#space">space</a>, this
method is available for polygon layers only, since only on such layers 
different polygons can be identified.
</p><p>
The following image shows the effect of the notch check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space2.png"/></td>
</tr>
</table>
</p>
<h2>"odd_polygons" - Checks for odd polygons (self-overlapping, non-orientable)</h2>
<keyword name="odd_polygons"/>
<a name="odd_polygons"/><p>Usage:</p>
<ul>
<li><tt>layer.odd_polygons</tt></li>
</ul>
<p>
Returns the parts of the polygons which are not orientable (i.e. "8" configuration) or self-overlapping.
Merged semantics does not apply for this method. Always the raw polygons are taken (see <a href="#raw">raw</a>).
</p>
<h2>"ongrid" - Checks for on-grid vertices</h2>
<keyword name="ongrid"/>
<a name="ongrid"/><p>Usage:</p>
<ul>
<li><tt>layer.ongrid(g)</tt></li>
<li><tt>layer.ongrid(gx, gy)</tt></li>
</ul>
<p>
Returns a single-vertex marker for each vertex whose x coordinate is not a
multiple of g or gx or whose y coordinate is not a multiple of g or gy.
The single-vertex markers are edge pair objects which describe a single point.
When setting the grid to 0, no grid check is performed in that specific direction.
</p><p>
This method requires a polygon layer. Merged semantics applies (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<h2>"or" - Boolean OR operation</h2>
<keyword name="or"/>
<a name="or"/><p>Usage:</p>
<ul>
<li><tt>layer.or(other)</tt></li>
</ul>
<p>
The method computes a boolean OR between self and other.
It is an alias for the "|" operator.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following images show the effect of the "or" method
on polygons and edges (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_or1.png"/></td>
<td><img src="/images/drc_or2.png"/></td>
</tr>
</table>
</p>
<h2>"output" - Outputs the content of the layer</h2>
<keyword name="output"/>
<a name="output"/><p>Usage:</p>
<ul>
<li><tt>layer.output(specs)</tt></li>
</ul>
<p>
This method will copy the content of the layer to the specified output.
</p><p>
If a report database is selected for the output, the specification has to include a 
category name and optionally a category description.
</p><p>
If the layout is selected for the output, the specification can consist of
one to three parameters: a layer number, a data type (optional, default is 0)
and a layer name (optional). Alternatively, the output can be specified by 
a single <class_doc href="LayerInfo">LayerInfo</class_doc> object.
</p><p>
See <a href="/about/drc_ref_global.xml#report">global#report</a> and <a href="/about/drc_ref_global.xml#target">global#target</a> on how to configure output to a target layout
or report database. 
</p>
<h2>"outside" - Selects shapes or regions of self which are outside the other region</h2>
<keyword name="outside"/>
<a name="outside"/><p>Usage:</p>
<ul>
<li><tt>layer.outside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are completely outside 
the other region (no part of these shapes or regions may be covered by shapes from
the other region). If self is in raw mode, this method will select individual 
shapes. Otherwise, this method will select coherent regions and no part of these 
regions may overlap with shapes from the other region.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_outside">select_outside</a>.
</p><p>
This method is available for polygon layers.
</p><p>
The following image shows the effect of the "outside" method (input1: red, input2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside.png"/></td>
</tr>
</table>
</p>
<h2>"outside_part" - Returns the parts of the edges outside the given region</h2>
<keyword name="outside_part"/>
<a name="outside_part"/><p>Usage:</p>
<ul>
<li><tt>layer.outside_part(region)</tt></li>
</ul>
<p>
This method returns the parts of the edges which are outside the given region. This is similar to the
"&amp;" operator, but this method does not remove edges that are exactly on the boundaries
of the polygons of the region.
</p><p>
This method is available for edge layers. The argument must be a polygon layer.
</p><p>
<table>
<tr>
<td><img src="/images/drc_outside_part.png"/></td>
</tr>
</table>
</p>
<h2>"overlap" - An overlap check</h2>
<keyword name="overlap"/>
<a name="overlap"/><p>Usage:</p>
<ul>
<li><tt>layer.overlap(other_layer, value [, options])</tt></li>
</ul>
<p>
This method checks whether layer and other_layer overlap by at least the
given length. Locations, where this is not the case will be reported in form
of edge pair error markers.
Locations, where both layers touch will be reported as errors as well. Formally
such locations form an overlap with a value of 0. Locations, where both regions 
do not overlap or touch will not be reported. Such regions can be detected 
with <a href="#outside">outside</a> or by a boolean "not".
</p><p>
Formally, the overlap method is a two-layer width check. In contrast to the single-
layer width method (<a href="#width">width</a>), the zero value also triggers an error and separate
polygons are checked against each other, while for the single-layer width, only 
single polygons are considered.
</p><p>
The overlap method can be applied to both edge or polygon layers. On edge layers 
the orientation of the edges matters: only edges which run back to back with their
inside side pointing towards each other are checked for distance.
</p><p>
As for the other DRC methods, merged semantics applies. The options available 
are the same than for <a href="#width">width</a>.  
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following images show the effect of the overlap check (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_overlap1.png"/></td>
<td><img src="/images/drc_overlap2.png"/></td>
</tr>
</table>
</p>
<h2>"overlapping" - Selects shapes or regions of self which overlap shapes from the other region</h2>
<keyword name="overlapping"/>
<a name="overlapping"/><p>Usage:</p>
<ul>
<li><tt>layer.overlapping(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It returns a new layer containing the selected shapes. A version which modifies self
is <a href="#select_overlapping">select_overlapping</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p><p>
The following image shows the effect of the "overlapping" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_overlapping.png"/></td>
</tr>
</table>
</p>
<h2>"perimeter" - Returns the total perimeter of the polygons in the region</h2>
<keyword name="perimeter"/>
<a name="perimeter"/><p>Usage:</p>
<ul>
<li><tt>layer.perimeter</tt></li>
</ul>
<p>
This method requires a polygon layer. It returns the total
perimeter of all polygons in micron. Merged semantics applies, 
i.e. before computing the perimeter, the polygons are merged unless
raw mode is chosen (see <a href="#raw">raw</a>).
</p><p>
The returned value gives the perimeter in micrometer units.
</p>
<h2>"polygons" - Returns polygons from edge pairs</h2>
<keyword name="polygons"/>
<a name="polygons"/><p>Usage:</p>
<ul>
<li><tt>layer.polygons([ enlargement ])</tt></li>
</ul>
<p>
This method applies to edge pair collections. The edge pairs will be
converted into polygons connecting the edges the edge pairs are made of.
In order to properly handle special edge pairs (coincident edges, point-like
edges etc.) an enlargement parameter can be specified which will make the 
resulting polygon somewhat larger than the original edge pair. If the enlargement
parameter is 0, special edge pairs with an area of 0 will be dropped.
</p>
<h2>"polygons?" - Returns true, if the layer is a polygon layer</h2>
<keyword name="polygons?"/>
<a name="polygons?"/><p>Usage:</p>
<ul>
<li><tt>layer.polygons?</tt></li>
</ul>
<h2>"raw" - Marks a layer as raw</h2>
<keyword name="raw"/>
<a name="raw"/><p>Usage:</p>
<ul>
<li><tt>layer.raw</tt></li>
</ul>
<p>
A raw layer basically is the opposite of a "clean" layer
(see <a href="#clean">clean</a>). Polygons on a raw layer are considered "as is", i.e.
overlapping polygons are not connected and inner edges may occur
due to cut lines. Holes may not exists if the polygons are derived
from a representation that does not allow holes (i.e. GDS2 files).
</p><p>
Note that this method will set the state of the layer. In combination
with the fact, that copied layers are references to the original layer,
this may lead to unexpected results:
</p><p>
<pre>
l = ...
l2 = l1
... do something
l.raw
# now l2 is also a raw layer
</pre>
</p><p>
To avoid that, use the <a href="#dup">dup</a> method to create a real (deep) copy.
</p>
<h2>"rectangles" - Selects all rectangle polygons from the input</h2>
<keyword name="rectangles"/>
<a name="rectangles"/><p>Usage:</p>
<ul>
<li><tt>layer.rectangles</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before rectangles are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
<a href="#non_rectangles">non_rectangles</a> will select all non-rectangles.
</p>
<h2>"rectilinear" - Selects all rectilinear polygons from the input</h2>
<keyword name="rectilinear"/>
<a name="rectilinear"/><p>Usage:</p>
<ul>
<li><tt>layer.rectilinear</tt></li>
</ul>
<p>
This method is available for polygon layers. By default "merged" semantics applies, 
i.e. all polygons are merged before rectilinear polygons are selected (see <a href="#clean">clean</a> and <a href="#raw">raw</a>).
<a href="#non_rectilinear">non_rectilinear</a> will select all non-rectangles.
</p>
<h2>"rotate" - Rotates a layer (modifies the layer)</h2>
<keyword name="rotate"/>
<a name="rotate"/><p>Usage:</p>
<ul>
<li><tt>layer.rotate(a)</tt></li>
</ul>
<p>
Rotates the input by the given angle (in degree). The layer that this method is called 
upon is modified and the modified version is returned for further processing.
</p>
<h2>"rotated" - Rotates a layer</h2>
<keyword name="rotated"/>
<a name="rotated"/><p>Usage:</p>
<ul>
<li><tt>layer.rotated(a)</tt></li>
</ul>
<p>
Rotates the input layer by the given angle (in degree) and returns
the rotated layer. The layer that this method is called upon is not modified.
</p><p>
The following image shows the effect of the "rotated" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_rotated1.png"/></td>
</tr>
</table>
</p>
<h2>"rounded_corners" - Applies corner rounding to each corner of the polygon</h2>
<keyword name="rounded_corners"/>
<a name="rounded_corners"/><p>Usage:</p>
<ul>
<li><tt>layer.rounded_corners(inner, outer, n)</tt></li>
</ul>
<p>
Inner (concave) corners are replaced by circle segments with a radius given by the 
"inner" parameter. Outer (convex) corners are relaced by circle segments with a radius
given by the "outer" parameter. 
</p><p>
The circles are approximated by polygons. "n" segments are used to approximate a full circle.
</p><p>
This method return a layer wit the modified polygons. Merged semantics applies for this
method (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
If used with tiling, the rounded_corners function may render invalid results because
in tiling mode, not the whole merged region may be captured. In that case, inner
edges may appear as outer ones and their corners will receive rounding.
</p><p>
The following image shows the effect of the "rounded_corners" method. The upper ends of 
the vertical bars are rounded with a smaller radius automatically because their width does not allow
a larger radius.
</p><p>
<table>
<tr>
<td><img src="/images/drc_rounded_corners.png"/></td>
</tr>
</table>
</p>
<h2>"scale" - Scales a layer (modifies the layer)</h2>
<keyword name="scale"/>
<a name="scale"/><p>Usage:</p>
<ul>
<li><tt>layer.scale(f)</tt></li>
</ul>
<p>
Scales the input. After scaling, features have a f times
bigger dimension. The layer that this method is called upon is modified and
the modified version is returned for further processing.
</p>
<h2>"scaled" - Scales a layer</h2>
<keyword name="scaled"/>
<a name="scaled"/><p>Usage:</p>
<ul>
<li><tt>layer.scaled(f)</tt></li>
</ul>
<p>
Scales the input layer and returns a new layer whose features have a f times
bigger dimension. The layer that this method is called upon is not modified.
</p><p>
The following images shows the effect of the "scaled" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_scaled1.png"/></td>
</tr>
</table>
</p>
<h2>"second_edges" - Returns the second edges of an edge pair collection</h2>
<keyword name="second_edges"/>
<a name="second_edges"/><p>Usage:</p>
<ul>
<li><tt>layer.second_edges</tt></li>
</ul>
<p>
Applies to edge pair collections only.
Returns the second edges of the edge pairs in the collection.
</p>
<h2>"select" - Selects edges, edge pairs or polygons based on evaluation of a block</h2>
<keyword name="select"/>
<a name="select"/><p>Usage:</p>
<ul>
<li><tt>layer.select { |object| ... }</tt></li>
</ul>
<p>
This method evaluates the block and returns a new container with those objects for which
the block evaluates to true. It is available for edge, polygon and edge pair layers.
The corresponding objects are <class_doc href="DPolygon">DPolygon</class_doc>, <class_doc href="DEdge">DEdge</class_doc> or <class_doc href="DEdgePair">DEdgePair</class_doc>.
</p><p>
Because this method executes inside the interpreter, it's inherently slow. Tiling does not
apply to this method.
</p><p>
Here is a (slow) equivalent of the area selection method:
</p><p>
<pre>
new_layer = layer.select { |polygon| polygon.area &gt;= 10.0 }
</pre>
</p>
<h2>"select_inside" - Selects shapes or regions of self which are inside the other region</h2>
<keyword name="select_inside"/>
<a name="select_inside"/><p>Usage:</p>
<ul>
<li><tt>layer.select_inside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are inside the other region.
completely (completely covered by polygons from the other region). If self is
in raw mode, this method will select individual shapes. Otherwise, this method
will select coherent regions and no part of these regions may be outside the 
other region.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#inside">inside</a>.
</p><p>
This method is available for polygon layers.
</p>
<h2>"select_interacting" - Selects shapes or regions of self which touch or overlap shapes from the other region</h2>
<keyword name="select_interacting"/>
<a name="select_interacting"/><p>Usage:</p>
<ul>
<li><tt>layer.select_interacting(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which touch or overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#interacting">interacting</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p>
<h2>"select_not_inside" - Selects shapes or regions of self which are not inside the other region</h2>
<keyword name="select_not_inside"/>
<a name="select_not_inside"/><p>Usage:</p>
<ul>
<li><tt>layer.select_not_inside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not inside the other region.
completely (completely covered by polygons from the other region). If self is
in raw mode, this method will select individual shapes. Otherwise, this method
will select coherent regions and no part of these regions may be outside the 
other region.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_inside">not_inside</a>.
</p><p>
This method is available for polygon layers.
</p>
<h2>"select_not_interacting" - Selects shapes or regions of self which do not touch or overlap shapes from the other region</h2>
<keyword name="select_not_interacting"/>
<a name="select_not_interacting"/><p>Usage:</p>
<ul>
<li><tt>layer.select_interacting(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not touch or overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_interacting">not_interacting</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p>
<h2>"select_not_outside" - Selects shapes or regions of self which are not outside the other region</h2>
<keyword name="select_not_outside"/>
<a name="select_not_outside"/><p>Usage:</p>
<ul>
<li><tt>layer.select_not_outside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are not completely outside 
the other region (part of these shapes or regions may be covered by shapes from
the other region). If self is in raw mode, this method will select individual 
shapes. Otherwise, this method will select coherent regions and no part of these 
regions may overlap with shapes from the other region.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_outside">not_outside</a>.
</p><p>
This method is available for polygon layers.
</p>
<h2>"select_not_overlapping" - Selects shapes or regions of self which do not overlap shapes from the other region</h2>
<keyword name="select_not_overlapping"/>
<a name="select_not_overlapping"/><p>Usage:</p>
<ul>
<li><tt>layer.select_not_overlapping(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which do not overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected. 
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#not_overlapping">not_overlapping</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p>
<h2>"select_outside" - Selects shapes or regions of self which are outside the other region</h2>
<keyword name="select_outside"/>
<a name="select_outside"/><p>Usage:</p>
<ul>
<li><tt>layer.select_outside(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which are completely outside 
the other region (no part of these shapes or regions may be covered by shapes from
the other region). If self is in raw mode, this method will select individual 
shapes. Otherwise, this method will select coherent regions and no part of these 
regions may overlap with shapes from the other region.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#outside">outside</a>.
</p><p>
This method is available for polygon layers.
</p>
<h2>"select_overlapping" - Selects shapes or regions of self which overlap shapes from the other region</h2>
<keyword name="select_overlapping"/>
<a name="select_overlapping"/><p>Usage:</p>
<ul>
<li><tt>layer.select_overlapping(other)</tt></li>
</ul>
<p>
This method selects all shapes or regions from self which overlap shapes from the other
region. If self is in raw mode (see <a href="#raw">raw</a>), coherent regions are selected from self, 
otherwise individual shapes are selected.
It modifies self to contain the selected shapes. A version which does not modify self
is <a href="#overlapping">overlapping</a>.
</p><p>
This method is available for polygon and edge layers. Edges can be selected
with respect to other edges or polygons.
</p>
<h2>"sep" - An alias for "separation"</h2>
<keyword name="sep"/>
<a name="sep"/><p>Usage:</p>
<ul>
<li><tt>layer.sep(value [, options])</tt></li>
</ul>
<p>
See <a href="#separation">separation</a> for a description of that method
</p>
<h2>"separation" - A two-layer spacing check</h2>
<keyword name="separation"/>
<a name="separation"/><p>Usage:</p>
<ul>
<li><tt>layer.separation(other_layer, value [, options])</tt></li>
</ul>
<p>
This method performs a two-layer spacing check. Like <a href="#space">space</a>, this method
can be applied to edge or polygon layers. Locations where edges of the layer
are closer than the specified distance to the other layer are reported
as edge pair error markers.
</p><p>
In contrast to the <a href="#space">space</a> and related methods, locations where both 
layers touch are also reported. More specifically, the case of zero spacing
will also trigger an error while for <a href="#space">space</a> it will not.
</p><p>
As for the other DRC methods, merged semantics applies. The options available 
are the same than for <a href="#width">width</a>.  
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following image shows the effect of the separation check (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_separation1.png"/></td>
</tr>
</table>
</p>
<h2>"size" - Polygon sizing (per-edge biasing, modifies the layer)</h2>
<keyword name="size"/>
<a name="size"/><p>Usage:</p>
<ul>
<li><tt>layer.size(d [, mode])</tt></li>
<li><tt>layer.size(dx, dy [, mode]))</tt></li>
</ul>
<p>
See <a href="#sized">sized</a>. The size method basically does the same but modifies the layer
it is called on. The input layer is returned and available for further processing.
</p>
<h2>"sized" - Polygon sizing (per-edge biasing)</h2>
<keyword name="sized"/>
<a name="sized"/><p>Usage:</p>
<ul>
<li><tt>layer.sized(d [, mode])</tt></li>
<li><tt>layer.sized(dx, dy [, mode]))</tt></li>
</ul>
<p>
This method requires a polygon layer. It will apply a bias per edge of the polygons 
and return the biased layer. The layer that this method is called on is not modified.
</p><p>
In the single-value form, that bias is applied both in horizontal or vertical direction.
In the two-value form, the horizontal and vertical bias can be specified separately.
</p><p>
The mode defines how to handle corners. The following modes are available:
</p><p>
<ul>
<li><b>diamond_limit </b>: This mode will connect the shifted edges without corner interpolation </li>
<li><b>octagon_limit </b>: This mode will create octagon-shaped corners </li>
<li><b>square_limit </b>: This mode will leave 90 degree corners untouched but 
cut off corners with a sharper angle. This is the default mode. </li>
<li><b>acute_limit </b>: This mode will leave 45 degree corners untouched but
cut off corners with a sharper angle </li>
<li><b>no_limit </b>: This mode will not cut off (only at extremely sharp angles </li>
</ul>
</p><p>
Merged semantics applies, i.e. polygons will be merged before the sizing is applied 
unless the layer was put into raw mode (see <a href="#raw">raw</a>). On output, the polygons are not
merged immediately, so it is possible to detect overlapping regions after a positive 
sizing using <a href="#raw">raw</a> and <a href="#merged">merged</a> with an overlap count, for example:
</p><p>
<pre>
layer.sized(300.nm).raw.merged(2)
</pre>
</p><p>
Bias values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
<a href="#size">size</a> is working like <a href="#sized">sized</a> but modifies the layer it is called on.
</p><p>
The following images show the effect of various forms of the "sized" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_sized1.png"/></td>
<td><img src="/images/drc_sized2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_sized3.png"/></td>
<td><img src="/images/drc_sized4.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_sized5.png"/></td>
<td><img src="/images/drc_sized6.png"/></td>
</tr>
</table>
</p>
<h2>"smoothed" - Smoothes the polygons of the region</h2>
<keyword name="smoothed"/>
<a name="smoothed"/><p>Usage:</p>
<ul>
<li><tt>layer.smoothed(d)</tt></li>
</ul>
<p>
"Smoothing" returns a simplified version of the polygons. Simplification is 
achieved by removing vertices unless the resulting polygon deviates by more
than the given distance d from the original polygon.
</p><p>
This method return a layer wit the modified polygons. Merged semantics applies for this
method (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<h2>"snap" - Brings each vertex on the given grid (g or gx/gy for x or y direction)</h2>
<keyword name="snap"/>
<a name="snap"/><p>Usage:</p>
<ul>
<li><tt>layer.snap(g)</tt></li>
<li><tt>layer.snap(gx, gy)</tt></li>
</ul>
<p>
Shifts each off-grid vertex to the nearest on-grid location. If one grid is given, this
grid is applied to x and y coordinates. If two grids are given, gx is applied to the x
coordinates and gy is applied to the y coordinates. If 0 is given as a grid, no snapping
is performed in that direction. 
</p><p>
This method modifies the layer. A version that returns a snapped version of the layer
without modifying the layer is <a href="#snapped">snapped</a>.
</p><p>
This method requires a polygon layer. Merged semantics applies (see <a href="#raw">raw</a> and <a href="#clean">clean</a>).
</p>
<h2>"snapped" - Returns a snapped version of the layer</h2>
<keyword name="snapped"/>
<a name="snapped"/><p>Usage:</p>
<ul>
<li><tt>layer.snapped(g)</tt></li>
<li><tt>layer.snapped(gx, gy)</tt></li>
</ul>
<p>
See <a href="#snap">snap</a> for a description of the functionality. In contrast to <a href="#snap">snap</a>, this method does
not modify the layer but returns a snapped copy.
</p>
<h2>"space" - A space check</h2>
<keyword name="space"/>
<a name="space"/><p>Usage:</p>
<ul>
<li><tt>layer.space(value [, options])</tt></li>
</ul>
<p>
This method performs a space check and returns a collection of edge pairs.
A space check can be performed on polygon and edge layers. On edge layers, all
edges are checked against all other edges. If two edges form a "face to face" relation
(i.e. their outer sides face each other) and their distance is less than the specified
value, an error shape is generated for that edge pair. 
On polygon layers, the polygons on each layer are checked for space against other polygons 
for locations where their space is less than the specified value. In that case, an edge 
pair error shape is generated.
The space check will also check the polygons for space violations against themselves, i.e.
notches violating the space condition are reported.
</p><p>
The <a href="#notch">notch</a> method is similar, but will only report self-space violations. The <a href="#isolated">isolated</a>
method will only report space violations to other polygons. <a href="#separation">separation</a> is a two-layer 
space check where space is checked against polygons of another layer.
</p><p>
The options available are the same than for the <a href="#width">width</a> method. Like for the <a href="#width">width</a> 
method, merged semantics applies.
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators.
</p><p>
The following image shows the effect of the space check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_space1.png"/></td>
</tr>
</table>
</p>
<h2>"start_segments" - Returns the part at the beginning of each edge</h2>
<keyword name="start_segments"/>
<a name="start_segments"/><p>Usage:</p>
<ul>
<li><tt>layer.start_segments(length)</tt></li>
<li><tt>layer.start_segments(length, fraction)</tt></li>
</ul>
<p>
This method will return a partial edge for each edge in the input, 
located and the end of the original edge.
The new edges will share the start point with the original edges, but not necessarily
their end points. For further details about the orientation of edges and the parameters
of this method, see <a href="#end_segments">end_segments</a>.
</p><p>
The following images show the effect of the method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_start_segments1.png"/></td>
<td><img src="/images/drc_start_segments2.png"/></td>
</tr>
</table>
</p>
<h2>"strict" - Marks a layer for strict handling</h2>
<keyword name="strict"/>
<a name="strict"/><p>Usage:</p>
<ul>
<li><tt>layer.strict</tt></li>
</ul>
<p>
If a layer is marked for strict handling, some optimizations 
are disabled. Specifically for boolean operations, the results
will also be merged if one input is empty. 
For boolean operations, strict handling should be enabled for both inputs.
Strict handling is disabled by default.
</p><p>
See <a href="#non_strict">non_strict</a> about how to reset this mode.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<h2>"strict?" - Returns true, if strict handling is enabled for this layer</h2>
<keyword name="strict?"/>
<a name="strict?"/><p>Usage:</p>
<ul>
<li><tt>layer.is_strict?</tt></li>
</ul>
<p>
See <a href="#strict">strict</a> for a discussion of strict handling.
</p><p>
This feature has been introduced in version 0.23.2.
</p>
<h2>"texts" - Selects texts from an original layer</h2>
<keyword name="texts"/>
<a name="texts"/><p>Usage:</p>
<ul>
<li><tt>layer.texts</tt></li>
<li><tt>layer.texts(p)</tt></li>
<li><tt>layer.texts([ options ])</tt></li>
</ul>
<p>
This method can be applied to original layers - i.e. ones that have
been created with <a href="#input">input</a>. By default, a small box (2x2 DBU) will be produced on each
selected text. By using the "as_dots" option, degenerated point-like edges will be
produced.
</p><p>
Texts can be selected either by exact match string or a pattern match with a 
glob-style pattern. By default, glob-style pattern are used. 
The options available are:
</p><p>
<ul>
<li><b>pattern(p) </b>: Use a pattern to match the string (this is the default) </li>
<li><b>text(s) </b>: Select the texts that exactly match the given string </li>
<li><b>as_boxes </b>: with this option, small boxes will be produced as markers </li>
<li><b>as_dots </b>: with this option, point-like edges will be produced instead of small boxes </li>
</ul>
</p><p>
Here are some examples:
</p><p>
<pre>
# Selects all texts
t = input(1, 0).texts
# Selects all texts beginning with an "A"
t = input(1, 0).texts("A*")
t = input(1, 0).texts(pattern("A*"))
# Selects all texts whose string is "A*"
t = input(1, 0).texts(text("A*"))
</pre>
</p>
<h2>"transform" - Transforms a layer (modifies the layer)</h2>
<keyword name="transform"/>
<a name="transform"/><p>Usage:</p>
<ul>
<li><tt>layer.transform(t)</tt></li>
</ul>
<p>
Like <a href="#transform">transform</a>, but modifies the input and returns a reference to it for
further processing.
</p>
<h2>"transformed" - Transforms a layer</h2>
<keyword name="transformed"/>
<a name="transformed"/><p>Usage:</p>
<ul>
<li><tt>layer.transformed(t)</tt></li>
</ul>
<p>
Transforms the input layer by the given transformation and returns
the moved layer. The layer that this method is called upon is not modified.
This is the most generic method is transform a layer. The transformation
is a <class_doc href="DCplxTrans">DCplxTrans</class_doc> object which describes many different kinds of affine transformations
except shear and anisotropic magnification.
</p><p>
The following image shows the effect of the "moved" method:
</p><p>
<table>
<tr>
<td><img src="/images/drc_moved1.png"/></td>
</tr>
</table>
</p>
<h2>"width" - A width check</h2>
<keyword name="width"/>
<a name="width"/><p>Usage:</p>
<ul>
<li><tt>layer.width(value [, options])</tt></li>
</ul>
<p>
This method performs a width check and returns a collection of edge pairs.
A width check can be performed on polygon and edge layers. On edge layers, all
edges are checked against all other edges. If two edges form a "back to back" relation
(i.e. their inner sides face each other) and their distance is less than the specified
value, an error shape is generated for that edge pair. 
On polygon layers, the polygons on each layer are checked for locations where their
width is less than the specified value. In that case, an edge pair error shape is generated.
</p><p>
The options available are:
</p><p>
<ul>
<li><b>euclidian </b>: perform the check using Euclidian metrics (this is the default) </li>
<li><b>square </b>: perform the check using Square metrics </li>
<li><b>projection </b>: perform the check using projection metrics </li>
<li><b>whole_edges </b>: With this option, the check will return all of the edges,
even if the criterion is violated only over a part of the edge </li>
<li><b>angle_limit(a) </b>: Specifies the angle above or equal to which no 
check is performed. The default value is 90, which means that for edges having 
an angle of 90 degree or more, no check is performed. Setting this value to 45 will
make the check only consider edges enclosing angles of less than 45 degree. </li>
<li><b>projection_limits(min, max) or projection_limits(min .. max) </b>:
this option makes the check only consider edge pairs whose projected length on
each other is more or equal than min and less than max </li>
</ul>
</p><p>
Note that without the angle_limit, acute corners will always be reported, since two 
connected edges always violate the width in the corner. By adjusting the angle_limit, an 
acute corner check can be implemented.
</p><p>
Merge semantics applies to this method, i.e. disconnected polygons are merged before the 
width is checked unless "raw" mode is chosen.
</p><p>
The resulting edge pairs can be converted to polygons using the <a href="#polygons">polygons</a> method.
</p><p>
Distance values can be given as floating-point values (in micron) or integer values (in
database units). To explicitly specify the unit, use the unit denominators, i.e.
</p><p>
<pre>
# width check for 1.5 micron:
markers = in.width(1.5)
# width check for 2 database units:
markers = in.width(2)
# width check for 2 micron:
markers = in.width(2.um)
# width check for 20 nanometers:
markers = in.width(20.nm)
</pre>
</p><p>
The following images show the effect of various forms of the width check:
</p><p>
<table>
<tr>
<td><img src="/images/drc_width1.png"/></td>
<td><img src="/images/drc_width2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_width3.png"/></td>
<td><img src="/images/drc_width4.png"/></td>
</tr>
</table>
</p>
<h2>"with_angle" - Selects edges by their angle</h2>
<keyword name="with_angle"/>
<a name="with_angle"/><p>Usage:</p>
<ul>
<li><tt>layer.with_angle(min .. max)</tt></li>
<li><tt>layer.with_angle(value)</tt></li>
<li><tt>layer.with_angle(min, max)</tt></li>
</ul>
<p>
When called on an edge layer, the method selects edges by their angle, 
measured against the horizontal axis in the mathematical sense. 
The first version selects
edges with a angle larger or equal to min and less than max (but not equal).
The second version selects edges with exactly the given angle. The third
version is identical to the first one. 
</p><p>
When called on a polygon layer, this method selects corners which match the 
given angle or is within the given angle interval. The angle is measured between the edges forming the corner.
For each corner, an edge pair containing the edges forming in the angle is returned.
</p><p>
A method delivering all objects not matching the angle criterion is <a href="#without_angle">without_angle</a>.
</p><p>
The following images demonstrate some use cases of <a href="#with_angle">with_angle</a> and <a href="#without_angle">without_angle</a>:
</p><p>
<table>
<tr>
<td><img src="/images/drc_with_angle1.png"/></td>
<td><img src="/images/drc_with_angle2.png"/></td>
</tr>
<tr>
<td><img src="/images/drc_with_angle3.png"/></td>
<td><img src="/images/drc_with_angle4.png"/></td>
</tr>
</table>
</p>
<h2>"with_area" - Selects polygons by area</h2>
<keyword name="with_area"/>
<a name="with_area"/><p>Usage:</p>
<ul>
<li><tt>layer.with_area(min .. max)</tt></li>
<li><tt>layer.with_area(value)</tt></li>
<li><tt>layer.with_area(min, max)</tt></li>
</ul>
<p>
The first form will select all polygons with an area larger or
equal to min and less (but not equal to) max. The second form
will select the polygons with exactly the given area.
The third form basically is equivalent to the first form, but
allows specification of nil for min or max indicating no lower or 
upper limit.
</p>
<h2>"with_bbox_height" - Selects polygons by the height of the bounding box</h2>
<keyword name="with_bbox_height"/>
<a name="with_bbox_height"/><p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_height(min .. max)</tt></li>
<li><tt>layer.with_bbox_height(value)</tt></li>
<li><tt>layer.with_bbox_height(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the width of the
bounding box. 
</p><p>
This method is available for polygon layers only.
</p>
<h2>"with_bbox_max" - Selects polygons by the maximum dimension of the bounding box</h2>
<keyword name="with_bbox_max"/>
<a name="with_bbox_max"/><p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_max(min .. max)</tt></li>
<li><tt>layer.with_bbox_max(value)</tt></li>
<li><tt>layer.with_bbox_max(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the maximum dimension of the
bounding box. The maximum dimension is either the width or height of 
the bounding box, whichever is larger.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"with_bbox_min" - Selects polygons by the minimum dimension of the bounding box</h2>
<keyword name="with_bbox_min"/>
<a name="with_bbox_min"/><p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_min(min .. max)</tt></li>
<li><tt>layer.with_bbox_min(value)</tt></li>
<li><tt>layer.with_bbox_min(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the minimum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is smaller.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"with_bbox_width" - Selects polygons by the width of the bounding box</h2>
<keyword name="with_bbox_width"/>
<a name="with_bbox_width"/><p>Usage:</p>
<ul>
<li><tt>layer.with_bbox_width(min .. max)</tt></li>
<li><tt>layer.with_bbox_width(value)</tt></li>
<li><tt>layer.with_bbox_width(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#with_area">with_area</a> or <a href="#with_perimeter">with_perimeter</a>.
However, the measured dimension is the width of the
bounding box. 
</p><p>
This method is available for polygon layers only.
</p>
<h2>"with_length" - Selects edges by their length</h2>
<keyword name="with_length"/>
<a name="with_length"/><p>Usage:</p>
<ul>
<li><tt>layer.with_length(min .. max)</tt></li>
<li><tt>layer.with_length(value)</tt></li>
<li><tt>layer.with_length(min, max)</tt></li>
</ul>
<p>
The method selects edges by their length. The first version selected
edges with a length larger or equal to min and less than max (but not equal).
The second version selects edges with exactly the given length. The third
version is similar to the first one, but allows specification of nil for min or
max indicating that there is no lower or upper limit. 
</p><p>
This method is available for edge layers only.
</p>
<h2>"with_perimeter" - Selects polygons by perimeter</h2>
<keyword name="with_perimeter"/>
<a name="with_perimeter"/><p>Usage:</p>
<ul>
<li><tt>layer.with_perimeter(min .. max)</tt></li>
<li><tt>layer.with_perimeter(value)</tt></li>
<li><tt>layer.with_perimeter(min, max)</tt></li>
</ul>
<p>
The first form will select all polygons with an perimeter larger or
equal to min and less (but not equal to) max. The second form
will select the polygons with exactly the given perimeter.
The third form basically is equivalent to the first form, but
allows specification of nil for min or max indicating no lower or 
upper limit.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_angle" - Selects edges by the their angle</h2>
<keyword name="without_angle"/>
<a name="without_angle"/><p>Usage:</p>
<ul>
<li><tt>layer.without_angle(min .. max)</tt></li>
<li><tt>layer.without_angle(value)</tt></li>
<li><tt>layer.without_angle(min, max)</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_angle">with_angle</a>. It selects all edges
of the edge layer or corners of the polygons which do not have the given angle (second form) or whose angle
is not inside the given interval (first and third form).
</p>
<h2>"without_area" - Selects polygons by area</h2>
<keyword name="without_area"/>
<a name="without_area"/><p>Usage:</p>
<ul>
<li><tt>layer.without_area(min .. max)</tt></li>
<li><tt>layer.without_area(value)</tt></li>
<li><tt>layer.without_area(min, max)</tt></li>
</ul>
<p>
This method is the inverse of "with_area". It will select 
polygons without an area equal to the given one or outside
the given interval.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_bbox_height" - Selects polygons by the height of the bounding box</h2>
<keyword name="without_bbox_height"/>
<a name="without_bbox_height"/><p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_height(min .. max)</tt></li>
<li><tt>layer.without_bbox_height(value)</tt></li>
<li><tt>layer.without_bbox_height(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the width of the
bounding box.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_bbox_max" - Selects polygons by the maximum dimension of the bounding box</h2>
<keyword name="without_bbox_max"/>
<a name="without_bbox_max"/><p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_max(min .. max)</tt></li>
<li><tt>layer.without_bbox_max(value)</tt></li>
<li><tt>layer.without_bbox_max(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the maximum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is larger.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_bbox_min" - Selects polygons by the minimum dimension of the bounding box</h2>
<keyword name="without_bbox_min"/>
<a name="without_bbox_min"/><p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_min(min .. max)</tt></li>
<li><tt>layer.without_bbox_min(value)</tt></li>
<li><tt>layer.without_bbox_min(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the minimum dimension of the
bounding box. The minimum dimension is either the width or height of 
the bounding box, whichever is smaller.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_bbox_width" - Selects polygons by the width of the bounding box</h2>
<keyword name="without_bbox_width"/>
<a name="without_bbox_width"/><p>Usage:</p>
<ul>
<li><tt>layer.without_bbox_width(min .. max)</tt></li>
<li><tt>layer.without_bbox_width(value)</tt></li>
<li><tt>layer.without_bbox_width(min, max)</tt></li>
</ul>
<p>
The method selects polygons similar to <a href="#without_area">without_area</a> or <a href="#without_perimeter">without_perimeter</a>.
However, the measured dimension is the width of the
bounding box.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"without_length" - Selects edges by the their length</h2>
<keyword name="without_length"/>
<a name="without_length"/><p>Usage:</p>
<ul>
<li><tt>layer.without_length(min .. max)</tt></li>
<li><tt>layer.without_length(value)</tt></li>
<li><tt>layer.without_length(min, max)</tt></li>
</ul>
<p>
The method basically is the inverse of <a href="#with_length">with_length</a>. It selects all edges
of the edge layer which do not have the given length (second form) or are
not inside the given interval (first and third form).
</p><p>
This method is available for edge layers only.
</p>
<h2>"without_perimeter" - Selects polygons by perimeter</h2>
<keyword name="without_perimeter"/>
<a name="without_perimeter"/><p>Usage:</p>
<ul>
<li><tt>layer.without_perimeter(min .. max)</tt></li>
<li><tt>layer.without_perimeter(value)</tt></li>
<li><tt>layer.without_perimeter(min, max)</tt></li>
</ul>
<p>
This method is the inverse of "with_perimeter". It will select 
polygons without a perimeter equal to the given one or outside
the given interval.
</p><p>
This method is available for polygon layers only.
</p>
<h2>"xor" - Boolean XOR operation</h2>
<keyword name="xor"/>
<a name="xor"/><p>Usage:</p>
<ul>
<li><tt>layer.xor(other)</tt></li>
</ul>
<p>
The method computes a boolean XOR between self and other.
It is an alias for the "^" operator.
</p><p>
This method is available for polygon and edge layers.
</p><p>
The following images show the effect of the "xor" method
on polygons and edges (layer1: red, layer2: blue):
</p><p>
<table>
<tr>
<td><img src="/images/drc_xor1.png"/></td>
<td><img src="/images/drc_xor2.png"/></td>
</tr>
</table>
</p>
<h2>"|" - Boolean OR operation</h2>
<keyword name="|"/>
<a name="|"/><p>Usage:</p>
<ul>
<li><tt>self | other</tt></li>
</ul>
<p>
The method computes a boolean OR between self and other. A similar
operation is <a href="#join">join</a> which will basically gives the same result but
won't merge the shapes.
</p><p>
This method is available for polygon and edge layers. An alias
is "<a href="#or">or</a>". See there for a description of the function.
</p>
</doc>
