<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Netter object</title>
<keyword name="Netter"/>
<p>
The Netter object provides services related to network extraction
from a layout. The relevant methods of this object are available
as global functions too where they act on a default incarnation
of the netter. Usually it's not required to instantiate a Netter
object, but it serves as a container for this functionality.
</p><p>
An individual netter object can be created, if the netter results
need to be kept for multiple extractions. If you really need
a Netter object, use the global <a href="#netter">netter</a> function:
</p><p>
<pre>
# create a new Netter object:
nx = netter
nx.connect(poly, contact)
...
</pre>
</p><p>
Network formation:
</p><p>
A basic Service the Netter object provides is the formation of 
connected networks of conductive shapes. To do so, the Netter
must be given a connection specification. This happens by calling
"connect" with two polygon layers. The Netter will then regard all
overlaps of shapes on these layers as connections between the
respective materials. Networks are the basis for netlist extraction,
network geometry deduction and the antenna check.
</p><p>
Connections can be cleared with "clear_connections". If not, 
connections add atop of the already defined ones. Here is an 
example for the antenna check:
</p><p>
<pre>
# build connction of poly+gate to metal1
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)

# runs an antenna check for metal1 with a ratio of 50
m1_antenna_errors = antenna_check(gate, metal1, 50.0)

# add connections to metal2
connect(metal1, via1)
connect(via1, metal2)

# runs an antenna check for metal2 with a ratio of 70.0
m2_antenna_errors = antenna_check(gate, metal2, 70.0)

# this will remove all connections made
clear_connections
...
</pre>
</p><p>
Further functionality of the Netter object:
</p><p>
More methods will be added in the future to support network-related features.
</p>
<h2-index/>
<h2>"antenna_check" - Performs an antenna check</h2>
<keyword name="antenna_check"/>
<a name="antenna_check"/><p>Usage:</p>
<ul>
<li><tt>antenna_check(gate, metal, ratio, [ diode_specs ... ])</tt></li>
</ul>
<p>
The antenna check is used to avoid plasma induced damage. Physically, 
the damage happes if during the manufacturing of a metal layer with
plasma etching charge accumulates on the metal islands. On reaching a
certain threshold, this charge may discarge over gate oxide attached of 
devices attached to such metal areas hence damaging it.
</p><p>
Antenna checks are performed by collecting all connected nets up to
a certain metal layer and then computing the area of all metal shapes
and all connected gates of a certain kind (e.g. thin and thick oxide gates).
The ratio of metal area divided by the gate area must not exceed a certain
threshold.
</p><p>
A simple antenna check is this:
</p><p>
<pre>
poly = ... # poly layer
diff = ... # diffusion layer
contact = ... # contact layer
metal1 = ... # metal layer

# compute gate area
gate = poly &amp; diff

# note that gate and poly have to be included - gate is
# a subset of poly, but forms the sensitive area
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)
errors = antenna_check(gate, metal1, 50.0)
</pre>
</p><p>
Plasma induced damage can be rectified by including diodes
which create a safe current path for discharging the metal
islands. Such diodes can be identified with a recognition layer
(usually the diffusion area of a certain kind). You can include
such diode recognition layers in the antenna check. If a connection
is detected to a diode, the respective network is skipped:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
errors = antenna_check(gate, metal1, 50.0, diode)
</pre>
</p><p>
You can also make diode connections decreases the
sensitivity of the antenna check depending on the size
of the diode. The following specification makes 
diode connections increase the ratio threshold by
10 per square micrometer of diode area:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
# each square micrometer of diode area connected to a network
# will add 10 to the ratio:
errors = antenna_check(gate, metal1, 50.0, [ diode, 10.0 ])
</pre>
</p><p>
Multiple diode specifications are allowed. Just add them 
to the antenna_check call.
</p><p>
The error shapes produced by the antenna check are copies
of the metal shapes on the metal layers of each network 
violating the antenna rule.
</p>
<h2>"clear_connections" - Clears all connections stored so far</h2>
<keyword name="clear_connections"/>
<a name="clear_connections"/><p>Usage:</p>
<ul>
<li><tt>clear_connections</tt></li>
</ul>
<p>
See <a href="#connect">connect</a> for more details.
</p>
<h2>"connect" - Specifies a connection between two layers</h2>
<keyword name="connect"/>
<a name="connect"/><p>Usage:</p>
<ul>
<li><tt>connect(a, b)</tt></li>
</ul>
<p>
a and b must be polygon layers. After calling this function, the
Netter regards all overlapping or touching shapes on these layers
to form an electrical connection between the materials formed by
these layers. This also implies intra-layer connections: shapes
on these layers touching or overlapping other shapes on these
layers will form bigger, electrically connected areas.
</p><p>
Multiple connect calls must be made to form larger connectivity
stacks across multiple layers. Such stacks may include forks and
joins.
</p><p>
Connections are accumulated. The connections defined so far
can be cleared with <a href="#clear_connections">clear_connections</a>.
</p>
<h2>"connect_global" - Connects a layer with a global net</h2>
<keyword name="connect_global"/>
<a name="connect_global"/><p>Usage:</p>
<ul>
<li><tt>connect_global(l, name)</tt></li>
</ul>
<p>
Connects the shapes from the given layer l to a global net with the given name.
Global nets are common to all cells. Global nets automatically connect to parent
cells throughs implied pins. An example is the substrate (bulk) net which connects
to shapes belonging to tie-down diodes.
</p>
<h2>"extract_devices" - Extracts devices based on the given extractor class, name and device layer selection</h2>
<keyword name="extract_devices"/>
<a name="extract_devices"/><p>Usage:</p>
<ul>
<li><tt>extract_devices(extractor, layer_hash)</tt></li>
</ul>
<p>
Runs the device extraction for given device extractor class.
</p><p>
The device extractor is either an instance of one of the predefined extractor
classes (e.g. <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc>) or a custom class. It provides the
algorithms for deriving the device parameters from the device geometry. It needs 
several device recognition layers which are passed in the layer hash.
</p><p>
Each device class (e.g. n-MOS/p-MOS or high Vt/low Vt) needs it's own instance
of device extractor. The device extractor beside the algorithm and specific 
extraction settings defines the name of the device to be built.
</p><p>
The layer hash is a map of device type specific functional names (key) and
polygon layers (value). Here is an example:
</p><p>
<pre>
deep

nwell   = input(1, 0)
active  = input(2, 0)
poly    = input(3, 0)
bulk    = make_layer   # renders an empty layer used for putting the terminals on

nactive = active - nwell      # active area of NMOS
nsd     = nactive - poly      # source/drain area
gate    = nactive &amp; poly  # gate area

mos4_ex = <class_doc href="DeviceExtractorMOS4Transistor">DeviceExtractorMOS4Transistor</class_doc>::new("NMOS4")
extract_devices(mos4_ex, { :SD =&gt; nsd, :G =&gt; gate, :P =&gt; poly, :W =&gt; bulk })
</pre>
</p>
<h2>"join_nets" - Specifies a search pattern for labels which create implicit net connections</h2>
<keyword name="join_nets"/>
<a name="join_nets"/><p>Usage:</p>
<ul>
<li><tt>join_nets(label_pattern)</tt></li>
</ul>
<p>
Use this method to supply a glob pattern for labels which create implicit net connections
on the top level circuit. This feature is useful to connect identically labelled nets
while a component isn't integrated yet. If the component is integrated, net may be connected
on a higher hierarchy level - e.g. by a power mesh. Inside the component this net consists
of individual islands. To properly perform netlist extraction and comparison, these islands
need to be connected even though there isn't a physical connection. "join_nets" can
achive this if these islands are labelled with the same text on the top level of the
component.
</p><p>
Glob pattern are used which resemble shell file pattern: "*" is for all labels, "VDD"
for all "VDD" labels (pattern act case sensitive). "VDD*" is for all labels beginning
with "VDD" (still different labels will be connected to different nets!). "{VDD,VSS}"
is either "VDD" or "VSS".
</p><p>
The search pattern is applied on the next net extraction. The search pattern is cleared
on "clear_connections".
</p>
<h2>"l2n_data" - Gets the internal <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object</h2>
<keyword name="l2n_data"/>
<a name="l2n_data"/><p>Usage:</p>
<ul>
<li><tt>l2n_data</tt></li>
</ul>
<p>
The <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object provides access to the internal details of
the netter object.
</p>
</doc>
