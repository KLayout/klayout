<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master/scripts/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Netter object</title>
<keyword name="Netter"/>
<p>
The Netter object provides services related to network extraction
from a layout. The relevant methods of this object are available
as global functions too where they act on a default incarnation
of the netter. Usually it's not required to instantiate a Netter
object, but it serves as a container for this functionality.
</p><p>
<pre>
# create a new Netter object:
nx = netter
nx.connect(poly, contact)
...
</pre>
</p><p>
Network formation:
</p><p>
A basic service the Netter object provides is the formation of 
connected networks of conductive shapes (netting). To do so, the Netter
must be given a connection specification. This happens by calling
"connect" with two polygon layers. The Netter will then regard all
overlaps of shapes on these layers as connections between the
respective materials. Networks are the basis for netlist extraction,
network geometry deduction and the antenna check.
</p><p>
Connections can be cleared with "clear_connections". If not, 
connections add atop of the already defined ones. Here is an 
example for the antenna check:
</p><p>
<pre>
# build connction of poly+gate to metal1
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)

# runs an antenna check for metal1 with a ratio of 50
m1_antenna_errors = antenna_check(gate, metal1, 50.0)

# add connections to metal2
connect(metal1, via1)
connect(via1, metal2)

# runs an antenna check for metal2 with a ratio of 70.0
m2_antenna_errors = antenna_check(gate, metal2, 70.0)

# this will remove all connections made
clear_connections
...
</pre>
</p><p>
Further functionality of the Netter object:
</p><p>
More methods will be added in the future to support network-related features.
</p>
<h2-index/>
<a name="antenna_check"/><h2>"antenna_check" - Performs an antenna check</h2>
<keyword name="antenna_check"/>
<p>Usage:</p>
<ul>
<li><tt>antenna_check(gate, metal, ratio, [ diode_specs ... ])</tt></li>
</ul>
<p>
The antenna check is used to avoid plasma induced damage. Physically, 
the damage happes if during the manufacturing of a metal layer with
plasma etching charge accumulates on the metal islands. On reaching a
certain threshold, this charge may discarge over gate oxide attached of 
devices attached to such metal areas hence damaging it.
</p><p>
Antenna checks are performed by collecting all connected nets up to
a certain metal layer and then computing the area of all metal shapes
and all connected gates of a certain kind (e.g. thin and thick oxide gates).
The ratio of metal area divided by the gate area must not exceed a certain
threshold.
</p><p>
A simple antenna check is this:
</p><p>
<pre>
poly = ... # poly layer
diff = ... # diffusion layer
contact = ... # contact layer
metal1 = ... # metal layer

# compute gate area
gate = poly &amp; diff

# note that gate and poly have to be included - gate is
# a subset of poly, but forms the sensitive area
connect(gate, poly)
connect(poly, contact)
connect(contact, metal1)
errors = antenna_check(gate, metal1, 50.0)
</pre>
</p><p>
Plasma induced damage can be rectified by including diodes
which create a safe current path for discharging the metal
islands. Such diodes can be identified with a recognition layer
(usually the diffusion area of a certain kind). You can include
such diode recognition layers in the antenna check. If a connection
is detected to a diode, the respective network is skipped:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
errors = antenna_check(gate, metal1, 50.0, diode)
</pre>
</p><p>
You can also make diode connections decreases the
sensitivity of the antenna check depending on the size
of the diode. The following specification makes 
diode connections increase the ratio threshold by
10 per square micrometer of diode area:
</p><p>
<pre>
...
diode = ... # diode recognition layer

connect(diode, contact)
# each square micrometer of diode area connected to a network
# will add 10 to the ratio:
errors = antenna_check(gate, metal1, 50.0, [ diode, 10.0 ])
</pre>
</p><p>
Multiple diode specifications are allowed. Just add them 
to the antenna_check call.
</p><p>
You can include the perimeter into the area computation for
the gate or metal layer or both. The physical picture
is this: the side walls of the material contribute to the 
surface too. As the side wall area can be estimated by taking
the perimeter times some material thickness, the effective 
area is: 
</p><p>
<pre>
A(eff) = A + P * t
</pre>
</p><p>
Here A is the area of the polygons and P is their perimeter.
t is the "thickness" in micrometer units. To specify such
a condition, use the following notation:
</p><p>
<pre>
errors = antenna_check(area_and_perimeter(gate, 0.5), ...)
</pre>
</p><p>
"area_and_perimeter" takes the polygon layer and the 
thickness (0.5 micrometers in this case). 
This notation can be applied to both gate and
metal layers. A detailed notation for the usual,
area-only case is available as well for completeness:
</p><p>
<pre>
errors = antenna_check(area_only(gate), ...)

# this is equivalent to a zero thickness:
errors = antenna_check(area_and_perimeter(gate, 0.0), ...)
# or the standard case:
errors = antenna_check(gate, ...)
</pre>
</p><p>
The error shapes produced by the antenna check are copies
of the metal shapes on the metal layers of each network 
violating the antenna rule.
</p>
<a name="clear_connections"/><h2>"clear_connections" - Clears all connections stored so far</h2>
<keyword name="clear_connections"/>
<p>Usage:</p>
<ul>
<li><tt>clear_connections</tt></li>
</ul>
<p>
See <a href="#connect">connect</a> for more details.
</p>
<a name="connect"/><h2>"connect" - Specifies a connection between two layers</h2>
<keyword name="connect"/>
<p>Usage:</p>
<ul>
<li><tt>connect(a, b)</tt></li>
</ul>
<p>
a and b must be polygon or text layers. After calling this function, the
Netter regards all overlapping or touching shapes on these layers
to form an electrical connection between the materials formed by
these layers. This also implies intra-layer connections: shapes
on these layers touching or overlapping other shapes on these
layers will form bigger, electrically connected areas.
</p><p>
Texts will be used to assign net names to the nets. The preferred
method is to use <a href="#labels">labels</a> to create a text layer from a design 
layer. When using <a href="#input">input</a>, text labels are carried implicitly
with the polygons but at the cost of small dummy shapes (2x2 DBU
marker polygons) and limited functionality.
</p><p>
Multiple connect calls must be made to form larger connectivity
stacks across multiple layers. Such stacks may include forks and
joins.
</p><p>
Connections are accumulated. The connections defined so far
can be cleared with <a href="#clear_connections">clear_connections</a>.
</p>
<a name="connect_global"/><h2>"connect_global" - Connects a layer with a global net</h2>
<keyword name="connect_global"/>
<p>Usage:</p>
<ul>
<li><tt>connect_global(l, name)</tt></li>
</ul>
<p>
Connects the shapes from the given layer l to a global net with the given name.
Global nets are common to all cells. Global nets automatically connect to parent
cells throughs implied pins. An example is the substrate (bulk) net which connects
to shapes belonging to tie-down diodes. "l" can be a polygon or text layer.
</p>
<a name="connect_implicit"/><h2>"connect_implicit" - Specifies a search pattern for labels which create implicit net connections</h2>
<keyword name="connect_implicit"/>
<p>Usage:</p>
<ul>
<li><tt>connect_implicit(label_pattern)</tt></li>
<li><tt>connect_implicit(cell_pattern, label_pattern)</tt></li>
</ul>
<p>
Use this method to supply label strings which create implicit net connections
on the top level circuit in the first version. This feature is useful to connect identically labelled nets
while a component isn't integrated yet. If the component is integrated, nets may be connected
on a higher hierarchy level - e.g. by a power mesh. Inside the component this net consists
of individual islands. To properly perform netlist extraction and comparison, these islands
need to be connected even though there isn't a physical connection. "connect_implicit" can
achive this if these islands are labelled with the same text on the top level of the
component.
</p><p>
In the second version, the pattern can be specified for a cell range (given by a cell name pattern or a 
single cell name). These pattern are applied to non-top cells. The unspecific pattern
has priority over the cell-specific ones. As the cell selector is a pattern itself, a
single cell may fall into more than one category. In this case, the label filters are
combined.
</p><p>
The implicit connections are applied on the next net extraction and cleared
on "clear_connections".
</p>
<a name="device_scaling"/><h2>"device_scaling" - Specifies a dimension scale factor for the geometrical device properties</h2>
<keyword name="device_scaling"/>
<p>Usage:</p>
<ul>
<li><tt>device_scaling(factor)</tt></li>
</ul>
<p>
Specifying a factor of 2 will make all devices being extracted as if the 
geometries were two times larger. This feature is useful when the drawn layout
does not correspond to the physical dimensions.
</p>
<a name="extract_devices"/><h2>"extract_devices" - Extracts devices based on the given extractor class, name and device layer selection</h2>
<keyword name="extract_devices"/>
<p>Usage:</p>
<ul>
<li><tt>extract_devices(extractor, layer_hash)</tt></li>
<li><tt>extract_devices(extractor_class, name, layer_hash)</tt></li>
</ul>
<p>
Runs the device extraction for given device extractor class. In the first
form, the extractor object is given. In the second form, the extractor's
class object and the new extractor's name is given.
</p><p>
The device extractor is either an instance of one of the predefined extractor
classes (e.g. obtained from the utility methods such as <a href="/about/drc_ref_global.xml#mos4">global#mos4</a>) or a custom class. 
It provides the
algorithms for deriving the device parameters from the device geometry. It needs 
several device recognition layers which are passed in the layer hash.
</p><p>
Predefined device extractors are:
</p><p>
<ul>
<li><a href="/about/drc_ref_global.xml#mos3">global#mos3</a> - A three-terminal MOS transistor </li>
<li><a href="/about/drc_ref_global.xml#mos4">global#mos4</a> - A four-terminal MOS transistor </li>
<li><a href="/about/drc_ref_global.xml#dmos3">global#dmos3</a> - A three-terminal MOS asymmetric transistor </li>
<li><a href="/about/drc_ref_global.xml#dmos4">global#dmos4</a> - A four-terminal MOS asymmetric transistor </li>
<li><a href="/about/drc_ref_global.xml#bjt3">global#bjt3</a> - A three-terminal bipolar transistor </li>
<li><a href="/about/drc_ref_global.xml#bjt4">global#bjt4</a> - A four-terminal bipolar transistor </li>
<li><a href="/about/drc_ref_global.xml#diode">global#diode</a> - A planar diode </li>
<li><a href="/about/drc_ref_global.xml#resistor">global#resistor</a> - A resistor </li>
<li><a href="/about/drc_ref_global.xml#resistor_with_bulk">global#resistor_with_bulk</a> - A resistor with a separate bulk terminal </li>
<li><a href="/about/drc_ref_global.xml#capacitor">global#capacitor</a> - A capacitor </li>
<li><a href="/about/drc_ref_global.xml#capacitor_with_bulk">global#capacitor_with_bulk</a> - A capacitor with a separate bulk terminal </li>
</ul>
</p><p>
Each device class (e.g. n-MOS/p-MOS or high Vt/low Vt) needs it's own instance
of device extractor. The device extractor beside the algorithm and specific 
extraction settings defines the name of the device to be built.
</p><p>
The layer hash is a map of device type specific functional names (key) and
polygon layers (value). Here is an example:
</p><p>
<pre>
deep

nwell   = input(1, 0)
active  = input(2, 0)
poly    = input(3, 0)
bulk    = make_layer   # renders an empty layer used for putting the terminals on

nactive = active - nwell  # active area of NMOS
nsd     = nactive - poly  # source/drain area
gate    = nactive &amp; poly  # gate area

extract_devices(mos4("NMOS4"), { :SD =&gt; nsd, :G =&gt; gate, :P =&gt; poly, :W =&gt; bulk })
</pre>
</p>
<a name="l2n_data"/><h2>"l2n_data" - Gets the internal <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object</h2>
<keyword name="l2n_data"/>
<p>Usage:</p>
<ul>
<li><tt>l2n_data</tt></li>
</ul>
<p>
The <class_doc href="LayoutToNetlist">LayoutToNetlist</class_doc> object provides access to the internal details of
the netter object.
</p>
<a name="netlist"/><h2>"netlist" - Gets the extracted netlist or triggers extraction if not done yet</h2>
<keyword name="netlist"/>
<p>Usage:</p>
<ul>
<li><tt>netlist</tt></li>
</ul>
<p>
If no extraction has been performed yet, this method will start the 
layout analysis. Hence, all <a href="#connect">connect</a>, <a href="#connect_global">connect_global</a> and <a href="#connect_implicit">connect_implicit</a>
calls must have been made before this method is used. Further <a href="#connect">connect</a>
statements will clear the netlist and re-extract it again.
</p>
</doc>
