<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE language SYSTEM "klayout_doc.dtd">

<!-- generated by /home/matthias/klayout/master2/scripts/drc_lvs_doc/extract_doc.rb  -->
<!-- DO NOT EDIT! -->

<doc>
<title>DRC Reference: Source Object</title>
<keyword name="Source"/>
<p>
The layer object represents a collection of polygons, edges or edge pairs.
A source specifies where to take layout from. That includes the actual layout,
the top cell and options such as clip/query boxes, cell filters etc.
</p>
<h2-index/>
<a name="cell"/><h2>"cell" - Specifies input from a specific cell</h2>
<keyword name="cell"/>
<p>Usage:</p>
<ul>
<li><tt>source.cell(name)</tt></li>
</ul>
<p>
This method will create a new source that delivers shapes from the 
specified cell. 
</p>
<a name="cell_name"/><h2>"cell_name" - Returns the name of the currently selected cell</h2>
<keyword name="cell_name"/>
<p>Usage:</p>
<ul>
<li><tt>cell_name</tt></li>
</ul>
<a name="cell_obj"/><h2>"cell_obj" - Returns the <class_doc href="Cell">Cell</class_doc> object of the currently selected cell</h2>
<keyword name="cell_obj"/>
<p>Usage:</p>
<ul>
<li><tt>cell_obj</tt></li>
</ul>
<a name="clip"/><h2>"clip" - Specifies clipped input</h2>
<keyword name="clip"/>
<p>Usage:</p>
<ul>
<li><tt>source.clip(box)</tt></li>
<li><tt>source.clip(p1, p2)</tt></li>
<li><tt>source.clip(l, b, r, t)</tt></li>
</ul>
<p>
Creates a source which represents a rectangular part of the 
original input. Three ways are provided to specify the rectangular
region: a single <class_doc href="DBox">DBox</class_doc> object (micron units), two <class_doc href="DPoint">DPoint</class_doc>
objects (lower/left and upper/right coordinate in micron units)
or four coordinates: left, bottom, right and top coordinate.
</p><p>
This method will create a new source which delivers the shapes
from that region clipped to the rectangle. A method doing the 
same but without clipping is <a href="#touching">touching</a> or <a href="#overlapping">overlapping</a>.
</p>
<a name="edge_pairs"/><h2>"edge_pairs" - Gets the edge pairs from an input layer</h2>
<keyword name="edge_pairs"/>
<p>Usage:</p>
<ul>
<li><tt>source.edge_pairs</tt></li>
<li><tt>source.edge_pairs(layer)</tt></li>
<li><tt>source.edge_pairs(layer, datatype)</tt></li>
<li><tt>source.edge_pairs(layer_info)</tt></li>
<li><tt>source.edge_pairs(filter, ...)</tt></li>
</ul>
<p>
Creates a layer with the edge_pairs from the given layer of the source.
Edge pairs are not supported by layout formats so far. So except if the source is
a custom-built layout object, this method has little use. It is provided for future 
extensions which may include edge pairs in file streams.
</p><p>
This method is identical to <a href="#input">input</a> with respect to the options supported.
</p><p>
Use the global version of "edge_pairs" without a source object to address the default source.
</p><p>
"edge_pairs" without any arguments will create a new, empty original layer.
</p><p>
This method has been introduced in version 0.27.
</p>
<a name="edges"/><h2>"edges" - Gets the edge shapes (or shapes that can be converted edges) from an input layer</h2>
<keyword name="edges"/>
<p>Usage:</p>
<ul>
<li><tt>source.edges</tt></li>
<li><tt>source.edges(layer)</tt></li>
<li><tt>source.edges(layer, datatype)</tt></li>
<li><tt>source.edges(layer_info)</tt></li>
<li><tt>source.edges(filter, ...)</tt></li>
</ul>
<p>
Creates a layer with the edges from the given layer of the source.
Edge layers are formed from shapes by decomposing the shapes into edges: polygons
for example are decomposed into their outline edges. Some file formats support egdes
as native objects. 
</p><p>
This method is identical to <a href="#input">input</a> with respect to the options supported.
</p><p>
Use the global version of "edges" without a source object to address the default source.
</p><p>
"edges" without any arguments will create a new, empty original layer.
</p><p>
This method has been introduced in version 0.27.
</p>
<a name="extent"/><h2>"extent" - Returns a layer with the bounding box of the selected layout or cells</h2>
<keyword name="extent"/>
<p>Usage:</p>
<ul>
<li><tt>source.extent</tt></li>
<li><tt>source.extent(cell_filter)</tt></li>
</ul>
<p>
Without an argument, the extent method returns a layer with the bounding box
of the top cell. With a cell filter argument, the method returns a layer
with the bounding boxes of the selected cells. The cell filter is a glob
pattern.
</p><p>
The extent function is useful to invert a layer:
</p><p>
<pre>
inverse_1 = extent.sized(100.0) - input(1, 0)
</pre>
</p><p>
The following example returns the bounding boxes of all cells whose
names start with "A":
</p><p>
<pre>
a_cells = extent("A*")
</pre>
</p>
<a name="global_transform"/><h2>"global_transform" - Gets or sets a global transformation</h2>
<keyword name="global_transform"/>
<p>Usage:</p>
<ul>
<li><tt>global_transform</tt></li>
<li><tt>global_transform([ transformations ])</tt></li>
</ul>
<p>
This method returns a new source representing the transformed layout. It is provided in the spritit of 
<a href="/about/drc_ref_source.xml#clip">Source#clip</a> and similar methods.
</p><p>
The transformation
is either given as a <class_doc href="DTrans">DTrans</class_doc>, <class_doc href="DVector">DVector</class_doc> or <class_doc href="DCplxTrans">DCplxTrans</class_doc> object or as one of the 
following specifications:
</p><p>
<ul>
<li>"shift(x, y)": shifts the input layout horizontally by x and vertically by y micrometers </li>
<li>"rotate(a)": rotates the input layout by a degree counter-clockwise </li>
<li>"magnify(m)": magnifies the input layout by the factor m (NOTE: using fractional scale factors may result in small gaps due to grid snapping) </li>
<li>"mirror_x": mirrors the input layout at the x axis </li>
<li>"mirror_y": mirrors the input layout at the y axis </li>
</ul>
</p><p>
Multiple transformation specs can be given. In that case the transformations are applied right to left.
Using "global_transform" will reset any global transformation present already.
Without an argument, the global transformation is reset.
</p><p>
The following example rotates the layout by 90 degree at the origin (0, 0) and then shifts it up by 
100 micrometers:
</p><p>
<pre>
source.global_transform(shift(0, 100.um), rotate(90.0))
</pre>
</p>
<a name="input"/><h2>"input" - Specifies input from a source</h2>
<keyword name="input"/>
<p>Usage:</p>
<ul>
<li><tt>source.input</tt></li>
<li><tt>source.input(layer)</tt></li>
<li><tt>source.input(layer, datatype)</tt></li>
<li><tt>source.input(layer_info)</tt></li>
<li><tt>source.input(filter, ...)</tt></li>
<li><tt>source.input(props_spec, ...)</tt></li>
</ul>
<p>
Creates a layer with the shapes from the given layer of the source.
The layer can be specified by layer and optionally datatype, by a <class_doc href="LayerInfo">LayerInfo</class_doc>
object or by a sequence of filters. 
Filters are expressions describing ranges
of layers and/or datatype numbers or layer names. Multiple filters
can be given and all layers matching at least one of these filter
expressions are joined to render the input layer for the DRC engine.
For the syntax of the filter expressions see <class_doc href="LayerMap#map">LayerMap#map</class_doc> (look for
the version that uses a map expression).
</p><p>
Some filter expressions are:
</p><p>
<ul>
<li><tt>1/0-255 </tt>: Datatypes 0 to 255 for layer 1 </li>
<li><tt>1/* </tt>: All datatypes for layer 1 </li>
<li><tt>1/0,5,10 </tt>: Datatypes 0, 5 and 10 for layer 1 </li>
<li><tt>1/0;2/17 </tt>: Layer 1, datatype 0 and layer 2, datatype 17 </li>
<li><tt>1-10 </tt>: Layers 1 to 10, datatype 0 </li>
<li><tt>METAL </tt>: A layer named "METAL" </li>
<li><tt>METAL;VIA </tt>: A layer named "METAL" and the layer named "VIA" </li>
<li><tt>METAL;17/0 </tt>: A layer named "METAL" and layer 17, datatype 0 </li>
<li><tt>'17' </tt>: A layer named "17". Note the quotes which indicate a string, not a layer number </li>
</ul>
</p><p>
Layers created with "input" may contain both texts (labels) and polygons. There is a subtle
difference between flat and deep mode: in flat mode, texts are not visible in polygon
operations. In deep mode, texts appear as small 2x2 DBU rectangles. In flat mode, 
some operations such as clipping are not fully supported for texts. Also, texts will
vanish in most polygon operations such as booleans etc.
</p><p>
Texts can later be selected on the layer returned by "input" with the <a href="/about/drc_ref_layer.xml#texts">Layer#texts</a> method.
</p><p>
If you don't want to see texts, use <a href="#polygons">polygons</a> to create an input layer with polygon data
only. If you only want to see texts, use <a href="#labels">labels</a> to create an input layer with texts only.
</p><p>
<a href="#labels">labels</a> also produces a true "text layer" which contains text objects. A variety of 
operations is available for these objects, such as boolean "and" and "not" with a polygon layer.
True text layers should be preferred over mixed polygon/text layers if text object processing
is required.
</p><p>
"input" without any arguments will create a new, empty original layer.
</p><p>
If you want to use user properties - for example with properties constraints in DRC checks -
you need to enable properties on input:
</p><p>
<pre>
input1_with_props = input(1, 0, enable_props)
</pre>
</p><p>
You can also filter or map property keys, similar to the functions available on
layers (<a href="/about/drc_ref_drclayer.xml#map_props">DRCLayer#map_props</a>, <a href="/about/drc_ref_drclayer.xml#select_props">DRCLayer#select_props</a>). For example to select
property values with key 17 (numerical) only, use:
</p><p>
<pre>
input1_with_props = input(1, 0, select_props(17))
</pre>
</p><p>
Use the global version of "input" without a source object to address the default source.
</p>
<a name="labels"/><h2>"labels" - Gets the labels (texts) from an input layer</h2>
<keyword name="labels"/>
<p>Usage:</p>
<ul>
<li><tt>source.labels</tt></li>
<li><tt>source.labels(layer)</tt></li>
<li><tt>source.labels(layer, datatype)</tt></li>
<li><tt>source.labels(layer_info)</tt></li>
<li><tt>source.labels(filter, ...)</tt></li>
</ul>
<p>
Creates a true text layer with the labels from the given layer of the source.
</p><p>
This method is identical to <a href="#input">input</a>, but takes only texts from the given input
layer. Starting with version 0.27, the result is no longer a polygon layer that tries
to provide text support but a layer type which is provided for carrying text objects
explicitly.
</p><p>
"labels" without any arguments will create a new, empty original layer.
</p><p>
Use the global version of "labels" without a source object to address the default source.
</p>
<a name="layers"/><h2>"layers" - Gets the layers the source contains</h2>
<keyword name="layers"/>
<p>Usage:</p>
<ul>
<li><tt>source.layers</tt></li>
</ul>
<p>
Delivers a list of <class_doc href="LayerInfo">LayerInfo</class_doc> objects representing the layers
inside the source.
</p><p>
One application is to read all layers from a source. In the following
example, the "and" operation is used to perform a clip with the given
rectangle. Note that this solution is not efficient - it's provided
as an example only:
</p><p>
<pre>
output_cell("Clipped")

clip_box = polygon_layer
clip_box.insert(box(0.um, -4.um, 4.um, 0.um))

layers.each { |l| (input(l) &amp; clip_box).output(l) }
</pre>
</p>
<a name="layout"/><h2>"layout" - Returns the <class_doc href="Layout">Layout</class_doc> object associated with this source</h2>
<keyword name="layout"/>
<p>Usage:</p>
<ul>
<li><tt>layout</tt></li>
</ul>
<a name="make_layer"/><h2>"make_layer" - Creates an empty polygon layer based on the hierarchy of the layout</h2>
<keyword name="make_layer"/>
<p>Usage:</p>
<ul>
<li><tt>make_layer</tt></li>
</ul>
<p>
This method delivers a new empty original layer. It is provided to keep old code working.
Use "input" without arguments instead.
</p>
<a name="overlapping"/><h2>"overlapping" - Specifies input selected from a region in overlapping mode</h2>
<keyword name="overlapping"/>
<p>Usage:</p>
<ul>
<li><tt>source.overlapping(...)</tt></li>
</ul>
<p>
Like <a href="#clip">clip</a>, this method will create a new source delivering shapes
from a specified rectangular region. In contrast to clip, all shapes
overlapping the region with their bounding boxes are delivered as a whole
and are not clipped. Hence shapes may extent beyond the limits of
the specified rectangle.
</p><p>
<a href="#touching">touching</a> is a similar method which delivers shapes touching
the search region with their bounding box (without the requirement to overlap)
</p>
<a name="path"/><h2>"path" - Gets the path of the corresponding layout file or nil if there is no path</h2>
<keyword name="path"/>
<p>Usage:</p>
<ul>
<li><tt>path</tt></li>
</ul>
<a name="polygons"/><h2>"polygons" - Gets the polygon shapes (or shapes that can be converted polygons) from an input layer</h2>
<keyword name="polygons"/>
<p>Usage:</p>
<ul>
<li><tt>source.polygons</tt></li>
<li><tt>source.polygons(layer)</tt></li>
<li><tt>source.polygons(layer, datatype)</tt></li>
<li><tt>source.polygons(layer_info)</tt></li>
<li><tt>source.polygons(filter, ...)</tt></li>
</ul>
<p>
Creates a layer with the polygon shapes from the given layer of the source.
With "polygon shapes" we mean all kind of shapes that can be converted to polygons.
Those are boxes, paths and real polygons.
</p><p>
This method is identical to <a href="#input">input</a> with respect to the options supported.
</p><p>
"polygons" without any arguments will create a new, empty original layer.
</p><p>
Use the global version of "polygons" without a source object to address the default source.
</p>
<a name="select"/><h2>"select" - Adds cell name expressions to the cell filters</h2>
<keyword name="select"/>
<p>Usage:</p>
<ul>
<li><tt>new_source = source.select(filter1, filter2, ...)</tt></li>
</ul>
<p>
This method will construct a new source object with the given cell filters 
applied. Note that there is a global version of "select" which does not 
create a new source, but acts on the default source.
</p><p>
Cell filters will enable or disable cells plus their subtree.
Cells can be switched on and off, which makes the hierarchy traversal
stop or begin delivering shapes at the given cell. The arguments of 
the select method form a sequence of enabling or disabling instructions
using cell name pattern in the glob notation ("*" as the wildcard, like shell).
Disabling instructions start with a "-", enabling instructions with a "+" or
no specification.
</p><p>
The following options are available:
</p><p>
<ul>
<li><tt>+</tt><i>name_filter </i>: Cells matching the name filter will be enabled </li>
<li><i>name_filter </i>: Same as "+name_filter" </li>
<li><tt>-</tt><i>name_filter </i>: Cells matching the name filter will be disabled </li>
</ul>
</p><p>
To disable the TOP cell but enabled a hypothetical cell B below the top cell, use that
code:
</p><p>
<pre>
source_with_selection = source.select("-TOP", "+B")
l1 = source_with_selection.input(1, 0)
...
</pre>
</p><p>
Please note that the sample above will deliver the children of "B" because there is 
nothing said about how to proceed with cells other than "TOP" or "B". Conceptually,
the instantiation path of a cell will be matched against the different filters in the
order they are given.
A matching negative expression will disable the cell, a matching positive expression
will enable the cell. Hence, every cell that has a "B" in the instantiation path 
is enabled.
</p><p>
The following code will just select "B" without its children, because in the 
first "-*" selection, all cells including the children of "B" are disabled:
</p><p>
<pre>
source_with_selection = source.select("-*", "+B")
l1 = source_with_selection.input(1, 0)
...
</pre>
</p><p>
The short form "-" will disable the top cell. This code is identical to the first example
and will start with a disabled top cell regardless of its name:
</p><p>
<pre>
source_with_selection = source.select("-", "+B")
l1 = source_with_selection.input(1, 0)
...
</pre>
</p>
<a name="touching"/><h2>"touching" - Specifies input selected from a region in touching mode</h2>
<keyword name="touching"/>
<p>Usage:</p>
<ul>
<li><tt>source.touching(box)</tt></li>
<li><tt>source.touching(p1, p2)</tt></li>
<li><tt>source.touching(l, b, r, t)</tt></li>
</ul>
<p>
Like <a href="#clip">clip</a>, this method will create a new source delivering shapes
from a specified rectangular region. In contrast to clip, all shapes
touching the region with their bounding boxes are delivered as a whole
and are not clipped. Hence shapes may extent beyond the limits of
the specified rectangle.
</p><p>
<a href="#overlapping">overlapping</a> is a similar method which delivers shapes overlapping
the search region with their bounding box (and not just touching)
</p>
</doc>
