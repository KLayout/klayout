
/*

  KLayout Layout Viewer
  Copyright (C) 2006-2022 Matthias Koefferlein

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/

/**
*  @file gsiDeclQMetaContainer.cc 
*
*  DO NOT EDIT THIS FILE. 
*  This file has been created automatically
*/

#include <QMetaContainer>
#include "gsiQt.h"
#include "gsiQtCoreCommon.h"
#include <memory>

// -----------------------------------------------------------------------
// class QMetaContainer

//  Constructor QMetaContainer::QMetaContainer()


static void _init_ctor_QMetaContainer_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return_new<QMetaContainer> ();
}

static void _call_ctor_QMetaContainer_0 (const qt_gsi::GenericStaticMethod * /*decl*/, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<QMetaContainer *> (new QMetaContainer ());
}


// void QMetaContainer::advanceConstIterator(void *iterator, qsizetype step)


static void _init_f_advanceConstIterator_c2390 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("iterator");
  decl->add_arg<void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("step");
  decl->add_arg<qsizetype > (argspec_1);
  decl->set_return<void > ();
}

static void _call_f_advanceConstIterator_c2390 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  qsizetype arg2 = gsi::arg_reader<qsizetype >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->advanceConstIterator (arg1, arg2);
}


// void QMetaContainer::advanceIterator(void *iterator, qsizetype step)


static void _init_f_advanceIterator_c2390 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("iterator");
  decl->add_arg<void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("step");
  decl->add_arg<qsizetype > (argspec_1);
  decl->set_return<void > ();
}

static void _call_f_advanceIterator_c2390 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  qsizetype arg2 = gsi::arg_reader<qsizetype >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->advanceIterator (arg1, arg2);
}


// void *QMetaContainer::begin(void *container)


static void _init_f_begin_c1056 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<void * > (argspec_0);
  decl->set_return<void * > ();
}

static void _call_f_begin_c1056 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  ret.write<void * > ((void *)((QMetaContainer *)cls)->begin (arg1));
}


// bool QMetaContainer::canClear()


static void _init_f_canClear_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_canClear_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->canClear ());
}


// void QMetaContainer::clear(void *container)


static void _init_f_clear_c1056 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<void * > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_clear_c1056 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->clear (arg1);
}


// bool QMetaContainer::compareConstIterator(const void *i, const void *j)


static void _init_f_compareConstIterator_c3394 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("i");
  decl->add_arg<const void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("j");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<bool > ();
}

static void _call_f_compareConstIterator_c3394 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->compareConstIterator (arg1, arg2));
}


// bool QMetaContainer::compareIterator(const void *i, const void *j)


static void _init_f_compareIterator_c3394 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("i");
  decl->add_arg<const void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("j");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<bool > ();
}

static void _call_f_compareIterator_c3394 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->compareIterator (arg1, arg2));
}


// void *QMetaContainer::constBegin(const void *container)


static void _init_f_constBegin_c1751 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<const void * > (argspec_0);
  decl->set_return<void * > ();
}

static void _call_f_constBegin_c1751 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<void * > ((void *)((QMetaContainer *)cls)->constBegin (arg1));
}


// void *QMetaContainer::constEnd(const void *container)


static void _init_f_constEnd_c1751 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<const void * > (argspec_0);
  decl->set_return<void * > ();
}

static void _call_f_constEnd_c1751 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<void * > ((void *)((QMetaContainer *)cls)->constEnd (arg1));
}


// void QMetaContainer::copyConstIterator(void *target, const void *source)


static void _init_f_copyConstIterator_c2699 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("target");
  decl->add_arg<void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("source");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<void > ();
}

static void _call_f_copyConstIterator_c2699 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->copyConstIterator (arg1, arg2);
}


// void QMetaContainer::copyIterator(void *target, const void *source)


static void _init_f_copyIterator_c2699 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("target");
  decl->add_arg<void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("source");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<void > ();
}

static void _call_f_copyIterator_c2699 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->copyIterator (arg1, arg2);
}


// void QMetaContainer::destroyConstIterator(const void *iterator)


static void _init_f_destroyConstIterator_c1751 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("iterator");
  decl->add_arg<const void * > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_destroyConstIterator_c1751 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->destroyConstIterator (arg1);
}


// void QMetaContainer::destroyIterator(const void *iterator)


static void _init_f_destroyIterator_c1751 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("iterator");
  decl->add_arg<const void * > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_destroyIterator_c1751 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  __SUPPRESS_UNUSED_WARNING(ret);
  ((QMetaContainer *)cls)->destroyIterator (arg1);
}


// qsizetype QMetaContainer::diffConstIterator(const void *i, const void *j)


static void _init_f_diffConstIterator_c3394 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("i");
  decl->add_arg<const void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("j");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<qsizetype > ();
}

static void _call_f_diffConstIterator_c3394 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<qsizetype > ((qsizetype)((QMetaContainer *)cls)->diffConstIterator (arg1, arg2));
}


// qsizetype QMetaContainer::diffIterator(const void *i, const void *j)


static void _init_f_diffIterator_c3394 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("i");
  decl->add_arg<const void * > (argspec_0);
  static gsi::ArgSpecBase argspec_1 ("j");
  decl->add_arg<const void * > (argspec_1);
  decl->set_return<qsizetype > ();
}

static void _call_f_diffIterator_c3394 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  const void *arg2 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<qsizetype > ((qsizetype)((QMetaContainer *)cls)->diffIterator (arg1, arg2));
}


// void *QMetaContainer::end(void *container)


static void _init_f_end_c1056 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<void * > (argspec_0);
  decl->set_return<void * > ();
}

static void _call_f_end_c1056 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  void *arg1 = gsi::arg_reader<void * >() (args, heap);
  ret.write<void * > ((void *)((QMetaContainer *)cls)->end (arg1));
}


// bool QMetaContainer::hasBidirectionalIterator()


static void _init_f_hasBidirectionalIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasBidirectionalIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasBidirectionalIterator ());
}


// bool QMetaContainer::hasConstIterator()


static void _init_f_hasConstIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasConstIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasConstIterator ());
}


// bool QMetaContainer::hasForwardIterator()


static void _init_f_hasForwardIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasForwardIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasForwardIterator ());
}


// bool QMetaContainer::hasInputIterator()


static void _init_f_hasInputIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasInputIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasInputIterator ());
}


// bool QMetaContainer::hasIterator()


static void _init_f_hasIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasIterator ());
}


// bool QMetaContainer::hasRandomAccessIterator()


static void _init_f_hasRandomAccessIterator_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasRandomAccessIterator_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasRandomAccessIterator ());
}


// bool QMetaContainer::hasSize()


static void _init_f_hasSize_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_hasSize_c0 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  ret.write<bool > ((bool)((QMetaContainer *)cls)->hasSize ());
}


// qsizetype QMetaContainer::size(const void *container)


static void _init_f_size_c1751 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("container");
  decl->add_arg<const void * > (argspec_0);
  decl->set_return<qsizetype > ();
}

static void _call_f_size_c1751 (const qt_gsi::GenericMethod * /*decl*/, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  __SUPPRESS_UNUSED_WARNING(args);
  tl::Heap heap;
  const void *arg1 = gsi::arg_reader<const void * >() (args, heap);
  ret.write<qsizetype > ((qsizetype)((QMetaContainer *)cls)->size (arg1));
}



namespace gsi
{

static gsi::Methods methods_QMetaContainer () {
  gsi::Methods methods;
  methods += new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QMetaContainer::QMetaContainer()\nThis method creates an object of class QMetaContainer.", &_init_ctor_QMetaContainer_0, &_call_ctor_QMetaContainer_0);
  methods += new qt_gsi::GenericMethod ("advanceConstIterator", "@brief Method void QMetaContainer::advanceConstIterator(void *iterator, qsizetype step)\n", true, &_init_f_advanceConstIterator_c2390, &_call_f_advanceConstIterator_c2390);
  methods += new qt_gsi::GenericMethod ("advanceIterator", "@brief Method void QMetaContainer::advanceIterator(void *iterator, qsizetype step)\n", true, &_init_f_advanceIterator_c2390, &_call_f_advanceIterator_c2390);
  methods += new qt_gsi::GenericMethod ("begin", "@brief Method void *QMetaContainer::begin(void *container)\n", true, &_init_f_begin_c1056, &_call_f_begin_c1056);
  methods += new qt_gsi::GenericMethod ("canClear", "@brief Method bool QMetaContainer::canClear()\n", true, &_init_f_canClear_c0, &_call_f_canClear_c0);
  methods += new qt_gsi::GenericMethod ("clear", "@brief Method void QMetaContainer::clear(void *container)\n", true, &_init_f_clear_c1056, &_call_f_clear_c1056);
  methods += new qt_gsi::GenericMethod ("compareConstIterator", "@brief Method bool QMetaContainer::compareConstIterator(const void *i, const void *j)\n", true, &_init_f_compareConstIterator_c3394, &_call_f_compareConstIterator_c3394);
  methods += new qt_gsi::GenericMethod ("compareIterator", "@brief Method bool QMetaContainer::compareIterator(const void *i, const void *j)\n", true, &_init_f_compareIterator_c3394, &_call_f_compareIterator_c3394);
  methods += new qt_gsi::GenericMethod ("constBegin", "@brief Method void *QMetaContainer::constBegin(const void *container)\n", true, &_init_f_constBegin_c1751, &_call_f_constBegin_c1751);
  methods += new qt_gsi::GenericMethod ("constEnd", "@brief Method void *QMetaContainer::constEnd(const void *container)\n", true, &_init_f_constEnd_c1751, &_call_f_constEnd_c1751);
  methods += new qt_gsi::GenericMethod ("copyConstIterator", "@brief Method void QMetaContainer::copyConstIterator(void *target, const void *source)\n", true, &_init_f_copyConstIterator_c2699, &_call_f_copyConstIterator_c2699);
  methods += new qt_gsi::GenericMethod ("copyIterator", "@brief Method void QMetaContainer::copyIterator(void *target, const void *source)\n", true, &_init_f_copyIterator_c2699, &_call_f_copyIterator_c2699);
  methods += new qt_gsi::GenericMethod ("destroyConstIterator", "@brief Method void QMetaContainer::destroyConstIterator(const void *iterator)\n", true, &_init_f_destroyConstIterator_c1751, &_call_f_destroyConstIterator_c1751);
  methods += new qt_gsi::GenericMethod ("destroyIterator", "@brief Method void QMetaContainer::destroyIterator(const void *iterator)\n", true, &_init_f_destroyIterator_c1751, &_call_f_destroyIterator_c1751);
  methods += new qt_gsi::GenericMethod ("diffConstIterator", "@brief Method qsizetype QMetaContainer::diffConstIterator(const void *i, const void *j)\n", true, &_init_f_diffConstIterator_c3394, &_call_f_diffConstIterator_c3394);
  methods += new qt_gsi::GenericMethod ("diffIterator", "@brief Method qsizetype QMetaContainer::diffIterator(const void *i, const void *j)\n", true, &_init_f_diffIterator_c3394, &_call_f_diffIterator_c3394);
  methods += new qt_gsi::GenericMethod ("end", "@brief Method void *QMetaContainer::end(void *container)\n", true, &_init_f_end_c1056, &_call_f_end_c1056);
  methods += new qt_gsi::GenericMethod ("hasBidirectionalIterator", "@brief Method bool QMetaContainer::hasBidirectionalIterator()\n", true, &_init_f_hasBidirectionalIterator_c0, &_call_f_hasBidirectionalIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasConstIterator", "@brief Method bool QMetaContainer::hasConstIterator()\n", true, &_init_f_hasConstIterator_c0, &_call_f_hasConstIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasForwardIterator", "@brief Method bool QMetaContainer::hasForwardIterator()\n", true, &_init_f_hasForwardIterator_c0, &_call_f_hasForwardIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasInputIterator", "@brief Method bool QMetaContainer::hasInputIterator()\n", true, &_init_f_hasInputIterator_c0, &_call_f_hasInputIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasIterator", "@brief Method bool QMetaContainer::hasIterator()\n", true, &_init_f_hasIterator_c0, &_call_f_hasIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasRandomAccessIterator", "@brief Method bool QMetaContainer::hasRandomAccessIterator()\n", true, &_init_f_hasRandomAccessIterator_c0, &_call_f_hasRandomAccessIterator_c0);
  methods += new qt_gsi::GenericMethod ("hasSize", "@brief Method bool QMetaContainer::hasSize()\n", true, &_init_f_hasSize_c0, &_call_f_hasSize_c0);
  methods += new qt_gsi::GenericMethod ("size", "@brief Method qsizetype QMetaContainer::size(const void *container)\n", true, &_init_f_size_c1751, &_call_f_size_c1751);
  return methods;
}

gsi::Class<QMetaContainer> decl_QMetaContainer ("QtCore", "QMetaContainer",
  methods_QMetaContainer (),
  "@qt\n@brief Binding of QMetaContainer");


GSI_QTCORE_PUBLIC gsi::Class<QMetaContainer> &qtdecl_QMetaContainer () { return decl_QMetaContainer; }

}

