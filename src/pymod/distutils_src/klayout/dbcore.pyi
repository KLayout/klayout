from typing import Any, ClassVar, Dict, Sequence, List, Iterator, Optional
from typing import overload
import klayout.rdb as rdb
import klayout.tl as tl
class Box:
    r"""
    @brief A box class with integer coordinates

    This object represents a box (a rectangular shape).

    The definition of the attributes is: p1 is the lower left point, p2 the 
    upper right one. If a box is constructed from two points (or four coordinates), the 
    coordinates are sorted accordingly.

    A box can be empty. An empty box represents no area
    (not even a point). Empty boxes behave neutral with respect to most operations. 
    Empty boxes return true on \empty?.

    A box can be a point or a single
    line. In this case, the area is zero but the box still
    can overlap other boxes for example and it is not empty. 

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    bottom: int
    r"""
    @brief Gets the bottom coordinate of the box
    @brief Sets the bottom coordinate of the box
    """
    left: int
    r"""
    @brief Gets the left coordinate of the box
    @brief Sets the left coordinate of the box
    """
    p1: Point
    r"""
    @brief Gets the lower left point of the box
    @brief Sets the lower left point of the box
    """
    p2: Point
    r"""
    @brief Gets the upper right point of the box
    @brief Sets the upper right point of the box
    """
    right: int
    r"""
    @brief Gets the right coordinate of the box
    @brief Sets the right coordinate of the box
    """
    top: int
    r"""
    @brief Gets the top coordinate of the box
    @brief Sets the top coordinate of the box
    """
    @classmethod
    def from_s(cls, s: str) -> Box:
        r"""
        @brief Creates a box object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    @overload
    def __add__(self, box: Box) -> Box:
        r"""
        @brief Joins two boxes


        The + operator joins the first box with the one given as 
        the second argument. Joining constructs a box that encloses
        both boxes given. Empty boxes are neutral: they do not
        change another box when joining. Overwrites this box
        with the result.

        @param box The box to join with this box.

        @return The joined box
        """
    @overload
    def __add__(self, point: Point) -> Box:
        r"""
        @brief Joins box with a point


        The + operator joins a point with the box. The resulting box will enclose both the original box and the point.

        @param point The point to join with this box.

        @return The box joined with the point
        """
    def __and__(self, box: Box) -> Box:
        r"""
        @brief Returns the intersection of this box with another box


        The intersection of two boxes is the largest
        box common to both boxes. The intersection may be 
        empty if both boxes to not touch. If the boxes do
        not overlap but touch the result may be a single
        line or point with an area of zero. Overwrites this box
        with the result.

        @param box The box to take the intersection with

        @return The intersection box
        """
    def __copy__(self) -> Box:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, box: object) -> bool:
        r"""
        @brief Returns true if this box is equal to the other box
        Returns true, if this box and the given box are equal 
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given box. This method enables boxes as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates an empty (invalid) box

        Empty boxes don't modify a box when joined with it. The intersection between an empty and any other box is also an empty box. The width, height, p1 and p2 attributes of an empty box are undefined. Use \empty? to get a value indicating whether the box is empty.
        """
    @overload
    def __init__(self, dbox: DBox) -> None:
        r"""
        @brief Creates an integer coordinate box from a floating-point coordinate box

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dbox'.
        """
    @overload
    def __init__(self, lower_left: Point, upper_right: Point) -> None:
        r"""
        @brief Creates a box from two points


        Two points are given to create a new box. If the coordinates are not provided in the correct order (i.e. right < left), these are swapped.
        """
    @overload
    def __init__(self, left: int, bottom: int, right: int, top: int) -> None:
        r"""
        @brief Creates a box with four coordinates


        Four coordinates are given to create a new box. If the coordinates are not provided in the correct order (i.e. right < left), these are swapped.
        """
    def __lt__(self, box: Box) -> bool:
        r"""
        @brief Returns true if this box is 'less' than another box
        Returns true, if this box is 'less' with respect to first and second point (in this order)
        """
    @overload
    def __mul__(self, box: Box) -> Box:
        r"""
        @brief Returns the convolution product from this box with another box


        The * operator convolves the firstbox with the one given as 
        the second argument. The box resulting from "convolution" is the
        outer boundary of the union set formed by placing 
        the second box at every point of the first. In other words,
        the returned box of (p1,p2)*(q1,q2) is (p1+q1,p2+q2).

        @param box The box to convolve with this box.

        @return The convolved box
        """
    @overload
    def __mul__(self, scale_factor: float) -> Box:
        r"""
        @brief Returns the scaled box


        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box
        """
    def __ne__(self, box: object) -> bool:
        r"""
        @brief Returns true if this box is not equal to the other box
        Returns true, if this box and the given box are not equal 
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    @overload
    def __rmul__(self, box: Box) -> Box:
        r"""
        @brief Returns the convolution product from this box with another box


        The * operator convolves the firstbox with the one given as 
        the second argument. The box resulting from "convolution" is the
        outer boundary of the union set formed by placing 
        the second box at every point of the first. In other words,
        the returned box of (p1,p2)*(q1,q2) is (p1+q1,p2+q2).

        @param box The box to convolve with this box.

        @return The convolved box
        """
    @overload
    def __rmul__(self, scale_factor: float) -> Box:
        r"""
        @brief Returns the scaled box


        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> float:
        r"""
        @brief Computes the box area

        Returns the box area or 0 if the box is empty
        """
    def assign(self, other: Box) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box
        This method is provided for consistency of the shape API is returns the box itself.

        This method has been introduced in version 0.27.
        """
    def center(self) -> Point:
        r"""
        @brief Gets the center of the box
        """
    @overload
    def contains(self, point: Point) -> bool:
        r"""
        @brief Returns true if the box contains the given point


        Tests whether a point is inside the box.
        It also returns true if the point is exactly on the box contour.

        @param p The point to test against.

        @return true if the point is inside the box.
        """
    @overload
    def contains(self, x: int, y: int) -> bool:
        r"""
        @brief Returns true if the box contains the given point


        Tests whether a point (x, y) is inside the box.
        It also returns true if the point is exactly on the box contour.

        @return true if the point is inside the box.
        """
    def dup(self) -> Box:
        r"""
        @brief Creates a copy of self
        """
    def empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the box is empty

        An empty box may be created with the default constructor for example. Such a box is neutral when combining it with other boxes and renders empty boxes if used in box intersections and false in geometrical relationship tests. 
        """
    @overload
    def enlarge(self, enlargement: Vector) -> Box:
        r"""
        @brief Enlarges the box by a certain amount.


        Enlarges the box by x and y value specified in the vector
        passed. Positive values with grow the box, negative ones
        will shrink the box. The result may be an empty box if the
        box disappears. The amount specifies the grow or shrink
        per edge. The width and height will change by twice the
        amount.
        Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return A reference to this box.
        """
    @overload
    def enlarge(self, dx: int, dy: int) -> Box:
        r"""
        @brief Enlarges the box by a certain amount.


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return A reference to this box.
        """
    @overload
    def enlarged(self, enlargement: Vector) -> Box:
        r"""
        @brief Returns the enlarged box.


        Enlarges the box by x and y value specified in the vector
        passed. Positive values with grow the box, negative ones
        will shrink the box. The result may be an empty box if the
        box disappears. The amount specifies the grow or shrink
        per edge. The width and height will change by twice the
        amount.
        Does not modify this box. Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return The enlarged box.
        """
    @overload
    def enlarged(self, dx: int, dy: int) -> Box:
        r"""
        @brief Enlarges the box by a certain amount.


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return The enlarged box.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given box. This method enables boxes as hash keys.

        This method has been introduced in version 0.25.
        """
    def height(self) -> int:
        r"""
        @brief Gets the height of the box
        """
    def inside(self, box: Box) -> bool:
        r"""
        @brief Tests if this box is inside the argument box


        Returns true, if this box is inside the given box, i.e. the box intersection renders this box
        """
    def is_point(self) -> bool:
        r"""
        @brief Returns true, if the box is a single point
        """
    @overload
    def move(self, distance: Vector) -> Box:
        r"""
        @brief Moves the box by a certain distance


        Moves the box by a given offset and returns the moved
        box. Does not check for coordinate overflows.

        @param distance The offset to move the box.

        @return A reference to this box.
        """
    @overload
    def move(self, dx: int, dy: int) -> Box:
        r"""
        @brief Moves the box by a certain distance


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return A reference to this box.
        """
    @overload
    def moved(self, distance: Vector) -> Box:
        r"""
        @brief Returns the box moved by a certain distance


        Moves the box by a given offset and returns the moved
        box. Does not modify this box. Does not check for coordinate
        overflows.

        @param distance The offset to move the box.

        @return The moved box.
        """
    @overload
    def moved(self, dx: int, dy: int) -> Box:
        r"""
        @brief Moves the box by a certain distance


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return The enlarged box.
        """
    def overlaps(self, box: Box) -> bool:
        r"""
        @brief Tests if this box overlaps the argument box


        Returns true, if the intersection box of this box with the argument box exists and has a non-vanishing area
        """
    def perimeter(self) -> int:
        r"""
        @brief Returns the perimeter of the box

        This method is equivalent to 2*(width+height). For empty boxes, this method returns 0.

        This method has been introduced in version 0.23.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DBox:
        r"""
        @brief Converts the box to a floating-point coordinate box

        The database unit can be specified to translate the integer-coordinate box into a floating-point coordinate box in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    def touches(self, box: Box) -> bool:
        r"""
        @brief Tests if this box touches the argument box


        Two boxes touch if they overlap or their boundaries share at least one common point. Touching is equivalent to a non-empty intersection ('!(b1 & b2).empty?').
        """
    @overload
    def transformed(self, t: CplxTrans) -> DBox:
        r"""
        @brief Returns the box transformed with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed box (a DBox now)
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Box:
        r"""
        @brief Transforms the box with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed box (in this case an integer coordinate box)

        This method has been introduced in version 0.18.
        """
    @overload
    def transformed(self, t: Trans) -> Box:
        r"""
        @brief Returns the box transformed with the given simple transformation


        @param t The transformation to apply
        @return The transformed box
        """
    def width(self) -> int:
        r"""
        @brief Gets the width of the box
        """

class DBox:
    r"""
    @brief A box class with floating-point coordinates

    This object represents a box (a rectangular shape).

    The definition of the attributes is: p1 is the lower left point, p2 the 
    upper right one. If a box is constructed from two points (or four coordinates), the 
    coordinates are sorted accordingly.

    A box can be empty. An empty box represents no area
    (not even a point). Empty boxes behave neutral with respect to most operations. 
    Empty boxes return true on \empty?.

    A box can be a point or a single
    line. In this case, the area is zero but the box still
    can overlap other boxes for example and it is not empty.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    bottom: float
    r"""
    @brief Gets the bottom coordinate of the box
    @brief Sets the bottom coordinate of the box
    """
    left: float
    r"""
    @brief Gets the left coordinate of the box
    @brief Sets the left coordinate of the box
    """
    p1: DPoint
    r"""
    @brief Gets the lower left point of the box
    @brief Sets the lower left point of the box
    """
    p2: DPoint
    r"""
    @brief Gets the upper right point of the box
    @brief Sets the upper right point of the box
    """
    right: float
    r"""
    @brief Gets the right coordinate of the box
    @brief Sets the right coordinate of the box
    """
    top: float
    r"""
    @brief Gets the top coordinate of the box
    @brief Sets the top coordinate of the box
    """
    @classmethod
    def from_s(cls, s: str) -> DBox:
        r"""
        @brief Creates a box object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    @overload
    def __add__(self, box: DBox) -> DBox:
        r"""
        @brief Joins two boxes


        The + operator joins the first box with the one given as 
        the second argument. Joining constructs a box that encloses
        both boxes given. Empty boxes are neutral: they do not
        change another box when joining. Overwrites this box
        with the result.

        @param box The box to join with this box.

        @return The joined box
        """
    @overload
    def __add__(self, point: DPoint) -> DBox:
        r"""
        @brief Joins box with a point


        The + operator joins a point with the box. The resulting box will enclose both the original box and the point.

        @param point The point to join with this box.

        @return The box joined with the point
        """
    def __and__(self, box: DBox) -> DBox:
        r"""
        @brief Returns the intersection of this box with another box


        The intersection of two boxes is the largest
        box common to both boxes. The intersection may be 
        empty if both boxes to not touch. If the boxes do
        not overlap but touch the result may be a single
        line or point with an area of zero. Overwrites this box
        with the result.

        @param box The box to take the intersection with

        @return The intersection box
        """
    def __copy__(self) -> DBox:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, box: object) -> bool:
        r"""
        @brief Returns true if this box is equal to the other box
        Returns true, if this box and the given box are equal 
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given box. This method enables boxes as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates an empty (invalid) box

        Empty boxes don't modify a box when joined with it. The intersection between an empty and any other box is also an empty box. The width, height, p1 and p2 attributes of an empty box are undefined. Use \empty? to get a value indicating whether the box is empty.
        """
    @overload
    def __init__(self, box: Box) -> None:
        r"""
        @brief Creates a floating-point coordinate box from an integer coordinate box

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_ibox'.
        """
    @overload
    def __init__(self, lower_left: DPoint, upper_right: DPoint) -> None:
        r"""
        @brief Creates a box from two points


        Two points are given to create a new box. If the coordinates are not provided in the correct order (i.e. right < left), these are swapped.
        """
    @overload
    def __init__(self, left: float, bottom: float, right: float, top: float) -> None:
        r"""
        @brief Creates a box with four coordinates


        Four coordinates are given to create a new box. If the coordinates are not provided in the correct order (i.e. right < left), these are swapped.
        """
    def __lt__(self, box: DBox) -> bool:
        r"""
        @brief Returns true if this box is 'less' than another box
        Returns true, if this box is 'less' with respect to first and second point (in this order)
        """
    @overload
    def __mul__(self, box: DBox) -> DBox:
        r"""
        @brief Returns the convolution product from this box with another box


        The * operator convolves the firstbox with the one given as 
        the second argument. The box resulting from "convolution" is the
        outer boundary of the union set formed by placing 
        the second box at every point of the first. In other words,
        the returned box of (p1,p2)*(q1,q2) is (p1+q1,p2+q2).

        @param box The box to convolve with this box.

        @return The convolved box
        """
    @overload
    def __mul__(self, scale_factor: float) -> DBox:
        r"""
        @brief Returns the scaled box


        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box
        """
    def __ne__(self, box: object) -> bool:
        r"""
        @brief Returns true if this box is not equal to the other box
        Returns true, if this box and the given box are not equal 
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    @overload
    def __rmul__(self, box: DBox) -> DBox:
        r"""
        @brief Returns the convolution product from this box with another box


        The * operator convolves the firstbox with the one given as 
        the second argument. The box resulting from "convolution" is the
        outer boundary of the union set formed by placing 
        the second box at every point of the first. In other words,
        the returned box of (p1,p2)*(q1,q2) is (p1+q1,p2+q2).

        @param box The box to convolve with this box.

        @return The convolved box
        """
    @overload
    def __rmul__(self, scale_factor: float) -> DBox:
        r"""
        @brief Returns the scaled box


        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> float:
        r"""
        @brief Computes the box area

        Returns the box area or 0 if the box is empty
        """
    def assign(self, other: DBox) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> DBox:
        r"""
        @brief Returns the bounding box
        This method is provided for consistency of the shape API is returns the box itself.

        This method has been introduced in version 0.27.
        """
    def center(self) -> DPoint:
        r"""
        @brief Gets the center of the box
        """
    @overload
    def contains(self, point: DPoint) -> bool:
        r"""
        @brief Returns true if the box contains the given point


        Tests whether a point is inside the box.
        It also returns true if the point is exactly on the box contour.

        @param p The point to test against.

        @return true if the point is inside the box.
        """
    @overload
    def contains(self, x: float, y: float) -> bool:
        r"""
        @brief Returns true if the box contains the given point


        Tests whether a point (x, y) is inside the box.
        It also returns true if the point is exactly on the box contour.

        @return true if the point is inside the box.
        """
    def dup(self) -> DBox:
        r"""
        @brief Creates a copy of self
        """
    def empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the box is empty

        An empty box may be created with the default constructor for example. Such a box is neutral when combining it with other boxes and renders empty boxes if used in box intersections and false in geometrical relationship tests. 
        """
    @overload
    def enlarge(self, enlargement: DVector) -> DBox:
        r"""
        @brief Enlarges the box by a certain amount.


        Enlarges the box by x and y value specified in the vector
        passed. Positive values with grow the box, negative ones
        will shrink the box. The result may be an empty box if the
        box disappears. The amount specifies the grow or shrink
        per edge. The width and height will change by twice the
        amount.
        Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return A reference to this box.
        """
    @overload
    def enlarge(self, dx: float, dy: float) -> DBox:
        r"""
        @brief Enlarges the box by a certain amount.


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return A reference to this box.
        """
    @overload
    def enlarged(self, enlargement: DVector) -> DBox:
        r"""
        @brief Returns the enlarged box.


        Enlarges the box by x and y value specified in the vector
        passed. Positive values with grow the box, negative ones
        will shrink the box. The result may be an empty box if the
        box disappears. The amount specifies the grow or shrink
        per edge. The width and height will change by twice the
        amount.
        Does not modify this box. Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return The enlarged box.
        """
    @overload
    def enlarged(self, dx: float, dy: float) -> DBox:
        r"""
        @brief Enlarges the box by a certain amount.


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return The enlarged box.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given box. This method enables boxes as hash keys.

        This method has been introduced in version 0.25.
        """
    def height(self) -> float:
        r"""
        @brief Gets the height of the box
        """
    def inside(self, box: DBox) -> bool:
        r"""
        @brief Tests if this box is inside the argument box


        Returns true, if this box is inside the given box, i.e. the box intersection renders this box
        """
    def is_point(self) -> bool:
        r"""
        @brief Returns true, if the box is a single point
        """
    @overload
    def move(self, distance: DVector) -> DBox:
        r"""
        @brief Moves the box by a certain distance


        Moves the box by a given offset and returns the moved
        box. Does not check for coordinate overflows.

        @param distance The offset to move the box.

        @return A reference to this box.
        """
    @overload
    def move(self, dx: float, dy: float) -> DBox:
        r"""
        @brief Moves the box by a certain distance


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return A reference to this box.
        """
    @overload
    def moved(self, distance: DVector) -> DBox:
        r"""
        @brief Returns the box moved by a certain distance


        Moves the box by a given offset and returns the moved
        box. Does not modify this box. Does not check for coordinate
        overflows.

        @param distance The offset to move the box.

        @return The moved box.
        """
    @overload
    def moved(self, dx: float, dy: float) -> DBox:
        r"""
        @brief Moves the box by a certain distance


        This is a convenience method which takes two values instead of a Point object.
        This method has been introduced in version 0.23.

        @return The enlarged box.
        """
    def overlaps(self, box: DBox) -> bool:
        r"""
        @brief Tests if this box overlaps the argument box


        Returns true, if the intersection box of this box with the argument box exists and has a non-vanishing area
        """
    def perimeter(self) -> float:
        r"""
        @brief Returns the perimeter of the box

        This method is equivalent to 2*(width+height). For empty boxes, this method returns 0.

        This method has been introduced in version 0.23.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Box:
        r"""
        @brief Converts the box to an integer coordinate box

        The database unit can be specified to translate the floating-point coordinate box in micron units to an integer-coordinate box in database units. The boxes coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing this box

        This string can be turned into a box again by using \from_s
        """
    def touches(self, box: DBox) -> bool:
        r"""
        @brief Tests if this box touches the argument box


        Two boxes touch if they overlap or their boundaries share at least one common point. Touching is equivalent to a non-empty intersection ('!(b1 & b2).empty?').
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DBox:
        r"""
        @brief Returns the box transformed with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed box (a DBox now)
        """
    @overload
    def transformed(self, t: DTrans) -> DBox:
        r"""
        @brief Returns the box transformed with the given simple transformation


        @param t The transformation to apply
        @return The transformed box
        """
    @overload
    def transformed(self, t: VCplxTrans) -> Box:
        r"""
        @brief Transforms the box with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed box (in this case an integer coordinate box)

        This method has been introduced in version 0.25.
        """
    def width(self) -> float:
        r"""
        @brief Gets the width of the box
        """

class Cell:
    r"""
    @brief A cell

    A cell object consists of a set of shape containers (called layers),
    a set of child cell instances and auxiliary information such as
    the parent instance list.
    A cell is identified through an index given to the cell upon instantiation.
    Cell instances refer to single instances or array instances. Both are encapsulated in the
    same object, the \CellInstArray object. In the simple case, this object refers to a single instance.
    In the general case, this object may refer to a regular array of cell instances as well.

    Starting from version 0.16, the child_inst and erase_inst methods are no longer available since
    they were using index addressing which is no longer supported. Instead, instances are now addressed
    with the \Instance reference objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects like the Cell class.
    """
    ghost_cell: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the "ghost cell" flag

    See \is_ghost_cell? for a description of this property.

    This method has been introduced in version 0.20.
    """
    name: str
    r"""
    @brief Gets the cell's name

    This method has been introduced in version 0.22.
    @brief Renames the cell
    Renaming a cell may cause name clashes, i.e. the name may be identical to the name
    of another cell. This does not have any immediate effect, but the cell needs to be renamed, for example when writing the layout to a GDS file.

    This method has been introduced in version 0.22.
    """
    prop_id: int
    r"""
    @brief Gets the properties ID associated with the cell

    This method has been introduced in version 0.23.@brief Sets the properties ID associated with the cell
    This method is provided, if a properties ID has been derived already. Usually it's more convenient to use \delete_property, \set_property or \property.

    This method has been introduced in version 0.23.
    """
    def __copy__(self) -> Cell:
        r"""
        @brief Creates a copy of the cell

        This method will create a copy of the cell. The new cell will be member of the same layout the original cell was member of. The copy will inherit all shapes and instances, but get a different cell_index and a modified name as duplicate cell names are not allowed in the same layout.

        This method has been introduced in version 0.27.
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def basic_name(self) -> str:
        r"""
        @brief Returns the name of the library or PCell or the real name of the cell
        For non-proxy cells (see \is_proxy?), this method simply returns the cell name.
        For proxy cells, this method returns the PCells definition name or the library
        cell name. This name may differ from the actual cell's name because to ensure
        that cell names are unique, KLayout may assign different names to the actual 
        cell compared to the source cell.

        This method has been introduced in version 0.22.
        """
    def bbox(self) -> Box:
        r"""
        @brief Gets the bounding box of the cell

        @return The bounding box of the cell

        The bounding box is computed over all layers. To compute the bounding box over single layers, use \bbox_per_layer.
        """
    def bbox_per_layer(self, layer_index: int) -> Box:
        r"""
        @brief Gets the per-layer bounding box of the cell

        @return The bounding box of the cell considering only the given layer

        The bounding box is the box enclosing all shapes on the given layer.
        """
    def begin_instances_rec(self) -> RecursiveInstanceIterator:
        r"""
        @brief Delivers a recursive instance iterator for the instances below the cell
        @return A suitable iterator

        For details see the description of the \RecursiveInstanceIterator class.

        This method has been added in version 0.27.
        """
    @overload
    def begin_instances_rec_overlapping(self, region: Box) -> RecursiveInstanceIterator:
        r"""
        @brief Delivers a recursive instance iterator for the instances below the cell using a region search
        @param region The search region
        @return A suitable iterator

        For details see the description of the \RecursiveInstanceIterator class.
        This version gives an iterator delivering instances whose bounding box overlaps the given region.

        This method has been added in version 0.27.
        """
    @overload
    def begin_instances_rec_overlapping(self, region: DBox) -> RecursiveInstanceIterator:
        r"""
        @brief Delivers a recursive instance iterator for the instances below the cell using a region search, with the region given in micrometer units
        @param region The search region as \DBox object in micrometer units
        @return A suitable iterator

        For details see the description of the \RecursiveInstanceIterator class.
        This version gives an iterator delivering instances whose bounding box overlaps the given region.

        This variant has been added in version 0.27.
        """
    @overload
    def begin_instances_rec_touching(self, region: Box) -> RecursiveInstanceIterator:
        r"""
        @brief Delivers a recursive instance iterator for the instances below the cell
        @param region The search region
        @return A suitable iterator

        For details see the description of the \RecursiveInstanceIterator class.
        This version gives an iterator delivering instances whose bounding box touches the given region.

        This method has been added in version 0.27.
        """
    @overload
    def begin_instances_rec_touching(self, region: DBox) -> RecursiveInstanceIterator:
        r"""
        @brief Delivers a recursive instance iterator for the instances below the cell using a region search, with the region given in micrometer units
        @param region The search region as \DBox object in micrometer units
        @return A suitable iterator

        For details see the description of the \RecursiveInstanceIterator class.
        This version gives an iterator delivering instances whose bounding box touches the given region.

        This variant has been added in version 0.27.
        """
    def begin_shapes_rec(self, layer: int) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the cell on the given layer
        @param layer The layer from which to get the shapes
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.

        This method has been added in version 0.23.
        """
    @overload
    def begin_shapes_rec_overlapping(self, layer: int, region: Box) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the cell on the given layer using a region search
        @param layer The layer from which to get the shapes
        @param region The search region
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.
        This version gives an iterator delivering shapes whose bounding box overlaps the given region.

        This method has been added in version 0.23.
        """
    @overload
    def begin_shapes_rec_overlapping(self, layer: int, region: DBox) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the cell on the given layer using a region search, with the region given in micrometer units
        @param layer The layer from which to get the shapes
        @param region The search region as \DBox object in micrometer units
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.
        This version gives an iterator delivering shapes whose bounding box overlaps the given region.

        This variant has been added in version 0.25.
        """
    @overload
    def begin_shapes_rec_touching(self, layer: int, region: Box) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the cell on the given layer using a region search
        @param layer The layer from which to get the shapes
        @param region The search region
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.
        This version gives an iterator delivering shapes whose bounding box touches the given region.

        This method has been added in version 0.23.
        """
    @overload
    def begin_shapes_rec_touching(self, layer: int, region: DBox) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the cell on the given layer using a region search, with the region given in micrometer units
        @param layer The layer from which to get the shapes
        @param region The search region as \DBox object in micrometer units
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.
        This version gives an iterator delivering shapes whose bounding box touches the given region.

        This variant has been added in version 0.25.
        """
    def called_cells(self) -> List[int]:
        r"""
        @brief Gets a list of all called cells

        This method determines all cells which are called either directly or indirectly by the cell.
        It returns an array of cell indexes. Use the 'cell' method of \Layout to retrieve the corresponding Cell object.

        This method has been introduced in version 0.19.

        @return A list of cell indices.
        """
    def caller_cells(self) -> List[int]:
        r"""
        @brief Gets a list of all caller cells

        This method determines all cells which call this cell either directly or indirectly.
        It returns an array of cell indexes. Use the 'cell' method of \Layout to retrieve the corresponding Cell object.

        This method has been introduced in version 0.19.

        @return A list of cell indices.
        """
    def cell_index(self) -> int:
        r"""
        @brief Gets the cell index

        @return The cell index of the cell
        """
    def change_pcell_parameter(self, instance: Instance, name: str, value: Any) -> Instance:
        r"""
        @brief Changes a single parameter for an individual PCell instance given by name
        @return The new instance (the old may be invalid)
        This will set the PCell parameter named 'name' to the given value for the instance addressed by 'instance'. If no parameter with that name exists, the method will do nothing.

        This method has been introduced in version 0.23.
        """
    @overload
    def change_pcell_parameters(self, instance: Instance, parameters: Sequence[Any]) -> Instance:
        r"""
        @brief Changes the parameters for an individual PCell instance
        @return The new instance (the old may be invalid)
        If necessary, this method creates a new variant and replaces the given instance
        by an instance of this variant.

        The parameters are given in the order the parameters are declared. Use \pcell_declaration on the instance to get the PCell declaration object of the cell. That PCellDeclaration object delivers the parameter declaration with it's 'get_parameters' method.
        Each parameter in the variant list passed to the second list of values corresponds to one parameter declaration.

        There is a more convenient method (\change_pcell_parameter) that changes a single parameter by name.

        This method has been introduced in version 0.22.
        """
    @overload
    def change_pcell_parameters(self, instance: Instance, dict: Dict[str, Any]) -> Instance:
        r"""
        @brief Changes the given parameter for an individual PCell instance
        @return The new instance (the old may be invalid)
        This version receives a dictionary of names and values. It will change the parameters given by the names to the values given by the values of the dictionary. The functionality is similar to the same function with an array, but more convenient to use.
        Values with unknown names are ignored.

        This method has been introduced in version 0.24.
        """
    def child_cells(self) -> int:
        r"""
        @brief Gets the number of child cells

        The number of child cells (not child instances!) is returned.
        CAUTION: this method is SLOW, in particular if many instances are present.
        """
    def child_instances(self) -> int:
        r"""
        @brief Gets the number of child instances

        @return Returns the number of cell instances
        """
    @overload
    def clear(self) -> None:
        r"""
        @brief Clears the cell (deletes shapes and instances)
        This method has been introduced in version 0.23.
        """
    @overload
    def clear(self, layer_index: int) -> None:
        r"""
        @brief Clears the shapes on the given layer
        """
    def clear_insts(self) -> None:
        r"""
        @brief Clears the instance list
        """
    def clear_shapes(self) -> None:
        r"""
        @brief Clears all shapes in the cell
        """
    @overload
    def copy(self, src: int, dest: int) -> None:
        r"""
        @brief Copies the shapes from the source to the target layer

        The destination layer is not overwritten. Instead, the shapes are added to the shapes of the destination layer.
        If source are target layer are identical, this method does nothing.
        This method will copy shapes within the cell. To copy shapes from another cell to this cell, use the copy method with the cell parameter.

        This method has been introduced in version 0.19.

        @param src The layer index of the source layer
        @param dest The layer index of the destination layer
        """
    @overload
    def copy(self, src_cell: Cell, src_layer: int, dest: int) -> None:
        r"""
        @brief Copies shapes from another cell to the target layer in this cell

        This method will copy all shapes on layer 'src_layer' of cell 'src_cell' to the layer 'dest' of this cell.
        The destination layer is not overwritten. Instead, the shapes are added to the shapes of the destination layer.
        If the source cell lives in a layout with a different database unit than that current cell is in, the shapes will be transformed accordingly. The same way, shape properties are transformed as well. Note that the shape transformation may require rounding to smaller coordinates. This may result in a slight distortion of the original shapes, in particular when transforming into a layout with a bigger database unit.
        @param src_cell The cell where to take the shapes from
        @param src_layer The layer index of the layer from which to take the shapes
        @param dest The layer index of the destination layer
        """
    def copy_instances(self, source_cell: Cell) -> None:
        r"""
        @brief Copies the instances of child cells in the source cell to this cell
        @param source_cell The cell where the instances are copied from
        The source cell must reside in the same layout than this cell. The instances of child cells inside the source cell are copied to this cell. No new cells are created, just new instances are created to already existing cells in the target cell.

        The instances will be added to any existing instances in the cell.

        More elaborate methods of copying hierarchy trees between layouts or duplicating trees are provided through the \copy_tree_shapes (in cooperation with the \CellMapping class) or \copy_tree methods.

        This method has been added in version 0.23.
        """
    @overload
    def copy_shapes(self, source_cell: Cell) -> None:
        r"""
        @brief Copies the shapes from the given cell into this cell
        @param source_cell The cell from where to copy shapes
        All shapes are copied from the source cell to this cell. Instances are not copied.

        The source cell can reside in a different layout. In this case, the shapes are copied over from the other layout into this layout. Database unit conversion is done automatically if the database units differ between the layouts. Note that this may lead to grid snapping effects if the database unit of the target layout is not an integer fraction of the source layout.

        If source and target layout are different, the layers of the source and target layout are identified by their layer/datatype number or name (if no layer/datatype is present).
        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.
        """
    @overload
    def copy_shapes(self, source_cell: Cell, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Copies the shapes from the given cell into this cell
        @param source_cell The cell from where to copy shapes
        @param layer_mapping A \LayerMapping object that specifies which layers are copied and where
        All shapes on layers specified in the layer mapping object are copied from the source cell to this cell. Instances are not copied.
        The target layer is taken from the mapping table.

        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.
        """
    def copy_tree(self, source_cell: Cell) -> List[int]:
        r"""
        @brief Copies the cell tree of the given cell into this cell
        @param source_cell The cell from where to copy the cell tree
        @return A list of indexes of newly created cells
        The complete cell tree of the source cell is copied to the target cell plus all shapes in that tree are copied as well. This method will basically duplicate the cell tree of the source cell.

        The source cell may reside in a separate layout. This method therefore provides a way to copy over complete cell trees from one layout to another.

        The shapes and instances will be added to any shapes or instances already in the cell.

        This method has been added in version 0.23.
        """
    @overload
    def copy_tree_shapes(self, source_cell: Cell, cell_mapping: CellMapping) -> None:
        r"""
        @brief Copies the shapes from the given cell and the cell tree below into this cell or subcells of this cell
        @param source_cell The starting cell from where to copy shapes
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout

        This method is provided if source and target cell reside in different layouts. If will copy the shapes from all cells below the given source cell, but use a cell mapping object that provides a specification how cells are identified between the layouts. Cells in the source tree, for which no mapping is provided, will be flattened - their shapes will be propagated into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the \CellMapping class for details about the mapping methods available. The cell mapping object is also responsible for creating a proper hierarchy of cells in the target layout if that is required.

        Layers are identified between the layouts by the layer/datatype number of name if no layer/datatype number is present.

        The shapes copied will be added to any shapes already in the cells.

        This method has been added in version 0.23.
        """
    @overload
    def copy_tree_shapes(self, source_cell: Cell, cell_mapping: CellMapping, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Copies the shapes from the given cell and the cell tree below into this cell or subcells of this cell with layer mapping
        @param source_cell The cell from where to copy shapes and instances
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout

        This method is provided if source and target cell reside in different layouts. If will copy the shapes from all cells below the given source cell, but use a cell mapping object that provides a specification how cells are identified between the layouts. Cells in the source tree, for which no mapping is provided, will be flattened - their shapes will be propagated into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the \CellMapping class for details about the mapping methods available. The cell mapping object is also responsible for creating a proper hierarchy of cells in the target layout if that is required.

        In addition, the layer mapping object can be specified which maps source to target layers. This feature can be used to restrict the copy operation to a subset of layers or to convert shapes to different layers in that step.

        The shapes copied will be added to any shapes already in the cells.

        This method has been added in version 0.23.
        """
    def dbbox(self) -> DBox:
        r"""
        @brief Gets the bounding box of the cell in micrometer units

        @return The bounding box of the cell

        The bounding box is computed over all layers. To compute the bounding box over single layers, use \dbbox_per_layer.

        This method has been introduced in version 0.25.
        """
    def dbbox_per_layer(self, layer_index: int) -> DBox:
        r"""
        @brief Gets the per-layer bounding box of the cell in micrometer units

        @return The bounding box of the cell considering only the given layer

        The bounding box is the box enclosing all shapes on the given layer.

        This method has been introduced in version 0.25.
        """
    def delete(self) -> None:
        r"""
        @brief Deletes this cell 

        This deletes the cell but not the sub cells of the cell.
        These subcells will likely become new top cells unless they are used
        otherwise.
        All instances of this cell are deleted as well.
        Hint: to delete multiple cells, use "delete_cells" which is 
        far more efficient in this case.

        After the cell has been deleted, the Cell object becomes invalid. Do not access methods or attributes of this object after deleting the cell.

        This method has been introduced in version 0.23.
        """
    def delete_property(self, key: Any) -> None:
        r"""
        @brief Deletes the user property with the given key
        This method is a convenience method that deletes the property with the given key. It does nothing if no property with that key exists. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID.

        This method has been introduced in version 0.23.
        """
    def display_title(self) -> str:
        r"""
        @brief Returns a nice looking name for display purposes

        For example, this name include PCell parameters for PCell proxy cells.

        This method has been introduced in version 0.22.
        """
    def dump_mem_statistics(self, detailed: Optional[bool] = ...) -> None:
        r"""
        @hide
        """
    def dup(self) -> Cell:
        r"""
        @brief Creates a copy of the cell

        This method will create a copy of the cell. The new cell will be member of the same layout the original cell was member of. The copy will inherit all shapes and instances, but get a different cell_index and a modified name as duplicate cell names are not allowed in the same layout.

        This method has been introduced in version 0.27.
        """
    def each_child_cell(self) -> Iterator[int]:
        r"""
        @brief Iterates over all child cells

        This iterator will report the child cell indices, not every instance.
        """
    def each_inst(self) -> Iterator[Instance]:
        r"""
        @brief Iterates over all child instances (which may actually be instance arrays)

        Starting with version 0.15, this iterator delivers \Instance objects rather than \CellInstArray objects.
        """
    @overload
    def each_overlapping_inst(self, b: Box) -> Iterator[Instance]:
        r"""
        @brief Gets the instances overlapping the given rectangle

        This will iterate over all child cell
        instances overlapping with the given rectangle b. 

        @param b The region to iterate over

        Starting with version 0.15, this iterator delivers \Instance objects rather than \CellInstArray objects.
        """
    @overload
    def each_overlapping_inst(self, b: DBox) -> Iterator[Instance]:
        r"""
        @brief Gets the instances overlapping the given rectangle, with the rectangle in micrometer units

        This will iterate over all child cell
        instances overlapping with the given rectangle b. This method is identical to the \each_overlapping_inst version that takes a \Box object, but instead of taking database unit coordinates in will take a micrometer unit \DBox object.

        @param b The region to iterate over

        This variant has been introduced in version 0.25.
        """
    @overload
    def each_overlapping_shape(self, layer_index: int, box: Box) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that overlap the given box

        @param box The box by which to query the shapes
        @param layer_index The layer on which to run the query

        This call is equivalent to each_overlapping_shape(layer_index,box,RBA::Shapes::SAll).
        This convenience method has been introduced in version 0.16.
        """
    @overload
    def each_overlapping_shape(self, layer_index: int, box: DBox) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that overlap the given box, with the box given in micrometer units

        @param box The box by which to query the shapes as a \DBox object in micrometer units
        @param layer_index The layer on which to run the query

        This call is equivalent to each_overlapping_shape(layer_index,box,RBA::Shapes::SAll).
        This convenience method has been introduced in version 0.16.
        """
    @overload
    def each_overlapping_shape(self, layer_index: int, box: Box, flags: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that overlap the given box

        @param flags An "or"-ed combination of the S.. constants of the \Shapes class
        @param box The box by which to query the shapes
        @param layer_index The layer on which to run the query
        """
    @overload
    def each_overlapping_shape(self, layer_index: int, box: DBox, flags: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that overlap the given box, with the box given in micrometer units

        @param flags An "or"-ed combination of the S.. constants of the \Shapes class
        @param box The box by which to query the shapes as a \DBox object in micrometer units
        @param layer_index The layer on which to run the query
        """
    def each_parent_cell(self) -> Iterator[int]:
        r"""
        @brief Iterates over all parent cells

        This iterator will iterate over the parent cells, just returning their
        cell index.
        """
    def each_parent_inst(self) -> Iterator[ParentInstArray]:
        r"""
        @brief Iterates over the parent instance list (which may actually be instance arrays)

        The parent instances are basically inversions of the instances. Using parent instances it is possible to determine how a specific cell is called from where.
        """
    @overload
    def each_shape(self, layer_index: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer

        @param layer_index The layer on which to run the query

        This call is equivalent to each_shape(layer_index,RBA::Shapes::SAll).
        This convenience method has been introduced in version 0.16.
        """
    @overload
    def each_shape(self, layer_index: int, flags: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer

        @param flags An "or"-ed combination of the S.. constants of the \Shapes class
        @param layer_index The layer on which to run the query

        This iterator is equivalent to 'shapes(layer).each'.
        """
    @overload
    def each_touching_inst(self, b: Box) -> Iterator[Instance]:
        r"""
        @brief Gets the instances touching the given rectangle

        This will iterate over all child cell
        instances overlapping with the given rectangle b. 

        @param b The region to iterate over

        Starting with version 0.15, this iterator delivers \Instance objects rather than \CellInstArray objects.
        """
    @overload
    def each_touching_inst(self, b: DBox) -> Iterator[Instance]:
        r"""
        @brief Gets the instances touching the given rectangle, with the rectangle in micrometer units

        This will iterate over all child cell
        instances touching the given rectangle b. This method is identical to the \each_touching_inst version that takes a \Box object, but instead of taking database unit coordinates in will take a micrometer unit \DBox object.

        @param b The region to iterate over

        This variant has been introduced in version 0.25.
        """
    @overload
    def each_touching_shape(self, layer_index: int, box: Box) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that touch the given box

        @param box The box by which to query the shapes
        @param layer_index The layer on which to run the query

        This call is equivalent to each_touching_shape(layer_index,box,RBA::Shapes::SAll).
        This convenience method has been introduced in version 0.16.
        """
    @overload
    def each_touching_shape(self, layer_index: int, box: DBox) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that touch the given box, with the box given in micrometer units

        @param box The box by which to query the shapes as a \DBox object in micrometer units
        @param layer_index The layer on which to run the query

        This call is equivalent to each_touching_shape(layer_index,box,RBA::Shapes::SAll).
        This convenience method has been introduced in version 0.16.
        """
    @overload
    def each_touching_shape(self, layer_index: int, box: Box, flags: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that touch the given box

        @param flags An "or"-ed combination of the S.. constants of the \Shapes class
        @param box The box by which to query the shapes
        @param layer_index The layer on which to run the query
        """
    @overload
    def each_touching_shape(self, layer_index: int, box: DBox, flags: int) -> Iterator[Shape]:
        r"""
        @brief Iterates over all shapes of a given layer that touch the given box, with the box given in micrometer units

        @param flags An "or"-ed combination of the S.. constants of the \Shapes class
        @param box The box by which to query the shapes as a \DBox object in micrometer units
        @param layer_index The layer on which to run the query
        """
    def erase(self, inst: Instance) -> None:
        r"""
        @brief Erases the instance given by the Instance object

        This method has been introduced in version 0.16. It can only be used in editable mode.
        """
    @overload
    def fill_region(self, region: Region, fill_cell_index: int, fc_box: Box, origin: Optional[Point] = ..., remaining_parts: Optional[Region] = ..., fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief Fills the given region with cells of the given type (extended version)
        @param region The region to fill
        @param fill_cell_index The fill cell to place
        @param fc_box The fill cell's footprint
        @param origin The global origin of the fill pattern or nil to allow local (per-polygon) optimization
        @param remaining_parts See explanation below
        @param fill_margin See explanation below
        @param remaining_polygons See explanation below
        @param glue_box Guarantees fill cell compatibility to neighbor regions in enhanced mode

        This method creates a regular pattern of fill cells to cover the interior of the given region as far as possible. This process is also known as tiling. This implementation supports rectangular (not necessarily square) tile cells. The tile cell's footprint is given by the fc_box parameter and the cells will be arranged with their footprints forming a seamless array.

        The algorithm supports a global fill raster as well as local (per-polygon) origin optimization. In the latter case the origin of the regular raster is optimized per individual polygon of the fill region. To enable optimization, pass 'nil' to the 'origin' argument.

        The implementation will basically try to find a repetition pattern of the tile cell's footprint and produce instances which fit entirely into the fill region.

        There is also a version available which offers skew step vectors as a generalization of the orthogonal ones.

        If the 'remaining_parts' argument is non-nil, the corresponding region will receive the parts of the polygons which are not covered by tiles. Basically the tiles are subtracted from the original polygons. A margin can be specified which is applied separately in x and y direction before the subtraction is done ('fill_margin' parameter).

        If the 'remaining_polygons' argument is non-nil, the corresponding region will receive all polygons from the input region which could not be filled and where there is no chance of filling because not a single tile will fit into them.

        'remaining_parts' and 'remaining_polygons' can be identical with the input. In that case the input will be overwritten with the respective output. Otherwise, the respective polygons are added to these regions.

        This allows setting up a more elaborate fill scheme using multiple iterations and local origin-optimization ('origin' is nil):

        @code
        r = ...        # region to fill
        c = ...        # cell in which to produce the fill cells
        fc_index = ... # fill cell index
        fc_box = ...   # fill cell footprint

        fill_margin = RBA::Point::new(0, 0)   # x/y distance between tile cells with different origin

        # Iteration: fill a region and fill the remaining parts as long as there is anything left.
        # Polygons not worth being considered further are dropped (last argument is nil).
        while !r.is_empty?
          c.fill_region(r, fc_index, fc_box, nil, r, fill_margin, nil)
        end
        @/code

        The glue box parameter supports fill cell array compatibility with neighboring regions. This is specifically useful when putting the fill_cell method into a tiling processor. Fill cell array compatibility means that the fill cell array continues over tile boundaries. This is easy with an origin: you can chose the origin identically over all tiles which is sufficient to guarantee fill cell array compatibility across the tiles. However there is no freedom of choice of the origin then and fill cell placement may not be optimal. To enable the origin for the tile boundary only, a glue box can given. The origin will then be used only when the polygons to fill not entirely inside and not at the border of the glue box. Hence, while a certain degree of freedom is present for the placement of fill cells inside the glue box, the fill cells are guaranteed to be placed at the raster implied by origin at the glue box border and beyond. To ensure fill cell compatibility inside the tiling processor, it is sufficient to use the tile box as the glue box.

        This method has been introduced in version 0.23 and enhanced in version 0.27.
        """
    @overload
    def fill_region(self, region: Region, fill_cell_index: int, fc_bbox: Box, row_step: Vector, column_step: Vector, origin: Optional[Point] = ..., remaining_parts: Optional[Region] = ..., fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief Fills the given region with cells of the given type (skew step version)
        @param region The region to fill
        @param fill_cell_index The fill cell to place
        @param fc_bbox The fill cell's box to place
        @param row_step The 'rows' step vector
        @param column_step The 'columns' step vector
        @param origin The global origin of the fill pattern or nil to allow local (per-polygon) optimization
        @param remaining_parts See explanation in other version
        @param fill_margin See explanation in other version
        @param remaining_polygons See explanation in other version

        This version is similar to the version providing an orthogonal fill, but it offers more generic stepping of the fill cell.
        The step pattern is defined by an origin and two vectors (row_step and column_step) which span the axes of the fill cell pattern.

        The fill box and the step vectors are decoupled which means the fill box can be larger or smaller than the step pitch - it can be overlapping and there can be space between the fill box instances. Fill boxes are placed where they fit entirely into a polygon of the region. The fill boxes lower left corner is the reference for the fill pattern and aligns with the origin if given.

        This variant has been introduced in version 0.27.
        """
    def fill_region_multi(self, region: Region, fill_cell_index: int, fc_bbox: Box, row_step: Vector, column_step: Vector, fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief Fills the given region with cells of the given type in enhanced mode with iterations
        This version operates like \fill_region, but repeats the fill generation until no further fill cells can be placed. As the fill pattern origin changes between the iterations, narrow regions can be filled which cannot with a fixed fill pattern origin. The \fill_margin parameter is important as it controls the distance between fill cells with a different origin and therefore introduces a safety distance between pitch-incompatible arrays.

        The origin is ignored unless a glue box is given. See \fill_region for a description of this concept.

        This method has been introduced in version 0.27.
        """
    @overload
    def flatten(self, prune: bool) -> None:
        r"""
        @brief Flattens the given cell

        This method propagates all shapes from the hierarchy below into the given cell.
        It also removes the instances of the cells from which the shapes came from, but does not remove the cells themselves if prune is set to false.
        If prune is set to true, these cells are removed if not used otherwise.

        A version of this method exists which allows one to specify the number of hierarchy levels to which subcells are considered.

        @param prune Set to true to remove orphan cells.

        This method has been introduced in version 0.23.
        """
    @overload
    def flatten(self, levels: int, prune: bool) -> None:
        r"""
        @brief Flattens the given cell

        This method propagates all shapes from the specified number of hierarchy levels below into the given cell.
        It also removes the instances of the cells from which the shapes came from, but does not remove the cells themselves if prune is set to false.
        If prune is set to true, these cells are removed if not used otherwise.

        @param levels The number of hierarchy levels to flatten (-1: all, 0: none, 1: one level etc.)
        @param prune Set to true to remove orphan cells.

        This method has been introduced in version 0.23.
        """
    def has_prop_id(self) -> bool:
        r"""
        @brief Returns true, if the cell has user properties

        This method has been introduced in version 0.23.
        """
    def hierarchy_levels(self) -> int:
        r"""
        @brief Returns the number of hierarchy levels below

        This method returns the number of call levels below the current cell. If there are no child cells, this method will return 0, if there are only direct children, it will return 1.

        CAUTION: this method may be expensive!
        """
    @overload
    def insert(self, cell_inst_array: CellInstArray) -> Instance:
        r"""
        @brief Inserts a cell instance (array)
        @return An Instance object representing the new instance
        With version 0.16, this method returns an Instance object that represents the new instance.
        It's use is discouraged in readonly mode, since it invalidates other Instance references.
        """
    @overload
    def insert(self, cell_inst_array: DCellInstArray) -> Instance:
        r"""
        @brief Inserts a cell instance (array) given in micron units
        @return An Instance object representing the new instance
        This method inserts an instance array, similar to \insert with a \CellInstArray parameter. But in this version, the argument is a cell instance array given in micrometer units. It is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, inst: Instance) -> Instance:
        r"""
        @brief Inserts a cell instance given by another reference
        @return An Instance object representing the new instance
        This method allows one to copy instances taken from a reference (an \Instance object).
        This method is not suited to inserting instances from other Layouts into this cell. For this purpose, the hierarchical copy methods of \Layout have to be used.

        It has been added in version 0.16.
        """
    @overload
    def insert(self, cell_inst_array: CellInstArray, property_id: int) -> Instance:
        r"""
        @brief Inserts a cell instance (array) with properties
        @return An \Instance object representing the new instance
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        With version 0.16, this method returns an Instance object that represents the new instance.
        It's use is discouraged in readonly mode, since it invalidates other Instance references.
        """
    @overload
    def insert(self, cell_inst_array: DCellInstArray, property_id: int) -> Instance:
        r"""
        @brief Inserts a cell instance (array) given in micron units with properties
        @return An Instance object representing the new instance
        This method inserts an instance array, similar to \insert with a \CellInstArray parameter and a property set ID. But in this version, the argument is a cell instance array given in micrometer units. It is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the cell is empty

        An empty cell is a cell not containing instances nor any shapes.

        This method has been introduced in version 0.20.
        """
    def is_ghost_cell(self) -> bool:
        r"""
        @brief Returns a value indicating whether the cell is a "ghost cell"

        The ghost cell flag is used by the GDS reader for example to indicate that
        the cell is not located inside the file. Upon writing the reader can determine
        whether to write the cell or not.
        To satisfy the references inside the layout, a dummy cell is created in this case
        which has the "ghost cell" flag set to true.

        This method has been introduced in version 0.20.
        """
    def is_leaf(self) -> bool:
        r"""
        @brief Gets a value indicating whether the cell is a leaf cell

        A cell is a leaf cell if there are no child instantiations.
        """
    def is_library_cell(self) -> bool:
        r"""
        @brief Returns true, if the cell is a proxy cell pointing to a library cell
        If the cell is imported from some library, this attribute returns true.
        Please note, that this attribute can combine with \is_pcell? for PCells imported from
        a library.

        This method has been introduced in version 0.22.
        """
    @overload
    def is_pcell_variant(self) -> bool:
        r"""
        @brief Returns true, if this cell is a pcell variant
        this method returns true, if this cell represents a pcell with a distinct
        set of parameters (a PCell proxy). This also is true, if the PCell is imported from a library.

        Technically, PCells imported from a library are library proxies which are 
        pointing to PCell variant proxies. This scheme can even proceed over multiple
        indirections, i.e. a library using PCells from another library.

        This method has been introduced in version 0.22.
        """
    @overload
    def is_pcell_variant(self, instance: Instance) -> bool:
        r"""
        @brief Returns true, if this instance is a PCell variant
        This method returns true, if this instance represents a PCell with a distinct
        set of parameters. This method also returns true, if it is a PCell imported from a library.

        This method has been introduced in version 0.22.
        """
    def is_proxy(self) -> bool:
        r"""
        @brief Returns true, if the cell presents some external entity   
        A cell may represent some data which is imported from some other source, i.e.
        a library. Such cells are called "proxy cells". For a library reference, the
        proxy cell is some kind of pointer to the library and the cell within the library.

        For PCells, this data can even be computed through some script.
        A PCell proxy represents all instances with a given set of parameters.

        Proxy cells cannot be modified, except that pcell parameters can be modified
        and PCell instances can be recomputed.

        This method has been introduced in version 0.22.
        """
    def is_top(self) -> bool:
        r"""
        @brief Gets a value indicating whether the cell is a top-level cell

        A cell is a top-level cell if there are no parent instantiations.
        """
    def is_valid(self, instance: Instance) -> bool:
        r"""
        @brief Tests if the given \Instance object is still pointing to a valid object
        This method has been introduced in version 0.16.
        If the instance represented by the given reference has been deleted, this method returns false. If however, another instance has been inserted already that occupies the original instances position, this method will return true again.
        """
    def layout(self) -> Layout:
        r"""
        @brief Returns a reference to the layout where the cell resides

        this method has been introduced in version 0.22.
        """
    def library(self) -> Library:
        r"""
        @brief Returns a reference to the library from which the cell is imported
        if the cell is not imported from a library, this reference is nil.

        this method has been introduced in version 0.22.
        """
    def library_cell_index(self) -> int:
        r"""
        @brief Returns the index of the cell in the layout of the library (if it's a library proxy)
        Together with the \library method, it is possible to locate the source cell of
        a library proxy. The source cell can be retrieved from a cell "c" with 

        @code
        c.library.layout.cell(c.library_cell_index)
        @/code

        This cell may be itself a proxy,
        i.e. for pcell libraries, where the library cells are pcell variants which itself
        are proxies to a pcell.

        This method has been introduced in version 0.22.
        """
    @overload
    def move(self, src: int, dest: int) -> None:
        r"""
        @brief Moves the shapes from the source to the target layer

        The destination layer is not overwritten. Instead, the shapes are added to the shapes of the destination layer.
        This method will move shapes within the cell. To move shapes from another cell to this cell, use the copy method with the cell parameter.

        This method has been introduced in version 0.19.

        @param src The layer index of the source layer
        @param dest The layer index of the destination layer
        """
    @overload
    def move(self, src_cell: Cell, src_layer: int, dest: int) -> None:
        r"""
        @brief Moves shapes from another cell to the target layer in this cell

        This method will move all shapes on layer 'src_layer' of cell 'src_cell' to the layer 'dest' of this cell.
        The destination layer is not overwritten. Instead, the shapes are added to the shapes of the destination layer.
        If the source cell lives in a layout with a different database unit than that current cell is in, the shapes will be transformed accordingly. The same way, shape properties are transformed as well. Note that the shape transformation may require rounding to smaller coordinates. This may result in a slight distortion of the original shapes, in particular when transforming into a layout with a bigger database unit.
        @param src_cell The cell where to take the shapes from
        @param src_layer The layer index of the layer from which to take the shapes
        @param dest The layer index of the destination layer
        """
    def move_instances(self, source_cell: Cell) -> None:
        r"""
        @brief Moves the instances of child cells in the source cell to this cell
        @param source_cell The cell where the instances are moved from
        The source cell must reside in the same layout than this cell. The instances of child cells inside the source cell are moved to this cell. No new cells are created, just new instances are created to already existing cells in the target cell.

        The instances will be added to any existing instances in the cell.

        More elaborate methods of moving hierarchy trees between layouts are provided through the \move_tree_shapes (in cooperation with the \CellMapping class) or \move_tree methods.

        This method has been added in version 0.23.
        """
    @overload
    def move_shapes(self, source_cell: Cell) -> None:
        r"""
        @brief Moves the shapes from the given cell into this cell
        @param source_cell The cell from where to move shapes
        All shapes are moved from the source cell to this cell. Instances are not moved.

        The source cell can reside in a different layout. In this case, the shapes are moved over from the other layout into this layout. Database unit conversion is done automatically if the database units differ between the layouts. Note that this may lead to grid snapping effects if the database unit of the target layout is not an integer fraction of the source layout.

        If source and target layout are different, the layers of the source and target layout are identified by their layer/datatype number or name (if no layer/datatype is present).
        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.
        """
    @overload
    def move_shapes(self, source_cell: Cell, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Moves the shapes from the given cell into this cell
        @param source_cell The cell from where to move shapes
        @param layer_mapping A \LayerMapping object that specifies which layers are moved and where
        All shapes on layers specified in the layer mapping object are moved from the source cell to this cell. Instances are not moved.
        The target layer is taken from the mapping table.

        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.
        """
    def move_tree(self, source_cell: Cell) -> List[int]:
        r"""
        @brief Moves the cell tree of the given cell into this cell
        @param source_cell The cell from where to move the cell tree
        @return A list of indexes of newly created cells
        The complete cell tree of the source cell is moved to the target cell plus all shapes in that tree are moved as well. This method will basically rebuild the cell tree of the source cell and empty the source cell.

        The source cell may reside in a separate layout. This method therefore provides a way to move over complete cell trees from one layout to another.

        The shapes and instances will be added to any shapes or instances already in the cell.

        This method has been added in version 0.23.
        """
    @overload
    def move_tree_shapes(self, source_cell: Cell, cell_mapping: CellMapping) -> None:
        r"""
        @brief Moves the shapes from the given cell and the cell tree below into this cell or subcells of this cell
        @param source_cell The starting cell from where to move shapes
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout

        This method is provided if source and target cell reside in different layouts. If will move the shapes from all cells below the given source cell, but use a cell mapping object that provides a specification how cells are identified between the layouts. Cells in the source tree, for which no mapping is provided, will be flattened - their shapes will be propagated into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the \CellMapping class for details about the mapping methods available. The cell mapping object is also responsible for creating a proper hierarchy of cells in the target layout if that is required.

        Layers are identified between the layouts by the layer/datatype number of name if no layer/datatype number is present.

        The shapes moved will be added to any shapes already in the cells.

        This method has been added in version 0.23.
        """
    @overload
    def move_tree_shapes(self, source_cell: Cell, cell_mapping: CellMapping, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Moves the shapes from the given cell and the cell tree below into this cell or subcells of this cell with layer mapping
        @param source_cell The cell from where to move shapes and instances
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout

        This method is provided if source and target cell reside in different layouts. If will move the shapes from all cells below the given source cell, but use a cell mapping object that provides a specification how cells are identified between the layouts. Cells in the source tree, for which no mapping is provided, will be flattened - their shapes will be propagated into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the \CellMapping class for details about the mapping methods available. The cell mapping object is also responsible for creating a proper hierarchy of cells in the target layout if that is required.

        In addition, the layer mapping object can be specified which maps source to target layers. This feature can be used to restrict the move operation to a subset of layers or to convert shapes to different layers in that step.

        The shapes moved will be added to any shapes already in the cells.

        This method has been added in version 0.23.
        """
    def parent_cells(self) -> int:
        r"""
        @brief Gets the number of parent cells 

        The number of parent cells (cells which reference our cell) is reported.
        """
    @overload
    def pcell_declaration(self) -> PCellDeclaration_Native:
        r"""
        @brief Returns a reference to the PCell declaration
        If this cell is not a PCell variant, this method returns nil.
        PCell variants are proxy cells which are PCell incarnations for a specific parameter set.
        The \PCellDeclaration object allows one to retrieve PCell parameter definitions for example.

        This method has been introduced in version 0.22.
        """
    @overload
    def pcell_declaration(self, instance: Instance) -> PCellDeclaration_Native:
        r"""
        @brief Returns the PCell declaration of a pcell instance
        If the instance is not a PCell instance, this method returns nil.
        The \PCellDeclaration object allows one to retrieve PCell parameter definitions for example.

        This method has been introduced in version 0.22.
        """
    def pcell_id(self) -> int:
        r"""
        @brief Returns the PCell ID if the cell is a pcell variant
        This method returns the ID which uniquely identifies the PCell within the 
        layout where it's declared. It can be used to retrieve the PCell declaration 
        or to create new PCell variants.

        The method will be rarely used. It's more convenient to use \pcell_declaration to directly retrieve the PCellDeclaration object for example.

        This method has been introduced in version 0.22.
        """
    def pcell_library(self) -> Library:
        r"""
        @brief Returns the library where the PCell is declared if this cell is a PCell and it is not defined locally.
        A PCell often is not declared within the current layout but in some library. 
        This method returns a reference to that library, which technically is the last of the 
        chained library proxies. If this cell is not a PCell or it is not located in a 
        library, this method returns nil.

        This method has been introduced in version 0.22.
        """
    @overload
    def pcell_parameter(self, name: str) -> Any:
        r"""
        @brief Gets a PCell parameter by name if the cell is a PCell variant
        If the cell is a PCell variant, this method returns the parameter with the given name.
        If the cell is not a PCell variant or the name is not a valid PCell parameter name, the return value is nil.

        This method has been introduced in version 0.25.
        """
    @overload
    def pcell_parameter(self, instance: Instance, name: str) -> Any:
        r"""
        @brief Returns a PCell parameter by name for a pcell instance

        If the given instance is a PCell instance, this method returns the value of the PCell parameter with the given name.
        If the instance is not a PCell instance or the name is not a valid PCell parameter name, this
        method returns nil.

        This method has been introduced in version 0.25.
        """
    @overload
    def pcell_parameters(self) -> List[Any]:
        r"""
        @brief Returns the PCell parameters for a pcell variant
        If the cell is a PCell variant, this method returns a list of
        values for the PCell parameters. If the cell is not a PCell variant, this
        method returns an empty list. This method also returns the PCell parameters if
        the cell is a PCell imported from a library.

        This method has been introduced in version 0.22.
        """
    @overload
    def pcell_parameters(self, instance: Instance) -> List[Any]:
        r"""
        @brief Returns the PCell parameters for a pcell instance
        If the given instance is a PCell instance, this method returns a list of
        values for the PCell parameters. If the instance is not a PCell instance, this
        method returns an empty list.

        This method has been introduced in version 0.22.
        """
    @overload
    def pcell_parameters_by_name(self) -> Dict[str, Any]:
        r"""
        @brief Returns the PCell parameters for a pcell variant as a name to value dictionary
        If the cell is a PCell variant, this method returns a dictionary of
        values for the PCell parameters with the parameter names as the keys. If the cell is not a PCell variant, this
        method returns an empty dictionary. This method also returns the PCell parameters if
        the cell is a PCell imported from a library.

        This method has been introduced in version 0.24.
        """
    @overload
    def pcell_parameters_by_name(self, instance: Instance) -> Dict[str, Any]:
        r"""
        @brief Returns the PCell parameters for a pcell instance as a name to value dictionary
        If the given instance is a PCell instance, this method returns a dictionary of
        values for the PCell parameters with the parameter names as the keys. If the instance is not a PCell instance, this
        method returns an empty dictionary.

        This method has been introduced in version 0.24.
        """
    def property(self, key: Any) -> Any:
        r"""
        @brief Gets the user property with the given key
        This method is a convenience method that gets the property with the given key. If no property with that key exists, it will return nil. Using that method is more convenient than using the layout object and the properties ID to retrieve the property value. 
        This method has been introduced in version 0.23.
        """
    @overload
    def prune_cell(self) -> None:
        r"""
        @brief Deletes the cell plus subcells not used otherwise

        This deletes the cell and also all sub cells of the cell which are not used otherwise.
        All instances of this cell are deleted as well.
        A version of this method exists which allows one to specify the number of hierarchy levels to which subcells are considered.

        After the cell has been deleted, the Cell object becomes invalid. Do not access methods or attributes of this object after deleting the cell.

        This method has been introduced in version 0.23.
        """
    @overload
    def prune_cell(self, levels: int) -> None:
        r"""
        @brief Deletes the cell plus subcells not used otherwise

        This deletes the cell and also all sub cells of the cell which are not used otherwise.
        The number of hierarchy levels to consider can be specified as well. One level of hierarchy means that only the direct children of the cell are deleted with the cell itself.
        All instances of this cell are deleted as well.

        After the cell has been deleted, the Cell object becomes invalid. Do not access methods or attributes of this object after deleting the cell.

        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.23.
        """
    @overload
    def prune_subcells(self) -> None:
        r"""
        @brief Deletes all sub cells of the cell which are not used otherwise

        This deletes all sub cells of the cell which are not used otherwise.
        All instances of the deleted cells are deleted as well.
        A version of this method exists which allows one to specify the number of hierarchy levels to which subcells are considered.

        This method has been introduced in version 0.23.
        """
    @overload
    def prune_subcells(self, levels: int) -> None:
        r"""
        @brief Deletes all sub cells of the cell which are not used otherwise down to the specified level of hierarchy

        This deletes all sub cells of the cell which are not used otherwise.
        All instances of the deleted cells are deleted as well.
        It is possible to specify how many levels of hierarchy below the given root cell are considered.

        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.23.
        """
    def qname(self) -> str:
        r"""
        @brief Returns the library-qualified name

        Library cells will be indicated by returning a qualified name composed of the library name, a dot and the basic cell name. For example: "Basic.TEXT" will be the qname of the TEXT cell of the Basic library. For non-library cells, the qname is identical to the basic name (see \name).

        This method has been introduced in version 0.25.
        """
    def refresh(self) -> None:
        r"""
        @brief Refreshes a proxy cell

        If the cell is a PCell variant, this method recomputes the PCell.
        If the cell is a library proxy, this method reloads the information from the library, but not the library itself.
        Note that if the cell is an PCell variant for a PCell coming from a library, this method will not recompute the PCell. Instead, you can use \Library#refresh to recompute all PCells from that library.

        You can use \Layout#refresh to refresh all cells from a layout.

        This method has been introduced in version 0.22.
        """
    @overload
    def replace(self, instance: Instance, cell_inst_array: CellInstArray) -> Instance:
        r"""
        @brief Replaces a cell instance (array) with a different one
        @return An \Instance object representing the new instance
        This method has been introduced in version 0.16. It can only be used in editable mode.
        The instance given by the instance object (first argument) is replaced by the given instance (second argument). The new object will not have any properties.
        """
    @overload
    def replace(self, instance: Instance, cell_inst_array: DCellInstArray) -> Instance:
        r"""
        @brief Replaces a cell instance (array) with a different one, given in micrometer units
        @return An \Instance object representing the new instance
        This method is identical to the corresponding \replace variant with a \CellInstArray argument. It however accepts a micrometer-unit \DCellInstArray object which is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, instance: Instance, cell_inst_array: CellInstArray, property_id: int) -> Instance:
        r"""
        @brief Replaces a cell instance (array) with a different one with properties
        @return An \Instance object representing the new instance
        This method has been introduced in version 0.16. It can only be used in editable mode.
        The instance given by the instance object (first argument) is replaced by the given instance (second argument) with the given properties Id.
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        The new object will not have any properties.
        """
    @overload
    def replace(self, instance: Instance, cell_inst_array: DCellInstArray, property_id: int) -> Instance:
        r"""
        @brief Replaces a cell instance (array) with a different one and new properties, where the cell instance is given in micrometer units
        @return An \Instance object representing the new instance
        This method is identical to the corresponding \replace variant with a \CellInstArray argument and a property ID. It however accepts a micrometer-unit \DCellInstArray object which is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    def replace_prop_id(self, instance: Instance, property_id: int) -> Instance:
        r"""
        @brief Replaces (or install) the properties of a cell
        @return An Instance object representing the new instance
        This method has been introduced in version 0.16. It can only be used in editable mode.
        Changes the properties Id of the given instance or install a properties Id on that instance if it does not have one yet.
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        """
    def set_property(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the user property with the given key to the given value
        This method is a convenience method that sets the property with the given key to the given value. If no property with that key exists, it will create one. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Note: GDS only supports integer keys. OASIS supports numeric and string keys. 
        This method has been introduced in version 0.23.
        """
    def shapes(self, layer_index: int) -> Shapes:
        r"""
        @brief Returns the shapes list of the given layer

        This method gives access to the shapes list on a certain layer.
        If the layer does not exist yet, it is created.

        @param index The layer index of the shapes list to retrieve

        @return A reference to the shapes list
        """
    def swap(self, layer_index1: int, layer_index2: int) -> None:
        r"""
        @brief Swaps the layers given

        This method swaps two layers inside this cell.
        """
    @overload
    def transform(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms the cell by the given, micrometer-unit transformation

        This method transforms all instances and all shapes by the given transformation. There is a variant called \transform_into which applies the transformation to instances in a way such that it can be applied recursively to the child cells. The difference is important in the presence of magnifications: "transform" will leave magnified instances while "transform_into" will not do so but expect the magnification to be applied inside the called cells too.

        This method has been introduced in version 0.26.7.
        """
    @overload
    def transform(self, trans: DTrans) -> None:
        r"""
        @brief Transforms the cell by the given, micrometer-unit transformation

        This method transforms all instances and all shapes by the given transformation. There is a variant called \transform_into which applies the transformation to instances in a way such that it can be applied recursively to the child cells.

        This method has been introduced in version 0.26.7.
        """
    @overload
    def transform(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms the cell by the given complex integer transformation

        This method transforms all instances and all shapes by the given transformation. There is a variant called \transform_into which applies the transformation to instances in a way such that it can be applied recursively to the child cells. The difference is important in the presence of magnifications: "transform" will leave magnified instances while "transform_into" will not do so but expect the magnification to be applied inside the called cells too.

        This method has been introduced in version 0.26.7.
        """
    @overload
    def transform(self, trans: Trans) -> None:
        r"""
        @brief Transforms the cell by the given integer transformation

        This method transforms all instances and all shapes by the given transformation. There is a variant called \transform_into which applies the transformation to instances in a way such that it can be applied recursively to the child cells.

        This method has been introduced in version 0.26.7.
        """
    @overload
    def transform(self, instance: Instance, trans: DCplxTrans) -> Instance:
        r"""
        @brief Transforms the instance with the given complex floating-point transformation given in micrometer units
        @return A reference (an \Instance object) to the new instance
        This method is identical to the corresponding \transform method with a \ICplxTrans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform(self, instance: Instance, trans: DTrans) -> Instance:
        r"""
        @brief Transforms the instance with the transformation given in micrometer units
        @return A reference (an \Instance object) to the new instance
        This method is identical to the corresponding \transform method with a \Trans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform(self, instance: Instance, trans: ICplxTrans) -> Instance:
        r"""
        @brief Transforms the instance with the given complex integer transformation
        @return A reference (an \Instance object) to the new instance
        This method has been introduced in version 0.23.
        The original instance may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        """
    @overload
    def transform(self, instance: Instance, trans: Trans) -> Instance:
        r"""
        @brief Transforms the instance with the given transformation
        @return A reference (an \Instance object) to the new instance
        This method has been introduced in version 0.16.
        The original instance may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        """
    @overload
    def transform_into(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms the cell into a new coordinate system with the given complex integer transformation where the transformation is in micrometer units
        This method is identical to the corresponding \transform_into method with a \ICplxTrans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, trans: DTrans) -> None:
        r"""
        @brief Transforms the cell into a new coordinate system with the given transformation where the transformation is in micrometer units
        This method is identical to the corresponding \transform_into method with a \Trans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms the cell into a new coordinate system with the given complex integer transformation

        See the comments for the simple-transformation version for a description of this method.
        This method has been introduced in version 0.23.
        """
    @overload
    def transform_into(self, trans: Trans) -> None:
        r"""
        @brief Transforms the cell into a new coordinate system with the given transformation

        This method transforms all instances and all shapes. The instances are transformed in a way that allows propagation of the transformation into child cells. For this, it applies just a part of the given transformation to the instance such that when transforming the shapes of the cell instantiated, the result will reflect the desired transformation. Mathematically spoken, the transformation of the instance (A) is transformed with the given transformation T using "A' = T * A * Tinv" where Tinv is the inverse of T. In effect, the transformation T commutes with the new instance transformation A' and can be applied to child cells as well. This method is therefore useful to transform a hierarchy of cells.

        It has been introduced in version 0.23.
        """
    @overload
    def transform_into(self, instance: Instance, trans: DCplxTrans) -> Instance:
        r"""
        @brief Transforms the instance into a new coordinate system with the given complex transformation where the transformation is in micrometer units
        @return A reference (an \Instance object) to the new instance
        This method is identical to the corresponding \transform_into method with a \ICplxTrans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, instance: Instance, trans: DTrans) -> Instance:
        r"""
        @brief Transforms the instance into a new coordinate system with the given transformation where the transformation is in micrometer units
        @return A reference (an \Instance object) to the new instance
        This method is identical to the corresponding \transform_into method with a \Trans argument. For this variant however, the transformation is given in micrometer units and is translated to database units internally.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, instance: Instance, trans: ICplxTrans) -> Instance:
        r"""
        @brief Transforms the instance into a new coordinate system with the given complex integer transformation
        @return A reference (an \Instance object) to the new instance

        See the comments for the simple-transformation version for a description of this method.
        This method has been introduced in version 0.23.
        The original instance may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        """
    @overload
    def transform_into(self, instance: Instance, trans: Trans) -> Instance:
        r"""
        @brief Transforms the instance into a new coordinate system with the given transformation
        @return A reference (an \Instance object) to the new instance

        In contrast to the \transform method, this method allows propagation of the transformation into child cells. More precisely: it applies just a part of the given transformation to the instance, such that when transforming the cell instantiated and it's shapes with the same transformation, the result will reflect the desired transformation. Mathematically spoken, the transformation of the instance (A) is transformed with the given transformation T using "A' = T * A * Tinv" where Tinv is the inverse of T. In effect, the transformation T commutes with the new instance transformation A' and can be applied to child cells as well. This method is therefore useful to transform a hierarchy of cells.

        This method has been introduced in version 0.23.
        The original instance may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        """
    @overload
    def write(self, file_name: str) -> None:
        r"""
        @brief Writes the cell to a layout file
        The format of the file will be determined from the file name. Only the cell and it's subtree below will be saved.

        This method has been introduced in version 0.23.
        """
    @overload
    def write(self, file_name: str, options: SaveLayoutOptions) -> None:
        r"""
        @brief Writes the cell to a layout file
        The format of the file will be determined from the file name. Only the cell and it's subtree below will be saved.
        In contrast to the other 'write' method, this version allows one to specify save options, i.e. scaling etc.

        This method has been introduced in version 0.23.
        """

class Instance:
    r"""
    @brief An instance proxy

    An instance proxy is basically a pointer to an instance of different kinds, 
    similar to \Shape, the shape proxy. \Instance objects can be duplicated without
    creating copies of the instances itself: the copy will still point to the same instance
    than the original.

    When the \Instance object is modified, the actual instance behind it is modified. The \Instance object acts as a simplified interface for single and array instances with or without properties.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    a: Vector
    r"""
    @brief Returns the displacement vector for the 'a' axis

    Starting with version 0.25 the displacement is of vector type.@brief Sets the displacement vector for the 'a' axis

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23. Starting with version 0.25 the displacement is of vector type.
    """
    b: Vector
    r"""
    @brief Returns the displacement vector for the 'b' axis

    Starting with version 0.25 the displacement is of vector type.@brief Sets the displacement vector for the 'b' axis

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23. Starting with version 0.25 the displacement is of vector type.
    """
    cell: Cell
    r"""
    @brief Gets the \Cell object of the cell this instance refers to

    Please note that before version 0.23 this method returned the cell the instance is contained in. For consistency, this method has been renamed \parent_cell.

    This method has been introduced in version 0.23.@brief Sets the \Cell object this instance refers to

    Setting the cell object to nil is equivalent to deleting the instance.

    This method has been introduced in version 0.23.
    """
    cell_index: int
    r"""
    @brief Get the index of the cell this instance refers to
    @brief Sets the index of the cell this instance refers to

    This method has been introduced in version 0.23.
    """
    cell_inst: CellInstArray
    r"""
    @brief Gets the basic \CellInstArray object associated with this instance reference.@brief Changes the \CellInstArray object to the given one.
    This method replaces the instance by the given CellInstArray object.

    This method has been introduced in version 0.22
    """
    cplx_trans: ICplxTrans
    r"""
    @brief Gets the complex transformation of the instance or the first instance in the array
    This method is always valid compared to \trans, since simple transformations can be expressed as complex transformations as well.@brief Sets the complex transformation of the instance or the first instance in the array

    This method has been introduced in version 0.23.
    """
    da: DVector
    r"""
    @brief Returns the displacement vector for the 'a' axis in micrometer units

    Like \a, this method returns the displacement, but it will be translated to database units internally.

    This method has been introduced in version 0.25.@brief Sets the displacement vector for the 'a' axis in micrometer units

    Like \a= with an integer displacement, this method will set the displacement vector but it accepts a vector in micrometer units that is of \DVector type. The vector will be translated to database units internally.

    This method has been introduced in version 0.25.
    """
    db: DVector
    r"""
    @brief Returns the displacement vector for the 'b' axis in micrometer units

    Like \b, this method returns the displacement, but it will be translated to database units internally.

    This method has been introduced in version 0.25.@brief Sets the displacement vector for the 'b' axis in micrometer units

    Like \b= with an integer displacement, this method will set the displacement vector but it accepts a vector in micrometer units that is of \DVector type. The vector will be translated to database units internally.

    This method has been introduced in version 0.25.
    """
    dcell_inst: DCellInstArray
    r"""
    @brief Returns the micrometer unit version of the basic cell instance array object.

    This method has been introduced in version 0.25@brief Returns the basic cell instance array object by giving a micrometer unit object.
    This method replaces the instance by the given CellInstArray object and it internally transformed into database units.

    This method has been introduced in version 0.25
    """
    dcplx_trans: DCplxTrans
    r"""
    @brief Gets the complex transformation of the instance or the first instance in the array (in micrometer units)
    This method returns the same transformation as \cplx_trans, but the displacement of this transformation is given in micrometer units. It is internally translated from database units into micrometers.

    This method has been introduced in version 0.25.
    @brief Sets the complex transformation of the instance or the first instance in the array (in micrometer units)
    This method sets the transformation the same way as \cplx_trans=, but the displacement of this transformation is given in micrometer units. It is internally translated into database units.

    This method has been introduced in version 0.25.
    """
    dtrans: DTrans
    r"""
    @brief Gets the transformation of the instance or the first instance in the array (in micrometer units)
    This method returns the same transformation as \cplx_trans, but the displacement of this transformation is given in micrometer units. It is internally translated from database units into micrometers.

    This method has been introduced in version 0.25.
    @brief Sets the transformation of the instance or the first instance in the array (in micrometer units)
    This method sets the transformation the same way as \cplx_trans=, but the displacement of this transformation is given in micrometer units. It is internally translated into database units.

    This method has been introduced in version 0.25.
    """
    na: int
    r"""
    @brief Returns the number of instances in the 'a' axis
    @brief Sets the number of instances in the 'a' axis

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23.
    """
    nb: int
    r"""
    @brief Returns the number of instances in the 'b' axis
    @brief Sets the number of instances in the 'b' axis

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23.
    """
    parent_cell: Cell
    r"""
    @brief Gets the cell this instance is contained in

    Returns nil if the instance does not live inside a cell.
    This method was named "cell" previously which lead to confusion with \cell_index.
    It was renamed to "parent_cell" in version 0.23.
    @brief Moves the instance to a different cell

    Both the current and the target cell must live in the same layout.

    This method has been introduced in version 0.23.
    """
    prop_id: int
    r"""
    @brief Gets the properties ID associated with the instance
    @brief Sets the properties ID associated with the instance
    This method is provided, if a properties ID has been derived already. Usually it's more convenient to use \delete_property, \set_property or \property.

    This method has been introduced in version 0.22.
    """
    trans: Trans
    r"""
    @brief Gets the transformation of the instance or the first instance in the array
    The transformation returned is only valid if the array does not represent a complex transformation array@brief Sets the transformation of the instance or the first instance in the array

    This method has been introduced in version 0.23.
    """
    def __copy__(self) -> Instance:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, b: object) -> bool:
        r"""
        @brief Tests for equality of two Instance objects
        See the hint on the < operator.
        """
    def __getitem__(self, key: Any) -> Any:
        r"""
        @brief Gets the user property with the given key or, if available, the PCell parameter with the name given by the key
        Getting the PCell parameter has priority over the user property.
        This method has been introduced in version 0.25.
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def __len__(self) -> int:
        r"""
        @brief Gets the number of single instances in the instance array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb.
        """
    def __lt__(self, b: Instance) -> bool:
        r"""
        @brief Provides an order criterion for two Instance objects
        Warning: this operator is just provided to establish any order, not a particular one.
        """
    def __ne__(self, b: object) -> bool:
        r"""
        @brief Tests for inequality of two Instance objects
        Warning: this operator returns true if both objects refer to the same instance, not just identical ones.
        """
    def __repr__(self) -> str:
        r"""
        @brief Creates a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    def __setitem__(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the user property with the given key or, if available, the PCell parameter with the name given by the key
        Setting the PCell parameter has priority over the user property.
        This method has been introduced in version 0.25.
        """
    def __str__(self) -> str:
        r"""
        @brief Creates a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Instance) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Gets the bounding box of the instance
        The bounding box incorporates all instances that the array represents. It gives the overall extension of the child cell as seen in the calling cell (or all array members if the instance forms an array). 
        This method has been introduced in version 0.23.
        """
    def bbox_per_layer(self, layer_index: int) -> Box:
        r"""
        @brief Gets the bounding box of the instance for a given layer
        @param layer_index The index of the layer the bounding box will be computed for.
        The bounding box incorporates all instances that the array represents. It gives the overall extension of the child cell as seen in the calling cell (or all array members if the instance forms an array) for the given layer. If the layer is empty in this cell and all it's children', an empty bounding box will be returned. 
        This method has been introduced in version 0.25.
        """
    def change_pcell_parameter(self, name: str, value: Any) -> None:
        r"""
        @brief Changes a single parameter of a PCell instance to the given value

        This method changes a parameter of a PCell instance to the given value. The name identifies the PCell parameter and must correspond to one parameter listed in the PCell declaration.

        This method has been introduced in version 0.24.
        """
    @overload
    def change_pcell_parameters(self, params: Sequence[Any]) -> None:
        r"""
        @brief Changes the parameters of a PCell instance to the list of parameters

        This method changes the parameters of a PCell instance to the given list of parameters. The list must correspond to the parameters listed in the pcell declaration.
        A more convenient method is provided with the same name which accepts a dictionary of names and values
        .
        This method has been introduced in version 0.24.
        """
    @overload
    def change_pcell_parameters(self, dict: Dict[str, Any]) -> None:
        r"""
        @brief Changes the parameters of a PCell instance to the dictionary of parameters

        This method changes the parameters of a PCell instance to the given values. The values are specifies as a dictionary of names (keys) vs. values.
        Unknown names are ignored and only the parameters listed in the dictionary are changed.

        This method has been introduced in version 0.24.
        """
    def convert_to_static(self) -> None:
        r"""
        @brief Converts a PCell instance to a static cell

        If the instance is a PCell instance, this method will convert the cell into a static cell and remove the PCell variant if required. A new cell will be created containing the PCell content but being a static cell. If the instance is not a PCell instance, this method won't do anything.

        This method has been introduced in version 0.24.
        """
    def dbbox(self) -> DBox:
        r"""
        @brief Gets the bounding box of the instance in micron units
        Gets the bounding box (see \bbox) of the instance, but will compute the micrometer unit box by multiplying \bbox with the database unit.

        This method has been introduced in version 0.25.
        """
    def dbbox_per_layer(self, layer_index: int) -> DBox:
        r"""
        @brief Gets the bounding box of the instance in micron units
        @param layer_index The index of the layer the bounding box will be computed for.
        Gets the bounding box (see \bbox_per_layer) of the instance, but will compute the micrometer unit box by multiplying \bbox_per_layer with the database unit.

        This method has been introduced in version 0.25.
        """
    def delete(self) -> None:
        r"""
        @brief Deletes this instance

        After this method was called, the instance object is pointing to nothing.

        This method has been introduced in version 0.23.
        """
    def delete_property(self, key: Any) -> None:
        r"""
        @brief Deletes the user property with the given key
        This method is a convenience method that deletes the property with the given key. It does nothing if no property with that key exists. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Calling this method may invalidate any iterators. It should not be called inside a loop iterating over instances.

        This method has been introduced in version 0.22.
        """
    def dup(self) -> Instance:
        r"""
        @brief Creates a copy of self
        """
    def explode(self) -> None:
        r"""
        @brief Explodes the instance array

        This method does nothing if the instance was not an array before.
        The instance object will point to the first instance of the array afterwards.

        This method has been introduced in version 0.23.
        """
    @overload
    def flatten(self) -> None:
        r"""
        @brief Flattens the instance

        This method will convert the instance to a number of shapes which are equivalent to the content of the cell. The instance itself will be removed.
        There is another variant of this method which allows specification of the number of hierarchy levels to flatten.

        This method has been introduced in version 0.24.
        """
    @overload
    def flatten(self, levels: int) -> None:
        r"""
        @brief Flattens the instance

        This method will convert the instance to a number of shapes which are equivalent to the content of the cell. The instance itself will be removed.
        This version of the method allows specification of the number of hierarchy levels to remove. Specifying 1 for 'levels' will remove the instance and replace it by the contents of the cell. Specifying a negative value or zero for the number of levels will flatten the instance completely.

        This method has been introduced in version 0.24.
        """
    def has_prop_id(self) -> bool:
        r"""
        @brief Returns true, if the instance has properties
        """
    def is_complex(self) -> bool:
        r"""
        @brief Tests, if the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and 
        arbitrary rotation angles).
        """
    def is_null(self) -> bool:
        r"""
        @brief Checks, if the instance is a valid one
        """
    def is_pcell(self) -> bool:
        r"""
        @brief Returns a value indicating whether the instance is a PCell instance

        This method has been introduced in version 0.24.
        """
    def is_regular_array(self) -> bool:
        r"""
        @brief Tests, if this instance is a regular array
        """
    def is_valid(self) -> bool:
        r"""
        @brief Tests if the \Instance object is still pointing to a valid instance
        If the instance represented by the given reference has been deleted, this method returns false. If however, another instance has been inserted already that occupies the original instances position, this method will return true again.

        This method has been introduced in version 0.23 and is a shortcut for "inst.cell.is_valid?(inst)".
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets the layout this instance is contained in

        This method has been introduced in version 0.22.
        """
    def pcell_declaration(self) -> PCellDeclaration_Native:
        r"""
        @brief Returns the PCell declaration object

        If the instance is a PCell instance, this method returns the PCell declaration object for that PCell. If not, this method will return nil.
        This method has been introduced in version 0.24.
        """
    def pcell_parameter(self, name: str) -> Any:
        r"""
        @brief Gets a PCell parameter by the name of the parameter
        @return The parameter value or nil if the instance is not a PCell or does not have a parameter with given name

        This method has been introduced in version 0.25.
        """
    def pcell_parameters(self) -> List[Any]:
        r"""
        @brief Gets the parameters of a PCell instance as a list of values
        @return A list of values

        If the instance is a PCell instance, this method will return an array of values where each value corresponds to one parameter. The order of the values is the order the parameters are declared in the PCell declaration.
        If the instance is not a PCell instance, this list returned will be empty.

        This method has been introduced in version 0.24.
        """
    def pcell_parameters_by_name(self) -> Dict[str, Any]:
        r"""
        @brief Gets the parameters of a PCell instance as a dictionary of values vs. names
        @return A dictionary of values by parameter name

        If the instance is a PCell instance, this method will return a map of values vs. parameter names. The names are the ones defined in the PCell declaration.If the instance is not a PCell instance, the dictionary returned will be empty.

        This method has been introduced in version 0.24.
        """
    def property(self, key: Any) -> Any:
        r"""
        @brief Gets the user property with the given key
        This method is a convenience method that gets the property with the given key. If no property with that key exists, it will return nil. Using that method is more convenient than using the layout object and the properties ID to retrieve the property value. 
        This method has been introduced in version 0.22.
        """
    def set_property(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the user property with the given key to the given value
        This method is a convenience method that sets the property with the given key to the given value. If no property with that key exists, it will create one. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Note: GDS only supports integer keys. OASIS supports numeric and string keys. Calling this method may invalidate any iterators. It should not be called inside a loop iterating over instances.

        This method has been introduced in version 0.22.
        """
    def size(self) -> int:
        r"""
        @brief Gets the number of single instances in the instance array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb.
        """
    @overload
    def to_s(self) -> str:
        r"""
        @brief Creates a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    @overload
    def to_s(self, with_cellname: bool) -> str:
        r"""
        @brief Creates a string showing the contents of the reference

        Passing true to with_cellname makes the string contain the cellname instead of the cell index

        This method has been introduced with version 0.23.
        """
    @overload
    def transform(self, t: DCplxTrans) -> None:
        r"""
        @brief Transforms the instance array with the given complex transformation (given in micrometer units)
        Transforms the instance like \transform does, but with a transformation given in micrometer units. The displacement of this transformation is given in micrometers and is internally translated to database units.

        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, t: DTrans) -> None:
        r"""
        @brief Transforms the instance array with the given transformation (given in micrometer units)
        Transforms the instance like \transform does, but with a transformation given in micrometer units. The displacement of this transformation is given in micrometers and is internally translated to database units.

        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, t: ICplxTrans) -> None:
        r"""
        @brief Transforms the instance array with the given complex transformation
        See \Cell#transform for a description of this method.

        This method has been introduced in version 0.23.
        """
    @overload
    def transform(self, t: Trans) -> None:
        r"""
        @brief Transforms the instance array with the given transformation
        See \Cell#transform for a description of this method.

        This method has been introduced in version 0.23.
        """
    @overload
    def transform_into(self, t: DCplxTrans) -> None:
        r"""
        @brief Transforms the instance array with the given complex transformation (given in micrometer units)
        Transforms the instance like \transform_into does, but with a transformation given in micrometer units. The displacement of this transformation is given in micrometers and is internally translated to database units.

        This method has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, t: DTrans) -> None:
        r"""
        @brief Transforms the instance array with the given transformation (given in micrometer units)
        Transforms the instance like \transform_into does, but with a transformation given in micrometer units. The displacement of this transformation is given in micrometers and is internally translated to database units.

        This method has been introduced in version 0.25.
        """
    @overload
    def transform_into(self, t: ICplxTrans) -> None:
        r"""
        @brief Transforms the instance array with the given transformation
        See \Cell#transform_into for a description of this method.

        This method has been introduced in version 0.23.
        """
    @overload
    def transform_into(self, t: Trans) -> None:
        r"""
        @brief Transforms the instance array with the given transformation
        See \Cell#transform_into for a description of this method.

        This method has been introduced in version 0.23.
        """

class ParentInstArray:
    r"""
    @brief A parent instance

    A parent instance is basically an inverse instance: instead of pointing
    to the child cell, it is pointing to the parent cell and the transformation
    is representing the shift of the parent cell relative to the child cell.
    For memory performance, a parent instance is not stored as a instance but
    rather as a reference to a child instance and a reference to the cell which
    is the parent.
    The parent instance itself is computed on the fly. It is representative for
    a set of instances belonging to the same cell index. The special parent instance
    iterator takes care of producing the right sequence (\Cell#each_parent_inst).

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    def __copy__(self) -> ParentInstArray:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ParentInstArray) -> None:
        r"""
        @brief Assigns another object to self
        """
    def child_inst(self) -> Instance:
        r"""
        @brief Retrieve the child instance associated with this parent instance

        Starting with version 0.15, this method returns an \Instance object rather than a \CellInstArray reference.
        """
    def dup(self) -> ParentInstArray:
        r"""
        @brief Creates a copy of self
        """
    def inst(self) -> CellInstArray:
        r"""
        @brief Compute the inverse instance by which the parent is seen from the child
        """
    def parent_cell_index(self) -> int:
        r"""
        @brief Gets the index of the parent cell
        """

class CellInstArray:
    r"""
    @brief A single or array cell instance
    This object represents either single or array cell instances. A cell instance array is a regular array, described by two displacement vectors (a, b) and the instance count along that axes (na, nb). 

    In addition, this object represents either instances with simple transformations or instances with complex transformations. The latter includes magnified instances and instances rotated by an arbitrary angle.

    The cell which is instantiated is given by a cell index. The cell index can be converted to a cell pointer by using \Layout#cell. The cell index of a cell can be obtained using \Cell#cell_index.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    a: Vector
    r"""
    @brief Gets the displacement vector for the 'a' axis

    Starting with version 0.25 the displacement is of vector type.
    @brief Sets the displacement vector for the 'a' axis

    If the instance was not regular before this property is set, it will be initialized to a regular instance.

    This method was introduced in version 0.22. Starting with version 0.25 the displacement is of vector type.
    """
    b: Vector
    r"""
    @brief Gets the displacement vector for the 'b' axis

    Starting with version 0.25 the displacement is of vector type.
    @brief Sets the displacement vector for the 'b' axis

    If the instance was not regular before this property is set, it will be initialized to a regular instance.

    This method was introduced in version 0.22. Starting with version 0.25 the displacement is of vector type.
    """
    cell_index: int
    r"""
    @brief Gets the cell index of the cell instantiated 
    @brief Sets the index of the cell this instance refers to
    """
    cplx_trans: ICplxTrans
    r"""
    @brief Gets the complex transformation of the first instance in the array
    This method is always applicable, compared to \trans, since simple transformations can be expressed as complex transformations as well.@brief Sets the complex transformation of the instance or the first instance in the array

    This method was introduced in version 0.22.
    """
    na: int
    r"""
    @brief Gets the number of instances in the 'a' axis
    @brief Sets the number of instances in the 'a' axis

    If the instance was not regular before this property is set to a value larger than zero, it will be initialized to a regular instance.
    To make an instance a single instance, set na or nb to 0.

    This method was introduced in version 0.22.
    """
    nb: int
    r"""
    @brief Gets the number of instances in the 'b' axis
    @brief Sets the number of instances in the 'b' axis

    If the instance was not regular before this property is set to a value larger than zero, it will be initialized to a regular instance.
    To make an instance a single instance, set na or nb to 0.

    This method was introduced in version 0.22.
    """
    trans: Trans
    r"""
    @brief Gets the transformation of the first instance in the array
    The transformation returned is only valid if the array does not represent a complex transformation array@brief Sets the transformation of the instance or the first instance in the array

    This method was introduced in version 0.22.
    """
    def __copy__(self) -> CellInstArray:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Compares two arrays for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given cell instance. This method enables cell instances as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates en empty cell instance with size 0
        """
    @overload
    def __init__(self, cell_index: int, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a single cell instance with a complex transformation
        @param cell_index The cell to instantiate
        @param trans The complex transformation by which to instantiate the cell
        """
    @overload
    def __init__(self, cell_index: int, trans: Trans) -> None:
        r"""
        @brief Creates a single cell instance
        @param cell_index The cell to instantiate
        @param trans The transformation by which to instantiate the cell
        """
    @overload
    def __init__(self, cell_index: int, trans: ICplxTrans, a: Vector, b: Vector, na: int, nb: int) -> None:
        r"""
        @brief Creates a single cell instance with a complex transformation
        @param cell_index The cell to instantiate
        @param trans The complex transformation by which to instantiate the cell
        @param a The displacement vector of the array in the 'a' axis
        @param b The displacement vector of the array in the 'b' axis
        @param na The number of placements in the 'a' axis
        @param nb The number of placements in the 'b' axis

        Starting with version 0.25 the displacements are of vector type.
        """
    @overload
    def __init__(self, cell_index: int, trans: Trans, a: Vector, b: Vector, na: int, nb: int) -> None:
        r"""
        @brief Creates a single cell instance
        @param cell_index The cell to instantiate
        @param trans The transformation by which to instantiate the cell
        @param a The displacement vector of the array in the 'a' axis
        @param b The displacement vector of the array in the 'b' axis
        @param na The number of placements in the 'a' axis
        @param nb The number of placements in the 'b' axis

        Starting with version 0.25 the displacements are of vector type.
        """
    def __len__(self) -> int:
        r"""
        @brief Gets the number of single instances in the array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb. Starting with version 0.27, there may be iterated instances for which the size is larger than 1, but \is_regular_array? will return false. In this case, use \each_trans or \each_cplx_trans to retrieve the individual placements of the iterated instance.
        """
    def __lt__(self, other: CellInstArray) -> bool:
        r"""
        @brief Compares two arrays for 'less'
        The comparison provides an arbitrary sorting criterion and not specific sorting order. It is guaranteed that if an array a is less than b, b is not less than a. In addition, it a is not less than b and b is not less than a, then a is equal to b.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Compares two arrays for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the array to a string

        This method was introduced in version 0.22.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the array to a string

        This method was introduced in version 0.22.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: CellInstArray) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self, layout: Layout) -> Box:
        r"""
        @brief Gets the bounding box of the array
        The bounding box incorporates all instances that the array represents. It needs the layout object to access the actual cell from the cell index.
        """
    def bbox_per_layer(self, layout: Layout, layer_index: int) -> Box:
        r"""
        @brief Gets the bounding box of the array with respect to one layer
        The bounding box incorporates all instances that the array represents. It needs the layout object to access the actual cell from the cell index.
        """
    def dup(self) -> CellInstArray:
        r"""
        @brief Creates a copy of self
        """
    def each_cplx_trans(self) -> Iterator[ICplxTrans]:
        r"""
        @brief Gets the complex transformations represented by this instance
        For a single instance, this iterator will deliver the single, complex transformation. For array instances, the iterator will deliver each complex transformation of the expanded array.
        This iterator is a generalization of \each_trans for general complex transformations.

        This method has been introduced in version 0.25.
        """
    def each_trans(self) -> Iterator[Trans]:
        r"""
        @brief Gets the simple transformations represented by this instance
        For a single instance, this iterator will deliver the single, simple transformation. For array instances, the iterator will deliver each simple transformation of the expanded array.

        This iterator will only deliver valid transformations if the instance array is not of complex type (see \is_complex?). A more general iterator that delivers the complex transformations is \each_cplx_trans.

        This method has been introduced in version 0.25.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given cell instance. This method enables cell instances as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> None:
        r"""
        @brief Inverts the array reference

        The inverted array reference describes in which transformations the parent cell is
        seen from the current cell.
        """
    def is_complex(self) -> bool:
        r"""
        @brief Gets a value indicating whether the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and 
        arbitrary rotation angles).
        """
    def is_regular_array(self) -> bool:
        r"""
        @brief Gets a value indicating whether this instance is a regular array
        """
    def size(self) -> int:
        r"""
        @brief Gets the number of single instances in the array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb. Starting with version 0.27, there may be iterated instances for which the size is larger than 1, but \is_regular_array? will return false. In this case, use \each_trans or \each_cplx_trans to retrieve the individual placements of the iterated instance.
        """
    def to_s(self) -> str:
        r"""
        @brief Converts the array to a string

        This method was introduced in version 0.22.
        """
    @overload
    def transform(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms the cell instance with the given complex transformation

        This method has been introduced in version 0.20.
        """
    @overload
    def transform(self, trans: Trans) -> None:
        r"""
        @brief Transforms the cell instance with the given transformation

        This method has been introduced in version 0.20.
        """
    @overload
    def transformed(self, trans: ICplxTrans) -> CellInstArray:
        r"""
        @brief Gets the transformed cell instance (complex transformation)

        This method has been introduced in version 0.20.
        """
    @overload
    def transformed(self, trans: Trans) -> CellInstArray:
        r"""
        @brief Gets the transformed cell instance

        This method has been introduced in version 0.20.
        """

class DCellInstArray:
    r"""
    @brief A single or array cell instance in micrometer units
    This object is identical to \CellInstArray, except that it holds coordinates in micron units instead of database units.

    This class has been introduced in version 0.25.
    """
    a: DVector
    r"""
    @brief Gets the displacement vector for the 'a' axis
    @brief Sets the displacement vector for the 'a' axis

    If the instance was not regular before this property is set, it will be initialized to a regular instance.
    """
    b: DVector
    r"""
    @brief Gets the displacement vector for the 'b' axis
    @brief Sets the displacement vector for the 'b' axis

    If the instance was not regular before this property is set, it will be initialized to a regular instance.
    """
    cell_index: int
    r"""
    @brief Gets the cell index of the cell instantiated 
    @brief Sets the index of the cell this instance refers to
    """
    cplx_trans: DCplxTrans
    r"""
    @brief Gets the complex transformation of the first instance in the array
    This method is always applicable, compared to \trans, since simple transformations can be expressed as complex transformations as well.@brief Sets the complex transformation of the instance or the first instance in the array
    """
    na: int
    r"""
    @brief Gets the number of instances in the 'a' axis
    @brief Sets the number of instances in the 'a' axis

    If the instance was not regular before this property is set to a value larger than zero, it will be initialized to a regular instance.
    To make an instance a single instance, set na or nb to 0.
    """
    nb: int
    r"""
    @brief Gets the number of instances in the 'b' axis
    @brief Sets the number of instances in the 'b' axis

    If the instance was not regular before this property is set to a value larger than zero, it will be initialized to a regular instance.
    To make an instance a single instance, set na or nb to 0.
    """
    trans: DTrans
    r"""
    @brief Gets the transformation of the first instance in the array
    The transformation returned is only valid if the array does not represent a complex transformation array@brief Sets the transformation of the instance or the first instance in the array
    """
    def __copy__(self) -> DCellInstArray:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Compares two arrays for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given cell instance. This method enables cell instances as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates en empty cell instance with size 0
        """
    @overload
    def __init__(self, cell_index: int, trans: DCplxTrans) -> None:
        r"""
        @brief Creates a single cell instance with a complex transformation
        @param cell_index The cell to instantiate
        @param trans The complex transformation by which to instantiate the cell
        """
    @overload
    def __init__(self, cell_index: int, trans: DTrans) -> None:
        r"""
        @brief Creates a single cell instance
        @param cell_index The cell to instantiate
        @param trans The transformation by which to instantiate the cell
        """
    @overload
    def __init__(self, cell_index: int, trans: DCplxTrans, a: DVector, b: DVector, na: int, nb: int) -> None:
        r"""
        @brief Creates a single cell instance with a complex transformation
        @param cell_index The cell to instantiate
        @param trans The complex transformation by which to instantiate the cell
        @param a The displacement vector of the array in the 'a' axis
        @param b The displacement vector of the array in the 'b' axis
        @param na The number of placements in the 'a' axis
        @param nb The number of placements in the 'b' axis
        """
    @overload
    def __init__(self, cell_index: int, trans: DTrans, a: DVector, b: DVector, na: int, nb: int) -> None:
        r"""
        @brief Creates a single cell instance
        @param cell_index The cell to instantiate
        @param trans The transformation by which to instantiate the cell
        @param a The displacement vector of the array in the 'a' axis
        @param b The displacement vector of the array in the 'b' axis
        @param na The number of placements in the 'a' axis
        @param nb The number of placements in the 'b' axis
        """
    def __len__(self) -> int:
        r"""
        @brief Gets the number of single instances in the array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb. Starting with version 0.27, there may be iterated instances for which the size is larger than 1, but \is_regular_array? will return false. In this case, use \each_trans or \each_cplx_trans to retrieve the individual placements of the iterated instance.
        """
    def __lt__(self, other: DCellInstArray) -> bool:
        r"""
        @brief Compares two arrays for 'less'
        The comparison provides an arbitrary sorting criterion and not specific sorting order. It is guaranteed that if an array a is less than b, b is not less than a. In addition, it a is not less than b and b is not less than a, then a is equal to b.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Compares two arrays for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the array to a string
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the array to a string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DCellInstArray) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self, layout: Layout) -> DBox:
        r"""
        @brief Gets the bounding box of the array
        The bounding box incorporates all instances that the array represents. It needs the layout object to access the actual cell from the cell index.
        """
    def bbox_per_layer(self, layout: Layout, layer_index: int) -> DBox:
        r"""
        @brief Gets the bounding box of the array with respect to one layer
        The bounding box incorporates all instances that the array represents. It needs the layout object to access the actual cell from the cell index.
        """
    def dup(self) -> DCellInstArray:
        r"""
        @brief Creates a copy of self
        """
    def each_cplx_trans(self) -> Iterator[DCplxTrans]:
        r"""
        @brief Gets the complex transformations represented by this instance
        For a single instance, this iterator will deliver the single, complex transformation. For array instances, the iterator will deliver each complex transformation of the expanded array.
        This iterator is a generalization of \each_trans for general complex transformations.
        """
    def each_trans(self) -> Iterator[DTrans]:
        r"""
        @brief Gets the simple transformations represented by this instance
        For a single instance, this iterator will deliver the single, simple transformation. For array instances, the iterator will deliver each simple transformation of the expanded array.

        This iterator will only deliver valid transformations if the instance array is not of complex type (see \is_complex?). A more general iterator that delivers the complex transformations is \each_cplx_trans.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given cell instance. This method enables cell instances as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> None:
        r"""
        @brief Inverts the array reference

        The inverted array reference describes in which transformations the parent cell is
        seen from the current cell.
        """
    def is_complex(self) -> bool:
        r"""
        @brief Gets a value indicating whether the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and 
        arbitrary rotation angles).
        """
    def is_regular_array(self) -> bool:
        r"""
        @brief Gets a value indicating whether this instance is a regular array
        """
    def size(self) -> int:
        r"""
        @brief Gets the number of single instances in the array
        If the instance represents a single instance, the count is 1. Otherwise it is na*nb. Starting with version 0.27, there may be iterated instances for which the size is larger than 1, but \is_regular_array? will return false. In this case, use \each_trans or \each_cplx_trans to retrieve the individual placements of the iterated instance.
        """
    def to_s(self) -> str:
        r"""
        @brief Converts the array to a string
        """
    @overload
    def transform(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms the cell instance with the given complex transformation
        """
    @overload
    def transform(self, trans: DTrans) -> None:
        r"""
        @brief Transforms the cell instance with the given transformation
        """
    @overload
    def transformed(self, trans: DCplxTrans) -> DCellInstArray:
        r"""
        @brief Gets the transformed cell instance (complex transformation)
        """
    @overload
    def transformed(self, trans: DTrans) -> DCellInstArray:
        r"""
        @brief Gets the transformed cell instance
        """

class CellMapping:
    r"""
    @brief A cell mapping (source to target layout)

    A cell mapping is an association of cells in two layouts forming pairs of cells, i.e. one cell corresponds to another cell in the other layout. The CellMapping object describes the mapping of cells of a source layout B to a target layout A. The cell mapping object is basically a table associating a cell in layout B with a cell in layout A.

    The mapping object is used to create and hold that table. There are three basic modes in which a table can be generated:

    @ul
      @li Top-level identity @/li
      @li Geometrical identity @/li
      @li Name identity @/li
    @/ul

    Top-level identity means that only one cell (the top cell) is regarded identical. All child cells are not considered identical. In full mode (see below), this will create a new, identical cell tree below the top cell in layout A.

    Geometrical identity is defined by the exact identity of the set of expanded instances in each starting cell. Therefore, when a cell is mapped to another cell, shapes can be transferred from one cell to another while effectively rendering the same flat geometry (in the context of the given starting cells). Location identity is basically the safest way to map cells from one hierarchy into another, because it preserves the flat shape geometry. However in some cases the algorithm may find multiple mapping candidates. In that case it will make a guess about what mapping to choose.

    Name identity means that cells are identified by their names - for a source cell in layer B, a target cell with the same name is looked up in the target layout A and a mapping is created if a cell with the same name is found. However, name identity does not mean that the cells are actually equivalent because they may be placed differently. Hence, cell mapping by name is not a good choice when it is important to preserve the shape geometry of a layer.

    A cell might not be mapped to another cell which basically means that there is no corresponding cell. In this case, flattening to the next mapped cell is an option to transfer geometries despite the missing mapping. You can enforce a mapping by using the mapping generator methods in 'full' mode, i.e. \from_names_full or \from_geometry_full. These versions will create new cells and their corresponding instances in the target layout if no suitable target cell is found.

    CellMapping objects play a role mainly in the hierarchical copy or move operations of \Layout. However, use is not restricted to these applications.

    Here is one example for using \CellMapping. It extracts cells 'A', 'B' and 'C' from one layout and copies them to another. It will also copy all shapes and all child cells. Child cells which are shared between the three initial cells will be shared in the target layout too.

    @code
    cell_names = [ "A", "B", "C" ]

    source = RBA::Layout::new
    source.read("input.gds")

    target = RBA::Layout::new

    source_cells = cell_names.collect { |n| source.cell_by_name(n).cell_index }
    target_cells = cell_names.collect { |n| target.create_cell(n).cell_index }

    cm = RBA::CellMapping::new
    cm.for_multi_cells_full(source, source_cells, target, target_cells)
    target.copy_tree_shapes(source, cm)
    @/code
    """
    DropCell: ClassVar[int]
    r"""
    @brief A constant indicating the reques to drop a cell

    If used as a pseudo-target for the cell mapping, this index indicates that the cell shall be dropped rather than created on the target side or skipped by flattening. Instead, all shapes of this cell are discarded and it's children are not translated unless explicitly requested or if required are children for other cells.

    This constant has been introduced in version 0.25.
    """
    def __copy__(self) -> CellMapping:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: CellMapping) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cell_mapping(self, cell_index_b: int) -> int:
        r"""
        @brief Determines cell mapping of a layout_b cell to the corresponding layout_a cell.


        @param cell_index_b The index of the cell in layout_b whose mapping is requested.
        @return The cell index in layout_a.

        Note that the returned index can be \DropCell to indicate the cell shall be dropped.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the mapping.

        This method has been introduced in version 0.23.
        """
    def dup(self) -> CellMapping:
        r"""
        @brief Creates a copy of self
        """
    def for_multi_cells(self, layout_a: Layout, cell_indexes_a: Sequence[int], layout_b: Layout, cell_indexes_b: Sequence[int]) -> None:
        r"""
        @brief Initializes the cell mapping for top-level identity

        @param layout_a The target layout.
        @param cell_indexes_a A list of cell indexes for the target cells.
        @param layout_b The source layout.
        @param cell_indexes_b A list of cell indexes for the source cells (same number of indexes than \cell_indexes_a).

        The cell mapping is created for cells from cell_indexes_b to cell from cell_indexes_a in the respective layouts. This method clears the mapping and creates one for each cell pair from cell_indexes_b vs. cell_indexes_a. If used for \Layout#copy_tree_shapes or \Layout#move_tree_shapes, this cell mapping will essentially flatten the source cells in the target layout.

        This method is equivalent to \clear, followed by \map(cell_index_a, cell_index_b) for each cell pair.

        This method has been introduced in version 0.27.
        """
    def for_multi_cells_full(self, layout_a: Layout, cell_indexes_a: Sequence[int], layout_b: Layout, cell_indexes_b: Sequence[int]) -> List[int]:
        r"""
        @brief Initializes the cell mapping for top-level identity

        @param layout_a The target layout.
        @param cell_indexes_a A list of cell indexes for the target cells.
        @param layout_b The source layout.
        @param cell_indexes_b A list of cell indexes for the source cells (same number of indexes than \cell_indexes_a).

        The cell mapping is created for cells from cell_indexes_b to cell from cell_indexes_a in the respective layouts. This method clears the mapping and creates one for each cell pair from cell_indexes_b vs. cell_indexes_a. In addition and in contrast to \for_multi_cells, this method completes the mapping by adding all the child cells of all cells in cell_indexes_b to layout_a and creating the proper instances.

        This method has been introduced in version 0.27.
        """
    def for_single_cell(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> None:
        r"""
        @brief Initializes the cell mapping for top-level identity

        @param layout_a The target layout.
        @param cell_index_a The index of the target cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source cell.

        The cell mapping is created for cell_b to cell_a in the respective layouts. This method clears the mapping and creates one for the single cell pair. If used for \Cell#copy_tree or \Cell#move_tree, this cell mapping will essentially flatten the cell.

        This method is equivalent to \clear, followed by \map(cell_index_a, cell_index_b).

        This method has been introduced in version 0.23.
        """
    def for_single_cell_full(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> List[int]:
        r"""
        @brief Initializes the cell mapping for top-level identity

        @param layout_a The target layout.
        @param cell_index_a The index of the target cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source cell.

        The cell mapping is created for cell_b to cell_a in the respective layouts. This method clears the mapping and creates one for the single cell pair. In addition and in contrast to \for_single_cell, this method completes the mapping by adding all the child cells of cell_b to layout_a and creating the proper instances.

        This method has been introduced in version 0.23.
        """
    def from_geometry(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> None:
        r"""
        @brief Initializes the cell mapping using the geometrical identity

        @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source starting cell.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts. This method employs geometrical identity to derive mappings for the child cells of the starting cell in layout A and B.
        If the geometrical identity is ambiguous, the algorithm will make an arbitrary choice.

        This method has been introduced in version 0.23.
        """
    def from_geometry_full(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> List[int]:
        r"""
        @brief Initializes the cell mapping using the geometrical identity in full mapping mode

        @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source starting cell.
        @return A list of indexes of cells created.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts. This method employs geometrical identity to derive mappings for the child cells of the starting cell in layout A and B.
        If the geometrical identity is ambiguous, the algorithm will make an arbitrary choice.

        Full mapping means that cells which are not found in the target layout A are created there plus their corresponding instances are created as well. The returned list will contain the indexes of all cells created for that reason.

        This method has been introduced in version 0.23.
        """
    def from_names(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> None:
        r"""
        @brief Initializes the cell mapping using the name identity

        @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source starting cell.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs name identity to derive mappings for the child cells of the starting cell in layout A and B.

        This method has been introduced in version 0.23.
        """
    def from_names_full(self, layout_a: Layout, cell_index_a: int, layout_b: Layout, cell_index_b: int) -> List[int]:
        r"""
        @brief Initializes the cell mapping using the name identity in full mapping mode

        @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell.
        @param layout_b The source layout.
        @param cell_index_b The index of the source starting cell.
        @return A list of indexes of cells created.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs name identity to derive mappings for the child cells of the starting cell in layout A and B.

        Full mapping means that cells which are not found in the target layout A are created there plus their corresponding instances are created as well. The returned list will contain the indexes of all cells created for that reason.

        This method has been introduced in version 0.23.
        """
    def has_mapping(self, cell_index_b: int) -> bool:
        r"""
        @brief Returns as value indicating whether a cell of layout_b has a mapping to a layout_a cell.


        @param cell_index_b The index of the cell in layout_b whose mapping is requested.
        @return true, if the cell has a mapping

        Note that if the cell is supposed to be dropped (see \DropCell), the respective source cell will also be regarded "mapped", so has_mapping? will return true in this case.
        """
    def map(self, cell_index_b: int, cell_index_a: int) -> None:
        r"""
        @brief Explicitly specifies a mapping.


        @param cell_index_b The index of the cell in layout B (the "source")
        @param cell_index_a The index of the cell in layout A (the "target") - this index can be \DropCell

        Beside using the mapping generator algorithms provided through \from_names and \from_geometry, it is possible to explicitly specify cell mappings using this method.

        This method has been introduced in version 0.23.
        """
    def table(self) -> Dict[int, int]:
        r"""
        @brief Returns the mapping table.

        The mapping table is a dictionary where the keys are source layout cell indexes and the values are the target layout cell indexes.
        Note that the target cell index can be \DropCell to indicate that a cell is supposed to be dropped.

        This method has been introduced in version 0.25.
        """

class CompoundRegionOperationNode:
    r"""
    @brief A base class for compound DRC operations

    This class is not intended to be used directly but rather provide a factory for various incarnations of compound operation nodes. Compound operations are a way to specify complex DRC operations put together by building a tree of operations. This operation tree then is executed with \Region#complex_op and will act on individual clusters of shapes and their interacting neighbors.

    A basic concept to the compound operations is the 'subject' (primary) and 'intruder' (secondary) input. The 'subject' is the Region, 'complex_op' with the operation tree is executed on. 'intruders' are regions inserted into the equation through secondary input nodes created with \new_secondary_node. The algorithm will execute the operation tree for every subject shape considering intruder shapes from the secondary inputs. The algorithm will only act on subject shapes primarily. As a consequence, 'lonely' intruder shapes without a subject shape are not considered at all. Only subject shapes trigger evaluation of the operation tree.

    The search distance for intruder shapes is determined by the operation and computed from the operation's requirements.

    NOTE: this feature is experimental and not deployed into the the DRC framework yet.

    This class has been introduced in version 0.27.
    """
    class LogicalOp:
        r"""
        @brief This class represents the CompoundRegionOperationNode::LogicalOp enum

        This enum has been introduced in version 0.27.
        """
        LogAnd: ClassVar[CompoundRegionOperationNode.LogicalOp]
        r"""
        @brief Indicates a logical '&&' (and).
        """
        LogOr: ClassVar[CompoundRegionOperationNode.LogicalOp]
        r"""
        @brief Indicates a logical '||' (or).
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: CompoundRegionOperationNode.LogicalOp) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class GeometricalOp:
        r"""
        @brief This class represents the CompoundRegionOperationNode::GeometricalOp enum

        This enum has been introduced in version 0.27.
        """
        And: ClassVar[CompoundRegionOperationNode.GeometricalOp]
        r"""
        @brief Indicates a geometrical '&' (and).
        """
        Not: ClassVar[CompoundRegionOperationNode.GeometricalOp]
        r"""
        @brief Indicates a geometrical '-' (not).
        """
        Or: ClassVar[CompoundRegionOperationNode.GeometricalOp]
        r"""
        @brief Indicates a geometrical '|' (or).
        """
        Xor: ClassVar[CompoundRegionOperationNode.GeometricalOp]
        r"""
        @brief Indicates a geometrical '^' (xor).
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: CompoundRegionOperationNode.GeometricalOp) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class ResultType:
        r"""
        @brief This class represents the CompoundRegionOperationNode::ResultType enum

        This enum has been introduced in version 0.27.
        """
        EdgePairs: ClassVar[CompoundRegionOperationNode.ResultType]
        r"""
        @brief Indicates edge pair result type.
        """
        Edges: ClassVar[CompoundRegionOperationNode.ResultType]
        r"""
        @brief Indicates edge result type.
        """
        Region: ClassVar[CompoundRegionOperationNode.ResultType]
        r"""
        @brief Indicates polygon result type.
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: CompoundRegionOperationNode.ResultType) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class ParameterType:
        r"""
        @brief This class represents the parameter type enum used in \CompoundRegionOperationNode#new_bbox_filter

        This enum has been introduced in version 0.27.
        """
        BoxAverageDim: ClassVar[CompoundRegionOperationNode.ParameterType]
        r"""
        @brief Measures the average of width and height of the bounding box
        """
        BoxHeight: ClassVar[CompoundRegionOperationNode.ParameterType]
        r"""
        @brief Measures the height of the bounding box
        """
        BoxMaxDim: ClassVar[CompoundRegionOperationNode.ParameterType]
        r"""
        @brief Measures the maximum dimension of the bounding box
        """
        BoxMinDim: ClassVar[CompoundRegionOperationNode.ParameterType]
        r"""
        @brief Measures the minimum dimension of the bounding box
        """
        BoxWidth: ClassVar[CompoundRegionOperationNode.ParameterType]
        r"""
        @brief Measures the width of the bounding box
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: CompoundRegionOperationNode.ParameterType) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class RatioParameterType:
        r"""
        @brief This class represents the parameter type enum used in \CompoundRegionOperationNode#new_ratio_filter

        This enum has been introduced in version 0.27.
        """
        AreaRatio: ClassVar[CompoundRegionOperationNode.RatioParameterType]
        r"""
        @brief Measures the area ratio (bounding box area / polygon area)
        """
        AspectRatio: ClassVar[CompoundRegionOperationNode.RatioParameterType]
        r"""
        @brief Measures the aspect ratio of the bounding box (larger / smaller dimension)
        """
        RelativeHeight: ClassVar[CompoundRegionOperationNode.RatioParameterType]
        r"""
        @brief Measures the relative height (height / width)
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: CompoundRegionOperationNode.RatioParameterType) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    description: str
    r"""
    @brief Gets the description for this node@brief Sets the description for this node
    """
    distance: int
    r"""
    @brief Gets the distance value for this node@brief Sets the distance value for this nodeUsually it's not required to provide a distance because the nodes compute a distance based on their operation. If necessary you can supply a distance. The processor will use this distance or the computed one, whichever is larger.
    """
    @classmethod
    def new_area_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., amin: Optional[int] = ..., amax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by area.
        This node renders the input if the area is between amin and amax (exclusively). If 'inverse' is set to true, the input shape is returned if the area is less than amin (exclusively) or larger than amax (inclusively).
        """
    @classmethod
    def new_area_sum_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., amin: Optional[int] = ..., amax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by area sum.
        Like \new_area_filter, but applies to the sum of all shapes in the current set.
        """
    @classmethod
    def new_bbox_filter(cls, input: CompoundRegionOperationNode, parameter: CompoundRegionOperationNode.ParameterType, inverse: Optional[bool] = ..., pmin: Optional[int] = ..., pmax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by bounding box parameters.
        This node renders the input if the specified bounding box parameter of the input shape is between pmin and pmax (exclusively). If 'inverse' is set to true, the input shape is returned if the parameter is less than pmin (exclusively) or larger than pmax (inclusively).
        """
    @classmethod
    def new_case(cls, inputs: Sequence[CompoundRegionOperationNode]) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a 'switch ladder' (case statement) compound operation node.

        The inputs are treated as a sequence of condition/result pairs: c1,r1,c2,r2 etc. If there is an odd number of inputs, the last element is taken as the default result. The implementation will evaluate c1 and if not empty, will render r1. Otherwise, c2 will be evaluated and r2 rendered if c2 isn't empty etc. If none of the conditions renders a non-empty set and a default result is present, the default will be returned. Otherwise, the result is empty.
        """
    @classmethod
    def new_centers(cls, input: CompoundRegionOperationNode, length: int, fraction: float) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a part at the center of each input edge.
        """
    @classmethod
    def new_convex_decomposition(cls, input: CompoundRegionOperationNode, mode: PreferredOrientation) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a composition into convex pieces.
        """
    @classmethod
    def new_corners_as_dots(cls, input: CompoundRegionOperationNode, angle_min: float, include_angle_min: bool, angle_max: float, include_angle_max: bool) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node turning corners into dots (single-point edges).
        """
    @classmethod
    def new_corners_as_edge_pairs(cls, input: CompoundRegionOperationNode, angle_min: float, include_angle_min: bool, angle_max: float, include_angle_max: bool) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node turning corners into edge pairs containing the two edges adjacent to the corner.
        The first edge will be the incoming edge and the second one the outgoing edge.

        This feature has been introduced in version 0.27.1.
        """
    @classmethod
    def new_corners_as_rectangles(cls, input: CompoundRegionOperationNode, angle_min: float, include_angle_min: bool, angle_max: float, include_angle_max: bool, dim: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node turning corners into rectangles.
        """
    @classmethod
    def new_count_filter(cls, inputs: CompoundRegionOperationNode, invert: Optional[bool] = ..., min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node selecting results but their shape count.
        """
    @classmethod
    def new_edge_length_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., lmin: Optional[int] = ..., lmax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering edges by their length.
        """
    @classmethod
    def new_edge_length_sum_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., lmin: Optional[int] = ..., lmax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering edges by their length sum (over the local set).
        """
    @classmethod
    def new_edge_orientation_filter(cls, input: CompoundRegionOperationNode, inverse: bool, amin: float, include_amin: bool, amax: float, include_amax: bool) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering edges by their orientation.
        """
    @classmethod
    def new_edge_pair_to_first_edges(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering the first edge of each edges pair.
        """
    @classmethod
    def new_edge_pair_to_second_edges(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering the second edge of each edges pair.
        """
    @classmethod
    def new_edges(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node converting polygons into it's edges.
        """
    @classmethod
    def new_empty(cls, type: CompoundRegionOperationNode.ResultType) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering an empty result of the given type
        """
    @classmethod
    def new_enclosed_check(cls, other: CompoundRegionOperationNode, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing an enclosed (secondary enclosing primary) check.

        This method has been added in version 0.27.5.
        """
    @classmethod
    def new_enclosing(cls, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode, inverse: Optional[bool] = ..., min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing an inside selection operation between the inputs.
        """
    @classmethod
    def new_enclosing_check(cls, other: CompoundRegionOperationNode, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing an inside (enclosure) check.
        """
    @classmethod
    def new_end_segments(cls, input: CompoundRegionOperationNode, length: int, fraction: float) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a part at the end of each input edge.
        """
    @classmethod
    def new_extended(cls, input: CompoundRegionOperationNode, ext_b: int, ext_e: int, ext_o: int, ext_i: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a polygonized version of the edges with the four extension parameters.
        """
    @classmethod
    def new_extended_in(cls, input: CompoundRegionOperationNode, e: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a polygonized, inside-extended version of the edges.
        """
    @classmethod
    def new_extended_out(cls, input: CompoundRegionOperationNode, e: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a polygonized, inside-extended version of the edges.
        """
    @classmethod
    def new_extents(cls, input: CompoundRegionOperationNode, e: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node returning the extents of the objects.
        The 'e' parameter provides a generic enlargement which is applied to the boxes. This is helpful to cover dot-like edges or edge pairs in the input.
        """
    @classmethod
    def new_foreign(cls) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node object representing the primary input without the current polygon
        """
    @classmethod
    def new_geometrical_boolean(cls, op: CompoundRegionOperationNode.GeometricalOp, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing a geometrical boolean operation between the inputs.
        """
    @classmethod
    def new_hole_count_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., hmin: Optional[int] = ..., hmax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by number of holes per polygon.
        This node renders the input if the hole count is between hmin and hmax (exclusively). If 'inverse' is set to true, the input shape is returned if the hole count is less than hmin (exclusively) or larger than hmax (inclusively).
        """
    @classmethod
    def new_holes(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node extracting the holes from polygons.
        """
    @classmethod
    def new_hulls(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node extracting the hulls from polygons.
        """
    @classmethod
    def new_inside(cls, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode, inverse: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing an inside selection operation between the inputs.
        """
    @classmethod
    def new_interacting(cls, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode, inverse: Optional[bool] = ..., min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing an interacting selection operation between the inputs.
        """
    @classmethod
    def new_isolated_check(cls, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a isolated polygons (space between different polygons) check.
        """
    @classmethod
    def new_join(cls, inputs: Sequence[CompoundRegionOperationNode]) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node that joins the inputs.
        """
    @classmethod
    def new_logical_boolean(cls, op: CompoundRegionOperationNode.LogicalOp, invert: bool, inputs: Sequence[CompoundRegionOperationNode]) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing a logical boolean operation between the inputs.

        A logical AND operation will evaluate the arguments and render the subject shape when all arguments are non-empty. The logical OR operation will evaluate the arguments and render the subject shape when one argument is non-empty. Setting 'inverse' to true will reverse the result and return the subject shape when one argument is empty in the AND case and when all arguments are empty in the OR case.
        """
    @classmethod
    def new_merged(cls, input: CompoundRegionOperationNode, min_coherence: Optional[bool] = ..., min_wc: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing merged input polygons.
        """
    @overload
    @classmethod
    def new_minkowski_sum(cls, input: CompoundRegionOperationNode, e: Edge) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a Minkowski sum with an edge.
        """
    @overload
    @classmethod
    def new_minkowski_sum(cls, input: CompoundRegionOperationNode, p: Box) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a Minkowski sum with a box.
        """
    @overload
    @classmethod
    def new_minkowski_sum(cls, input: CompoundRegionOperationNode, p: Polygon) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a Minkowski sum with a polygon.
        """
    @overload
    @classmethod
    def new_minkowski_sum(cls, input: CompoundRegionOperationNode, p: Sequence[Point]) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a Minkowski sum with a point sequence forming a contour.
        """
    @classmethod
    def new_notch_check(cls, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a intra-polygon space check.
        """
    @classmethod
    def new_outside(cls, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode, inverse: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing an outside selection operation between the inputs.
        """
    @classmethod
    def new_overlap_check(cls, other: CompoundRegionOperationNode, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing an overlap check.
        """
    @classmethod
    def new_overlapping(cls, a: CompoundRegionOperationNode, b: CompoundRegionOperationNode, inverse: Optional[bool] = ..., min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node representing an overlapping selection operation between the inputs.
        """
    @classmethod
    def new_perimeter_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., pmin: Optional[int] = ..., pmax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by perimeter.
        This node renders the input if the perimeter is between pmin and pmax (exclusively). If 'inverse' is set to true, the input shape is returned if the perimeter is less than pmin (exclusively) or larger than pmax (inclusively).
        """
    @classmethod
    def new_perimeter_sum_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ..., amin: Optional[int] = ..., amax: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by area sum.
        Like \new_perimeter_filter, but applies to the sum of all shapes in the current set.
        """
    @classmethod
    def new_polygon_breaker(cls, input: CompoundRegionOperationNode, max_vertex_count: int, max_area_ratio: float) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a composition into parts with less than the given number of points and a smaller area ratio.
        """
    @classmethod
    def new_polygons(cls, input: CompoundRegionOperationNode, e: Optional[int] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node converting the input to polygons.
        @param e The enlargement parameter when converting edges or edge pairs to polygons.
        """
    @classmethod
    def new_primary(cls) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node object representing the primary input
        """
    @classmethod
    def new_ratio_filter(cls, input: CompoundRegionOperationNode, parameter: CompoundRegionOperationNode.RatioParameterType, inverse: Optional[bool] = ..., pmin: Optional[float] = ..., pmin_included: Optional[bool] = ..., pmax: Optional[float] = ..., pmax_included: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input by ratio parameters.
        This node renders the input if the specified ratio parameter of the input shape is between pmin and pmax. If 'pmin_included' is true, the range will include pmin. Same for 'pmax_included' and pmax. If 'inverse' is set to true, the input shape is returned if the parameter is not within the specified range.
        """
    @classmethod
    def new_rectangle_filter(cls, input: CompoundRegionOperationNode, is_square: Optional[bool] = ..., inverse: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input for rectangular or square shapes.
        If 'is_square' is true, only squares will be selected. If 'inverse' is true, the non-rectangle/non-square shapes are returned.
        """
    @classmethod
    def new_rectilinear_filter(cls, input: CompoundRegionOperationNode, inverse: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node filtering the input for rectilinear shapes (or non-rectilinear ones with 'inverse' set to 'true').
        """
    @classmethod
    def new_relative_extents(cls, input: CompoundRegionOperationNode, fx1: float, fy1: float, fx2: float, fy2: float, dx: int, dy: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node returning markers at specified locations of the extent (e.g. at the center).
        """
    @classmethod
    def new_relative_extents_as_edges(cls, input: CompoundRegionOperationNode, fx1: float, fy1: float, fx2: float, fy2: float) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node returning edges at specified locations of the extent (e.g. at the center).
        """
    @classmethod
    def new_rounded_corners(cls, input: CompoundRegionOperationNode, rinner: float, router: float, n: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node generating rounded corners.
        @param rinner The inner corner radius.@param router The outer corner radius.@param n The number if points per full circle.
        """
    @classmethod
    def new_secondary(cls, region: Region) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node object representing the secondary input from the given region
        """
    @classmethod
    def new_separation_check(cls, other: CompoundRegionOperationNode, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a separation check.
        """
    @classmethod
    def new_sized(cls, input: CompoundRegionOperationNode, dx: int, dy: int, mode: int) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing sizing.
        """
    @classmethod
    def new_smoothed(cls, input: CompoundRegionOperationNode, d: int, keep_hv: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node smoothing the polygons.
        @param d The tolerance to be applied for the smoothing.
        @param keep_hv If true, horizontal and vertical edges are maintained.
        """
    @classmethod
    def new_space_check(cls, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a space check.
        """
    @classmethod
    def new_start_segments(cls, input: CompoundRegionOperationNode, length: int, fraction: float) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node delivering a part at the beginning of each input edge.
        """
    @classmethod
    def new_strange_polygons_filter(cls, input: CompoundRegionOperationNode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node extracting strange polygons.
        'strange polygons' are ones which cannot be oriented - e.g. '8' shape polygons.
        """
    @classmethod
    def new_trapezoid_decomposition(cls, input: CompoundRegionOperationNode, mode: TrapezoidDecompositionMode) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a composition into trapezoids.
        """
    @classmethod
    def new_width_check(cls, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., negative: Optional[bool] = ...) -> CompoundRegionOperationNode:
        r"""
        @brief Creates a node providing a width check.
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def result_type(self) -> CompoundRegionOperationNode.ResultType:
        r"""
        @brief Gets the result type of this node
        """

class TrapezoidDecompositionMode:
    r"""
    @brief This class represents the TrapezoidDecompositionMode enum used within trapezoid decomposition

    This enum has been introduced in version 0.27.
    """
    TD_htrapezoids: ClassVar[TrapezoidDecompositionMode]
    r"""
    @brief Indicates horizontal trapezoid decomposition.
    """
    TD_simple: ClassVar[TrapezoidDecompositionMode]
    r"""
    @brief Indicates unspecific decomposition.
    """
    TD_vtrapezoids: ClassVar[TrapezoidDecompositionMode]
    r"""
    @brief Indicates vertical trapezoid decomposition.
    """
    def __copy__(self) -> TrapezoidDecompositionMode:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Compares two enums
        """
    @overload
    def __init__(self, i: int) -> None:
        r"""
        @brief Creates an enum from an integer value
        """
    @overload
    def __init__(self, s: str) -> None:
        r"""
        @brief Creates an enum from a string value
        """
    def __lt__(self, other: TrapezoidDecompositionMode) -> bool:
        r"""
        @brief Returns true if the first enum is less (in the enum symbol order) than the second
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Compares two enums for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """
    def __str__(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: TrapezoidDecompositionMode) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> TrapezoidDecompositionMode:
        r"""
        @brief Creates a copy of self
        """
    def inspect(self) -> str:
        r"""
        @brief Converts an enum to a visual string
        """
    def to_i(self) -> int:
        r"""
        @brief Gets the integer value from the enum
        """
    def to_s(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """

class PreferredOrientation:
    r"""
    @brief This class represents the PreferredOrientation enum used within polygon decomposition

    This enum has been introduced in version 0.27.
    """
    PO_any: ClassVar[PreferredOrientation]
    r"""
    @brief Indicates any orientation.
    """
    PO_horizontal: ClassVar[PreferredOrientation]
    r"""
    @brief Indicates horizontal orientation.
    """
    PO_htrapezoids: ClassVar[PreferredOrientation]
    r"""
    @brief Indicates horizontal trapezoid decomposition.
    """
    PO_vertical: ClassVar[PreferredOrientation]
    r"""
    @brief Indicates vertical orientation.
    """
    PO_vtrapezoids: ClassVar[PreferredOrientation]
    r"""
    @brief Indicates vertical trapezoid decomposition.
    """
    def __copy__(self) -> PreferredOrientation:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Compares two enums
        """
    @overload
    def __init__(self, i: int) -> None:
        r"""
        @brief Creates an enum from an integer value
        """
    @overload
    def __init__(self, s: str) -> None:
        r"""
        @brief Creates an enum from a string value
        """
    def __lt__(self, other: PreferredOrientation) -> bool:
        r"""
        @brief Returns true if the first enum is less (in the enum symbol order) than the second
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Compares two enums for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """
    def __str__(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: PreferredOrientation) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> PreferredOrientation:
        r"""
        @brief Creates a copy of self
        """
    def inspect(self) -> str:
        r"""
        @brief Converts an enum to a visual string
        """
    def to_i(self) -> int:
        r"""
        @brief Gets the integer value from the enum
        """
    def to_s(self) -> str:
        r"""
        @brief Gets the symbolic string from an enum
        """

class DeepShapeStore:
    r"""
    @brief An opaque layout heap for the deep region processor

    This class is used for keeping intermediate, hierarchical data for the deep region processor. It is used in conjunction with the region constructor to create a deep (hierarchical) region.
    @code
    layout = ... # a layout
    layer = ...  # a layer
    cell = ...   # a cell (initial cell for the deep region)
    dss = RBA::DeepShapeStore::new
    region = RBA::Region::new(cell.begin(layer), dss)
    @/code

    The DeepShapeStore object also supplies some configuration options for the operations acting on the deep regions. See for example \threads=.

    This class has been introduced in version 0.26.
    """
    max_area_ratio: float
    r"""
    @brief Gets the max. area ratio.
    @brief Sets the max. area ratio for bounding box vs. polygon area

    This parameter is used to simplify complex polygons. It is used by
    create_polygon_layer with the default parameters. It's also used by
    boolean operations when they deliver their output.
    """
    max_vertex_count: int
    r"""
    @brief Gets the maximum vertex count.
    @brief Sets the maximum vertex count default value

    This parameter is used to simplify complex polygons. It is used by
    create_polygon_layer with the default parameters. It's also used by
    boolean operations when they deliver their output.
    """
    reject_odd_polygons: bool
    r"""
    @brief Gets a flag indicating whether to reject odd polygons.
    This attribute has been introduced in version 0.27.@brief Sets a flag indicating whether to reject odd polygons

    Some kind of 'odd' (e.g. non-orientable) polygons may spoil the functionality because they cannot be handled properly. By using this flag, the shape store we reject these kind of polygons. The default is 'accept' (without warning).

    This attribute has been introduced in version 0.27.
    """
    text_enlargement: int
    r"""
    @brief Gets the text enlargement value.
    @brief Sets the text enlargement value

    If set to a non-negative value, text objects are converted to boxes with the
    given enlargement (width = 2 * enlargement). The box centers are identical
    to the original location of the text.
    If this value is negative (the default), texts are ignored.
    """
    text_property_name: Any
    r"""
    @brief Gets the text property name.
    @brief Sets the text property name.

    If set to a non-null variant, text strings are attached to the generated boxes
    as properties with this particular name. This option has an effect only if the
    text_enlargement property is not negative.
    By default, the name is empty.
    """
    threads: int
    r"""
    @brief Gets the number of threads.
    @brief Sets the number of threads to allocate for the hierarchical processor
    """
    @classmethod
    def instance_count(cls) -> int:
        r"""
        @hide
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_breakout_cell(self, layout_index: int, cell_index: Sequence[int]) -> None:
        r"""
        @brief Adds a cell indexe to the breakout cell list for the given layout inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def add_breakout_cells(self, pattern: str) -> None:
        r"""
        @brief Adds cells (given by a cell name pattern) to the breakout cell list to all layouts inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def add_breakout_cells(self, layout_index: int, cells: Sequence[int]) -> None:
        r"""
        @brief Adds cell indexes to the breakout cell list for the given layout inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def add_breakout_cells(self, layout_index: int, pattern: str) -> None:
        r"""
        @brief Adds cells (given by a cell name pattern) to the breakout cell list for the given layout inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def clear_breakout_cells(self) -> None:
        r"""
        @brief Clears the breakout cells
        See the other variant of \clear_breakout_cells for details.

        This method has been added in version 0.26.1
        """
    @overload
    def clear_breakout_cells(self, layout_index: int) -> None:
        r"""
        @brief Clears the breakout cells
        Breakout cells are a feature by which hierarchy handling can be disabled for specific cells. If cells are specified as breakout cells, they don't interact with neighbor or parent cells, hence are virtually isolated. Breakout cells are useful to shortcut hierarchy evaluation for cells which are otherwise difficult to handle. An example are memory array cells with overlaps to their neighbors: a precise handling of such cells would generate variants and the boundary of the array. Although precise, this behavior leads to partial flattening and propagation of shapes. In consequence, this will also result in wrong device detection in LVS applications. In such cases, these array cells can be declared 'breakout cells' which makes them isolated entities and variant generation does not happen.

        See also \set_breakout_cells and \add_breakout_cells.

        This method has been added in version 0.26.1
        """
    def is_singular(self) -> bool:
        r"""
        @brief Gets a value indicating whether there is a single layout variant

        Specifically for network extraction, singular DSS objects are required. Multiple layouts may be present if different sources of layouts have been used. Such DSS objects are not usable for network extraction.
        """
    def pop_state(self) -> None:
        r"""
        @brief Restores the store's state on the state state
        This will restore the state pushed by \push_state.

        This method has been added in version 0.26.1
        """
    def push_state(self) -> None:
        r"""
        @brief Pushes the store's state on the state state
        This will save the stores state (\threads, \max_vertex_count, \max_area_ratio, breakout cells ...) on the state stack. \pop_state can be used to restore the state.

        This method has been added in version 0.26.1
        """
    @overload
    def set_breakout_cells(self, pattern: str) -> None:
        r"""
        @brief Sets the breakout cell list (as cell name pattern) for the all layouts inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def set_breakout_cells(self, layout_index: int, cells: Sequence[int]) -> None:
        r"""
        @brief Sets the breakout cell list (as cell indexes) for the given layout inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """
    @overload
    def set_breakout_cells(self, layout_index: int, pattern: str) -> None:
        r"""
        @brief Sets the breakout cell list (as cell name pattern) for the given layout inside the store
        See \clear_breakout_cells for an explanation of breakout cells.

        This method has been added in version 0.26.1
        """

class Edge:
    r"""
    @brief An edge class

    An edge is a connection between points, usually participating in a larger context such as a polygon. An edge has a defined direction (from p1 to p2). Edges play a role in the database as parts of polygons and to describe a line through both points.
    Although supported, edges are rarely used as individual database objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects like the Edge class.
    """
    p1: Point
    r"""
    @brief The first point.
    @brief Sets the first point.
    This method has been added in version 0.23.
    """
    p2: Point
    r"""
    @brief The second point.
    @brief Sets the second point.
    This method has been added in version 0.23.
    """
    x1: int
    r"""
    @brief Shortcut for p1.x
    @brief Sets p1.x
    This method has been added in version 0.23.
    """
    x2: int
    r"""
    @brief Shortcut for p2.x
    @brief Sets p2.x
    This method has been added in version 0.23.
    """
    y1: int
    r"""
    @brief Shortcut for p1.y
    @brief Sets p1.y
    This method has been added in version 0.23.
    """
    y2: int
    r"""
    @brief Shortcut for p2.y
    @brief Sets p2.y
    This method has been added in version 0.23.
    """
    @classmethod
    def from_s(cls, s: str) -> Edge:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> Edge:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, e: object) -> bool:
        r"""
        @brief Equality test
        @param e The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge. This method enables edges as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a degenerated edge 0,0 to 0,0
        """
    @overload
    def __init__(self, dedge: DEdge) -> None:
        r"""
        @brief Creates an integer coordinate edge from a floating-point coordinate edge

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dedge'.
        """
    @overload
    def __init__(self, p1: Point, p2: Point) -> None:
        r"""
        @brief Constructor with two points

        Two points are given to create a new edge.
        """
    @overload
    def __init__(self, x1: int, y1: int, x2: int, y2: int) -> None:
        r"""
        @brief Constructor with two coordinates given as single values

        Two points are given to create a new edge.
        """
    def __lt__(self, e: Edge) -> bool:
        r"""
        @brief Less operator
        @param e The object to compare against
        @return True, if the edge is 'less' as the other edge with respect to first and second point
        """
    def __mul__(self, scale_factor: float) -> Edge:
        r"""
        @brief Scale edge

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge
        """
    def __ne__(self, e: object) -> bool:
        r"""
        @brief Inequality test
        @param e The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    def __rmul__(self, scale_factor: float) -> Edge:
        r"""
        @brief Scale edge

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Edge) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Return the bounding box of the edge.
        """
    def clipped(self, box: Box) -> Any:
        r"""
        @brief Returns the edge clipped at the given box

        @param box The clip box.
        @return The clipped edge or nil if the edge does not intersect with the box.

        This method has been introduced in version 0.26.2.
        """
    def clipped_line(self, box: Box) -> Any:
        r"""
        @brief Returns the line through the edge clipped at the given box

        @param box The clip box.
        @return The part of the line through the box or nil if the line does not intersect with the box.

        In contrast to \clipped, this method will consider the edge extended infinitely (a "line"). The returned edge will be the part of this line going through the box.

        This method has been introduced in version 0.26.2.
        """
    def coincident(self, e: Edge) -> bool:
        r"""
        @brief Coincidence check.

        Checks whether a edge is coincident with another edge. 
        Coincidence is defined by being parallel and that 
        at least one point of one edge is on the other edge.

        @param e the edge to test with

        @return True if the edges are coincident.
        """
    def contains(self, p: Point) -> bool:
        r"""
        @brief Test whether a point is on an edge.

        A point is on a edge if it is on (or at least closer 
        than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge.
        """
    def contains_excl(self, p: Point) -> bool:
        r"""
        @brief Test whether a point is on an edge excluding the endpoints.

        A point is on a edge if it is on (or at least closer 
        than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge but not equal p1 or p2.
        """
    def crossed_by(self, e: Edge) -> bool:
        r"""
        @brief Check, if an edge is cut by a line (given by an edge)

        This method returns true if p1 is in one semispace 
        while p2 is in the other or one of them is on the line
        through the edge "e"

        @param e The edge representing the line that the edge must be crossing.
        """
    def crossing_point(self, e: Edge) -> Point:
        r"""
        @brief Returns the crossing point on two edges. 

        This method delivers the point where the given edge (self) crosses the line given by the edge in argument "e". If self does not cross this line, the result is undefined. See \crossed_by? for a description of the crossing predicate.

        @param e The edge representing the line that self must be crossing.
        @return The point where self crosses the line given by "e".

        This method has been introduced in version 0.19.
        """
    def cut_point(self, e: Edge) -> Any:
        r"""
        @brief Returns the intersection point of the lines through the two edges.

        This method delivers the intersection point between the lines through the two edges. If the lines are parallel and do not intersect, the result will be nil.
        In contrast to \intersection_point, this method will regard the edges as infinitely extended and intersection is not confined to the edge span.

        @param e The edge to test.
        @return The point where the lines intersect.

        This method has been introduced in version 0.27.1.
        """
    def d(self) -> Vector:
        r"""
        @brief Gets the edge extension as a vector.
        This method is equivalent to p2 - p1.
        This method has been introduced in version 0.26.2.
        """
    def distance(self, p: Point) -> int:
        r"""
        @brief Distance between the edge and a point.

        Returns the distance between the edge and the point. The 
        distance is signed which is negative if the point is to the
        "right" of the edge and positive if the point is to the "left".
        The distance is measured by projecting the point onto the
        line through the edge. If the edge is degenerated, the distance
        is not defined.

        @param p The point to test.

        @return The distance
        """
    def distance_abs(self, p: Point) -> int:
        r"""
        @brief Absolute distance between the edge and a point.

        Returns the distance between the edge and the point. 

        @param p The point to test.

        @return The distance
        """
    def dup(self) -> Edge:
        r"""
        @brief Creates a copy of self
        """
    def dx(self) -> int:
        r"""
        @brief The horizontal extend of the edge.
        """
    def dx_abs(self) -> int:
        r"""
        @brief The absolute value of the horizontal extend of the edge.
        """
    def dy(self) -> int:
        r"""
        @brief The vertical extend of the edge.
        """
    def dy_abs(self) -> int:
        r"""
        @brief The absolute value of the vertical extend of the edge.
        """
    def enlarge(self, p: Vector) -> Edge:
        r"""
        @brief Enlarges the edge.

        Enlarges the edge by the given distance and returns the 
        enlarged edge. The edge is overwritten.
        Enlargement means
        that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.
        """
    def enlarged(self, p: Vector) -> Edge:
        r"""
        @brief Returns the enlarged edge (does not modify self)

        Enlarges the edge by the given offset and returns the 
        enlarged edge. The edge is not modified. Enlargement means
        that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.
        """
    def extend(self, d: int) -> Edge:
        r"""
        @brief Extends the edge (modifies self)

        Extends the edge by the given distance and returns the 
        extended edge. The edge is not modified. Extending means
        that the first point is shifted by -d along the edge, the second by d.
        The length of the edge will increase by 2*d.

        \extended is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge (self).
        """
    def extended(self, d: int) -> Edge:
        r"""
        @brief Returns the extended edge (does not modify self)

        Extends the edge by the given distance and returns the 
        extended edge. The edge is not modified. Extending means
        that the first point is shifted by -d along the edge, the second by d.
        The length of the edge will increase by 2*d.

        \extend is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge. This method enables edges as hash keys.

        This method has been introduced in version 0.25.
        """
    def intersect(self, e: Edge) -> bool:
        r"""
        @brief Intersection test. 

        Returns true if the edges intersect. Two edges intersect if they share at least one point. 
        If the edges coincide, they also intersect.
        For degenerated edges, the intersection is mapped to
        point containment tests.

        @param e The edge to test.
        """
    def intersection_point(self, e: Edge) -> Any:
        r"""
        @brief Returns the intersection point of two edges. 

        This method delivers the intersection point. If the edges do not intersect, the result will be nil.

        @param e The edge to test.
        @return The point where the edges intersect.

        This method has been introduced in version 0.19.
        From version 0.26.2, this method will return nil in case of non-intersection.
        """
    def is_degenerate(self) -> bool:
        r"""
        @brief Test for degenerated edge

        An edge is degenerate, if both end and start point are identical.
        """
    def is_parallel(self, e: Edge) -> bool:
        r"""
        @brief Test for being parallel

        @param e The edge to test against

        @return True if both edges are parallel
        """
    def length(self) -> int:
        r"""
        @brief The length of the edge
        """
    @overload
    def move(self, p: Vector) -> Edge:
        r"""
        @brief Moves the edge.

        Moves the edge by the given offset and returns the 
        moved edge. The edge is overwritten.

        @param p The distance to move the edge.

        @return The moved edge.
        """
    @overload
    def move(self, dx: int, dy: int) -> Edge:
        r"""
        @brief Moves the edge.

        Moves the edge by the given offset and returns the 
        moved edge. The edge is overwritten.

        @param dx The x distance to move the edge.
        @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.
        """
    @overload
    def moved(self, p: Vector) -> Edge:
        r"""
        @brief Returns the moved edge (does not modify self)

        Moves the edge by the given offset and returns the 
        moved edge. The edge is not modified.

        @param p The distance to move the edge.

        @return The moved edge.
        """
    @overload
    def moved(self, dx: int, dy: int) -> Edge:
        r"""
        @brief Returns the moved edge (does not modify self)

        Moves the edge by the given offset and returns the 
        moved edge. The edge is not modified.

        @param dx The x distance to move the edge.
        @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.
        """
    def ortho_length(self) -> int:
        r"""
        @brief The orthogonal length of the edge ("manhattan-length")

        @return The orthogonal length (abs(dx)+abs(dy))
        """
    def shift(self, d: int) -> Edge:
        r"""
        @brief Shifts the edge (modifies self)

        Shifts the edge by the given distance and returns the 
        shifted edge. The edge is not modified. Shifting by a positive value will produce an edge which is shifted by d to the left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \shifted is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge (self).
        """
    def shifted(self, d: int) -> Edge:
        r"""
        @brief Returns the shifted edge (does not modify self)

        Shifts the edge by the given distance and returns the 
        shifted edge. The edge is not modified. Shifting by a positive value will produce an edge which is shifted by d to the left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \shift is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge.
        """
    def side_of(self, p: Point) -> int:
        r"""
        @brief Indicates at which side the point is located relative to the edge.

        Returns 1 if the point is "left" of the edge, 0 if on
        and -1 if the point is "right" of the edge.

        @param p The point to test.

        @return The side value
        """
    def sq_length(self) -> int:
        r"""
        @brief The square of the length of the edge
        """
    def swap_points(self) -> Edge:
        r"""
        @brief Swap the points of the edge

        This version modifies self. A version that does not modify self is \swapped_points. Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.
        """
    def swapped_points(self) -> Edge:
        r"""
        @brief Returns an edge in which both points are swapped

        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DEdge:
        r"""
        @brief Converts the edge to a floating-point coordinate edge

        The database unit can be specified to translate the integer-coordinate edge into a floating-point coordinate edge in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    @overload
    def transformed(self, t: CplxTrans) -> DEdge:
        r"""
        @brief Transform the edge.

        Transforms the edge with the given complex transformation.
        Does not modify the edge but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Edge:
        r"""
        @brief Transform the edge.

        Transforms the edge with the given complex transformation.
        Does not modify the edge but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge (in this case an integer coordinate edge).

        This method has been introduced in version 0.18.
        """
    @overload
    def transformed(self, t: Trans) -> Edge:
        r"""
        @brief Transform the edge.

        Transforms the edge with the given transformation.
        Does not modify the edge but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.
        """

class DEdge:
    r"""
    @brief An edge class

    An edge is a connection between points, usually participating in a larger context such as a polygon. An edge has a defined direction (from p1 to p2). Edges play a role in the database as parts of polygons and to describe a line through both points.
    The \Edge object is also used inside the boolean processor (\EdgeProcessor).
    Although supported, edges are rarely used as individual database objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects like the Edge class.
    """
    p1: DPoint
    r"""
    @brief The first point.
    @brief Sets the first point.
    This method has been added in version 0.23.
    """
    p2: DPoint
    r"""
    @brief The second point.
    @brief Sets the second point.
    This method has been added in version 0.23.
    """
    x1: float
    r"""
    @brief Shortcut for p1.x
    @brief Sets p1.x
    This method has been added in version 0.23.
    """
    x2: float
    r"""
    @brief Shortcut for p2.x
    @brief Sets p2.x
    This method has been added in version 0.23.
    """
    y1: float
    r"""
    @brief Shortcut for p1.y
    @brief Sets p1.y
    This method has been added in version 0.23.
    """
    y2: float
    r"""
    @brief Shortcut for p2.y
    @brief Sets p2.y
    This method has been added in version 0.23.
    """
    @classmethod
    def from_s(cls, s: str) -> DEdge:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DEdge:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, e: object) -> bool:
        r"""
        @brief Equality test
        @param e The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge. This method enables edges as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a degenerated edge 0,0 to 0,0
        """
    @overload
    def __init__(self, edge: Edge) -> None:
        r"""
        @brief Creates a floating-point coordinate edge from an integer coordinate edge

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_iedge'.
        """
    @overload
    def __init__(self, p1: DPoint, p2: DPoint) -> None:
        r"""
        @brief Constructor with two points

        Two points are given to create a new edge.
        """
    @overload
    def __init__(self, x1: float, y1: float, x2: float, y2: float) -> None:
        r"""
        @brief Constructor with two coordinates given as single values

        Two points are given to create a new edge.
        """
    def __lt__(self, e: DEdge) -> bool:
        r"""
        @brief Less operator
        @param e The object to compare against
        @return True, if the edge is 'less' as the other edge with respect to first and second point
        """
    def __mul__(self, scale_factor: float) -> DEdge:
        r"""
        @brief Scale edge

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge
        """
    def __ne__(self, e: object) -> bool:
        r"""
        @brief Inequality test
        @param e The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    def __rmul__(self, scale_factor: float) -> DEdge:
        r"""
        @brief Scale edge

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DEdge) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> DBox:
        r"""
        @brief Return the bounding box of the edge.
        """
    def clipped(self, box: DBox) -> Any:
        r"""
        @brief Returns the edge clipped at the given box

        @param box The clip box.
        @return The clipped edge or nil if the edge does not intersect with the box.

        This method has been introduced in version 0.26.2.
        """
    def clipped_line(self, box: DBox) -> Any:
        r"""
        @brief Returns the line through the edge clipped at the given box

        @param box The clip box.
        @return The part of the line through the box or nil if the line does not intersect with the box.

        In contrast to \clipped, this method will consider the edge extended infinitely (a "line"). The returned edge will be the part of this line going through the box.

        This method has been introduced in version 0.26.2.
        """
    def coincident(self, e: DEdge) -> bool:
        r"""
        @brief Coincidence check.

        Checks whether a edge is coincident with another edge. 
        Coincidence is defined by being parallel and that 
        at least one point of one edge is on the other edge.

        @param e the edge to test with

        @return True if the edges are coincident.
        """
    def contains(self, p: DPoint) -> bool:
        r"""
        @brief Test whether a point is on an edge.

        A point is on a edge if it is on (or at least closer 
        than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge.
        """
    def contains_excl(self, p: DPoint) -> bool:
        r"""
        @brief Test whether a point is on an edge excluding the endpoints.

        A point is on a edge if it is on (or at least closer 
        than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge but not equal p1 or p2.
        """
    def crossed_by(self, e: DEdge) -> bool:
        r"""
        @brief Check, if an edge is cut by a line (given by an edge)

        This method returns true if p1 is in one semispace 
        while p2 is in the other or one of them is on the line
        through the edge "e"

        @param e The edge representing the line that the edge must be crossing.
        """
    def crossing_point(self, e: DEdge) -> DPoint:
        r"""
        @brief Returns the crossing point on two edges. 

        This method delivers the point where the given edge (self) crosses the line given by the edge in argument "e". If self does not cross this line, the result is undefined. See \crossed_by? for a description of the crossing predicate.

        @param e The edge representing the line that self must be crossing.
        @return The point where self crosses the line given by "e".

        This method has been introduced in version 0.19.
        """
    def cut_point(self, e: DEdge) -> Any:
        r"""
        @brief Returns the intersection point of the lines through the two edges.

        This method delivers the intersection point between the lines through the two edges. If the lines are parallel and do not intersect, the result will be nil.
        In contrast to \intersection_point, this method will regard the edges as infinitely extended and intersection is not confined to the edge span.

        @param e The edge to test.
        @return The point where the lines intersect.

        This method has been introduced in version 0.27.1.
        """
    def d(self) -> DVector:
        r"""
        @brief Gets the edge extension as a vector.
        This method is equivalent to p2 - p1.
        This method has been introduced in version 0.26.2.
        """
    def distance(self, p: DPoint) -> float:
        r"""
        @brief Distance between the edge and a point.

        Returns the distance between the edge and the point. The 
        distance is signed which is negative if the point is to the
        "right" of the edge and positive if the point is to the "left".
        The distance is measured by projecting the point onto the
        line through the edge. If the edge is degenerated, the distance
        is not defined.

        @param p The point to test.

        @return The distance
        """
    def distance_abs(self, p: DPoint) -> float:
        r"""
        @brief Absolute distance between the edge and a point.

        Returns the distance between the edge and the point. 

        @param p The point to test.

        @return The distance
        """
    def dup(self) -> DEdge:
        r"""
        @brief Creates a copy of self
        """
    def dx(self) -> float:
        r"""
        @brief The horizontal extend of the edge.
        """
    def dx_abs(self) -> float:
        r"""
        @brief The absolute value of the horizontal extend of the edge.
        """
    def dy(self) -> float:
        r"""
        @brief The vertical extend of the edge.
        """
    def dy_abs(self) -> float:
        r"""
        @brief The absolute value of the vertical extend of the edge.
        """
    def enlarge(self, p: DVector) -> DEdge:
        r"""
        @brief Enlarges the edge.

        Enlarges the edge by the given distance and returns the 
        enlarged edge. The edge is overwritten.
        Enlargement means
        that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.
        """
    def enlarged(self, p: DVector) -> DEdge:
        r"""
        @brief Returns the enlarged edge (does not modify self)

        Enlarges the edge by the given offset and returns the 
        enlarged edge. The edge is not modified. Enlargement means
        that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.
        """
    def extend(self, d: float) -> DEdge:
        r"""
        @brief Extends the edge (modifies self)

        Extends the edge by the given distance and returns the 
        extended edge. The edge is not modified. Extending means
        that the first point is shifted by -d along the edge, the second by d.
        The length of the edge will increase by 2*d.

        \extended is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge (self).
        """
    def extended(self, d: float) -> DEdge:
        r"""
        @brief Returns the extended edge (does not modify self)

        Extends the edge by the given distance and returns the 
        extended edge. The edge is not modified. Extending means
        that the first point is shifted by -d along the edge, the second by d.
        The length of the edge will increase by 2*d.

        \extend is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge. This method enables edges as hash keys.

        This method has been introduced in version 0.25.
        """
    def intersect(self, e: DEdge) -> bool:
        r"""
        @brief Intersection test. 

        Returns true if the edges intersect. Two edges intersect if they share at least one point. 
        If the edges coincide, they also intersect.
        For degenerated edges, the intersection is mapped to
        point containment tests.

        @param e The edge to test.
        """
    def intersection_point(self, e: DEdge) -> Any:
        r"""
        @brief Returns the intersection point of two edges. 

        This method delivers the intersection point. If the edges do not intersect, the result will be nil.

        @param e The edge to test.
        @return The point where the edges intersect.

        This method has been introduced in version 0.19.
        From version 0.26.2, this method will return nil in case of non-intersection.
        """
    def is_degenerate(self) -> bool:
        r"""
        @brief Test for degenerated edge

        An edge is degenerate, if both end and start point are identical.
        """
    def is_parallel(self, e: DEdge) -> bool:
        r"""
        @brief Test for being parallel

        @param e The edge to test against

        @return True if both edges are parallel
        """
    def length(self) -> float:
        r"""
        @brief The length of the edge
        """
    @overload
    def move(self, p: DVector) -> DEdge:
        r"""
        @brief Moves the edge.

        Moves the edge by the given offset and returns the 
        moved edge. The edge is overwritten.

        @param p The distance to move the edge.

        @return The moved edge.
        """
    @overload
    def move(self, dx: float, dy: float) -> DEdge:
        r"""
        @brief Moves the edge.

        Moves the edge by the given offset and returns the 
        moved edge. The edge is overwritten.

        @param dx The x distance to move the edge.
        @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.
        """
    @overload
    def moved(self, p: DVector) -> DEdge:
        r"""
        @brief Returns the moved edge (does not modify self)

        Moves the edge by the given offset and returns the 
        moved edge. The edge is not modified.

        @param p The distance to move the edge.

        @return The moved edge.
        """
    @overload
    def moved(self, dx: float, dy: float) -> DEdge:
        r"""
        @brief Returns the moved edge (does not modify self)

        Moves the edge by the given offset and returns the 
        moved edge. The edge is not modified.

        @param dx The x distance to move the edge.
        @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.
        """
    def ortho_length(self) -> float:
        r"""
        @brief The orthogonal length of the edge ("manhattan-length")

        @return The orthogonal length (abs(dx)+abs(dy))
        """
    def shift(self, d: float) -> DEdge:
        r"""
        @brief Shifts the edge (modifies self)

        Shifts the edge by the given distance and returns the 
        shifted edge. The edge is not modified. Shifting by a positive value will produce an edge which is shifted by d to the left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \shifted is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge (self).
        """
    def shifted(self, d: float) -> DEdge:
        r"""
        @brief Returns the shifted edge (does not modify self)

        Shifts the edge by the given distance and returns the 
        shifted edge. The edge is not modified. Shifting by a positive value will produce an edge which is shifted by d to the left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \shift is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge.
        """
    def side_of(self, p: DPoint) -> int:
        r"""
        @brief Indicates at which side the point is located relative to the edge.

        Returns 1 if the point is "left" of the edge, 0 if on
        and -1 if the point is "right" of the edge.

        @param p The point to test.

        @return The side value
        """
    def sq_length(self) -> float:
        r"""
        @brief The square of the length of the edge
        """
    def swap_points(self) -> DEdge:
        r"""
        @brief Swap the points of the edge

        This version modifies self. A version that does not modify self is \swapped_points. Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.
        """
    def swapped_points(self) -> DEdge:
        r"""
        @brief Returns an edge in which both points are swapped

        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Edge:
        r"""
        @brief Converts the edge to an integer coordinate edge

        The database unit can be specified to translate the floating-point coordinate edge in micron units to an integer-coordinate edge in database units. The edges coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the edge
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DEdge:
        r"""
        @brief Transform the edge.

        Transforms the edge with the given complex transformation.
        Does not modify the edge but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.
        """
    @overload
    def transformed(self, t: DTrans) -> DEdge:
        r"""
        @brief Transform the edge.

        Transforms the edge with the given transformation.
        Does not modify the edge but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.
        """
    @overload
    def transformed(self, t: VCplxTrans) -> Edge:
        r"""
        @brief Transforms the edge with the given complex transformation

        @param t The magnifying transformation to apply
        @return The transformed edge (in this case an integer coordinate edge)

        This method has been introduced in version 0.25.
        """

class EdgePair:
    r"""
    @brief An edge pair (a pair of two edges)
    Edge pairs are objects representing two edges or parts of edges. They play a role mainly in the context of DRC functions, where they specify a DRC violation by connecting two edges which violate the condition checked. Within the framework of polygon and edge collections which provide DRC functionality, edges pairs are used in the form of edge pair collections (\EdgePairs).

    Edge pairs basically consist of two edges, called first and second. If created by a two-layer DRC function, the first edge will correspond to edges from the first layer and the second to edges from the second layer.

    This class has been introduced in version 0.23.
    """
    first: Edge
    r"""
    @brief Gets the first edge
    @brief Sets the first edge
    """
    second: Edge
    r"""
    @brief Gets the second edge
    @brief Sets the second edge
    """
    symmetric: bool
    r"""
    @brief Returns a value indicating whether the edge pair is symmetric
    For symmetric edge pairs, the edges are commutable. Specifically, a symmetric edge pair with (e1,e2) is identical to (e2,e1). Symmetric edge pairs are generated by some checks for which there is no directed error marker (width, space, notch, isolated).

    Symmetric edge pairs have been introduced in version 0.27.
    @brief Sets a value indicating whether the edge pair is symmetric
    See \symmetric? for a description of this attribute.

    Symmetric edge pairs have been introduced in version 0.27.
    """
    @classmethod
    def from_s(cls, s: str) -> EdgePair:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> EdgePair:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, box: object) -> bool:
        r"""
        @brief Equality
        Returns true, if this edge pair and the given one are equal

        This method has been introduced in version 0.25.
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge pair. This method enables edge pairs as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an default edge pair.
        """
    @overload
    def __init__(self, dedge_pair: DEdgePair) -> None:
        r"""
        @brief Creates an integer coordinate edge pair from a floating-point coordinate edge pair

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dedge_pair'.
        """
    @overload
    def __init__(self, first: Edge, second: Edge, symmetric: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.
        See \symmetric? for a description of this attribute.
        """
    def __lt__(self, box: EdgePair) -> bool:
        r"""
        @brief Less operator
        Returns true, if this edge pair is 'less' with respect to first and second edge

        This method has been introduced in version 0.25.
        """
    def __ne__(self, box: object) -> bool:
        r"""
        @brief Inequality
        Returns true, if this edge pair and the given one are not equal

        This method has been introduced in version 0.25.
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: EdgePair) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Gets the bounding box of the edge pair
        """
    def dup(self) -> EdgePair:
        r"""
        @brief Creates a copy of self
        """
    def greater(self) -> Edge:
        r"""
        @brief Gets the 'greater' edge for symmetric edge pairs
        As first and second edges are commutable for symmetric edge pairs (see \symmetric?), this accessor allows retrieving a 'second' edge in a way independent on the actual assignment.

        This read-only attribute has been introduced in version 0.27.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge pair. This method enables edge pairs as hash keys.

        This method has been introduced in version 0.25.
        """
    def lesser(self) -> Edge:
        r"""
        @brief Gets the 'lesser' edge for symmetric edge pairs
        As first and second edges are commutable for symmetric edge pairs (see \symmetric?), this accessor allows retrieving a 'first' edge in a way independent on the actual assignment.

        This read-only attribute has been introduced in version 0.27.
        """
    def normalized(self) -> EdgePair:
        r"""
        @brief Normalizes the edge pair
        This method normalized the edge pair such that when connecting the edges at their 
        start and end points a closed loop is formed which is oriented clockwise. To achieve this, the points of the first and/or first and second edge are swapped. Normalization is a first step recommended before converting an edge pair to a polygon, because that way the polygons won't be self-overlapping and the enlargement parameter is applied properly.
        """
    def polygon(self, e: int) -> Polygon:
        r"""
        @brief Convert an edge pair to a polygon
        The polygon is formed by connecting the end and start points of the edges. It is recommended to use \normalized before converting the edge pair to a polygon.

        The enlargement parameter applies the specified enlargement parallel and perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by the specified amount. That parameter is useful to convert degenerated edge pairs to valid polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like edges.

        Another version for converting edge pairs to simple polygons is \simple_polygon which renders a \SimplePolygon object.
        @param e The enlargement (set to zero for exact representation)
        """
    def simple_polygon(self, e: int) -> SimplePolygon:
        r"""
        @brief Convert an edge pair to a simple polygon
        The polygon is formed by connecting the end and start points of the edges. It is recommended to use \normalized before converting the edge pair to a polygon.

        The enlargement parameter applies the specified enlargement parallel and perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by the specified amount. That parameter is useful to convert degenerated edge pairs to valid polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like edges.

        Another version for converting edge pairs to polygons is \polygon which renders a \Polygon object.
        @param e The enlargement (set to zero for exact representation)
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DEdgePair:
        r"""
        @brief Converts the edge pair to a floating-point coordinate edge pair

        The database unit can be specified to translate the integer-coordinate edge pair into a floating-point coordinate edge pair in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    @overload
    def transformed(self, t: CplxTrans) -> DEdgePair:
        r"""
        @brief Returns the transformed edge pair

        Transforms the edge pair with the given complex transformation.
        Does not modify the edge pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair
        """
    @overload
    def transformed(self, t: ICplxTrans) -> EdgePair:
        r"""
        @brief Returns the transformed edge pair

        Transforms the edge pair with the given complex transformation.
        Does not modify the edge pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair (in this case an integer coordinate edge pair).
        """
    @overload
    def transformed(self, t: Trans) -> EdgePair:
        r"""
        @brief Returns the transformed pair

        Transforms the edge pair with the given transformation.
        Does not modify the edge pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair
        """

class DEdgePair:
    r"""
    @brief An edge pair (a pair of two edges)
    Edge pairs are objects representing two edges or parts of edges. They play a role mainly in the context of DRC functions, where they specify a DRC violation by connecting two edges which violate the condition checked. Within the framework of polygon and edge collections which provide DRC functionality, edges pairs with integer coordinates (\EdgePair type) are used in the form of edge pair collections (\EdgePairs).

    Edge pairs basically consist of two edges, called first and second. If created by a two-layer DRC function, the first edge will correspond to edges from the first layer and the second to edges from the second layer.

    This class has been introduced in version 0.23.
    """
    first: DEdge
    r"""
    @brief Gets the first edge
    @brief Sets the first edge
    """
    second: DEdge
    r"""
    @brief Gets the second edge
    @brief Sets the second edge
    """
    symmetric: bool
    r"""
    @brief Returns a value indicating whether the edge pair is symmetric
    For symmetric edge pairs, the edges are commutable. Specifically, a symmetric edge pair with (e1,e2) is identical to (e2,e1). Symmetric edge pairs are generated by some checks for which there is no directed error marker (width, space, notch, isolated).

    Symmetric edge pairs have been introduced in version 0.27.
    @brief Sets a value indicating whether the edge pair is symmetric
    See \symmetric? for a description of this attribute.

    Symmetric edge pairs have been introduced in version 0.27.
    """
    @classmethod
    def from_s(cls, s: str) -> DEdgePair:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DEdgePair:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, box: object) -> bool:
        r"""
        @brief Equality
        Returns true, if this edge pair and the given one are equal

        This method has been introduced in version 0.25.
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge pair. This method enables edge pairs as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an default edge pair.
        """
    @overload
    def __init__(self, edge_pair: EdgePair) -> None:
        r"""
        @brief Creates a floating-point coordinate edge pair from an integer coordinate edge

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_iedge_pair'.
        """
    @overload
    def __init__(self, first: DEdge, second: DEdge, symmetric: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.
        See \symmetric? for a description of this attribute.
        """
    def __lt__(self, box: DEdgePair) -> bool:
        r"""
        @brief Less operator
        Returns true, if this edge pair is 'less' with respect to first and second edge

        This method has been introduced in version 0.25.
        """
    def __ne__(self, box: object) -> bool:
        r"""
        @brief Inequality
        Returns true, if this edge pair and the given one are not equal

        This method has been introduced in version 0.25.
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DEdgePair) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> DBox:
        r"""
        @brief Gets the bounding box of the edge pair
        """
    def dup(self) -> DEdgePair:
        r"""
        @brief Creates a copy of self
        """
    def greater(self) -> DEdge:
        r"""
        @brief Gets the 'greater' edge for symmetric edge pairs
        As first and second edges are commutable for symmetric edge pairs (see \symmetric?), this accessor allows retrieving a 'second' edge in a way independent on the actual assignment.

        This read-only attribute has been introduced in version 0.27.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given edge pair. This method enables edge pairs as hash keys.

        This method has been introduced in version 0.25.
        """
    def lesser(self) -> DEdge:
        r"""
        @brief Gets the 'lesser' edge for symmetric edge pairs
        As first and second edges are commutable for symmetric edge pairs (see \symmetric?), this accessor allows retrieving a 'first' edge in a way independent on the actual assignment.

        This read-only attribute has been introduced in version 0.27.
        """
    def normalized(self) -> DEdgePair:
        r"""
        @brief Normalizes the edge pair
        This method normalized the edge pair such that when connecting the edges at their 
        start and end points a closed loop is formed which is oriented clockwise. To achieve this, the points of the first and/or first and second edge are swapped. Normalization is a first step recommended before converting an edge pair to a polygon, because that way the polygons won't be self-overlapping and the enlargement parameter is applied properly.
        """
    def polygon(self, e: float) -> DPolygon:
        r"""
        @brief Convert an edge pair to a polygon
        The polygon is formed by connecting the end and start points of the edges. It is recommended to use \normalized before converting the edge pair to a polygon.

        The enlargement parameter applies the specified enlargement parallel and perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by the specified amount. That parameter is useful to convert degenerated edge pairs to valid polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like edges.

        Another version for converting edge pairs to simple polygons is \simple_polygon which renders a \SimplePolygon object.
        @param e The enlargement (set to zero for exact representation)
        """
    def simple_polygon(self, e: float) -> DSimplePolygon:
        r"""
        @brief Convert an edge pair to a simple polygon
        The polygon is formed by connecting the end and start points of the edges. It is recommended to use \normalized before converting the edge pair to a polygon.

        The enlargement parameter applies the specified enlargement parallel and perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by the specified amount. That parameter is useful to convert degenerated edge pairs to valid polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like edges.

        Another version for converting edge pairs to polygons is \polygon which renders a \Polygon object.
        @param e The enlargement (set to zero for exact representation)
        """
    def to_itype(self, dbu: Optional[float] = ...) -> EdgePair:
        r"""
        @brief Converts the edge pair to an integer coordinate edge pair

        The database unit can be specified to translate the floating-point coordinate edge pair in micron units to an integer-coordinate edge pair in database units. The edge pair's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the edge pair
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DEdgePair:
        r"""
        @brief Returns the transformed edge pair

        Transforms the edge pair with the given complex transformation.
        Does not modify the edge pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair
        """
    @overload
    def transformed(self, t: DTrans) -> DEdgePair:
        r"""
        @brief Returns the transformed pair

        Transforms the edge pair with the given transformation.
        Does not modify the edge pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair
        """
    @overload
    def transformed(self, t: VCplxTrans) -> EdgePair:
        r"""
        @brief Transforms the edge pair with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed edge pair (in this case an integer coordinate edge pair)

        This method has been introduced in version 0.25.
        """

class EdgePairs(ShapeCollection):
    r"""
    @brief EdgePairs (a collection of edge pairs)

    Edge pairs are used mainly in the context of the DRC functions (width_check, space_check etc.) of \Region and \Edges. A single edge pair represents two edges participating in a DRC violation. In the two-layer checks (inside, overlap) The first edge represents an edge from the first layer and the second edge an edge from the second layer. For single-layer checks (width, space) the order of the edges is arbitrary.

    This class has been introduced in version 0.23.
    """
    def __add__(self, other: EdgePairs) -> EdgePairs:
        r"""
        @brief Returns the combined edge pair collection of self and the other one

        @return The resulting edge pair collection

        This operator adds the edge pairs of the other collection to self and returns a new combined set.

        This method has been introduced in version 0.24.
        """
    def __copy__(self) -> EdgePairs:
        r"""
        @brief Creates a copy of self
        """
    def __getitem__(self, n: int) -> EdgePair:
        r"""
        @brief Returns the nth edge pair

        This method returns nil if the index is out of range. It is available for flat edge pairs only - i.e. those for which \has_valid_edge_pairs? is true. Use \flatten to explicitly flatten an edge pair collection.

        The \each iterator is the more general approach to access the edge pairs.
        """
    def __iadd__(self, other: EdgePairs) -> EdgePairs:
        r"""
        @brief Adds the edge pairs of the other edge pair collection to self

        @return The edge pair collection after modification (self)

        This operator adds the edge pairs of the other collection to self.

        This method has been introduced in version 0.24.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an empty edge pair collection.
        """
    @overload
    def __init__(self, array: Sequence[EdgePair]) -> None:
        r"""
        @brief Constructor from an edge pair array

        This constructor creates an edge pair collection from an array of \EdgePair objects.

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, edge_pair: EdgePair) -> None:
        r"""
        @brief Constructor from a single edge pair object

        This constructor creates an edge pair collection with a single edge pair.

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator) -> None:
        r"""
        @brief Constructor from a hierarchical shape set

        This constructor creates an edge pair collection from the shapes delivered by the given recursive shape iterator.
        Only edge pairs are taken from the shape set and other shapes are ignored.
        This method allows feeding the edge pair collection from a hierarchy of cells.
        Edge pairs in layout objects are somewhat special as most formats don't support reading or writing of edge pairs. Still they are useful objects and can be created and manipulated inside layouts.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::EdgePairs::new(layout.begin_shapes(cell, layer))
        @/code

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shapes: Shapes) -> None:
        r"""
        @brief Shapes constructor

        This constructor creates an edge pair collection from a \Shapes collection.

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore) -> None:
        r"""
        @brief Creates a hierarchical edge pair collection from an original layer

        This constructor creates an edge pair collection from the shapes delivered by the given recursive shape iterator.
        This version will create a hierarchical edge pair collection which supports hierarchical operations.
        Edge pairs in layout objects are somewhat special as most formats don't support reading or writing of edge pairs. Still they are useful objects and can be created and manipulated inside layouts.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::EdgePairs::new(layout.begin_shapes(cell, layer))
        @/code

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Constructor from a hierarchical shape set with a transformation

        This constructor creates an edge pair collection from the shapes delivered by the given recursive shape iterator.
        Only edge pairs are taken from the shape set and other shapes are ignored.
        The given transformation is applied to each edge pair taken.
        This method allows feeding the edge pair collection from a hierarchy of cells.
        The transformation is useful to scale to a specific database unit for example.
        Edge pairs in layout objects are somewhat special as most formats don't support reading or writing of edge pairs. Still they are useful objects and can be created and manipulated inside layouts.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::EdgePairs::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code

        This constructor has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a hierarchical edge pair collection from an original layer with a transformation

        This constructor creates an edge pair collection from the shapes delivered by the given recursive shape iterator.
        This version will create a hierarchical edge pair collection which supports hierarchical operations.
        The transformation is useful to scale to a specific database unit for example.
        Edge pairs in layout objects are somewhat special as most formats don't support reading or writing of edge pairs. Still they are useful objects and can be created and manipulated inside layouts.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::EdgePairs::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code

        This constructor has been introduced in version 0.26.
        """
    def __iter__(self) -> Iterator[EdgePair]:
        r"""
        @brief Returns each edge pair of the edge pair collection
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the edge pair collection to a string
        The length of the output is limited to 20 edge pairs to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the edge pair collection to a string
        The length of the output is limited to 20 edge pairs to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ShapeCollection) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Return the bounding box of the edge pair collection
        The bounding box is the box enclosing all points of all edge pairs.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the edge pair collection
        """
    def count(self) -> int:
        r"""
        @brief Returns the (flat) number of edge pairs in the edge pair collection

        The count is computed 'as if flat', i.e. edge pairs inside a cell are multiplied by the number of times a cell is instantiated.

        Starting with version 0.27, the method is called 'count' for consistency with \Region. 'size' is still provided as an alias.
        """
    def data_id(self) -> int:
        r"""
        @brief Returns the data ID (a unique identifier for the underlying data storage)

        This method has been added in version 0.26.
        """
    def disable_progress(self) -> None:
        r"""
        @brief Disable progress reporting
        Calling this method will disable progress reporting. See \enable_progress.
        """
    def dup(self) -> EdgePairs:
        r"""
        @brief Creates a copy of self
        """
    def each(self) -> Iterator[EdgePair]:
        r"""
        @brief Returns each edge pair of the edge pair collection
        """
    def edges(self) -> Edges:
        r"""
        @brief Decomposes the edge pairs into single edges
        @return An edge collection containing the individual edges
        """
    def enable_progress(self, label: str) -> None:
        r"""
        @brief Enable progress reporting
        After calling this method, the edge pair collection will report the progress through a progress bar while expensive operations are running.
        The label is a text which is put in front of the progress bar.
        Using a progress bar will imply a performance penalty of a few percent typically.
        """
    @overload
    def extents(self) -> Region:
        r"""
        @brief Returns a region with the bounding boxes of the edge pairs
        This method will return a region consisting of the bounding boxes of the edge pairs.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    @overload
    def extents(self, d: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the edge pairs
        This method will return a region consisting of the bounding boxes of the edge pairs enlarged by the given distance d.
        The enlargement is specified per edge, i.e the width and height will be increased by 2*d.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    @overload
    def extents(self, dx: int, dy: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the edge pairs
        This method will return a region consisting of the bounding boxes of the edge pairs enlarged by the given distance dx in x direction and dy in y direction.
        The enlargement is specified per edge, i.e the width will be increased by 2*dx.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    def first_edges(self) -> Edges:
        r"""
        @brief Returns the first one of all edges
        @return An edge collection containing the first edges
        """
    def flatten(self) -> None:
        r"""
        @brief Explicitly flattens an edge pair collection

        If the collection is already flat (i.e. \has_valid_edge_pairs? returns true), this method will not change the collection.

        This method has been introduced in version 0.26.
        """
    def has_valid_edge_pairs(self) -> bool:
        r"""
        @brief Returns true if the edge pair collection is flat and individual edge pairs can be accessed randomly

        This method has been introduced in version 0.26.
        """
    def hier_count(self) -> int:
        r"""
        @brief Returns the (hierarchical) number of edge pairs in the edge pair collection

        The count is computed 'hierarchical', i.e. edge pairs inside a cell are counted once even if the cell is instantiated multiple times.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, edge_pair: EdgePair) -> None:
        r"""
        @brief Inserts an edge pair into the collection
        """
    @overload
    def insert(self, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Inserts all edge pairs from the other edge pair collection into this edge pair collection
        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, first: Edge, second: Edge) -> None:
        r"""
        @brief Inserts an edge pair into the collection
        """
    def insert_into(self, layout: Layout, cell_index: int, layer: int) -> None:
        r"""
        @brief Inserts this edge pairs into the given layout, below the given cell and into the given layer.
        If the edge pair collection is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.

        This method has been introduced in version 0.26.
        """
    def insert_into_as_polygons(self, layout: Layout, cell_index: int, layer: int, e: int) -> None:
        r"""
        @brief Inserts this edge pairs into the given layout, below the given cell and into the given layer.
        If the edge pair collection is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.

        The edge pairs will be converted to polygons with the enlargement value given be 'e'.

        This method has been introduced in version 0.26.
        """
    def is_deep(self) -> bool:
        r"""
        @brief Returns true if the edge pair collection is a deep (hierarchical) one

        This method has been added in version 0.26.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns true if the collection is empty
        """
    @overload
    def move(self, p: Vector) -> EdgePairs:
        r"""
        @brief Moves the edge pair collection

        Moves the edge pairs by the given offset and returns the 
        moved edge pair collection. The edge pair collection is overwritten.

        @param p The distance to move the edge pairs.

        @return The moved edge pairs (self).

        Starting with version 0.25 the displacement is of vector type.
        """
    @overload
    def move(self, x: int, y: int) -> EdgePairs:
        r"""
        @brief Moves the edge pair collection

        Moves the edge pairs by the given offset and returns the 
        moved edge pairs. The edge pair collection is overwritten.

        @param x The x distance to move the edge pairs.
        @param y The y distance to move the edge pairs.

        @return The moved edge pairs (self).
        """
    @overload
    def moved(self, p: Vector) -> EdgePairs:
        r"""
        @brief Returns the moved edge pair collection (does not modify self)

        Moves the edge pairs by the given offset and returns the 
        moved edge pairs. The edge pair collection is not modified.

        @param p The distance to move the edge pairs.

        @return The moved edge pairs.

        Starting with version 0.25 the displacement is of vector type.
        """
    @overload
    def moved(self, x: int, y: int) -> EdgePairs:
        r"""
        @brief Returns the moved edge pair collection (does not modify self)

        Moves the edge pairs by the given offset and returns the 
        moved edge pairs. The edge pair collection is not modified.

        @param x The x distance to move the edge pairs.
        @param y The y distance to move the edge pairs.

        @return The moved edge pairs.
        """
    @overload
    def polygons(self) -> Region:
        r"""
        @brief Converts the edge pairs to polygons
        This method creates polygons from the edge pairs. Each polygon will be a triangle or quadrangle which connects the start and end points of the edges forming the edge pair.
        """
    @overload
    def polygons(self, e: int) -> Region:
        r"""
        @brief Converts the edge pairs to polygons
        This method creates polygons from the edge pairs. Each polygon will be a triangle or quadrangle which connects the start and end points of the edges forming the edge pair. This version allows one to specify an enlargement which is applied to the edges. The length of the edges is modified by applying the enlargement and the edges are shifted by the enlargement. By specifying an enlargement it is possible to give edge pairs an area which otherwise would not have one (coincident edges, two point-like edges).
        """
    def second_edges(self) -> Edges:
        r"""
        @brief Returns the second one of all edges
        @return An edge collection containing the second edges
        """
    def swap(self, other: EdgePairs) -> None:
        r"""
        @brief Swap the contents of this collection with the contents of another collection
        This method is useful to avoid excessive memory allocation in some cases. For managed memory languages such as Ruby, those cases will be rare. 
        """
    @overload
    def to_s(self) -> str:
        r"""
        @brief Converts the edge pair collection to a string
        The length of the output is limited to 20 edge pairs to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    @overload
    def to_s(self, max_count: int) -> str:
        r"""
        @brief Converts the edge pair collection to a string
        This version allows specification of the maximum number of edge pairs contained in the string.
        """
    @overload
    def transform(self, t: ICplxTrans) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection with a complex transformation (modifies self)

        Transforms the edge pair collection with the given transformation.
        This version modifies the edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.
        """
    @overload
    def transform(self, t: IMatrix2d) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection (modifies self)

        Transforms the edge pair collection with the given 2d matrix transformation.
        This version modifies the edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transform(self, t: IMatrix3d) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection (modifies self)

        Transforms the edge pair collection with the given 3d matrix transformation.
        This version modifies the edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transform(self, t: Trans) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection (modifies self)

        Transforms the edge pair collection with the given transformation.
        This version modifies the edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection with a complex transformation

        Transforms the edge pairs with the given complex transformation.
        Does not modify the edge pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.
        """
    @overload
    def transformed(self, t: IMatrix2d) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection

        Transforms the edge pairs with the given 2d matrix transformation.
        Does not modify the edge pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transformed(self, t: IMatrix3d) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection

        Transforms the edge pairs with the given 3d matrix transformation.
        Does not modify the edge pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transformed(self, t: Trans) -> EdgePairs:
        r"""
        @brief Transform the edge pair collection

        Transforms the edge pairs with the given transformation.
        Does not modify the edge pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.
        """
    @overload
    def with_angle(self, angle: float, inverse: bool) -> EdgePairs:
        r"""
        @brief Filter the edge pairs by orientation of their edges
        Filters the edge pairs in the edge pair collection by orientation. If "inverse" is false, only edge pairs with at least one edge having the given angle to the x-axis are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        This will filter edge pairs with at least one horizontal edge:

        @code
        horizontal = edge_pairs.with_orientation(0, false)
        @/code

        This method has been added in version 0.27.1.
        """
    @overload
    def with_angle(self, min_angle: float, max_angle: float, inverse: bool, include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Filter the edge pairs by orientation of their edges
        Filters the edge pairs in the edge pair collection by orientation. If "inverse" is false, only edge pairs with at least one edge having an angle between min_angle and max_angle are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        With "include_min_angle" set to true (the default), the minimum angle is included in the criterion while with false, the minimum angle itself is not included. Same for "include_max_angle" where the default is false, meaning the maximum angle is not included in the range.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_angle_both(self, angle: float, inverse: bool) -> EdgePairs:
        r"""
        @brief Filter the edge pairs by orientation of both of their edges
        Filters the edge pairs in the edge pair collection by orientation. If "inverse" is false, only edge pairs with both edges having the given angle to the x-axis are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        This will filter edge pairs with at least one horizontal edge:

        @code
        horizontal = edge_pairs.with_orientation(0, false)
        @/code

        This method has been added in version 0.27.1.
        """
    @overload
    def with_angle_both(self, min_angle: float, max_angle: float, inverse: bool, include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Filter the edge pairs by orientation of both of their edges
        Filters the edge pairs in the edge pair collection by orientation. If "inverse" is false, only edge pairs with both edges having an angle between min_angle and max_angle are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        With "include_min_angle" set to true (the default), the minimum angle is included in the criterion while with false, the minimum angle itself is not included. Same for "include_max_angle" where the default is false, meaning the maximum angle is not included in the range.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_area(self, area: int, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the enclosed area
        Filters the edge pairs in the edge pair collection by enclosed area. If "inverse" is false, only edge pairs with the given area are returned. If "inverse" is true, edge pairs not with the given area are returned.

        This method has been added in version 0.27.2.
        """
    @overload
    def with_area(self, min_area: int, max_area: int, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the enclosed area
        Filters the edge pairs in the edge pair collection by enclosed area. If "inverse" is false, only edge pairs with an area between min_area and max_area (max_area itself is excluded) are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        This method has been added in version 0.27.2.
        """
    @overload
    def with_distance(self, distance: int, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the distance of the edges
        Filters the edge pairs in the edge pair collection by distance of the edges. If "inverse" is false, only edge pairs where both edges have the given distance are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        Distance is measured as the shortest distance between any of the points on the edges.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_distance(self, min_distance: Any, max_distance: Any, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the distance of the edges
        Filters the edge pairs in the edge pair collection by distance of the edges. If "inverse" is false, only edge pairs where both edges have a distance between min_distance and max_distance (max_distance itself is excluded) are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        Distance is measured as the shortest distance between any of the points on the edges.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_internal_angle(self, angle: float, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the angle between their edges
        Filters the edge pairs in the edge pair collection by the angle between their edges. If "inverse" is false, only edge pairs with the given angle are returned. If "inverse" is true, edge pairs not with the given angle are returned.

        The angle is measured between the two edges. It is between 0 (parallel or anti-parallel edges) and 90 degree (perpendicular edges).

        This method has been added in version 0.27.2.
        """
    @overload
    def with_internal_angle(self, min_angle: float, max_angle: float, inverse: bool, include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by the angle between their edges
        Filters the edge pairs in the edge pair collection by the angle between their edges. If "inverse" is false, only edge pairs with an angle between min_angle and max_angle (max_angle itself is excluded) are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        The angle is measured between the two edges. It is between 0 (parallel or anti-parallel edges) and 90 degree (perpendicular edges).

        With "include_min_angle" set to true (the default), the minimum angle is included in the criterion while with false, the minimum angle itself is not included. Same for "include_max_angle" where the default is false, meaning the maximum angle is not included in the range.

        This method has been added in version 0.27.2.
        """
    @overload
    def with_length(self, length: int, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by length of one of their edges
        Filters the edge pairs in the edge pair collection by length of at least one of their edges. If "inverse" is false, only edge pairs with at least one edge having the given length are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_length(self, min_length: Any, max_length: Any, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by length of one of their edges
        Filters the edge pairs in the edge pair collection by length of at least one of their edges. If "inverse" is false, only edge pairs with at least one edge having a length between min_length and max_length (excluding max_length itself) are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_length_both(self, length: int, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by length of both of their edges
        Filters the edge pairs in the edge pair collection by length of both of their edges. If "inverse" is false, only edge pairs where both edges have the given length are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        This method has been added in version 0.27.1.
        """
    @overload
    def with_length_both(self, min_length: Any, max_length: Any, inverse: bool) -> EdgePairs:
        r"""
        @brief Filters the edge pairs by length of both of their edges
        Filters the edge pairs in the edge pair collection by length of both of their edges. If "inverse" is false, only edge pairs with both edges having a length between min_length and max_length (excluding max_length itself) are returned. If "inverse" is true, edge pairs not fulfilling this criterion are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        This method has been added in version 0.27.1.
        """

class EdgeProcessor:
    r"""
    @brief The edge processor (boolean, sizing, merge)

    The edge processor implements the boolean and edge set operations (size, merge). Because the edge processor might allocate resources which can be reused in later operations, it is implemented as an object that can be used several times.

    Here is a simple example of how to use the edge processor:

    @code
    ep = RBA::EdgeProcessor::new
    # Prepare two boxes
    a = [ RBA::Polygon::new(RBA::Box::new(0, 0, 300, 300)) ]
    b = [ RBA::Polygon::new(RBA::Box::new(100, 100, 200, 200)) ]
    # Run an XOR -> creates a polygon with a hole, since the 'resolve_holes' parameter
    # is false:
    out = ep.boolean_p2p(a, b, RBA::EdgeProcessor::ModeXor, false, false)
    out.to_s    # -> [(0,0;0,300;300,300;300,0/100,100;200,100;200,200;100,200)]
    @/code
    """
    ModeANotB: ClassVar[int]
    r"""
    @brief boolean method's mode value for A NOT B operation
    """
    ModeAnd: ClassVar[int]
    r"""
    @brief boolean method's mode value for AND operation
    """
    ModeBNotA: ClassVar[int]
    r"""
    @brief boolean method's mode value for B NOT A operation
    """
    ModeOr: ClassVar[int]
    r"""
    @brief boolean method's mode value for OR operation
    """
    ModeXor: ClassVar[int]
    r"""
    @brief boolean method's mode value for XOR operation
    """
    def __copy__(self) -> EdgeProcessor:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: EdgeProcessor) -> None:
        r"""
        @brief Assigns another object to self
        """
    def boolean_e2e(self, a: Sequence[Edge], b: Sequence[Edge], mode: int) -> List[Edge]:
        r"""
        @brief Boolean operation for a set of given edges, creating edges

        This method computes the result for the given boolean operation on two sets of edges.
        The input edges must form closed contours where holes and hulls must be oriented differently. 
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'boolean'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input edges (first operand)
        @param b The input edges (second operand)
        @param mode The boolean mode (one of the Mode.. values)
        @return The output edges
        """
    def boolean_e2p(self, a: Sequence[Edge], b: Sequence[Edge], mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Boolean operation for a set of given edges, creating polygons

        This method computes the result for the given boolean operation on two sets of edges.
        The input edges must form closed contours where holes and hulls must be oriented differently. 
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        This method produces polygons on output and allows fine-tuning of the parameters for that purpose.

        Prior to version 0.21 this method was called 'boolean_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand)
        @param b The input polygons (second operand)
        @param mode The boolean mode (one of the Mode.. values)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    def boolean_p2e(self, a: Sequence[Polygon], b: Sequence[Polygon], mode: int) -> List[Edge]:
        r"""
        @brief Boolean operation for a set of given polygons, creating edges

        This method computes the result for the given boolean operation on two sets of polygons.
        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with
        a Boolean operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'boolean'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand)
        @param b The input polygons (second operand)
        @param mode The boolean mode
        @return The output edges
        """
    def boolean_p2p(self, a: Sequence[Polygon], b: Sequence[Polygon], mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Boolean operation for a set of given polygons, creating polygons

        This method computes the result for the given boolean operation on two sets of polygons.
        This method produces polygons on output and allows fine-tuning of the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with
        a Boolean operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'boolean_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand)
        @param b The input polygons (second operand)
        @param mode The boolean mode (one of the Mode.. values)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    def disable_progress(self) -> None:
        r"""
        @brief Disable progress reporting
        Calling this method will stop the edge processor from showing a progress bar. See \enable_progress.

        This method has been introduced in version 0.23.
        """
    def dup(self) -> EdgeProcessor:
        r"""
        @brief Creates a copy of self
        """
    def enable_progress(self, label: str) -> None:
        r"""
        @brief Enable progress reporting
        After calling this method, the edge processor will report the progress through a progress bar.
        The label is a text which is put in front of the progress bar.
        Using a progress bar will imply a performance penalty of a few percent typically.

        This method has been introduced in version 0.23.
        """
    def merge_p2e(self, in_: Sequence[Polygon], min_wc: int) -> List[Edge]:
        r"""
        @brief Merge the given polygons 

        In contrast to "simple_merge", this merge implementation considers each polygon individually before merging them.
        Thus self-overlaps are effectively removed before the output is computed and holes are correctly merged with the
        hull. In addition, this method allows selecting areas with a higher wrap count which in turn allows computing overlaps
        of polygons on the same layer. Because this method merges the polygons before the overlap is computed, self-overlapping
        polygons do not contribute to higher wrap count areas.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'merge'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        @return The output edges
        """
    def merge_p2p(self, in_: Sequence[Polygon], min_wc: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Merge the given polygons 

        In contrast to "simple_merge", this merge implementation considers each polygon individually before merging them.
        Thus self-overlaps are effectively removed before the output is computed and holes are correctly merged with the
        hull. In addition, this method allows selecting areas with a higher wrap count which in turn allows computing overlaps
        of polygons on the same layer. Because this method merges the polygons before the overlap is computed, self-overlapping
        polygons do not contribute to higher wrap count areas.

        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        Prior to version 0.21 this method was called 'merge_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def simple_merge_e2e(self, in_: Sequence[Edge]) -> List[Edge]:
        r"""
        @brief Merge the given edges in a simple "non-zero wrapcount" fashion

        The edges provided must form valid closed contours. Contours oriented differently "cancel" each other. 
        Overlapping contours are merged when the orientation is the same.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'simple_merge'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input edges
        @return The output edges
        """
    @overload
    def simple_merge_e2e(self, in_: Sequence[Edge], mode: int) -> List[Edge]:
        r"""
        @brief Merge the given polygons and specify the merge mode

        The edges provided must form valid closed contours. Contours oriented differently "cancel" each other. 
        Overlapping contours are merged when the orientation is the same.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-odd rule. A positive value specifies the wrap count threshold (positive only). A negative value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero rule).

        @param mode See description
        @param in The input edges
        @return The output edges
        """
    @overload
    def simple_merge_e2p(self, in_: Sequence[Edge], resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Merge the given edges in a simple "non-zero wrapcount" fashion into polygons

        The edges provided must form valid closed contours. Contours oriented differently "cancel" each other. 
        Overlapping contours are merged when the orientation is the same.

        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'simple_merge_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input edges
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def simple_merge_e2p(self, in_: Sequence[Edge], resolve_holes: bool, min_coherence: bool, mode: int) -> List[Polygon]:
        r"""
        @brief Merge the given polygons and specify the merge mode

        The edges provided must form valid closed contours. Contours oriented differently "cancel" each other. 
        Overlapping contours are merged when the orientation is the same.

        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-odd rule. A positive value specifies the wrap count threshold (positive only). A negative value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero rule).

        @param mode See description
        @param in The input edges
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def simple_merge_p2e(self, in_: Sequence[Polygon]) -> List[Edge]:
        r"""
        @brief Merge the given polygons in a simple "non-zero wrapcount" fashion

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to achieve).
        The other merge operation provided for this purpose is "merge" which normalizes each polygon individually before
        merging them. "simple_merge" is somewhat faster and consumes less memory.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'simple_merge'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @return The output edges
        """
    @overload
    def simple_merge_p2e(self, in_: Sequence[Polygon], mode: int) -> List[Edge]:
        r"""
        @brief Merge the given polygons and specify the merge mode

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to achieve).
        The other merge operation provided for this purpose is "merge" which normalizes each polygon individually before
        merging them. "simple_merge" is somewhat faster and consumes less memory.

        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-odd rule. A positive value specifies the wrap count threshold (positive only). A negative value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero rule).

        @param mode See description
        @param in The input polygons
        @return The output edges
        """
    @overload
    def simple_merge_p2p(self, in_: Sequence[Polygon], resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Merge the given polygons in a simple "non-zero wrapcount" fashion into polygons

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to achieve).
        The other merge operation provided for this purpose is "merge" which normalizes each polygon individually before
        merging them. "simple_merge" is somewhat faster and consumes less memory.

        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'simple_merge_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def simple_merge_p2p(self, in_: Sequence[Polygon], resolve_holes: bool, min_coherence: bool, mode: int) -> List[Polygon]:
        r"""
        @brief Merge the given polygons and specify the merge mode

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to achieve).
        The other merge operation provided for this purpose is "merge" which normalizes each polygon individually before
        merging them. "simple_merge" is somewhat faster and consumes less memory.

        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with
        a SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-odd rule. A positive value specifies the wrap count threshold (positive only). A negative value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero rule).

        @param mode See description
        @param in The input polygons
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def size_p2e(self, in_: Sequence[Polygon], d: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given polygons (isotropic)

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param d The sizing value in x direction
        @param mode The sizing mode
        @return The output edges
        """
    @overload
    def size_p2e(self, in_: Sequence[Polygon], dx: int, dy: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given polygons 

        This method sizes a set of polygons. Before the sizing is applied, the polygons are merged. After that, sizing is applied 
        on the individual result polygons of the merge step. The result may contain overlapping contours, but no self-overlaps. 

        dx and dy describe the sizing. A positive value indicates oversize (outwards) while a negative one describes undersize (inwards).
        The sizing applied can be chosen differently in x and y direction. In this case, the sign must be identical for both
        dx and dy.

        The 'mode' parameter describes the corner fill strategy. Mode 0 connects all corner segments directly. Mode 1 is the 'octagon' strategy in which square corners are interpolated with a partial octagon. Mode 2 is the standard mode in which corners are filled by expanding edges unless these edges form a sharp bend with an angle of more than 90 degree. In that case, the corners are cut off. In Mode 3, no cutoff occurs up to a bending angle of 135 degree. Mode 4 and 5 are even more aggressive and allow very sharp bends without cutoff. This strategy may produce long spikes on sharply bending corners. 
        The result is presented as a set of edges forming closed contours. Hulls are oriented clockwise while
        holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'size'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param dx The sizing value in x direction
        @param dy The sizing value in y direction
        @param mode The sizing mode (standard is 2)
        @return The output edges
        """
    @overload
    def size_p2p(self, in_: Sequence[Polygon], d: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given polygons into polygons (isotropic)

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param d The sizing value in x direction
        @param mode The sizing mode
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """
    @overload
    def size_p2p(self, in_: Sequence[Polygon], dx: int, dy: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given polygons into polygons

        This method sizes a set of polygons. Before the sizing is applied, the polygons are merged. After that, sizing is applied 
        on the individual result polygons of the merge step. The result may contain overlapping polygons, but no self-overlapping ones. 
        Polygon overlap occurs if the polygons are close enough, so a positive sizing makes polygons overlap.

        dx and dy describe the sizing. A positive value indicates oversize (outwards) while a negative one describes undersize (inwards).
        The sizing applied can be chosen differently in x and y direction. In this case, the sign must be identical for both
        dx and dy.

        The 'mode' parameter describes the corner fill strategy. Mode 0 connects all corner segments directly. Mode 1 is the 'octagon' strategy in which square corners are interpolated with a partial octagon. Mode 2 is the standard mode in which corners are filled by expanding edges unless these edges form a sharp bend with an angle of more than 90 degree. In that case, the corners are cut off. In Mode 3, no cutoff occurs up to a bending angle of 135 degree. Mode 4 and 5 are even more aggressive and allow very sharp bends without cutoff. This strategy may produce long spikes on sharply bending corners. 
        This method produces polygons and allows fine-tuning of the parameters for that purpose.

        Prior to version 0.21 this method was called 'size_to_polygon'. Is was renamed to avoid ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons
        @param dx The sizing value in x direction
        @param dy The sizing value in y direction
        @param mode The sizing mode (standard is 2)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons
        """

class Edges(ShapeCollection):
    r"""
    @brief A collection of edges (Not necessarily describing closed contours)


    This class was introduced to simplify operations on edges sets. See \Edge for a description of the individual edge object. The edge collection contains an arbitrary number of edges and supports operations to select edges by various criteria, produce polygons from the edges by applying an extension, filtering edges against other edges collections and checking geometrical relations to other edges (DRC functionality).

    The edge collection is supposed to work closely with the \Region polygon set. Both are related, although the edge collection has a lower rank since it potentially represents a disconnected collection of edges. Edge collections may form closed contours, for example immediately after they have been derived from a polygon set using \Region#edges. But this state is volatile and can easily be destroyed by filtering edges. Hence the connected state does not play an important role in the edge collection's API.

    Edge collections may also contain points (degenerated edges with identical start and end points). Such point-like objects participate in some although not all methods of the edge collection class. 
    Edge collections can be used in two different flavors: in raw mode or merged semantics. With merged semantics (the default), connected edges are considered to belong together and are effectively merged.
    Overlapping parts are counted once in that mode. Dot-like edges are not considered in merged semantics.
    In raw mode (without merged semantics), each edge is considered as it is. Overlaps between edges
    may exists and merging has to be done explicitly using the \merge method. The semantics can be
    selected using \merged_semantics=.


    This class has been introduced in version 0.23.
    """
    Euclidian: ClassVar[Region.Metrics]
    r"""
    @brief Specifies Euclidian metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies Euclidian metrics, i.e. the distance between two points is measured by:

    @code
    d = sqrt(dx^2 + dy^2)
    @/code

    All points within a circle with radius d around one point are considered to have a smaller distance than d.
    """
    Projection: ClassVar[Region.Metrics]
    r"""
    @brief Specifies projected distance metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies projected metrics, i.e. the distance is defined as the minimum distance measured perpendicular to one edge. That implies that the distance is defined only where two edges have a non-vanishing projection onto each other.
    """
    Square: ClassVar[Region.Metrics]
    r"""
    @brief Specifies square metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies square metrics, i.e. the distance between two points is measured by:

    @code
    d = max(abs(dx), abs(dy))
    @/code

    All points within a square with length 2*d around one point are considered to have a smaller distance than d in this metrics.
    """
    merged_semantics: bool
    r"""
    @brief Gets a flag indicating whether merged semantics is enabled
    See \merged_semantics= for a description of this attribute.
    @brief Enable or disable merged semantics
    If merged semantics is enabled (the default), colinear, connected or overlapping edges will be considered
    as single edges.
    """
    def __add__(self, other: Edges) -> Edges:
        r"""
        @brief Returns the combined edge set of self and the other one

        @return The resulting edge set

        This operator adds the edges of the other edge set to self and returns a new combined edge set. This usually creates unmerged edge sets and edges may overlap. Use \merge if you want to ensure the result edge set is merged.
        """
    @overload
    def __and__(self, other: Edges) -> Edges:
        r"""
        @brief Returns the boolean AND between self and the other edge collection

        @return The result of the boolean AND operation

        The boolean AND operation will return all parts of the edges in this collection which are coincident with parts of the edges in the other collection.The result will be a merged edge collection.
        """
    @overload
    def __and__(self, other: Region) -> Edges:
        r"""
        @brief Returns the parts of the edges inside the given region

        @return The edges inside the given region

        This operation returns the parts of the edges which are inside the given region.
        Edges on the borders of the polygons are included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    def __copy__(self) -> Edges:
        r"""
        @brief Creates a copy of self
        """
    def __getitem__(self, n: int) -> Edge:
        r"""
        @brief Returns the nth edge of the collection

        This method returns nil if the index is out of range. It is available for flat edge collections only - i.e. those for which \has_valid_edges? is true. Use \flatten to explicitly flatten an edge collection.
        This method returns the raw edge (not merged edges, even if merged semantics is enabled).

        The \each iterator is the more general approach to access the edges.
        """
    def __iadd__(self, other: Edges) -> Edges:
        r"""
        @brief Adds the edges of the other edge collection to self

        @return The edge set after modification (self)

        This operator adds the edges of the other edge set to self. This usually creates unmerged edge sets and edges may overlap. Use \merge if you want to ensure the result edge set is merged.
        """
    @overload
    def __iand__(self, other: Edges) -> Edges:
        r"""
        @brief Performs the boolean AND between self and the other edge collection

        @return The edge collection after modification (self)

        The boolean AND operation will return all parts of the edges in this collection which are coincident with parts of the edges in the other collection.The result will be a merged edge collection.
        """
    @overload
    def __iand__(self, other: Region) -> Edges:
        r"""
        @brief Selects the parts of the edges inside the given region

        @return The edge collection after modification (self)

        This operation selects the parts of the edges which are inside the given region.
        Edges on the borders of the polygons are included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an empty edge collection.
        """
    @overload
    def __init__(self, array: Sequence[Edge]) -> None:
        r"""
        @brief Constructor from an edge array

        This constructor creates an edge collection from an array of edges.
        """
    @overload
    def __init__(self, array: Sequence[Polygon]) -> None:
        r"""
        @brief Constructor from a polygon array

        This constructor creates an edge collection from an array of polygons.
        The edges form the contours of the polygons.
        """
    @overload
    def __init__(self, box: Box) -> None:
        r"""
        @brief Box constructor

        This constructor creates an edge collection from a box.
        The edges form the contour of the box.
        """
    @overload
    def __init__(self, edge: Edge) -> None:
        r"""
        @brief Constructor from a single edge

        This constructor creates an edge collection with a single edge.
        """
    @overload
    def __init__(self, path: Path) -> None:
        r"""
        @brief Path constructor

        This constructor creates an edge collection from a path.
        The edges form the contour of the path.
        """
    @overload
    def __init__(self, polygon: Polygon) -> None:
        r"""
        @brief Polygon constructor

        This constructor creates an edge collection from a polygon.
        The edges form the contour of the polygon.
        """
    @overload
    def __init__(self, polygon: SimplePolygon) -> None:
        r"""
        @brief Simple polygon constructor

        This constructor creates an edge collection from a simple polygon.
        The edges form the contour of the polygon.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, as_edges: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor of a flat edge collection from a hierarchical shape set

        This constructor creates an edge collection from the shapes delivered by the given recursive shape iterator.
        It feeds the shapes from a hierarchy of cells into a flat edge set.

        Text objects are not inserted, because they cannot be converted to edges.
        Edge objects are inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are converted to edges which form the hull of these objects. If "as_edges" is false, solid objects are ignored.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::Edges::new(layout.begin_shapes(cell, layer), false)
        @/code
        """
    @overload
    def __init__(self, shapes: Shapes, as_edges: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor of a flat edge collection from a \Shapes container

        If 'as_edges' is true, the shapes from the container will be converted to edges (i.e. polygon contours to edges). Otherwise, only edges will be taken from the container.

        This method has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, as_edges: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor of a hierarchical edge collection

        This constructor creates an edge collection from the shapes delivered by the given recursive shape iterator.
        It feeds the shapes from a hierarchy of cells into the hierarchical edge set.
        The edges remain within their original hierarchy unless other operations require the edges to be moved in the hierarchy.

        Text objects are not inserted, because they cannot be converted to edges.
        Edge objects are inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are converted to edges which form the hull of these objects. If "as_edges" is false, solid objects are ignored.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::Edges::new(layout.begin_shapes(cell, layer), dss, false)
        @/code
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, expr: str, as_pattern: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts
        @param expr The selection string
        @param as_pattern If true, the selection string is treated as a glob pattern. Otherwise the match is exact.

        This special constructor will create dot-like edges from the text objects delivered by the shape iterator. Each text object will give a degenerated edge (a dot) that represents the text origin.
        Texts can be selected by their strings - either through a glob pattern or by exact comparison with the given string. The following options are available:

        @code
        dots = RBA::Edges::new(iter, "*")           # all texts
        dots = RBA::Edges::new(iter, "A*")          # all texts starting with an 'A'
        dots = RBA::Edges::new(iter, "A*", false)   # all texts exactly matching 'A*'
        @/code

        This method has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans, as_edges: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor of a flat edge collection from a hierarchical shape set with a transformation

        This constructor creates an edge collection from the shapes delivered by the given recursive shape iterator.
        It feeds the shapes from a hierarchy of cells into a flat edge set.
        The transformation is useful to scale to a specific database unit for example.

        Text objects are not inserted, because they cannot be converted to edges.
        Edge objects are inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are converted to edges which form the hull of these objects. If "as_edges" is false, solid objects are ignored.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::Edges::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, expr: str, as_pattern: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts
        @param dss The \DeepShapeStore object that acts as a heap for hierarchical operations.
        @param expr The selection string
        @param as_pattern If true, the selection string is treated as a glob pattern. Otherwise the match is exact.

        This special constructor will create a deep edge set from the text objects delivered by the shape iterator. Each text object will give a degenerated edge (a dot) that represents the text origin.
        Texts can be selected by their strings - either through a glob pattern or by exact comparison with the given string. The following options are available:

        @code
        region = RBA::Region::new(iter, dss, "*")           # all texts
        region = RBA::Region::new(iter, dss, "A*")          # all texts starting with an 'A'
        region = RBA::Region::new(iter, dss, "A*", false)   # all texts exactly matching 'A*'
        @/code

        This method has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, trans: ICplxTrans, as_edges: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor of a hierarchical edge collection with a transformation

        This constructor creates an edge collection from the shapes delivered by the given recursive shape iterator.
        It feeds the shapes from a hierarchy of cells into the hierarchical edge set.
        The edges remain within their original hierarchy unless other operations require the edges to be moved in the hierarchy.
        The transformation is useful to scale to a specific database unit for example.

        Text objects are not inserted, because they cannot be converted to edges.
        Edge objects are inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are converted to edges which form the hull of these objects. If "as_edges" is false, solid objects are ignored.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::Edges::new(layout.begin_shapes(cell, layer), dss, RBA::ICplxTrans::new(layout.dbu / dbu), false)
        @/code
        """
    def __ior__(self, other: Edges) -> Edges:
        r"""
        @brief Performs the boolean OR between self and the other edge set

        @return The edge collection after modification (self)

        The boolean OR is implemented by merging the edges of both edge sets. To simply join the edge collections without merging, the + operator is more efficient.
        """
    @overload
    def __isub__(self, other: Edges) -> Edges:
        r"""
        @brief Performs the boolean NOT between self and the other edge collection

        @return The edge collection after modification (self)

        The boolean NOT operation will return all parts of the edges in this collection which are not coincident with parts of the edges in the other collection.The result will be a merged edge collection.
        """
    @overload
    def __isub__(self, other: Region) -> Edges:
        r"""
        @brief Selects the parts of the edges outside the given region

        @return The edge collection after modification (self)

        This operation selects the parts of the edges which are outside the given region.
        Edges on the borders of the polygons are not included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    def __iter__(self) -> Iterator[Edge]:
        r"""
        @brief Returns each edge of the region
        """
    def __ixor__(self, other: Edges) -> Edges:
        r"""
        @brief Performs the boolean XOR between self and the other edge collection

        @return The edge collection after modification (self)

        The boolean XOR operation will return all parts of the edges in this and the other collection except the parts where both are coincident.
        The result will be a merged edge collection.
        """
    def __or__(self, other: Edges) -> Edges:
        r"""
        @brief Returns the boolean OR between self and the other edge set

        @return The resulting edge collection

        The boolean OR is implemented by merging the edges of both edge sets. To simply join the edge collections without merging, the + operator is more efficient.
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the edge collection to a string
        The length of the output is limited to 20 edges to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the edge collection to a string
        The length of the output is limited to 20 edges to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    @overload
    def __sub__(self, other: Edges) -> Edges:
        r"""
        @brief Returns the boolean NOT between self and the other edge collection

        @return The result of the boolean NOT operation

        The boolean NOT operation will return all parts of the edges in this collection which are not coincident with parts of the edges in the other collection.The result will be a merged edge collection.
        """
    @overload
    def __sub__(self, other: Region) -> Edges:
        r"""
        @brief Returns the parts of the edges outside the given region

        @return The edges outside the given region

        This operation returns the parts of the edges which are outside the given region.
        Edges on the borders of the polygons are not included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    def __xor__(self, other: Edges) -> Edges:
        r"""
        @brief Returns the boolean XOR between self and the other edge collection

        @return The result of the boolean XOR operation

        The boolean XOR operation will return all parts of the edges in this and the other collection except the parts where both are coincident.
        The result will be a merged edge collection.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ShapeCollection) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box of the edge collection
        The bounding box is the box enclosing all points of all edges.
        """
    def centers(self, length: int, fraction: float) -> Edges:
        r"""
        @brief Returns edges representing the center part of the edges
        @return A new collection of edges representing the part around the center
        This method allows one to specify the length of these segments in a twofold way: either as a fixed length or by specifying a fraction of the original length:

        @code
        edges = ...  # An edge collection
        edges.centers(100, 0.0)     # All segments have a length of 100 DBU
        edges.centers(0, 50.0)      # All segments have a length of half the original length
        edges.centers(100, 50.0)    # All segments have a length of half the original length
                                    # or 100 DBU, whichever is larger
        @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are delivered which specify the centers of the edges but can't participate in some functions.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the edge collection
        """
    def count(self) -> int:
        r"""
        @brief Returns the (flat) number of edges in the edge collection

        This returns the number of raw edges (not merged edges if merged semantics is enabled).
        The count is computed 'as if flat', i.e. edges inside a cell are multiplied by the number of times a cell is instantiated.

        Starting with version 0.27, the method is called 'count' for consistency with \Region. 'size' is still provided as an alias.
        """
    def data_id(self) -> int:
        r"""
        @brief Returns the data ID (a unique identifier for the underlying data storage)

        This method has been added in version 0.26.
        """
    def disable_progress(self) -> None:
        r"""
        @brief Disable progress reporting
        Calling this method will disable progress reporting. See \enable_progress.
        """
    def dup(self) -> Edges:
        r"""
        @brief Creates a copy of self
        """
    def each(self) -> Iterator[Edge]:
        r"""
        @brief Returns each edge of the region
        """
    def each_merged(self) -> Iterator[Edge]:
        r"""
        @brief Returns each edge of the region

        In contrast to \each, this method delivers merged edges if merge semantics applies while \each delivers the original edges only.

        This method has been introduced in version 0.25.
        """
    def enable_progress(self, label: str) -> None:
        r"""
        @brief Enable progress reporting
        After calling this method, the edge collection will report the progress through a progress bar while expensive operations are running.
        The label is a text which is put in front of the progress bar.
        Using a progress bar will imply a performance penalty of a few percent typically.
        """
    def enclosed_check(self, other: Edges, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        Note: This is an alias of 'inside_check'.
        @brief Performs an inside check with options
        @param d The minimum distance for which the edges are checked
        @param other The other edge collection against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.

        The 'enclosed_check' alias was introduced in version 0.27.5.
        """
    def enclosing_check(self, other: Edges, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs an enclosing check with options
        @param d The minimum distance for which the edges are checked
        @param other The other edge collection against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.
        """
    def end_segments(self, length: int, fraction: float) -> Edges:
        r"""
        @brief Returns edges representing a part of the edge before the end point
        @return A new collection of edges representing the end part
        This method allows one to specify the length of these segments in a twofold way: either as a fixed length or by specifying a fraction of the original length:

        @code
        edges = ...  # An edge collection
        edges.end_segments(100, 0.0)     # All segments have a length of 100 DBU
        edges.end_segments(0, 50.0)      # All segments have a length of half the original length
        edges.end_segments(100, 50.0)    # All segments have a length of half the original length
                                          # or 100 DBU, whichever is larger
        @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are delivered which specify the end positions of the edges but can't participate in some functions.
        """
    def extended(self, b: int, e: int, o: int, i: int, join: bool) -> Region:
        r"""
        @brief Returns a region with shapes representing the edges with the specified extensions
        @param b the parallel extension at the start point of the edge
        @param e the parallel extension at the end point of the edge
        @param o the perpendicular extension to the "outside" (left side as seen in the direction of the edge)
        @param i the perpendicular extension to the "inside" (right side as seen in the direction of the edge)
        @param join If true, connected edges are joined before the extension is applied
        @return A region containing the polygons representing these extended edges
        This is a generic version of \extended_in and \extended_out. It allows one to specify extensions for all four directions of an edge and to join the edges before the extension is applied.

        For degenerated edges forming a point, a rectangle with the b, e, o and i used as left, right, top and bottom distance to the center point of this edge is created.

        If join is true and edges form a closed loop, the b and e parameters are ignored and a rim polygon is created that forms the loop with the outside and inside extension given by o and i.
        """
    def extended_in(self, e: int) -> Region:
        r"""
        @brief Returns a region with shapes representing the edges with the given width
        @param e The extension width
        @return A region containing the polygons representing these extended edges
        The edges are extended to the "inside" by the given distance "e". The distance will be applied to the right side as seen in the direction of the edge. By definition, this is the side pointing to the inside of the polygon if the edge was derived from a polygon.

        Other versions of this feature are \extended_out and \extended.
        """
    def extended_out(self, e: int) -> Region:
        r"""
        @brief Returns a region with shapes representing the edges with the given width
        @param e The extension width
        @return A region containing the polygons representing these extended edges
        The edges are extended to the "outside" by the given distance "e". The distance will be applied to the left side as seen in the direction of the edge. By definition, this is the side pointing to the outside of the polygon if the edge was derived from a polygon.

        Other versions of this feature are \extended_in and \extended.
        """
    @overload
    def extents(self) -> Region:
        r"""
        @brief Returns a region with the bounding boxes of the edges
        This method will return a region consisting of the bounding boxes of the edges.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    @overload
    def extents(self, d: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the edges
        This method will return a region consisting of the bounding boxes of the edges enlarged by the given distance d.
        The enlargement is specified per edge, i.e the width and height will be increased by 2*d.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    @overload
    def extents(self, dx: int, dy: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the edges
        This method will return a region consisting of the bounding boxes of the edges enlarged by the given distance dx in x direction and dy in y direction.
        The enlargement is specified per edge, i.e the width will be increased by 2*dx.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    def flatten(self) -> None:
        r"""
        @brief Explicitly flattens an edge collection

        If the collection is already flat (i.e. \has_valid_edges? returns true), this method will not change it.

        This method has been introduced in version 0.26.
        """
    def has_valid_edges(self) -> bool:
        r"""
        @brief Returns true if the edge collection is flat and individual edges can be accessed randomly

        This method has been introduced in version 0.26.
        """
    def hier_count(self) -> int:
        r"""
        @brief Returns the (hierarchical) number of edges in the edge collection

        This returns the number of raw edges (not merged edges if merged semantics is enabled).
        The count is computed 'hierarchical', i.e. edges inside a cell are counted once even if the cell is instantiated multiple times.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, box: Box) -> None:
        r"""
        @brief Inserts a box

        Inserts the edges that form the contour of the box into the edge collection.
        """
    @overload
    def insert(self, edge: Edge) -> None:
        r"""
        @brief Inserts an edge

        Inserts the edge into the edge collection.
        """
    @overload
    def insert(self, edges: Edges) -> None:
        r"""
        @brief Inserts all edges from the other edge collection into this one
        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, edges: Sequence[Edge]) -> None:
        r"""
        @brief Inserts all edges from the array into this edge collection
        """
    @overload
    def insert(self, path: Path) -> None:
        r"""
        @brief Inserts a path

        Inserts the edges that form the contour of the path into the edge collection.
        """
    @overload
    def insert(self, polygon: Polygon) -> None:
        r"""
        @brief Inserts a polygon

        Inserts the edges that form the contour of the polygon into the edge collection.
        """
    @overload
    def insert(self, polygon: SimplePolygon) -> None:
        r"""
        @brief Inserts a simple polygon

        Inserts the edges that form the contour of the simple polygon into the edge collection.
        """
    @overload
    def insert(self, polygons: Sequence[Polygon]) -> None:
        r"""
        @brief Inserts all polygons from the array into this edge collection
        """
    @overload
    def insert(self, region: Region) -> None:
        r"""
        @brief Inserts a region
        Inserts the edges that form the contours of the polygons from the region into the edge collection.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape_iterator: RecursiveShapeIterator) -> None:
        r"""
        @brief Inserts all shapes delivered by the recursive shape iterator into this edge collection

        For "solid" shapes (boxes, polygons, paths), this method inserts the edges that form the contour of the shape into the edge collection.
        Edge shapes are inserted as such.
        Text objects are not inserted, because they cannot be converted to polygons.
        """
    @overload
    def insert(self, shapes: Shapes) -> None:
        r"""
        @brief Inserts all edges from the shape collection into this edge collection
        This method takes each edge from the shape collection and inserts it into the region. "Polygon-like" objects are inserted as edges forming the contours of the polygons.
        Text objects are ignored.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts all shapes delivered by the recursive shape iterator into this edge collection with a transformation

        For "solid" shapes (boxes, polygons, paths), this method inserts the edges that form the contour of the shape into the edge collection.
        Edge shapes are inserted as such.
        Text objects are not inserted, because they cannot be converted to polygons.
        This variant will apply the given transformation to the shapes. This is useful to scale the shapes to a specific database unit for example.
        """
    @overload
    def insert(self, shapes: Shapes, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts all edges from the shape collection into this edge collection with complex transformation
        This method acts as the version without transformation, but will apply the given complex transformation before inserting the edges.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shapes: Shapes, trans: Trans) -> None:
        r"""
        @brief Inserts all edges from the shape collection into this edge collection (with transformation)
        This method acts as the version without transformation, but will apply the given transformation before inserting the edges.

        This method has been introduced in version 0.25.
        """
    def insert_into(self, layout: Layout, cell_index: int, layer: int) -> None:
        r"""
        @brief Inserts this edge collection into the given layout, below the given cell and into the given layer.
        If the edge collection is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.

        This method has been introduced in version 0.26.
        """
    def inside_check(self, other: Edges, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs an inside check with options
        @param d The minimum distance for which the edges are checked
        @param other The other edge collection against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.

        The 'enclosed_check' alias was introduced in version 0.27.5.
        """
    def inside_part(self, other: Region) -> Edges:
        r"""
        @brief Returns the parts of the edges of this edge collection which are inside the polygons of the region

        @return A new edge collection containing the edge parts inside the region

        This operation returns the parts of the edges which are inside the given region.
        This functionality is similar to the '&' operator, but edges on the borders of the polygons are not included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    @overload
    def interacting(self, other: Edges) -> Edges:
        r"""
        @brief Returns the edges of this edge collection which overlap or touch edges from the other edge collection

        @return A new edge collection containing the edges overlapping or touching edges from the other edge collection

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    @overload
    def interacting(self, other: Region) -> Edges:
        r"""
        @brief Returns the edges from this edge collection which overlap or touch polygons from the region

        @return A new edge collection containing the edges overlapping or touching polygons from the region

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    def intersections(self, other: Edges) -> Edges:
        r"""
        @brief Computes the intersections between this edges and other edges
        This computation is like an AND operation, but also including crossing points between non-coincident edges as degenerated (point-like) edges.

        This method has been introduced in version 0.26.2
        """
    def is_deep(self) -> bool:
        r"""
        @brief Returns true if the edge collection is a deep (hierarchical) one

        This method has been added in version 0.26.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns true if the edge collection is empty
        """
    def is_merged(self) -> bool:
        r"""
        @brief Returns true if the edge collection is merged
        If the region is merged, coincident edges have been merged into single edges. You can ensure merged state by calling \merge.
        """
    @overload
    def length(self) -> int:
        r"""
        @brief Returns the total length of all edges in the edge collection

        Merged semantics applies for this method (see \merged_semantics= of merged semantics)
        """
    @overload
    def length(self, rect: Box) -> int:
        r"""
        @brief Returns the total length of all edges in the edge collection (restricted to a rectangle)
        This version will compute the total length of all edges in the collection, restricting the computation to the given rectangle.
        Edges along the border are handled in a special way: they are counted when they are oriented with their inside side toward the rectangle (in other words: outside edges must coincide with the rectangle's border in order to be counted).

        Merged semantics applies for this method (see \merged_semantics= of merged semantics)
        """
    def members_of(self, other: Edges) -> Edges:
        r"""
        @brief Returns all edges which are members of the other edge collection
        This method returns all edges in self which can be found in the other edge collection as well with exactly the same geometry.
        """
    def merge(self) -> Edges:
        r"""
        @brief Merge the edges

        @return The edge collection after the edges have been merged (self).

        Merging joins parallel edges which overlap or touch.
        Crossing edges are not merged.
        If the edge collection is already merged, this method does nothing
        """
    def merged(self) -> Edges:
        r"""
        @brief Returns the merged edge collection

        @return The edge collection after the edges have been merged.

        Merging joins parallel edges which overlap or touch.
        Crossing edges are not merged.
        In contrast to \merge, this method does not modify the edge collection but returns a merged copy.
        """
    @overload
    def move(self, v: Vector) -> Edges:
        r"""
        @brief Moves the edge collection

        Moves the polygon by the given offset and returns the 
        moved edge collection. The edge collection is overwritten.

        @param v The distance to move the edge collection.

        @return The moved edge collection (self).

        Starting with version 0.25 the displacement type is a vector.
        """
    @overload
    def move(self, x: int, y: int) -> Edges:
        r"""
        @brief Moves the edge collection

        Moves the edge collection by the given offset and returns the 
        moved edge collection. The edge collection is overwritten.

        @param x The x distance to move the edge collection.
        @param y The y distance to move the edge collection.

        @return The moved edge collection (self).
        """
    @overload
    def moved(self, v: Vector) -> Edges:
        r"""
        @brief Returns the moved edge collection (does not modify self)

        Moves the edge collection by the given offset and returns the 
        moved edge collection. The edge collection is not modified.

        @param v The distance to move the edge collection.

        @return The moved edge collection.

        Starting with version 0.25 the displacement type is a vector.
        """
    @overload
    def moved(self, x: int, v: int) -> Edges:
        r"""
        @brief Returns the moved edge collection (does not modify self)

        Moves the edge collection by the given offset and returns the 
        moved edge collection. The edge collection is not modified.

        @param x The x distance to move the edge collection.
        @param y The y distance to move the edge collection.

        @return The moved edge collection.
        """
    @overload
    def not_interacting(self, other: Edges) -> Edges:
        r"""
        @brief Returns the edges of this edge collection which do not overlap or touch edges from the other edge collection

        @return A new edge collection containing the edges not overlapping or touching edges from the other edge collection

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    @overload
    def not_interacting(self, other: Region) -> Edges:
        r"""
        @brief Returns the edges from this edge collection which do not overlap or touch polygons from the region

        @return A new edge collection containing the edges not overlapping or touching polygons from the region

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    def not_members_of(self, other: Edges) -> Edges:
        r"""
        @brief Returns all edges which are not members of the other edge collection
        This method returns all edges in self which can not be found in the other edge collection with exactly the same geometry.
        """
    def outside_part(self, other: Region) -> Edges:
        r"""
        @brief Returns the parts of the edges of this edge collection which are outside the polygons of the region

        @return A new edge collection containing the edge parts outside the region

        This operation returns the parts of the edges which are not inside the given region.
        This functionality is similar to the '-' operator, but edges on the borders of the polygons are included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    def overlap_check(self, other: Edges, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs an overlap check with options
        @param d The minimum distance for which the edges are checked
        @param other The other edge collection against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.
        """
    @overload
    def pull_interacting(self, other: Edges) -> Edges:
        r"""
        @brief Returns all edges of "other" which are interacting with polygons of this edge set
        See the other \pull_interacting version for more details.

        @return The edge collection after the edges have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= of merged semantics)

        This method has been introduced in version 0.26.1
        """
    @overload
    def pull_interacting(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons of "other" which are interacting with (overlapping, touching) edges of this edge set
        The "pull_..." methods are similar to "select_..." but work the opposite way: they select shapes from the argument region rather than self. In a deep (hierarchical) context the output region will be hierarchically aligned with self, so the "pull_..." methods provide a way for re-hierarchization.

        @return The region after the polygons have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= of merged semantics)

        This method has been introduced in version 0.26.1
        """
    def select_inside_part(self, other: Region) -> Edges:
        r"""
        @brief Selects the parts of the edges from this edge collection which are inside the polygons of the given region

        @return The edge collection after the edges have been selected (self)

        This operation selects the parts of the edges which are inside the given region.
        This functionality is similar to the '&=' operator, but edges on the borders of the polygons are not included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    @overload
    def select_interacting(self, other: Edges) -> Edges:
        r"""
        @brief Selects the edges from this edge collection which overlap or touch edges from the other edge collection

        @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    @overload
    def select_interacting(self, other: Region) -> Edges:
        r"""
        @brief Selects the edges from this edge collection which overlap or touch polygons from the region

        @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    @overload
    def select_not_interacting(self, other: Edges) -> Edges:
        r"""
        @brief Selects the edges from this edge collection which do not overlap or touch edges from the other edge collection

        @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    @overload
    def select_not_interacting(self, other: Region) -> Edges:
        r"""
        @brief Selects the edges from this edge collection which do not overlap or touch polygons from the region

        @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select coherent edges, make sure the edge collection is merged before this method is used.
        """
    def select_outside_part(self, other: Region) -> Edges:
        r"""
        @brief Selects the parts of the edges from this edge collection which are outside the polygons of the given region

        @return The edge collection after the edges have been selected (self)

        This operation selects the parts of the edges which are not inside the given region.
        This functionality is similar to the '-=' operator, but edges on the borders of the polygons are included in the edge set.
        As a side effect, the edges are made non-intersecting by introducing cut points where
        edges intersect.

        This method has been introduced in version 0.24.
        """
    def separation_check(self, other: Edges, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs an overlap check with options
        @param d The minimum distance for which the edges are checked
        @param other The other edge collection against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.
        """
    def space_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs a space check with options
        @param d The minimum distance for which the edges are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the space check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.
        """
    def start_segments(self, length: int, fraction: float) -> Edges:
        r"""
        @brief Returns edges representing a part of the edge after the start point
        @return A new collection of edges representing the start part
        This method allows one to specify the length of these segments in a twofold way: either as a fixed length or by specifying a fraction of the original length:

        @code
        edges = ...  # An edge collection
        edges.start_segments(100, 0.0)    # All segments have a length of 100 DBU
        edges.start_segments(0, 50.0)     # All segments have a length of half the original length
        edges.start_segments(100, 50.0)   # All segments have a length of half the original length
                                          # or 100 DBU, whichever is larger
        @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are delivered which specify the start positions of the edges but can't participate in some functions.
        """
    def swap(self, other: Edges) -> None:
        r"""
        @brief Swap the contents of this edge collection with the contents of another one
        This method is useful to avoid excessive memory allocation in some cases. For managed memory languages such as Ruby, those cases will be rare. 
        """
    @overload
    def to_s(self) -> str:
        r"""
        @brief Converts the edge collection to a string
        The length of the output is limited to 20 edges to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    @overload
    def to_s(self, max_count: int) -> str:
        r"""
        @brief Converts the edge collection to a string
        This version allows specification of the maximum number of edges contained in the string.
        """
    @overload
    def transform(self, t: ICplxTrans) -> Edges:
        r"""
        @brief Transform the edge collection with a complex transformation (modifies self)

        Transforms the edge collection with the given transformation.
        This version modifies the edge collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.
        """
    @overload
    def transform(self, t: IMatrix2d) -> Edges:
        r"""
        @brief Transform the edge collection (modifies self)

        Transforms the edge collection with the given 2d matrix transformation.
        This version modifies the edge collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transform(self, t: IMatrix3d) -> Edges:
        r"""
        @brief Transform the edge collection (modifies self)

        Transforms the edge collection with the given 3d matrix transformation.
        This version modifies the edge collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transform(self, t: Trans) -> Edges:
        r"""
        @brief Transform the edge collection (modifies self)

        Transforms the edge collection with the given transformation.
        This version modifies the edge collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Edges:
        r"""
        @brief Transform the edge collection with a complex transformation

        Transforms the edge collection with the given complex transformation.
        Does not modify the edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.
        """
    @overload
    def transformed(self, t: IMatrix2d) -> Edges:
        r"""
        @brief Transform the edge collection

        Transforms the edge collection with the given 2d matrix transformation.
        Does not modify the edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transformed(self, t: IMatrix3d) -> Edges:
        r"""
        @brief Transform the edge collection

        Transforms the edge collection with the given 3d matrix transformation.
        Does not modify the edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.

        This variant has been introduced in version 0.27.
        """
    @overload
    def transformed(self, t: Trans) -> Edges:
        r"""
        @brief Transform the edge collection

        Transforms the edge collection with the given transformation.
        Does not modify the edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.
        """
    def width_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ...) -> EdgePairs:
        r"""
        @brief Performs a width check with options
        @param d The minimum width for which the edges are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper threshold of the projected length of one edge onto another

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one threshold, pass nil to the respective value.
        """
    @overload
    def with_angle(self, angle: float, inverse: bool) -> Edges:
        r"""
        @brief Filter the edges by orientation
        Filters the edges in the edge collection by orientation. If "inverse" is false, only edges which have the given angle to the x-axis are returned. If "inverse" is true, edges not having the given angle are returned.

        This will select horizontal edges:

        @code
        horizontal = edges.with_orientation(0, false)
        @/code
        """
    @overload
    def with_angle(self, min_angle: float, max_angle: float, inverse: bool, include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> Edges:
        r"""
        @brief Filter the edges by orientation
        Filters the edges in the edge collection by orientation. If "inverse" is false, only edges which have an angle to the x-axis larger or equal to "min_angle" (depending on "include_min_angle") and equal or less than "max_angle" (depending on "include_max_angle") are returned. If "inverse" is true, edges which do not conform to this criterion are returned.

        With "include_min_angle" set to true (the default), the minimum angle is included in the criterion while with false, the minimum angle itself is not included. Same for "include_max_angle" where the default is false, meaning the maximum angle is not included in the range.

        The two "include.." arguments have been added in version 0.27.
        """
    @overload
    def with_length(self, length: int, inverse: bool) -> Edges:
        r"""
        @brief Filter the edges by length
        Filters the edges in the edge collection by length. If "inverse" is false, only edges which have the given length are returned. If "inverse" is true, edges not having the given length are returned.
        """
    @overload
    def with_length(self, min_length: Any, max_length: Any, inverse: bool) -> Edges:
        r"""
        @brief Filter the edges by length
        Filters the edges in the edge collection by length. If "inverse" is false, only edges which have a length larger or equal to "min_length" and less than "max_length" are returned. If "inverse" is true, edges not having a length less than "min_length" or larger or equal than "max_length" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.
        """

class TextGenerator:
    r"""
    @brief A text generator class

    A text generator is basically a way to produce human-readable text for labelling layouts. It's similar to the Basic.TEXT PCell, but more convenient to use in a scripting context.

    Generators can be constructed from font files (or resources) or one of the registered generators can be used.

    To create a generator from a font file proceed this way:
    @code
    gen = RBA::TextGenerator::new
    gen.load_from_file("myfont.gds")
    region = gen.text("A TEXT", 0.001)
    @/code

    This code produces a RBA::Region with a database unit of 0.001 micron. This region can be fed into a \Shapes container to place it into a cell for example.

    By convention the font files must have two to three layers:

    @ul
    @li 1/0 for the actual data @/li
    @li 2/0 for the borders @/li
    @li 3/0 for an optional additional background @/li
    @/ul

    Currently, all glyphs must be bottom-left aligned at 0, 0. The
    border must be drawn in at least one glyph cell. The border is taken
    as the overall bbox of all borders.

    The glyph cells must be named with a single character or "nnn" where "d" is the
    ASCII code of the character (i.e. "032" for space). Allowed ASCII codes are 32 through 127.
    If a lower-case "a" character is defined, lower-case letters are supported.
    Otherwise, lowercase letters are mapped to uppercase letters.

    Undefined characters are left blank in the output.

    A comment cell can be defined ("COMMENT") which must hold one text in layer 1
    stating the comment, and additional descriptions such as line width:

    @ul
    @li "line_width=<x>": Specifies the intended line width in micron units @/li
    @li "design_grid=<x>": Specifies the intended design grid in micron units @/li
    @li any other text: The description string @/li
    @/ul

    Generators can be picked form a list of predefined generator. See \generators, \default_generator and \generator_by_name for picking a generator from the list.

    This class has been introduced in version 0.25.
    """
    @classmethod
    def default_generator(cls) -> TextGenerator:
        r"""
        @brief Gets the default text generator (a standard font)
        This method delivers the default generator or nil if no such generator is installed.
        """
    @classmethod
    def font_paths(cls) -> List[str]:
        r"""
        @brief Gets the paths where to look for font files
        See \set_font_paths for a description of this function.

        This method has been introduced in version 0.27.4.
        """
    @classmethod
    def generators(cls) -> List[TextGenerator]:
        r"""
        @brief Gets the generators registered in the system
        This method delivers a list of generator objects that can be used to create texts.
        """
    def __copy__(self) -> TextGenerator:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: TextGenerator) -> None:
        r"""
        @brief Assigns another object to self
        """
    def background(self) -> Box:
        r"""
        @brief Gets the background rectangle of each glyph in the generator's database units
        The background rectangle is the one that is used as background for inverted rendering. A version that delivers this value in micrometer units is \dbackground.
        """
    def dbackground(self) -> DBox:
        r"""
        @brief Gets the background rectangle in micron units
        The background rectangle is the one that is used as background for inverted rendering.
        """
    def dbu(self) -> float:
        r"""
        @brief Gets the basic database unit the design of the glyphs was made
        This database unit the basic resolution of the glyphs.
        """
    def ddesign_grid(self) -> float:
        r"""
        @brief Gets the design grid of the glyphs in micron units
        The design grid is the basic grid used when designing the glyphs. In most cases this grid is bigger than the database unit. 
        """
    def description(self) -> str:
        r"""
        @brief Gets the description text of the generator
        The generator's description text is a human-readable text that is used to identify the generator (aka 'font') in user interfaces.
        """
    def design_grid(self) -> int:
        r"""
        @brief Gets the design grid of the glyphs in the generator's database units
        The design grid is the basic grid used when designing the glyphs. In most cases this grid is bigger than the database unit. A version that delivers this value in micrometer units is \ddesign_grid.
        """
    def dheight(self) -> float:
        r"""
        @brief Gets the design height of the glyphs in micron units
        The height is the height of the rectangle occupied by each character. 
        """
    def dline_width(self) -> float:
        r"""
        @brief Gets the line width of the glyphs in micron units
        The line width is the intended (not necessarily precisely) line width of typical character lines (such as the bar of an 'I').
        """
    def dup(self) -> TextGenerator:
        r"""
        @brief Creates a copy of self
        """
    def dwidth(self) -> float:
        r"""
        @brief Gets the design width of the glyphs in micron units
        The width is the width of the rectangle occupied by each character. 
        """
    def generator_by_name(self, name: str) -> TextGenerator:
        r"""
        @brief Gets the text generator for a given name
        This method delivers the generator with the given name or nil if no such generator is registered.
        """
    def glyph(self, char: str) -> Region:
        r"""
        @brief Gets the glyph of the given character as a region
        The region represents the glyph's outline and is delivered in the generator's database units .A more elaborate way to getting the text's outline is \text.
        """
    def height(self) -> int:
        r"""
        @brief Gets the design height of the glyphs in the generator's database units
        The height is the height of the rectangle occupied by each character. A version that delivers this value in micrometer units is \dheight.
        """
    def line_width(self) -> int:
        r"""
        @brief Gets the line width of the glyphs in the generator's database units
        The line width is the intended (not necessarily precisely) line width of typical character lines (such as the bar of an 'I'). A version that delivers this value in micrometer units is \dline_width.
        """
    def load_from_file(self, path: str) -> None:
        r"""
        @brief Loads the given file into the generator
        See the description of the class how the layout data is read.
        """
    def name(self) -> str:
        r"""
        @brief Gets the name of the generator
        The generator's name is the basic key by which the generator is identified.
        """
    def set_font_paths(self, arg0: Sequence[str]) -> None:
        r"""
        @brief Sets the paths where to look for font files
        This function sets the paths where to look for font files. After setting such a path, each font found will render a specific generator. The generator can be found under the font file's name. As the text generator is also the basis for the Basic.TEXT PCell, using this function also allows configuring custom fonts for this library cell.

        This method has been introduced in version 0.27.4.
        """
    def text(self, text: str, target_dbu: float, mag: Optional[float] = ..., inv: Optional[bool] = ..., bias: Optional[float] = ..., char_spacing: Optional[float] = ..., line_spacing: Optional[float] = ...) -> Region:
        r"""
        @brief Gets the rendered text as a region
        @param text The text string
        @param target_dbu The database unit for which to produce the text
        @param mag The magnification (1.0 for original size)
        @param inv inverted rendering: if true, the glyphs are rendered inverse with the background box as the outer bounding box
        @param bias An additional bias to be applied (happens before inversion, can be negative)
        @param char_spacing Additional space between characters (in micron units)
        @param line_spacing Additional space between lines (in micron units)
        Various options can be specified to control the appearance of the text. See the description of the parameters. It's important to specify the target database unit in \target_dbu to indicate what database unit shall be used to create the output for.
        """
    def width(self) -> int:
        r"""
        @brief Gets the design height of the glyphs in the generator's database units
        The width is the width of the rectangle occupied by each character. A version that delivers this value in micrometer units is \dwidth.
        """

class Connectivity:
    r"""
    @brief This class specifies connections between different layers.
    Connections are build using \connect. There are basically two flavours of connections: intra-layer and inter-layer.

    Intra-layer connections make nets begin propagated along different shapes on the same net. Without the intra-layer connections, nets are not propagated over shape boundaries. As this is usually intended, intra-layer connections should always be specified for each layer.

    Inter-layer connections connect shapes on different layers. Shapes which touch across layers will be connected if their layers are specified as being connected through inter-layer \connect.

    All layers are specified in terms of layer indexes. Layer indexes are layout layer indexes (see \Layout class).

    The connectivity object also manages the global nets. Global nets are substrate for example and they are propagated automatically from subcircuits to circuits. Global nets are defined by name and are managed through IDs. To get the name for a given ID, use \global_net_name.
    This class has been introduced in version 0.26.
    """
    def __copy__(self) -> Connectivity:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Connectivity) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def connect(self, layer: int) -> None:
        r"""
        @brief Specifies intra-layer connectivity.
        """
    @overload
    def connect(self, layer_a: int, layer_b: int) -> None:
        r"""
        @brief Specifies inter-layer connectivity.
        """
    def connect_global(self, layer: int, global_net_name: str) -> int:
        r"""
        @brief Connects the given layer to the global net given by name.
        Returns the ID of the global net.
        """
    def dup(self) -> Connectivity:
        r"""
        @brief Creates a copy of self
        """
    def global_net_id(self, global_net_name: str) -> int:
        r"""
        @brief Gets the ID for a given global net name.
        """
    def global_net_name(self, global_net_id: int) -> str:
        r"""
        @brief Gets the name for a given global net ID.
        """

class InstElement:
    r"""
    @brief An element in an instantiation path

    This objects are used to reference a single instance in a instantiation path. The object is composed of a \CellInstArray object (accessible through the \cell_inst accessor) that describes the basic instance, which may be an array. The particular instance within the array can be further retrieved using the \array_member_trans, \specific_trans or \specific_cplx_trans methods.
    """
    def __copy__(self) -> InstElement:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, b: object) -> bool:
        r"""
        @brief Equality of two InstElement objects
        Note: this operator returns true if both instance elements refer to the same instance, not just identical ones.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor
        """
    @overload
    def __init__(self, inst: Instance) -> None:
        r"""
        @brief Create an instance element from a single instance alone
        Starting with version 0.15, this method takes an \Instance object (an instance reference) as the argument.
        """
    @overload
    def __init__(self, inst: Instance, a_index: int, b_index: int) -> None:
        r"""
        @brief Create an instance element from an array instance pointing into a certain array member
        Starting with version 0.15, this method takes an \Instance object (an instance reference) as the first argument.
        """
    def __lt__(self, b: InstElement) -> bool:
        r"""
        @brief Provides an order criterion for two InstElement objects
        Note: this operator is just provided to establish any order, not a particular one.
        """
    def __ne__(self, b: object) -> bool:
        r"""
        @brief Inequality of two InstElement objects
        See the comments on the == operator.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def array_member_trans(self) -> Trans:
        r"""
        @brief Returns the transformation for this array member

        The array member transformation is the one applicable in addition to the global transformation for the member selected from an array.
        If this instance is not an array instance, the specific transformation is a unit transformation without displacement.
        """
    def assign(self, other: InstElement) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cell_inst(self) -> CellInstArray:
        r"""
        @brief Accessor to the cell instance (array).

        This method is equivalent to "self.inst.cell_inst" and provided for convenience.
        """
    def dup(self) -> InstElement:
        r"""
        @brief Creates a copy of self
        """
    def ia(self) -> int:
        r"""
        @brief Returns the 'a' axis index for array instances
        For instance elements describing one member of an array, this attribute will deliver the a axis index addressed by this element. See \ib and \array_member_trans for further attributes applicable to array members.
        If the element is a plain instance and not an array member, this attribute is a negative value.

        This method has been introduced in version 0.25.
        """
    def ib(self) -> int:
        r"""
        @brief Returns the 'b' axis index for array instances
        For instance elements describing one member of an array, this attribute will deliver the a axis index addressed by this element. See \ia and \array_member_trans for further attributes applicable to array members.
        If the element is a plain instance and not an array member, this attribute is a negative value.

        This method has been introduced in version 0.25.
        """
    def inst(self) -> Instance:
        r"""
        @brief Gets the \Instance object held in this instance path element.

        This method has been added in version 0.24.
        """
    def prop_id(self) -> int:
        r"""
        @brief Accessor to the property attached to this instance.

        This method is equivalent to "self.inst.prop_id" and provided for convenience.
        """
    def specific_cplx_trans(self) -> ICplxTrans:
        r"""
        @brief Returns the specific complex transformation for this instance

        The specific transformation is the one applicable for the member selected from an array.
        This is the effective transformation applied for this array member. \array_member_trans gives the transformation applied additionally to the instances' global transformation (in other words, specific_cplx_trans = array_member_trans * cell_inst.cplx_trans).
        """
    def specific_trans(self) -> Trans:
        r"""
        @brief Returns the specific transformation for this instance

        The specific transformation is the one applicable for the member selected from an array.
        This is the effective transformation applied for this array member. \array_member_trans gives the transformation applied additionally to the instances' global transformation (in other words, specific_trans = array_member_trans * cell_inst.trans).
        This method delivers a simple transformation that does not include magnification components. To get these as well, use \specific_cplx_trans.
        """

class LayerMapping:
    r"""
    @brief A layer mapping (source to target layout)

    A layer mapping is an association of layers in two layouts forming pairs of layers, i.e. one layer corresponds to another layer in the other layout. The LayerMapping object describes the mapping of layers of a source layout A to a target layout B.

    A layer mapping can be set up manually or using the methods \create or \create_full.

    @code
    lm = RBA::LayerMapping::new
    # explicit:
    lm.map(2, 1)  # map layer index 2 of source to 1 of target
    lm.map(7, 3)  # map layer index 7 of source to 3 of target
    ...
    # or employing the specification identity:
    lm.create(target_layout, source_layout)
    # plus creating layers which don't exist in the target layout yet:
    new_layers = lm.create_full(target_layout, source_layout)
    @/code

    A layer might not be mapped to another layer which basically means that there is no corresponding layer.
    Such layers will be ignored in operations using the layer mapping. Use \create_full to ensure all layers
    of the source layout are mapped.

    LayerMapping objects play a role mainly in the hierarchical copy or move operations of \Layout. However, use is not restricted to these applications.

    This class has been introduced in version 0.23.
    """
    def __copy__(self) -> LayerMapping:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: LayerMapping) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear(self) -> None:
        r"""
        @brief Clears the mapping.
        """
    def create(self, layout_a: Layout, layout_b: Layout) -> None:
        r"""
        @brief Initialize the layer mapping from two layouts

        @param layout_a The target layout
        @param layout_b The source layout

        The layer mapping is created by looking up each layer of layout_b in layout_a. All layers with matching specifications (\LayerInfo) are mapped. Layouts without a layer/datatype/name specification will not be mapped.
        \create_full is a version of this method which creates new layers in layout_a if no corresponding layer is found.
        """
    def create_full(self, layout_a: Layout, layout_b: Layout) -> List[int]:
        r"""
        @brief Initialize the layer mapping from two layouts

        @param layout_a The target layout
        @param layout_b The source layout
        @return A list of layers created

        The layer mapping is created by looking up each layer of layout_b in layout_a. All layers with matching specifications (\LayerInfo) are mapped. Layouts without a layer/datatype/name specification will not be mapped.
        Layers with a valid specification which are not found in layout_a are created there.
        """
    def dup(self) -> LayerMapping:
        r"""
        @brief Creates a copy of self
        """
    def has_mapping(self, layer_index_b: int) -> bool:
        r"""
        @brief Determine if a layer in layout_b has a mapping to a layout_a layer.


        @param layer_index_b The index of the layer in layout_b whose mapping is requested.
        @return true, if the layer has a mapping
        """
    def layer_mapping(self, layer_index_b: int) -> int:
        r"""
        @brief Determine layer mapping of a layout_b layer to the corresponding layout_a layer.


        @param layer_index_b The index of the layer in layout_b whose mapping is requested.
        @return The corresponding layer in layout_a.
        """
    def map(self, layer_index_b: int, layer_index_a: int) -> None:
        r"""
        @brief Explicitly specify a mapping.


        @param layer_index_b The index of the layer in layout B (the "source")
        @param layer_index_a The index of the layer in layout A (the "target")

        Beside using the mapping generator algorithms provided through \create and \create_full, it is possible to explicitly specify layer mappings using this method.
        """
    def table(self) -> Dict[int, int]:
        r"""
        @brief Returns the mapping table.

        The mapping table is a dictionary where the keys are source layout layer indexes and the values are the target layout layer indexes.

        This method has been introduced in version 0.25.
        """

class LayerInfo:
    r"""
    @brief A structure encapsulating the layer properties

    The layer properties describe how a layer is stored in a GDS2 or OASIS file for example. The \LayerInfo object represents the storage properties that are attached to a layer in the database.

    In general, a layer has either a layer and a datatype number (in GDS2), a name (for example in DXF or CIF) or both (in OASIS). In the latter case, the primary identification is through layer and datatype number and the name is some annotation attached to it. A \LayerInfo object which specifies just a name returns true on \is_named?.
    The \LayerInfo object can also specify an anonymous layer (use \LayerInfo#new without arguments). Such a layer will not be stored when saving the layout. They can be employed for temporary layers for example. Use \LayerInfo#anonymous? to test whether a layer does not have a specification.

    The \LayerInfo is used for example in \Layout#insert_layer to specify the properties of the new layer that will be created. The \is_equivalent? method compares two \LayerInfo objects using the layer and datatype numbers with a higher priority over the name.
    """
    datatype: int
    r"""
    @brief Gets the datatype
    @brief Set the datatype
    """
    layer: int
    r"""
    @brief Gets the layer number
    @brief Sets the layer number
    """
    name: str
    r"""
    @brief Gets the layer name
    @brief Set the layer name
    The name is set on OASIS input for example, if the layer has a name.
    """
    def __copy__(self) -> LayerInfo:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, b: object) -> bool:
        r"""
        @brief Compares two layer info objects
        @return True, if both are equal

        This method was added in version 0.18.
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given layer info object. This method enables layer info objects as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief The default constructor.
        Creates a default \LayerInfo object.

        This method was added in version 0.18.
        """
    @overload
    def __init__(self, name: str) -> None:
        r"""
        @brief The constructor for a named layer.
        Creates a \LayerInfo object representing a named layer.
        @param name The name

        This method was added in version 0.18.
        """
    @overload
    def __init__(self, layer: int, datatype: int) -> None:
        r"""
        @brief The constructor for a layer/datatype pair.
        Creates a \LayerInfo object representing a layer and datatype.
        @param layer The layer number
        @param datatype The datatype number

        This method was added in version 0.18.
        """
    @overload
    def __init__(self, layer: int, datatype: int, name: str) -> None:
        r"""
        @brief The constructor for a named layer with layer and datatype.
        Creates a \LayerInfo object representing a named layer with layer and datatype.
        @param layer The layer number
        @param datatype The datatype number
        @param name The name

        This method was added in version 0.18.
        """
    def __ne__(self, b: object) -> bool:
        r"""
        @brief Compares two layer info objects
        @return True, if both are not equal

        This method was added in version 0.18.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def anonymous(self) -> bool:
        r"""
        @brief Returns true, if the layer has no specification (i.e. is created by the default constructor).
        @return True, if the layer does not have any specification.

        This method was added in version 0.23.
        """
    def assign(self, other: LayerInfo) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> LayerInfo:
        r"""
        @brief Creates a copy of self
        """
    def from_string(self, s: str, as_target: Optional[bool] = ...) -> LayerInfo:
        r"""
        @brief Create a layer info object from a string
        @param The string
        @return The LayerInfo object

        If 'as_target' is true, relative specifications such as '*+1' for layer or datatype are permitted.

        This method will take strings as produced by \to_s and create a \LayerInfo object from them. The format is either "layer", "layer/datatype", "name" or "name (layer/datatype)".

        This method was added in version 0.23.
        The 'as_target' argument has been added in version 0.26.5.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given layer info object. This method enables layer info objects as hash keys.

        This method has been introduced in version 0.25.
        """
    def is_equivalent(self, b: LayerInfo) -> bool:
        r"""
        @brief Equivalence of two layer info objects
        @return True, if both are equivalent

        First, layer and datatype are compared. The name is of second order and used only if no layer or datatype is given.
        This is basically a weak comparison that reflects the search preferences.

        This method was added in version 0.18.
        """
    def is_named(self) -> bool:
        r"""
        @brief Returns true, if the layer is purely specified by name.
        @return True, if no layer or datatype is given.

        This method was added in version 0.18.
        """
    def to_s(self, as_target: Optional[bool] = ...) -> str:
        r"""
        @brief Convert the layer info object to a string
        @return The string

        If 'as_target' is true, wildcard and relative specifications are formatted such such.

        This method was added in version 0.18.
        The 'as_target' argument has been added in version 0.26.5.
        """

class LayoutMetaInfo:
    r"""
    @brief A piece of layout meta information
    Layout meta information is basically additional data that can be attached to a layout. Layout readers may generate meta information and some writers will add layout information to the layout object. Some writers will also read meta information to determine certain attributes.

    Multiple layout meta information objects can be attached to one layout using \Layout#add_meta_info. Meta information is identified by a unique name and carries a string value plus an optional description string. The description string is for information only and is not evaluated by code.

    See also \Layout#each_meta_info and \Layout#meta_info_value and \Layout#remove_meta_info
    This class has been introduced in version 0.25.
    """
    description: str
    r"""
    @brief Gets the description of the layout meta info object
    @brief Sets the description of the layout meta info object
    """
    name: str
    r"""
    @brief Gets the name of the layout meta info object
    @brief Sets the name of the layout meta info object
    """
    value: str
    r"""
    @brief Gets the value of the layout meta info object
    @brief Sets the value of the layout meta info object
    """
    def __copy__(self) -> LayoutMetaInfo:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self, name: str, value: str, description: Optional[str] = ...) -> None:
        r"""
        @brief Creates a layout meta info object
        @param name The name
        @param value The value
        @param description An optional description text
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: LayoutMetaInfo) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> LayoutMetaInfo:
        r"""
        @brief Creates a copy of self
        """

class Layout:
    r"""
    @brief The layout object

    This object represents a layout.
    The layout object contains the cell hierarchy and
    adds functionality for managing cell names and layer names.
    The cell hierarchy can be changed by adding cells and cell instances.
    Cell instances will virtually put the content of a cell into another cell. Many cell instances can be put into a cell thus forming repetitions of the cell content. This process can be repeated over multiple levels. In effect a cell graphs is created with parent cells and child cells. The graph must not be recursive, so there is at least one top cell, which does not have a parent cell. Multiple top cells can be present.

    \Layout is the very basic class of the layout database. It has a rich set of methods to manipulate and query the layout hierarchy, the geometrical objects, the meta information and other features of the layout database. For a discussion of the basic API and the related classes see @<a href="/programming/database_api.xml">The Database API@</a>.

    Usually layout objects have already been created by KLayout's application core. You can address such a layout via the \CellView object inside the \LayoutView class. For example:

    @code
    active_layout = RBA::CellView::active.layout
    puts "Top cell of current layout is #{active_layout.top_cell.name}"
    @/code

    However, a layout can also be used standalone:

    @code
    layout = RBA::Layout::new
    cell = layout.create_cell("TOP")
    layer = layout.layer(RBA::LayerInfo::new(1, 0))
    cell.shapes(layer).insert(RBA::Box::new(0, 0, 1000, 1000))
    layout.write("single_rect.gds")
    @/code
    """
    dbu: float
    r"""
    @brief Gets the database unit

    The database unit is the value of one units distance in micrometers.
    For numerical reasons and to be compliant with the GDS2 format, the database objects use integer coordinates. The basic unit of these coordinates is the database unit.
    You can convert coordinates to micrometers by multiplying the integer value with the database unit.
    Typical values for the database unit are 0.001 micrometer (one nanometer).
    @brief Sets the database unit

    See \dbu for a description of the database unit.
    """
    prop_id: int
    r"""
    @brief Gets the properties ID associated with the layout

    This method has been introduced in version 0.24.@brief Sets the properties ID associated with the layout
    This method is provided, if a properties ID has been derived already. Usually it's more convenient to use \delete_property, \set_property or \property.

    This method has been introduced in version 0.24.
    """
    technology_name: str
    r"""
    @brief Gets the name of the technology this layout is associated with
    This method has been introduced in version 0.27. Before that, the technology has been kept in the 'technology' meta data element.@brief Sets the name of the technology this layout is associated with
    Changing the technology name will re-assess all library references because libraries can be technology specified. Cell layouts may be substituted during this re-assessment.

    This method has been introduced in version 0.27.
    """
    def __copy__(self) -> Layout:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a layout object

        Starting with version 0.25, layouts created with the default constructor are always editable. Before that version, they inherited the editable flag from the application.
        """
    @overload
    def __init__(self, editable: bool) -> None:
        r"""
        @brief Creates a layout object

        This constructor specifies whether the layout is editable. In editable mode, some optimizations are disabled and the layout can be manipulated through a variety of methods.

        This method was introduced in version 0.22.
        """
    @overload
    def __init__(self, manager: Manager) -> None:
        r"""
        @brief Creates a layout object attached to a manager

        This constructor specifies a manager object which is used to store undo information for example.

        Starting with version 0.25, layouts created with the default constructor are always editable. Before that version, they inherited the editable flag from the application.
        """
    @overload
    def __init__(self, editable: bool, manager: Manager) -> None:
        r"""
        @brief Creates a layout object attached to a manager

        This constructor specifies a manager object which is used to store undo information for example. It also allows one to specify whether the layout is editable. In editable mode, some optimizations are disabled and the layout can be manipulated through a variety of methods.

        This method was introduced in version 0.22.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_lib_cell(self, library: Library, lib_cell_index: int) -> int:
        r"""
        @brief Imports a cell from the library
        @param library The reference to the library from which to import the cell
        @param lib_cell_index The index of the imported cell in the library
        @return The cell index of the new proxy cell in this layout
        This method imports the given cell from the library and creates a new proxy cell.
        The proxy cell acts as a pointer to the actual cell which still resides in the 
        library (precisely: in library.layout). The name of the new cell will be the name of
        library cell. 

        This method has been introduced in version 0.22.
        """
    def add_meta_info(self, info: LayoutMetaInfo) -> None:
        r"""
        @brief Adds meta information to the layout
        See \LayoutMetaInfo for details about layouts and meta information.
        This method has been introduced in version 0.25.
        """
    @overload
    def add_pcell_variant(self, pcell_id: int, parameters: Sequence[Any]) -> int:
        r"""
        @brief Creates a PCell variant for the given PCell ID with the given parameters
        @return The cell index of the pcell variant proxy cell
        This method will create a PCell variant proxy for a local PCell definition.
        It will create the PCell variant for the given parameters. Note that this method 
        does not allow one to create PCell instances for PCells located in a library. Use
        \add_pcell_variant with the library parameter for that purpose.

        The parameters are a sequence of variants which correspond to the parameters declared by the \PCellDeclaration object.

        The name of the new cell will be the name of the PCell. 
        If a cell with that name already exists, a new unique name is generated.

        This method has been introduced in version 0.22.
        """
    @overload
    def add_pcell_variant(self, library: Library, pcell_id: int, parameters: Sequence[Any]) -> int:
        r"""
        @brief Creates a PCell variant for a PCell located in an external library
        @return The cell index of the new proxy cell in this layout
        This method will import a PCell from a library and create a variant for the 
        given parameter set.
        Technically, this method creates a proxy to the library and creates the variant
        inside that library.  

        The parameters are a sequence of variants which correspond to the parameters declared by the \PCellDeclaration object.

        The name of the new cell will be the name of the PCell. 
        If a cell with that name already exists, a new unique name is generated.

        This method has been introduced in version 0.22.
        """
    @overload
    def add_pcell_variant(self, pcell_id: int, parameters: Dict[str, Any]) -> int:
        r"""
        @brief Creates a PCell variant for the given PCell ID with the parameters given as a name/value dictionary
        @return The cell index of the pcell variant proxy cell
        This method will create a PCell variant proxy for a local PCell definition.
        It will create the PCell variant for the given parameters. Note that this method 
        does not allow one to create PCell instances for PCells located in a library. Use
        \add_pcell_variant with the library parameter for that purpose.
        Unlike the variant using a list of parameters, this version allows specification
        of the parameters with a key/value dictionary. The keys are the parameter names
        as given by the PCell declaration.

        The parameters are a sequence of variants which correspond to the parameters declared by the \PCellDeclaration object.

        The name of the new cell will be the name of the PCell. 
        If a cell with that name already exists, a new unique name is generated.

        This method has been introduced in version 0.22.
        """
    @overload
    def add_pcell_variant(self, library: Library, pcell_id: int, parameters: Dict[str, Any]) -> int:
        r"""
        @brief Creates a PCell variant for a PCell located in an external library with the parameters given as a name/value dictionary
        @return The cell index of the new proxy cell in this layout
        This method will import a PCell from a library and create a variant for the 
        given parameter set.
        Technically, this method creates a proxy to the library and creates the variant
        inside that library.
        Unlike the variant using a list of parameters, this version allows specification
        of the parameters with a key/value dictionary. The keys are the parameter names
        as given by the PCell declaration.

        The parameters are a sequence of variants which correspond to the parameters declared by the \PCellDeclaration object.

        The name of the new cell will be the name of the PCell. 
        If a cell with that name already exists, a new unique name is generated.

        This method has been introduced in version 0.22.
        """
    def assign(self, other: Layout) -> None:
        r"""
        @brief Assigns another object to self
        """
    def begin_shapes(self, cell: Cell, layer: int) -> RecursiveShapeIterator:
        r"""
        @brief Delivers a recursive shape iterator for the shapes below the given cell on the given layer
        @param cell The cell object of the initial (top) cell
        @param layer The layer from which to get the shapes
        @return A suitable iterator

        For details see the description of the \RecursiveShapeIterator class.
        This version is convenience overload which takes a cell object instead of a cell index.

        This method is deprecated. Use \Cell#begin_shapes_rec instead.

        This method has been added in version 0.24.
        """
    @overload
    def cell(self, i: int) -> Cell:
        r"""
        @brief Gets a cell object from the cell index

        @param i The cell index
        @return A reference to the cell (a \Cell object)

        If the cell index is not a valid cell index, this method will raise an error. Use \is_valid_cell_index? to test whether a given cell index is valid.
        """
    @overload
    def cell(self, name: str) -> Cell:
        r"""
        @brief Gets a cell object from the cell name

        @param name The cell name
        @return A reference to the cell (a \Cell object)

        If name is not a valid cell name, this method will return "nil".
        This method has been introduced in version 0.23 and replaces \cell_by_name.
        """
    def cell_name(self, index: int) -> str:
        r"""
        @brief Gets the name for a cell with the given index
        """
    @overload
    def cells(self) -> int:
        r"""
        @brief Returns the number of cells

        @return The number of cells (the maximum cell index)
        """
    @overload
    def cells(self, name_filter: str) -> List[Cell]:
        r"""
        @brief Gets the cell objects for a given name filter

        @param name_filter The cell name filter (glob pattern)
        @return A list of \Cell object of the cells matching the pattern

        This method has been introduced in version 0.27.3.
        """
    def cleanup(self, cell_indexes_to_keep: Optional[Sequence[int]] = ...) -> None:
        r"""
        @brief Cleans up the layout
        This method will remove proxy objects that are no longer in use. After changing PCell parameters such proxy objects may still be present in the layout and are cached for later reuse. Usually they are cleaned up automatically, but in a scripting context it may be useful to clean up these cells explicitly.

        Use 'cell_indexes_to_keep' for specifying a list of cell indexes of PCell variants or library proxies you don't want to be cleaned up.

        This method has been introduced in version 0.25.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the layout

        Clears the layout completely.
        """
    def clear_layer(self, layer_index: int) -> None:
        r"""
        @brief Clears a layer

        Clears the layer: removes all shapes.

        This method was introduced in version 0.19.

        @param layer_index The index of the layer to delete.
        """
    def clip(self, cell: int, box: Box) -> int:
        r"""
        @brief Clips the given cell by the given rectangle and produce a new cell with the clip
        @param cell The cell index of the cell to clip
        @param box The clip box in database units
        @return The index of the new cell

        This method will cut a rectangular region given by the box from the given cell. The clip will be stored in a new cell whose index is returned. The clip will be performed hierarchically. The resulting cell will hold a hierarchy of child cells, which are potentially clipped versions of child cells of the original cell.
        This method has been added in version 0.21.
        """
    def clip_into(self, cell: int, target: Layout, box: Box) -> int:
        r"""
        @brief Clips the given cell by the given rectangle and produce a new cell with the clip
        @param cell The cell index of the cell to clip
        @param box The clip box in database units
        @param target The target layout
        @return The index of the new cell in the target layout

        This method will cut a rectangular region given by the box from the given cell. The clip will be stored in a new cell in the target layout. The clip will be performed hierarchically. The resulting cell will hold a hierarchy of child cells, which are potentially clipped versions of child cells of the original cell.

        Please note that it is important that the database unit of the target layout is identical to the database unit of the source layout to achieve the desired results.This method also assumes that the target layout holds the same layers than the source layout. It will copy shapes to the same layers than they have been on the original layout. 
        This method has been added in version 0.21.
        """
    def convert_cell_to_static(self, cell_index: int) -> int:
        r"""
        @brief Converts a PCell or library cell to a usual (static) cell
        @return The index of the new cell
        This method will create a new cell which contains the static representation of the PCell or library proxy given by "cell_index". If that cell is not a PCell or library proxy, it won't be touched and the input cell index is returned.

        This method has been added in version 0.23.
        """
    def copy_layer(self, src: int, dest: int) -> None:
        r"""
        @brief Copies a layer

        This method was introduced in version 0.19.

        Copy a layer from the source to the target. The target is not cleared before, so that this method 
        merges shapes from the source with the target layer.

        @param src The layer index of the source layer.
        @param dest The layer index of the destination layer.
        """
    @overload
    def copy_tree_shapes(self, source_layout: Layout, cell_mapping: CellMapping) -> None:
        r"""
        @brief Copies the shapes for all given mappings in the \CellMapping object
        @param source_layout The layout where to take the shapes from
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout

        Provide a \CellMapping object to specify pairs of cells which are mapped from the source layout to this layout. When constructing such a cell mapping object for example with \CellMapping#for_multi_cells_full, use self as the target layout. During the cell mapping construction, the cell mapper will usually create a suitable target hierarchy already. After having completed the cell mapping, use \copy_tree_shapes to copy over the shapes from the source to the target layout.

        This method has been added in version 0.26.8.
        """
    @overload
    def copy_tree_shapes(self, source_layout: Layout, cell_mapping: CellMapping, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Copies the shapes for all given mappings in the \CellMapping object using the given layer mapping
        @param source_layout The layout where to take the shapes from
        @param cell_mapping The cell mapping object that determines how cells are identified between source and target layout
        @param layer_mapping Specifies which layers are copied from the source layout to the target layout

        Provide a \CellMapping object to specify pairs of cells which are mapped from the source layout to this layout. When constructing such a cell mapping object for example with \CellMapping#for_multi_cells_full, use self as the target layout. During the cell mapping construction, the cell mapper will usually create a suitable target hierarchy already. After having completed the cell mapping, use \copy_tree_shapes to copy over the shapes from the source to the target layout.

        This method has been added in version 0.26.8.
        """
    @overload
    def create_cell(self, name: str) -> Cell:
        r"""
        @brief Creates a cell with the given name
        @param name The name of the cell to create
        @return The \Cell object of the newly created cell.

        If a cell with that name already exists, the unique name will be chosen for the new cell consisting of the given name plus a suitable suffix.

        This method has been introduce in version 0.23 and replaces \add_cell.
        """
    @overload
    def create_cell(self, name: str, lib_name: str) -> Cell:
        r"""
        @brief Creates a cell with the given name
        @param name The name of the library cell and the name of the cell to create
        @param lib_name The name of the library where to take the cell from
        @return The \Cell object of the newly created cell.

        This method will look up the cell by the given name in the specified library and create a new library proxy to this cell.
        If the library name is not valid, nil is returned.

        This method has been introduce in version 0.24.
        """
    @overload
    def create_cell(self, name: str, params: Dict[str, Any]) -> Cell:
        r"""
        @brief Creates a cell as a PCell variant with the given name
        @param name The name of the PCell and the name of the cell to create
        @param params The PCell parameters (key/value dictionary)
        @return The \Cell object of the newly created cell.

        This method will look up the PCell by the given name and create a new PCell variant with the given parameters. The parameters are specified as a key/value dictionary with the names being the ones from the PCell declaration.

        If no PCell with the given name exists, nil is returned.

        This method has been introduce in version 0.24.
        """
    @overload
    def create_cell(self, name: str, lib_name: str, params: Dict[str, Any]) -> Cell:
        r"""
        @brief Creates a cell with the given name
        @param name The name of the PCell and the name of the cell to create
        @param lib_name The name of the library where to take the PCell from
        @param params The PCell parameters (key/value dictionary)
        @return The \Cell object of the newly created cell.

        This method will look up the PCell by the given name in the specified library and create a new PCell variant with the given parameters. The parameters are specified as a key/value dictionary with the names being the ones from the PCell declaration.

        If no PCell with the given name exists or the library name is not valid, nil is returned.

        This method has been introduce in version 0.24.
        """
    def delete_cell(self, cell_index: int) -> None:
        r"""
        @brief Deletes a cell 

        This deletes a cell but not the sub cells of the cell.
        These subcells will likely become new top cells unless they are used
        otherwise.
        All instances of this cell are deleted as well.
        Hint: to delete multiple cells, use "delete_cells" which is 
        far more efficient in this case.

        @param cell_index The index of the cell to delete

        This method has been introduced in version 0.20.
        """
    def delete_cell_rec(self, cell_index: int) -> None:
        r"""
        @brief Deletes a cell plus all subcells

        This deletes a cell and also all sub cells of the cell.
        In contrast to \prune_cell, all cells are deleted together with their instances even if they are used otherwise.

        @param cell_index The index of the cell to delete

        This method has been introduced in version 0.20.
        """
    def delete_cells(self, cell_index_list: Sequence[int]) -> None:
        r"""
        @brief Deletes multiple cells

        This deletes the cells but not the sub cells of these cells.
        These subcells will likely become new top cells unless they are used
        otherwise.
        All instances of these cells are deleted as well.

        @param cell_index_list An array of cell indices of the cells to delete

        This method has been introduced in version 0.20.
        """
    def delete_layer(self, layer_index: int) -> None:
        r"""
        @brief Deletes a layer

        This method frees the memory allocated for the shapes of this layer and remembers the
        layer's index for reuse when the next layer is allocated.

        @param layer_index The index of the layer to delete.
        """
    def delete_property(self, key: Any) -> None:
        r"""
        @brief Deletes the user property with the given key
        This method is a convenience method that deletes the property with the given key. It does nothing if no property with that key exists. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID.

        This method has been introduced in version 0.24.
        """
    def dump_mem_statistics(self, detailed: Optional[bool] = ...) -> None:
        r"""
        @hide
        """
    def dup(self) -> Layout:
        r"""
        @brief Creates a copy of self
        """
    def each_cell(self) -> Iterator[Cell]:
        r"""
        @brief Iterates the unsorted cell list
        """
    def each_cell_bottom_up(self) -> Iterator[int]:
        r"""
        @brief Iterates the bottom-up sorted cell list

        In bottom-up traversal a cell is not delivered before
        the last child cell of this cell has been delivered.
        The bottom-up iterator does not deliver cells but cell
        indices actually.
        """
    def each_cell_top_down(self) -> Iterator[int]:
        r"""
        @brief Iterates the top-down sorted cell list

        The top-down cell list has the property of delivering all
        cells before they are instantiated. In addition the first
        cells are all top cells. There is at least one top cell.
        The top-down iterator does not deliver cells but cell
        indices actually.
        @brief begin iterator of the top-down sorted cell list
        """
    def each_meta_info(self) -> Iterator[LayoutMetaInfo]:
        r"""
        @brief Iterates over the meta information of the layout
        See \LayoutMetaInfo for details about layouts and meta information.

        This method has been introduced in version 0.25.
        """
    def each_top_cell(self) -> Iterator[int]:
        r"""
        @brief Iterates the top cells
        A layout may have an arbitrary number of top cells. The usual case however is that there is one top cell.
        """
    def end_changes(self) -> None:
        r"""
        @brief Cancels the "in changes" state (see "start_changes")
        """
    @overload
    def find_layer(self, info: LayerInfo) -> Any:
        r"""
        @brief Finds a layer with the given properties

        If a layer with the given properties already exists, this method will return the index of that layer.If no such layer exists, it will return nil.

        This method has been introduced in version 0.23.
        """
    @overload
    def find_layer(self, name: str) -> Any:
        r"""
        @brief Finds a layer with the given name

        If a layer with the given name already exists, this method will return the index of that layer.If no such layer exists, it will return nil.

        This method has been introduced in version 0.23.
        """
    @overload
    def find_layer(self, layer: int, datatype: int) -> Any:
        r"""
        @brief Finds a layer with the given layer and datatype number

        If a layer with the given layer/datatype already exists, this method will return the index of that layer.If no such layer exists, it will return nil.

        This method has been introduced in version 0.23.
        """
    @overload
    def find_layer(self, layer: int, datatype: int, name: str) -> Any:
        r"""
        @brief Finds a layer with the given layer and datatype number and name

        If a layer with the given layer/datatype/name already exists, this method will return the index of that layer.If no such layer exists, it will return nil.

        This method has been introduced in version 0.23.
        """
    def flatten(self, cell_index: int, levels: int, prune: bool) -> None:
        r"""
        @brief Flattens the given cell

        This method propagates all shapes and instances from the specified number of hierarchy levels below into the given cell.
        It also removes the instances of the cells from which the shapes came from, but does not remove the cells themselves if prune is set to false.
        If prune is set to true, these cells are removed if not used otherwise.

        @param cell_index The cell which should be flattened
        @param levels The number of hierarchy levels to flatten (-1: all, 0: none, 1: one level etc.)
        @param prune Set to true to remove orphan cells.

        This method has been introduced in version 0.20.
        """
    def flatten_into(self, source_cell_index: int, target_cell_index: int, trans: ICplxTrans, levels: int) -> None:
        r"""
        @brief Flattens the given cell into another cell

        This method works like 'flatten', but allows specification of a target cell which can be different from the source cell plus a transformation which is applied for all shapes and instances in the target cell.

        In contrast to the 'flatten' method, the source cell is not modified.

        @param source_cell_index The source cell which should be flattened
        @param target_cell_index The target cell into which the resulting objects are written
        @param trans The transformation to apply on the output shapes and instances
        @param levels The number of hierarchy levels to flatten (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.24.
        """
    def get_info(self, index: int) -> LayerInfo:
        r"""
        @brief Gets the info structure for a specified layer
        """
    def guiding_shape_layer(self) -> int:
        r"""
        @brief Returns the index of the guiding shape layer
        The guiding shape layer is used to store guiding shapes for PCells.

        This method has been added in version 0.22.
        """
    def has_cell(self, name: str) -> bool:
        r"""
        @brief Returns true if a cell with a given name exists
        Returns true, if the layout has a cell with the given name
        """
    def has_prop_id(self) -> bool:
        r"""
        @brief Returns true, if the layout has user properties

        This method has been introduced in version 0.24.
        """
    @overload
    def insert(self, cell_index: int, layer: int, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Inserts an edge pair collection into the given cell and layer
        If the edge pair collection is (conceptionally) flat, it will be inserted into the cell's shapes list as a flat sequence of edge pairs.
        If the edge pair collection is deep (hierarchical), it will create a subhierarchy below the given cell and it's edge pairs will be put into the respective cells. Suitable subcells will be picked for inserting the edge pairs. If a hierarchy already exists below the given cell, the algorithm will try to reuse this hierarchy.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, cell_index: int, layer: int, edges: Edges) -> None:
        r"""
        @brief Inserts an edge collection into the given cell and layer
        If the edge collection is (conceptionally) flat, it will be inserted into the cell's shapes list as a flat sequence of edges.
        If the edge collection is deep (hierarchical), it will create a subhierarchy below the given cell and it's edges will be put into the respective cells. Suitable subcells will be picked for inserting the edges. If a hierarchy already exists below the given cell, the algorithm will try to reuse this hierarchy.

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, cell_index: int, layer: int, region: Region) -> None:
        r"""
        @brief Inserts a region into the given cell and layer
        If the region is (conceptionally) a flat region, it will be inserted into the cell's shapes list as a flat sequence of polygons.
        If the region is a deep (hierarchical) region, it will create a subhierarchy below the given cell and it's shapes will be put into the respective cells. Suitable subcells will be picked for inserting the shapes. If a hierarchy already exists below the given cell, the algorithm will try to reuse this hierarchy.

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, cell_index: int, layer: int, texts: Texts) -> None:
        r"""
        @brief Inserts an text collection into the given cell and layer
        If the text collection is (conceptionally) flat, it will be inserted into the cell's shapes list as a flat sequence of texts.
        If the text collection is deep (hierarchical), it will create a subhierarchy below the given cell and it's texts will be put into the respective cells. Suitable subcells will be picked for inserting the texts. If a hierarchy already exists below the given cell, the algorithm will try to reuse this hierarchy.

        This method has been introduced in version 0.27.
        """
    def insert_layer(self, props: LayerInfo) -> int:
        r"""
        @brief Inserts a new layer with the given properties
        @return The index of the newly created layer
        """
    def insert_layer_at(self, index: int, props: LayerInfo) -> None:
        r"""
        @brief Inserts a new layer with the given properties at the given index
        This method will associate the given layer info with the given layer index. If a layer with that index already exists, this method will change the properties of the layer with that index. Otherwise a new layer is created.
        """
    def insert_special_layer(self, props: LayerInfo) -> int:
        r"""
        @brief Inserts a new special layer with the given properties

        Special layers can be used to represent objects that should not participate in normal viewing or other related operations. Special layers are not reported as valid layers.

        @return The index of the newly created layer
        """
    def insert_special_layer_at(self, index: int, props: LayerInfo) -> None:
        r"""
        @brief Inserts a new special layer with the given properties at the given index

        See \insert_special_layer for a description of special layers.
        """
    def is_editable(self) -> bool:
        r"""
        @brief Returns a value indicating whether the layout is editable.
        @return True, if the layout is editable.
        If a layout is editable, in general manipulation methods are enabled and some optimizations are disabled (i.e. shape arrays are expanded).

        This method has been introduced in version 0.22.
        """
    def is_free_layer(self, layer_index: int) -> bool:
        r"""
        @brief Returns true, if a layer index is a free (unused) layer index

        @return true, if this is the case

        This method has been introduced in version 0.26.
        """
    def is_special_layer(self, layer_index: int) -> bool:
        r"""
        @brief Returns true, if a layer index is a special layer index

        @return true, if this is the case
        """
    def is_valid_cell_index(self, cell_index: int) -> bool:
        r"""
        @brief Returns true, if a cell index is a valid index

        @return true, if this is the case
        This method has been added in version 0.20.
        """
    def is_valid_layer(self, layer_index: int) -> bool:
        r"""
        @brief Returns true, if a layer index is a valid normal layout layer index

        @return true, if this is the case
        """
    @overload
    def layer(self) -> int:
        r"""
        @brief Creates a new internal layer

        This method will create a new internal layer and return the layer index for this layer.
        The layer does not have any properties attached to it. That means, it is not going to be saved to a layout file unless it is given database properties with \set_info.

        This method is equivalent to "layer(RBA::LayerInfo::new())".

        This method has been introduced in version 0.25.
        """
    @overload
    def layer(self, info: LayerInfo) -> int:
        r"""
        @brief Finds or creates a layer with the given properties

        If a layer with the given properties already exists, this method will return the index of that layer.If no such layer exists, a new one with these properties will be created and its index will be returned. If "info" is anonymous (info.anonymous? is true), a new layer will always be created.

        This method has been introduced in version 0.23.
        """
    @overload
    def layer(self, name: str) -> int:
        r"""
        @brief Finds or creates a layer with the given name

        If a layer with the given name already exists, this method will return the index of that layer.If no such layer exists, a new one with this name will be created and its index will be returned.

        This method has been introduced in version 0.23.
        """
    @overload
    def layer(self, layer: int, datatype: int) -> int:
        r"""
        @brief Finds or creates a layer with the given layer and datatype number

        If a layer with the given layer/datatype already exists, this method will return the index of that layer.If no such layer exists, a new one with these properties will be created and its index will be returned.

        This method has been introduced in version 0.23.
        """
    @overload
    def layer(self, layer: int, datatype: int, name: str) -> int:
        r"""
        @brief Finds or creates a layer with the given layer and datatype number and name

        If a layer with the given layer/datatype/name already exists, this method will return the index of that layer.If no such layer exists, a new one with these properties will be created and its index will be returned.

        This method has been introduced in version 0.23.
        """
    def layer_indexes(self) -> List[int]:
        r"""
        @brief Gets a list of valid layer's indices
        This method returns an array with layer indices representing valid layers.

        This method has been introduced in version 0.19.
        """
    def layer_infos(self) -> List[LayerInfo]:
        r"""
        @brief Gets a list of valid layer's properties
        The method returns an array with layer properties representing valid layers.
        The sequence and length of this list corresponds to that of \layer_indexes.

        This method has been introduced in version 0.25.
        """
    def layers(self) -> int:
        r"""
        @brief Returns the number of layers
        The number of layers reports the maximum (plus 1) layer index used so far. Not all of the layers with an index in the range of 0 to layers-1 needs to be a valid layer. These layers can be either valid, special or unused. Use \is_valid_layer? and \is_special_layer? to test for the first two states.
        """
    def library(self) -> Library:
        r"""
        @brief Gets the library this layout lives in or nil if the layout is not part of a library
        This attribute has been introduced in version 0.27.5.
        """
    def meta_info_value(self, name: str) -> str:
        r"""
        @brief Gets the meta information value for a given name
        See \LayoutMetaInfo for details about layouts and meta information.

        If no meta information with the given name exists, an empty string will be returned.

        This method has been introduced in version 0.25.
        """
    def move_layer(self, src: int, dest: int) -> None:
        r"""
        @brief Moves a layer

        This method was introduced in version 0.19.

        Move a layer from the source to the target. The target is not cleared before, so that this method 
        merges shapes from the source with the target layer. The source layer is empty after that operation.

        @param src The layer index of the source layer.
        @param dest The layer index of the destination layer.
        """
    @overload
    def move_tree_shapes(self, source_layout: Layout, cell_mapping: CellMapping) -> None:
        r"""
        @brief Moves the shapes for all given mappings in the \CellMapping object

        This method acts like the corresponding \copy_tree_shapes method, but removes the shapes from the source layout after they have been copied.

        This method has been added in version 0.26.8.
        """
    @overload
    def move_tree_shapes(self, source_layout: Layout, cell_mapping: CellMapping, layer_mapping: LayerMapping) -> None:
        r"""
        @brief Moves the shapes for all given mappings in the \CellMapping object using the given layer mapping

        This method acts like the corresponding \copy_tree_shapes method, but removes the shapes from the source layout after they have been copied.

        This method has been added in version 0.26.8.
        """
    def multi_clip(self, cell: int, boxes: Sequence[Box]) -> List[int]:
        r"""
        @brief Clips the given cell by the given rectangles and produce new cells with the clips, one for each rectangle.
        @param cell The cell index of the cell to clip
        @param boxes The clip boxes in database units
        @return The indexes of the new cells

        This method will cut rectangular regions given by the boxes from the given cell. The clips will be stored in a new cells whose indexed are returned. The clips will be performed hierarchically. The resulting cells will hold a hierarchy of child cells, which are potentially clipped versions of child cells of the original cell. This version is somewhat more efficient than doing individual clips because the clip cells may share clipped versions of child cells.

        This method has been added in version 0.21.
        """
    def multi_clip_into(self, cell: int, target: Layout, boxes: Sequence[Box]) -> List[int]:
        r"""
        @brief Clips the given cell by the given rectangles and produce new cells with the clips, one for each rectangle.
        @param cell The cell index of the cell to clip
        @param boxes The clip boxes in database units
        @param target The target layout
        @return The indexes of the new cells

        This method will cut rectangular regions given by the boxes from the given cell. The clips will be stored in a new cells in the given target layout. The clips will be performed hierarchically. The resulting cells will hold a hierarchy of child cells, which are potentially clipped versions of child cells of the original cell. This version is somewhat more efficient than doing individual clips because the clip cells may share clipped versions of child cells.

        Please note that it is important that the database unit of the target layout is identical to the database unit of the source layout to achieve the desired results. This method also assumes that the target layout holds the same layers than the source layout. It will copy shapes to the same layers than they have been on the original layout.

        This method has been added in version 0.21.
        """
    @overload
    def pcell_declaration(self, name: str) -> PCellDeclaration_Native:
        r"""
        @brief Gets a reference to the PCell declaration for the PCell with the given name
        Returns a reference to the local PCell declaration with the given name. If the name
        is not a valid PCell name, this method returns nil.

        Usually this method is used on library layouts that define
        PCells. Note that this method cannot be used on the layouts using the PCell from 
        a library.

        This method has been introduced in version 0.22.
        """
    @overload
    def pcell_declaration(self, pcell_id: int) -> PCellDeclaration_Native:
        r"""
        @brief Gets a reference to the PCell declaration for the PCell with the given PCell ID.
        Returns a reference to the local PCell declaration with the given PCell id. If the parameter
        is not a valid PCell ID, this method returns nil. The PCell ID is the number returned 
        by \register_pcell for example.

        Usually this method is used on library layouts that define
        PCells. Note that this method cannot be used on the layouts using the PCell from 
        a library.

        This method has been introduced in version 0.22.
        """
    def pcell_id(self, name: str) -> int:
        r"""
        @brief Gets the ID of the PCell with the given name
        This method is equivalent to 'pcell_declaration(name).id'.

        This method has been introduced in version 0.22.
        """
    def pcell_ids(self) -> List[int]:
        r"""
        @brief Gets the IDs of the PCells registered in the layout
        Returns an array of PCell IDs.

        This method has been introduced in version 0.24.
        """
    def pcell_names(self) -> List[str]:
        r"""
        @brief Gets the names of the PCells registered in the layout
        Returns an array of PCell names.

        This method has been introduced in version 0.24.
        """
    def properties(self, properties_id: int) -> List[Any]:
        r"""
        @brief Gets the properties set for a given properties ID

        Basically performs the backward conversion of the 'properties_id' method. Given a properties ID, returns the properties set as an array of pairs of variants. In this array, each key and the value are stored as pairs (arrays with two elements).
        If the properties ID is not valid, an empty array is returned.

        @param properties_id The properties ID to get the properties for
        @return The array of variants (see \properties_id)
        """
    def properties_id(self, properties: Sequence[Any]) -> int:
        r"""
        @brief Gets the properties ID for a given properties set

        Before a set of properties can be attached to a shape, it must be converted into an ID that is unique for that set. The properties set must be given as a list of pairs of variants, each pair describing a name and a value. The name acts as the key for the property and does not need to be a string (it can be an integer or double value as well).
        The backward conversion can be performed with the 'properties' method.

        @param properties The array of pairs of variants (both elements can be integer, double or string)
        @return The unique properties ID for that set
        """
    def property(self, key: Any) -> Any:
        r"""
        @brief Gets the user property with the given key
        This method is a convenience method that gets the property with the given key. If no property with that key exists, it will return nil. Using that method is more convenient than using the properties ID to retrieve the property value. 
        This method has been introduced in version 0.24.
        """
    def prune_cell(self, cell_index: int, levels: int) -> None:
        r"""
        @brief Deletes a cell plus subcells not used otherwise

        This deletes a cell and also all sub cells of the cell which are not used otherwise.
        The number of hierarchy levels to consider can be specified as well. One level of hierarchy means that only the direct children of the cell are deleted with the cell itself.
        All instances of this cell are deleted as well.

        @param cell_index The index of the cell to delete
        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.20.
        """
    def prune_subcells(self, cell_index: int, levels: int) -> None:
        r"""
        @brief Deletes all sub cells of the cell which are not used otherwise down to the specified level of hierarchy

        This deletes all sub cells of the cell which are not used otherwise.
        All instances of the deleted cells are deleted as well.
        It is possible to specify how many levels of hierarchy below the given root cell are considered.

        @param cell_index The root cell from which to delete a sub cells
        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.20.
        """
    @overload
    def read(self, filename: str) -> LayerMap:
        r"""
        @brief Load the layout from the given file
        The format of the file is determined automatically and automatic unzipping is provided. No particular options can be specified.
        @param filename The name of the file to load.
        @return A layer map that contains the mapping used by the reader including the layers that have been created.
        This method has been added in version 0.18.
        """
    @overload
    def read(self, filename: str, options: LoadLayoutOptions) -> LayerMap:
        r"""
        @brief Load the layout from the given file with options
        The format of the file is determined automatically and automatic unzipping is provided. In this version, some reader options can be specified. @param filename The name of the file to load.
        @param options The options object specifying further options for the reader.
        @return A layer map that contains the mapping used by the reader including the layers that have been created.
        This method has been added in version 0.18.
        """
    def refresh(self) -> None:
        r"""
        @brief Calls \Cell#refresh on all cells inside this layout
        This method is useful to recompute all PCells from a layout. Note that this does not update PCells which are linked from a library. To recompute PCells from a library, you need to use \Library#refresh on the library object from which the PCells are imported.

        This method has been introduced in version 0.27.9.
        """
    def register_pcell(self, name: str, declaration: PCellDeclaration_Native) -> int:
        r"""
        @brief Registers a PCell declaration under the given name
        Registers a local PCell in the current layout. If a declaration with that name
        already exists, it is replaced with the new declaration.

        This method has been introduced in version 0.22.
        """
    def remove_meta_info(self, name: str) -> None:
        r"""
        @brief Removes meta information from the layout
        See \LayoutMetaInfo for details about layouts and meta information.
        This method has been introduced in version 0.25.
        """
    def rename_cell(self, index: int, name: str) -> None:
        r"""
        @brief name
        """
    @overload
    def scale_and_snap(self, cell: Cell, grid: int, mult: int, div: int) -> None:
        r"""
        @brief Scales and snaps the layout below a given cell by the given rational factor and snaps to the given grid

        This method is useful to scale a layout by a non-integer factor. The scale factor is given by the rational number mult / div. After scaling, the layout will be snapped to the given grid.

        Snapping happens 'as-if-flat' - that is, touching edges will stay touching, regardless of their hierarchy path. To achieve this, this method usually needs to produce cell variants.

        This method has been introduced in version 0.26.1.
        """
    @overload
    def scale_and_snap(self, cell_index: int, grid: int, mult: int, div: int) -> None:
        r"""
        @brief Scales and snaps the layout below a given cell by the given rational factor and snaps to the given grid

        Like the other version of \scale_and_snap, but taking a cell index for the argument.

        This method has been introduced in version 0.26.1.
        """
    def set_info(self, index: int, props: LayerInfo) -> None:
        r"""
        @brief Sets the info structure for a specified layer
        """
    def set_property(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the user property with the given key to the given value
        This method is a convenience method that sets the property with the given key to the given value. If no property with that key exists, it will create one. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Note: GDS only supports integer keys. OASIS supports numeric and string keys. 
        This method has been introduced in version 0.24.
        """
    def start_changes(self) -> None:
        r"""
        @brief Signals the start of an operation bringing the layout into invalid state

        This method should be called whenever the layout is
        about to be brought into an invalid state. After calling
        this method, \under_construction? returns true which 
        tells foreign code (i.e. the asynchronous painter or the cell tree view)
        not to use this layout object.

        This state is cancelled by the \end_changes method.
        The start_changes method can be called multiple times
        and must be cancelled the same number of times.

        This method can be used to speed up certain operations. For example iterating over the layout with a \RecursiveShapeIterator while modifying other layers of the layout can be very inefficient, because inside the loop the layout's state is invalidate and updated frequently.
        Putting a update and start_changes sequence before the loop (use both methods in that order!) and a end_changes call after the loop can improve the performance dramatically.

        In addition, it can be necessary to prevent redraw operations in certain cases by using start_changes .. end_changes, in particular when it is possible to put a layout object into an invalid state temporarily.

        While the layout is under construction \update can be called to update the internal state explicitly if required.
        This for example might be necessary to update the cell bounding boxes or to redo the sorting for region queries.
        """
    def swap_layers(self, a: int, b: int) -> None:
        r"""
        @brief Swap two layers

        Swaps the shapes of both layers.

        This method was introduced in version 0.19.

        @param a The first of the layers to swap.
        @param b The second of the layers to swap.
        """
    def technology(self) -> Technology:
        r"""
        @brief Gets the \Technology object of the technology this layout is associated with or nil if the layout is not associated with a technology
        This method has been introduced in version 0.27. Before that, the technology has been kept in the 'technology' meta data element.
        """
    def top_cell(self) -> Cell:
        r"""
        @brief Returns the top cell object
        @return The \Cell object of the top cell
        If the layout has a single top cell, this method returns the top cell's \Cell object.
        If the layout does not have a top cell, this method returns "nil". If the layout has multiple
        top cells, this method raises an error.

        This method has been introduced in version 0.23.
        """
    def top_cells(self) -> List[Cell]:
        r"""
        @brief Returns the top cell objects
        @return The \Cell objects of the top cells
        This method returns and array of \Cell objects representing the top cells of the layout.
        This array can be empty, if the layout does not have a top cell (i.e. no cell at all).

        This method has been introduced in version 0.23.
        """
    @overload
    def transform(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms the layout with the given complex integer transformation, which is in micrometer units
        This variant will internally translate the transformation's displacement into database units. Apart from that, it behaves identical to the version with a \ICplxTrans argument.

        This method has been introduced in version 0.23.
        """
    @overload
    def transform(self, trans: DTrans) -> None:
        r"""
        @brief Transforms the layout with the given transformation, which is in micrometer units
        This variant will internally translate the transformation's displacement into database units. Apart from that, it behaves identical to the version with a \Trans argument.

        This variant has been introduced in version 0.25.
        """
    @overload
    def transform(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms the layout with the given complex integer transformation

        This method has been introduced in version 0.23.
        """
    @overload
    def transform(self, trans: Trans) -> None:
        r"""
        @brief Transforms the layout with the given transformation

        This method has been introduced in version 0.23.
        """
    def under_construction(self) -> bool:
        r"""
        @brief Returns true if the layout object is under construction

        A layout object is either under construction if a transaction
        is ongoing or the layout is brought into invalid state by
        "start_changes".
        """
    def update(self) -> None:
        r"""
        @brief Updates the internals of the layout
        This method updates the internal state of the layout. Usually this is done automatically
        This method is provided to ensure this explicitly. This can be useful while using \start_changes and \end_changes to wrap a performance-critical operation. See \start_changes for more details.
        """
    @overload
    def write(self, filename: str) -> None:
        r"""
        @brief Writes the layout to a stream file
        @param filename The file to which to write the layout
        """
    @overload
    def write(self, filename: str, options: SaveLayoutOptions) -> None:
        r"""
        @brief Writes the layout to a stream file
        @param filename The file to which to write the layout
        @param options The option set to use for writing. See \SaveLayoutOptions for details

        This version automatically determines the compression mode from the file name. The file is written with zlib compression if the suffix is ".gz" or ".gzip".

        This variant has been introduced in version 0.23.
        """

class SaveLayoutOptions:
    r"""
    @brief Options for saving layouts

    This class describes the various options for saving a layout to a stream file (GDS2, OASIS and others).
    There are: layers to be saved, cell or cells to be saved, scale factor, format, database unit
    and format specific options.

    Usually the default constructor provides a suitable object. Please note, that the format written is "GDS2" by default. Either explicitly set a format using \format= or derive the format from the file name using \set_format_from_filename.

    The layers are specified by either selecting all layers or by defining layer by layer using the
    \add_layer method. \select_all_layers will explicitly select all layers for saving, \deselect_all_layers will explicitly clear the list of layers.

    Cells are selected in a similar fashion: by default, all cells are selected. Using \add_cell, specific
    cells can be selected for saving. All these cells plus their hierarchy will then be written to the stream file.

    """
    cif_blank_separator: bool
    r"""
    @brief Gets a flag indicating whether blanks shall be used as x/y separator characters
    See \cif_blank_separator= method for a description of that property.
    This property has been added in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.
    @brief Sets a flag indicating whether blanks shall be used as x/y separator characters
    If this property is set to true, the x and y coordinates are separated with blank characters rather than comma characters.
    This property has been added in version 0.23.10.
    """
    cif_dummy_calls: bool
    r"""
    @brief Gets a flag indicating whether dummy calls shall be written
    See \cif_dummy_calls= method for a description of that property.
    This property has been added in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.
    @brief Sets a flag indicating whether dummy calls shall be written
    If this property is set to true, dummy calls will be written in the top level entity of the CIF file calling every top cell.
    This option is useful for enhanced compatibility with other tools.

    This property has been added in version 0.23.10.
    """
    dbu: float
    r"""
    @brief Get the explicit database unit if one is set

    See \dbu= for a description of that attribute.
    @brief Set the database unit to be used in the stream file

    By default, the database unit of the layout is used. This method allows one to explicitly use a different
    database unit. A scale factor is introduced automatically which scales all layout objects accordingly so their physical dimensions remain the same. When scaling to a larger database unit or one that is not an integer fraction of the original one, rounding errors may occur and the layout may become slightly distorted.
    """
    dxf_polygon_mode: int
    r"""
    @brief Specifies how to write polygons.
    See \dxf_polygon_mode= for a description of this property.

    This property has been added in version 0.21.3.
    @brief Specifies how to write polygons.
    The mode is 0 (write POLYLINE entities), 1 (write LWPOLYLINE entities), 2 (decompose into SOLID entities), 3 (write HATCH entities), or 4 (write LINE entities).

    This property has been added in version 0.21.3. '4', in version 0.25.6.
    """
    format: str
    r"""
    @brief Gets the format name

    See \format= for a description of that method.
    @brief Select a format
    The format string can be either "GDS2", "OASIS", "CIF" or "DXF". Other formats may be available if
    a suitable plugin is installed.
    """
    gds2_libname: str
    r"""
    @brief Get the library name
    See \gds2_libname= method for a description of the library name.
    This property has been added in version 0.18.
    @brief Set the library name

    The library name is the string written into the LIBNAME records of the GDS file.
    The library name should not be an empty string and is subject to certain limitations in the character choice.

    This property has been added in version 0.18.
    """
    gds2_max_cellname_length: int
    r"""
    @brief Get the maximum length of cell names
    See \gds2_max_cellname_length= method for a description of the maximum cell name length.
    This property has been added in version 0.18.
    @brief Maximum length of cell names

    This property describes the maximum number of characters for cell names. 
    Longer cell names will be shortened.

    This property has been added in version 0.18.
    """
    gds2_max_vertex_count: int
    r"""
    @brief Gets the maximum number of vertices for polygons to write
    See \gds2_max_vertex_count= method for a description of the maximum vertex count.
    This property has been added in version 0.18.
    @brief Sets the maximum number of vertices for polygons to write
    This property describes the maximum number of point for polygons in GDS2 files.
    Polygons with more points will be split.
    The minimum value for this property is 4. The maximum allowed value is about 4000 or 8000, depending on the
    GDS2 interpretation. If \gds2_multi_xy_records is true, this
    property is not used. Instead, the number of points is unlimited.

    This property has been added in version 0.18.
    """
    gds2_multi_xy_records: bool
    r"""
    @brief Gets the property enabling multiple XY records for BOUNDARY elements
    See \gds2_multi_xy_records= method for a description of this property.
    This property has been added in version 0.18.
    @brief Uses multiple XY records in BOUNDARY elements for unlimited large polygons

    Setting this property to true allows producing polygons with an unlimited number of points 
    at the cost of incompatible formats. Setting it to true disables the \gds2_max_vertex_count setting.

    This property has been added in version 0.18.
    """
    gds2_no_zero_length_paths: bool
    r"""
    @brief Gets a value indicating whether zero-length paths are eliminated

    This property has been added in version 0.23.
    @brief Eliminates zero-length paths if true

    If this property is set to true, paths with zero length will be converted to BOUNDARY objects.


    This property has been added in version 0.23.
    """
    gds2_resolve_skew_arrays: bool
    r"""
    @brief Gets a value indicating whether to resolve skew arrays into single instances
    See \gds2_resolve_skew_arrays= method for a description of this property.
    This property has been added in version 0.27.1.
    @brief Resolves skew arrays into single instances

    Setting this property to true will make skew (non-orthogonal) arrays being resolved into single instances.
    Skew arrays happen if either the row or column vector isn't parallel to x or y axis. Such arrays can cause problems with some legacy software and can be disabled with this option.

    This property has been added in version 0.27.1.
    """
    gds2_user_units: float
    r"""
    @brief Get the user units
    See \gds2_user_units= method for a description of the user units.
    This property has been added in version 0.18.
    @brief Set the users units to write into the GDS file

    The user units of a GDS file are rarely used and usually are set to 1 (micron).
    The intention of the user units is to specify the display units. KLayout ignores the user unit and uses microns as the display unit.
    The user unit must be larger than zero.

    This property has been added in version 0.18.
    """
    gds2_write_cell_properties: bool
    r"""
    @brief Gets a value indicating whether cell properties are written

    This property has been added in version 0.23.
    @brief Enables writing of cell properties if set to true

    If this property is set to true, cell properties will be written as PROPATTR/PROPVALUE records immediately following the BGNSTR records. This is a non-standard extension and is therefore disabled by default.


    This property has been added in version 0.23.
    """
    gds2_write_file_properties: bool
    r"""
    @brief Gets a value indicating whether layout properties are written

    This property has been added in version 0.24.
    @brief Enables writing of file properties if set to true

    If this property is set to true, layout properties will be written as PROPATTR/PROPVALUE records immediately following the BGNLIB records. This is a non-standard extension and is therefore disabled by default.


    This property has been added in version 0.24.
    """
    gds2_write_timestamps: bool
    r"""
    @brief Gets a value indicating whether the current time is written into the GDS2 timestamp fields

    This property has been added in version 0.21.16.
    @brief Writes the current time into the GDS2 timestamps if set to true

    If this property is set to false, the time fields will all be zero. This somewhat simplifies compare and diff applications.


    This property has been added in version 0.21.16.
    """
    keep_instances: bool
    r"""
    @brief Gets a flag indicating whether instances will be kept even if the target cell is dropped

    See \keep_instances= for details about this flag.

    This method was introduced in version 0.23.
    @brief Enables or disables instances for dropped cells

    If this flag is set to true, instances for cells will be written, even if the cell is dropped. That may happen, if cells are selected with \select_this_cell or \add_this_cell or \no_empty_cells is used. Even if cells called by such cells are not selected, instances will be written for that cell if "keep_instances" is true. That feature is supported by the GDS format currently and results in "ghost cells" which have instances but no cell definition.

    The default value is false (instances of dropped cells are not written).

    This method was introduced in version 0.23.
    """
    mag_lambda: float
    r"""
    @brief Gets the lambda value
    See \mag_lambda= method for a description of this attribute.
    This property has been added in version 0.26.2.
    @brief Specifies the lambda value to used for writing

    The lambda value is the basic unit of the layout.
    The layout is brought to units of this value. If the layout is not on-grid on this unit, snapping will happen. If the value is less or equal to zero, KLayout will use the lambda value stored inside the layout set by a previous read operation of a MAGIC file. The lambda value is stored in the Layout object as the "lambda" metadata attribute.

    This property has been added in version 0.26.2.
    """
    mag_tech: str
    r"""
    @brief Gets the technology string used for writing
    See \mag_tech= method for a description of this attribute.
    This property has been added in version 0.26.2.
    @brief Specifies the technology string used for writing

    If this string is empty, the writer will try to obtain the technology from the "technology" metadata attribute of the layout.

    This property has been added in version 0.26.2.
    """
    mag_write_timestamp: bool
    r"""
    @brief Gets a value indicating whether to write a timestamp
    See \write_timestamp= method for a description of this attribute.

    This property has been added in version 0.26.2.
    @brief Specifies whether to write a timestamp

    If this attribute is set to false, the timestamp written is 0. This is not permitted in the strict sense, but simplifies comparison of Magic files.

    This property has been added in version 0.26.2.
    """
    no_empty_cells: bool
    r"""
    @brief Returns a flag indicating whether empty cells are not written.
    @brief Don't write empty cells if this flag is set

    By default, all cells are written (no_empty_cells is false).
    This applies to empty cells which do not contain shapes for the specified layers as well as cells which are empty because they reference empty cells only.
    """
    oasis_compression_level: int
    r"""
    @brief Get the OASIS compression level
    See \oasis_compression_level= method for a description of the OASIS compression level.@brief Set the OASIS compression level
    The OASIS compression level is an integer number between 0 and 10. 0 basically is no compression, 1 produces shape arrays in a simple fashion. 2 and higher compression levels will use a more elaborate algorithm to find shape arrays which uses 2nd and further neighbor distances. The higher the level, the higher the memory requirements and run times.
    """
    oasis_permissive: bool
    r"""
    @brief Gets the OASIS permissive mode
    See \oasis_permissive= method for a description of this predicate.
    This method has been introduced in version 0.25.1.@brief Sets OASIS permissive mode
    If this flag is true, certain shapes which cannot be written to OASIS are reported as warnings, not as errors. For example, paths with odd width (are rounded) or polygons with less than three points (are skipped).

    This method has been introduced in version 0.25.1.
    """
    oasis_recompress: bool
    r"""
    @brief Gets the OASIS recompression mode
    See \oasis_recompress= method for a description of this predicate.
    This method has been introduced in version 0.23.@brief Sets OASIS recompression mode
    If this flag is true, shape arrays already existing will be resolved and compression is applied to the individual shapes again. If this flag is false (the default), shape arrays already existing will be written as such.

    This method has been introduced in version 0.23.
    """
    oasis_strict_mode: bool
    r"""
    @brief Gets a value indicating whether to write strict-mode OASIS files
    @brief Sets a value indicating whether to write strict-mode OASIS files
    Setting this property clears all format specific options for other formats such as GDS.
    """
    oasis_substitution_char: str
    r"""
    @brief Gets the substitution character

    See \oasis_substitution_char for details. This attribute has been introduced in version 0.23.
    @brief Sets the substitution character for a-strings and n-strings
    The substitution character is used in place of invalid characters. The value of this attribute is a string which is either empty or a single character. If the string is empty, no substitution is made at the risk of producing invalid OASIS files.

    This attribute has been introduce in version 0.23.
    """
    oasis_write_cblocks: bool
    r"""
    @brief Gets a value indicating whether to write compressed CBLOCKS per cell
    @brief Sets a value indicating whether to write compressed CBLOCKS per cell
    Setting this property clears all format specific options for other formats such as GDS.
    """
    oasis_write_cell_bounding_boxes: bool
    r"""
    @brief Gets a value indicating whether cell bounding boxes are written
    See \oasis_write_cell_bounding_boxes= method for a description of this flag.
    This method has been introduced in version 0.24.3.@brief Sets a value indicating whether cell bounding boxes are written
    If this value is set to true, cell bounding boxes are written (S_BOUNDING_BOX). The S_BOUNDING_BOX properties will be attached to the CELLNAME records.

    Setting this value to true will also enable writing of other standard properties like S_TOP_CELL (see \oasis_write_std_properties=).
    By default, cell bounding boxes are not written, but standard properties are.

    This method has been introduced in version 0.24.3.
    """
    oasis_write_std_properties: bool
    r"""
    @brief Gets a value indicating whether standard properties will be written
    See \oasis_write_std_properties= method for a description of this flag.
    This method has been introduced in version 0.24.@brief Sets a value indicating whether standard properties will be written
    If this value is false, no standard properties are written. If true, S_TOP_CELL and some other global standard properties are written. In addition, \oasis_write_cell_bounding_boxes= can be used to write cell bounding boxes using S_BOUNDING_BOX.

    By default, this flag is true and standard properties are written.

    Setting this property to false clears the oasis_write_cell_bounding_boxes flag too.

    This method has been introduced in version 0.24.
    """
    oasis_write_std_properties_ext: int
    r"""
    @hide@hide
    """
    scale_factor: float
    r"""
    @brief Gets the scaling factor currently set
    @brief Set the scaling factor for the saving 

    Using a scaling factor will scale all objects accordingly. This scale factor adds to a potential scaling implied by using an explicit database unit.

    Be aware that rounding effects may occur if fractional scaling factors are used.

    By default, no scaling is applied.
    """
    write_context_info: bool
    r"""
    @brief Gets a flag indicating whether context information will be stored

    See \write_context_info= for details about this flag.

    This method was introduced in version 0.23.
    @brief Enables or disables context information

    If this flag is set to false, no context information for PCell or library cell instances is written. Those cells will be converted to plain cells and KLayout will not be able to restore the identity of those cells. Use this option to enforce compatibility with other tools that don't understand the context information of KLayout.

    The default value is true (context information is stored). Not all formats support context information, hence that flag has no effect for formats like CIF or DXF.

    This method was introduced in version 0.23.
    """
    def __copy__(self) -> SaveLayoutOptions:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This will initialize the scale factor to 1.0, the database unit is set to
        "same as original" and all layers are selected as well as all cells.
        The default format is GDS2.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_cell(self, cell_index: int) -> None:
        r"""
        @brief Add a cell (plus hierarchy) to be saved


        The index of the cell must be a valid index in the context of the layout that will be saved.
        This method clears the 'select all cells' flag.

        This method also implicitly adds the children of that cell. A method that does not add the children in \add_this_cell.
        """
    def add_layer(self, layer_index: int, properties: LayerInfo) -> None:
        r"""
        @brief Add a layer to be saved 


        Adds the layer with the given index to the layer list that will be written.
        If all layers have been selected previously, all layers will 
        be unselected first and only the new layer remains.

        The 'properties' argument can be used to assign different layer properties than the ones
        present in the layout. Pass a default \LayerInfo object to this argument to use the
        properties from the layout object. Construct a valid \LayerInfo object with explicit layer,
        datatype and possibly a name to override the properties stored in the layout.
        """
    def add_this_cell(self, cell_index: int) -> None:
        r"""
        @brief Adds a cell to be saved


        The index of the cell must be a valid index in the context of the layout that will be saved.
        This method clears the 'select all cells' flag.
        Unlike \add_cell, this method does not implicitly add all children of that cell.

        This method has been added in version 0.23.
        """
    def assign(self, other: SaveLayoutOptions) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear_cells(self) -> None:
        r"""
        @brief Clears all cells to be saved

        This method can be used to ensure that no cell is selected before \add_cell is called to specify a cell.
        This method clears the 'select all cells' flag.

        This method has been added in version 0.22.
        """
    def deselect_all_layers(self) -> None:
        r"""
        @brief Unselect all layers: no layer will be saved

        This method will clear all layers selected with \add_layer so far and clear the 'select all layers' flag.
        Using this method is the only way to save a layout without any layers.
        """
    def dup(self) -> SaveLayoutOptions:
        r"""
        @brief Creates a copy of self
        """
    def select_all_cells(self) -> None:
        r"""
        @brief Select all cells to save

        This method will clear all cells specified with \add_cells so far and set the 'select all cells' flag.
        This is the default.
        """
    def select_all_layers(self) -> None:
        r"""
        @brief Select all layers to be saved

        This method will clear all layers selected with \add_layer so far and set the 'select all layers' flag.
        This is the default.
        """
    def select_cell(self, cell_index: int) -> None:
        r"""
        @brief Selects a cell to be saved (plus hierarchy below)


        This method is basically a convenience method that combines \clear_cells and \add_cell.
        This method clears the 'select all cells' flag.

        This method has been added in version 0.22.
        """
    def select_this_cell(self, cell_index: int) -> None:
        r"""
        @brief Selects a cell to be saved


        This method is basically a convenience method that combines \clear_cells and \add_this_cell.
        This method clears the 'select all cells' flag.

        This method has been added in version 0.23.
        """
    def set_format_from_filename(self, filename: str) -> bool:
        r"""
        @brief Select a format from the given file name

        This method will set the format according to the file's extension.

        This method has been introduced in version 0.22. Beginning with version 0.23, this method always returns true, since the only consumer for the return value, Layout#write, now ignores that parameter and automatically determines the compression mode from the file name.
        """

class LayoutDiff:
    r"""
    @brief The layout compare tool

    The layout compare tool is a facility to quickly compare layouts and derive events that give details about the differences. The events are basically emitted following a certain order:

    @ul
    @li General configuration events (database units, layers ...) @/li
    @li \on_begin_cell @/li
    @li \on_begin_inst_differences (if the instances differ) @/li
    @li details about instance differences (if \Verbose flag is given) @/li
    @li \on_end_inst_differences (if the instances differ) @/li
    @li \on_begin_layer @/li
    @li \on_begin_polygon_differences (if the polygons differ) @/li
    @li details about polygon differences (if \Verbose flag is given) @/li
    @li \on_end_polygon_differences (if the polygons differ) @/li
    @li other shape difference events (paths, boxes, ...) @/li
    @li \on_end_layer @/li
    @li repeated layer event groups @/li
    @li \on_end_cell @/li
    @li repeated cell event groups @/li
    @/ul

    To use the diff facility, create a \LayoutDiff object and call the \compare_layout or \compare_cell method:

    @code
    lya = ... # layout A
    lyb = ... # layout B

    diff = RBA::LayoutDiff::new
    diff.on_polygon_in_a_only do |poly|
      puts "Polygon in A: #{diff.cell_a.name}@#{diff.layer_info_a.to_s}: #{poly.to_s}"
    end
    diff.on_polygon_in_b_only do |poly|
      puts "Polygon in A: #{diff.cell_b.name}@#{diff.layer_info_b.to_s}: #{poly.to_s}"
    end
    diff.compare(lya, lyb, RBA::LayoutDiff::Verbose + RBA::LayoutDiff::NoLayerNames)
    @/code
    """
    BoxesAsPolygons: ClassVar[int]
    r"""
    @brief Compare boxes to polygons
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    DontSummarizeMissingLayers: ClassVar[int]
    r"""
    @brief Don't summarize missing layers
    If this mode is present, missing layers are treated as empty ones and every shape on the other layer will be reported as difference.

    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    FlattenArrayInsts: ClassVar[int]
    r"""
    @brief Compare array instances instance by instance
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    NoLayerNames: ClassVar[int]
    r"""
    @brief Do not compare layer names
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    NoProperties: ClassVar[int]
    r"""
    @brief Ignore properties
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    NoTextDetails: ClassVar[int]
    r"""
    @brief Ignore text details (font, size, presentation)
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    NoTextOrientation: ClassVar[int]
    r"""
    @brief Ignore text orientation
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    PathsAsPolygons: ClassVar[int]
    r"""
    @brief Compare paths to polygons
    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    Silent: ClassVar[int]
    r"""
    @brief Silent compare - just report whether the layouts are identical
    Silent mode will not issue any signals, but instead the return value of the \LayoutDiff#compare method will indicate whether the layouts are identical. In silent mode, the compare method will return immediately once a difference has been encountered so that mode may be much faster than the full compare.

    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    SmartCellMapping: ClassVar[int]
    r"""
    @brief Derive smart cell mapping instead of name mapping (available only if top cells are specified)
    Smart cell mapping is only effective currently when cells are compared (with \LayoutDiff#compare with cells instead of layout objects).

    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    Verbose: ClassVar[int]
    r"""
    @brief Enables verbose mode (gives details about the differences)

    See the event descriptions for details about the differences in verbose and non-verbose mode.

    This constant can be used for the flags parameter of \compare_layouts and \compare_cells. It can be compared with other constants to form a flag set.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def cell_a(self) -> Cell:
        r"""
        @brief Gets the current cell for the first layout
        This attribute is the current cell and is set after \on_begin_cell and reset after \on_end_cell.
        """
    def cell_b(self) -> Cell:
        r"""
        @brief Gets the current cell for the second layout
        This attribute is the current cell and is set after \on_begin_cell and reset after \on_end_cell.
        """
    @overload
    def compare(self, a: Cell, b: Cell, flags: Optional[int] = ..., tolerance: Optional[int] = ...) -> bool:
        r"""
        @brief Compares two cells

        Compares layer definitions, cells, instances and shapes and properties of two layout hierarchies starting from the given cells.
        Cells are identified by name. Only layers with valid layer and datatype are compared.
        Several flags can be specified as a bitwise or combination of the constants.

        @param a The first top cell
        @param b The second top cell
        @param flags Flags to use for the comparison
        @param tolerance A coordinate tolerance to apply (0: exact match, 1: one DBU tolerance is allowed ...)

        @return True, if the cells are identical
        """
    @overload
    def compare(self, a: Layout, b: Layout, flags: Optional[int] = ..., tolerance: Optional[int] = ...) -> bool:
        r"""
        @brief Compares two layouts

        Compares layer definitions, cells, instances and shapes and properties.
        Cells are identified by name. Only layers with valid layer and datatype are compared.
        Several flags can be specified as a bitwise or combination of the constants.

        @param a The first input layout
        @param b The second input layout
        @param flags Flags to use for the comparison
        @param tolerance A coordinate tolerance to apply (0: exact match, 1: one DBU tolerance is allowed ...)

        @return True, if the layouts are identical
        """
    def layer_index_a(self) -> int:
        r"""
        @brief Gets the current layer for the first layout
        This attribute is the current cell and is set after \on_begin_layer and reset after \on_end_layer.
        """
    def layer_index_b(self) -> int:
        r"""
        @brief Gets the current layer for the second layout
        This attribute is the current cell and is set after \on_begin_layer and reset after \on_end_layer.
        """
    def layer_info_a(self) -> LayerInfo:
        r"""
        @brief Gets the current layer properties for the first layout
        This attribute is the current cell and is set after \on_begin_layer and reset after \on_end_layer.
        """
    def layer_info_b(self) -> LayerInfo:
        r"""
        @brief Gets the current layer properties for the second layout
        This attribute is the current cell and is set after \on_begin_layer and reset after \on_end_layer.
        """
    def layout_a(self) -> Layout:
        r"""
        @brief Gets the first layout the difference detector runs on
        """
    def layout_b(self) -> Layout:
        r"""
        @brief Gets the second layout the difference detector runs on
        """
    def on_bbox_differs(self, ba: Box, bb: Box) -> None:
        r"""
        @brief This signal indicates a difference in the bounding boxes of two cells
        This signal is only emitted in non-verbose mode (without \Verbose flag) as a summarizing cell property. In verbose mode detailed events will be issued indicating the differences.
        """
    def on_begin_box_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the boxes on the current layer
        The current layer is indicated by the \begin_layer_event signal or can be obtained from the diff object through \LayoutDiff#layer_info_a, \LayoutDiff#layer_index_a, \LayoutDiff#layer_info_b and \LayoutDiff#layer_index_b. In verbose mode (see \Verbose flag) more signals will be emitted for boxes that are different between the two layouts.
        """
    def on_begin_cell(self, ca: Cell, cb: Cell) -> None:
        r"""
        @brief This signal initiates the sequence of events for a cell pair
        All cell specific events happen between \begin_cell_event and \end_cell_event signals.
        """
    def on_begin_edge_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the edges on the current layer
        The current layer is indicated by the \begin_layer_event signal or can be obtained from the diff object through \LayoutDiff#layer_info_a, \LayoutDiff#layer_index_a, \LayoutDiff#layer_info_b and \LayoutDiff#layer_index_b. In verbose mode (see \Verbose flag) more signals will be emitted for edges that are different between the two layouts.
        """
    def on_begin_inst_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the cell instances
        In verbose mode (see \Verbose) more events will follow that indicate the instances that are present only in the first and second layout (\instance_in_a_only_event and \instance_in_b_only_event). 
        """
    def on_begin_layer(self, layer: LayerInfo, layer_index_a: int, layer_index_b: int) -> None:
        r"""
        @brief This signal indicates differences on the given layer
        In verbose mode (see \Verbose) more events will follow that indicate the instances that are present only in the first and second layout (\polygon_in_a_only_event, \polygon_in_b_only_event and similar). 
        """
    def on_begin_path_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the paths on the current layer
        The current layer is indicated by the \begin_layer_event signal or can be obtained from the diff object through \LayoutDiff#layer_info_a, \LayoutDiff#layer_index_a, \LayoutDiff#layer_info_b and \LayoutDiff#layer_index_b. In verbose mode (see \Verbose flag) more signals will be emitted for paths that are different between the two layouts.
        """
    def on_begin_polygon_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the polygons on the current layer
        The current layer is indicated by the \begin_layer_event signal or can be obtained from the diff object through \LayoutDiff#layer_info_a, \LayoutDiff#layer_index_a, \LayoutDiff#layer_info_b and \LayoutDiff#layer_index_b. In verbose mode (see \Verbose flag) more signals will be emitted for polygons that are different between the two layouts.
        """
    def on_begin_text_differences(self) -> None:
        r"""
        @brief This signal indicates differences in the texts on the current layer
        The current layer is indicated by the \begin_layer_event signal or can be obtained from the diff object through \LayoutDiff#layer_info_a, \LayoutDiff#layer_index_a, \LayoutDiff#layer_info_b and \LayoutDiff#layer_index_b. In verbose mode (see \Verbose flag) more signals will be emitted for texts that are different between the two layouts.
        """
    def on_box_in_a_only(self, anotb: Box, prop_id: int) -> None:
        r"""
        @brief This signal indicates a box that is present in the first layout only
        """
    def on_box_in_b_only(self, bnota: Box, prop_id: int) -> None:
        r"""
        @brief This signal indicates a box that is present in the second layout only
        """
    def on_cell_in_a_only(self, c: Cell) -> None:
        r"""
        @brief This signal indicates that the given cell is only present in the first layout
        """
    def on_cell_in_b_only(self, c: Cell) -> None:
        r"""
        @brief This signal indicates that the given cell is only present in the second layout
        """
    def on_cell_name_differs(self, ca: Cell, cb: Cell) -> None:
        r"""
        @brief This signal indicates a difference in the cell names
        This signal is emitted in 'smart cell mapping' mode (see \SmartCellMapping) if two cells are considered identical, but have different names.
        """
    def on_dbu_differs(self, dbu_a: float, dbu_b: float) -> None:
        r"""
        @brief This signal indicates a difference in the database units of the layouts
        """
    def on_edge_in_a_only(self, anotb: Edge, prop_id: int) -> None:
        r"""
        @brief This signal indicates an edge that is present in the first layout only
        """
    def on_edge_in_b_only(self, bnota: Edge, prop_id: int) -> None:
        r"""
        @brief This signal indicates an edge that is present in the second layout only
        """
    def on_end_box_differences(self) -> None:
        r"""
        @brief This signal indicates the end of sequence of box differences
        """
    def on_end_cell(self) -> None:
        r"""
        @brief This signal indicates the end of a sequence of signals for a specific cell
        """
    def on_end_edge_differences(self) -> None:
        r"""
        @brief This signal indicates the end of sequence of edge differences
        """
    def on_end_inst_differences(self) -> None:
        r"""
        @brief This signal finishes a sequence of detailed instance difference events
        """
    def on_end_layer(self) -> None:
        r"""
        @brief This signal indicates the end of a sequence of signals for a specific layer
        """
    def on_end_path_differences(self) -> None:
        r"""
        @brief This signal indicates the end of sequence of path differences
        """
    def on_end_polygon_differences(self) -> None:
        r"""
        @brief This signal indicates the end of sequence of polygon differences
        """
    def on_end_text_differences(self) -> None:
        r"""
        @brief This signal indicates the end of sequence of text differences
        """
    def on_instance_in_a_only(self, anotb: CellInstArray, prop_id: int) -> None:
        r"""
        @brief This signal indicates an instance that is present only in the first layout
        This event is only emitted in verbose mode (\Verbose flag).
        """
    def on_instance_in_b_only(self, bnota: CellInstArray, prop_id: int) -> None:
        r"""
        @brief This signal indicates an instance that is present only in the second layout
        This event is only emitted in verbose mode (\Verbose flag).
        """
    def on_layer_in_a_only(self, a: LayerInfo) -> None:
        r"""
        @brief This signal indicates a layer that is present only in the first layout
        """
    def on_layer_in_b_only(self, b: LayerInfo) -> None:
        r"""
        @brief This signal indicates a layer that is present only in the second layout
        """
    def on_layer_name_differs(self, a: LayerInfo, b: LayerInfo) -> None:
        r"""
        @brief This signal indicates a difference in the layer names
        """
    def on_path_in_a_only(self, anotb: Path, prop_id: int) -> None:
        r"""
        @brief This signal indicates a path that is present in the first layout only
        """
    def on_path_in_b_only(self, bnota: Path, prop_id: int) -> None:
        r"""
        @brief This signal indicates a path that is present in the second layout only
        """
    def on_per_layer_bbox_differs(self, ba: Box, bb: Box) -> None:
        r"""
        @brief This signal indicates differences in the per-layer bounding boxes of the current cell
        """
    def on_polygon_in_a_only(self, anotb: Polygon, prop_id: int) -> None:
        r"""
        @brief This signal indicates a polygon that is present in the first layout only
        """
    def on_polygon_in_b_only(self, bnota: Polygon, prop_id: int) -> None:
        r"""
        @brief This signal indicates a polygon that is present in the second layout only
        """
    def on_text_in_a_only(self, anotb: Text, prop_id: int) -> None:
        r"""
        @brief This signal indicates a text that is present in the first layout only
        """
    def on_text_in_b_only(self, bnota: Text, prop_id: int) -> None:
        r"""
        @brief This signal indicates a text that is present in the second layout only
        """

class LayoutQueryIterator:
    r"""
    @brief Provides the results of the query

    This object is used by \LayoutQuery#each to deliver the results of a query in an iterative fashion. See \LayoutQuery for a detailed description of the query interface.

    The LayoutQueryIterator class has been introduced in version 0.25.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def cell(self) -> Any:
        r"""
        @brief A shortcut for 'get("cell")'
        """
    def cell_index(self) -> Any:
        r"""
        @brief A shortcut for 'get("cell_index")'
        """
    def data(self) -> Any:
        r"""
        @brief A shortcut for 'get("data")'
        """
    def get(self, name: str) -> Any:
        r"""
        @brief Gets the query property with the given name
        The query properties available can be obtained from the query object using \LayoutQuery#property_names.
        Some shortcut methods are available. For example, the \data method provides a shortcut for 'get("data")'.

        If a property with the given name is not available, nil will be returned.
        """
    def initial_cell(self) -> Any:
        r"""
        @brief A shortcut for 'get("initial_cell")'
        """
    def initial_cell_index(self) -> Any:
        r"""
        @brief A shortcut for 'get("initial_cell_index")'
        """
    def inst(self) -> Any:
        r"""
        @brief A shortcut for 'get("inst")'
        """
    def layer_index(self) -> Any:
        r"""
        @brief A shortcut for 'get("layer_index")'
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets the layout the query acts on
        """
    def parent_cell(self) -> Any:
        r"""
        @brief A shortcut for 'get("parent_cell")'
        """
    def parent_cell_index(self) -> Any:
        r"""
        @brief A shortcut for 'get("parent_cell_index")'
        """
    def path_trans(self) -> Any:
        r"""
        @brief A shortcut for 'get("path_trans")'
        """
    def query(self) -> LayoutQuery:
        r"""
        @brief Gets the query the iterator follows on
        """
    def shape(self) -> Any:
        r"""
        @brief A shortcut for 'get("shape")'
        """
    def trans(self) -> Any:
        r"""
        @brief A shortcut for 'get("trans")'
        """

class LayoutQuery:
    r"""
    @brief A layout query
    Layout queries are the backbone of the "Search & replace" feature. Layout queries allow retrieval of data from layouts and manipulation of layouts. This object provides script binding for this feature.
    Layout queries are used by first creating a query object. Depending on the nature of the query, either \execute or \each can be used to execute the query. \execute will run the query and return once the query is finished. \execute is useful for running queries that don't return results such as "delete" or "with ... do" queries.
    \each can be used when the results of the query need to be retrieved.

    The \each method will call a block a of code for every result available. It will provide a \LayoutQueryIterator object that allows accessing the results of the query. Depending on the query, different attributes of the iterator object will be available. For example, "select" queries will fill the "data" attribute with an array of values corresponding to the columns of the selection.

    Here is some sample code:
    @code
    ly = RBA::CellView::active.layout
    q = RBA::LayoutQuery::new("select cell.name, cell.bbox from *")
    q.each(ly) do |iter|
      puts "cell name: #{iter.data[0]}, bounding box: #{iter.data[1]}"
    end
    @/code

    The LayoutQuery class has been introduced in version 0.25.
    """
    def __init__(self, query: str) -> None:
        r"""
        @brief Creates a new query object from the given query string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def each(self, layout: Layout, context: Optional[tl.ExpressionContext] = ...) -> Iterator[LayoutQueryIterator]:
        r"""
        @brief Executes the query and delivered the results iteratively.
        The argument to the block is a \LayoutQueryIterator object which can be asked for specific results.

        The context argument allows supplying an expression execution context. This context can be used for example to supply variables for the execution. It has been added in version 0.26.
        """
    def execute(self, layout: Layout, context: Optional[tl.ExpressionContext] = ...) -> None:
        r"""
        @brief Executes the query

        This method can be used to execute "active" queries such
        as "delete" or "with ... do".
        It is basically equivalent to iterating over the query until it is
        done.

        The context argument allows supplying an expression execution context. This context can be used for example to supply variables for the execution. It has been added in version 0.26.
        """
    def property_names(self) -> List[str]:
        r"""
        @brief Gets a list of property names available.
        The list of properties available from the query depends on the nature of the query. This method allows detection of the properties available. Within the query, all of these properties can be obtained from the query iterator using \LayoutQueryIterator#get.
        """

class LayoutToNetlist:
    r"""
    @brief A generic framework for extracting netlists from layouts

    This class wraps various concepts from db::NetlistExtractor and db::NetlistDeviceExtractor
    and more. It is supposed to provide a framework for extracting a netlist from a layout.

    The use model of this class consists of five steps which need to be executed in this order.

    @ul
    @li Configuration: in this step, the LayoutToNetlist object is created and
        if required, configured. Methods to be used in this step are \threads=,
        \area_ratio= or \max_vertex_count=. The constructor for the LayoutToNetlist
        object receives a \RecursiveShapeIterator object which basically supplies the
        hierarchy and the layout taken as input.
    @/li
    @li Preparation
        In this step, the device recognition and extraction layers are drawn from
        the framework. Derived can now be computed using boolean operations.
        Methods to use in this step are \make_layer and it's variants.
        Layer preparation is not necessarily required to happen before all
        other steps. Layers can be computed shortly before they are required.
    @/li
    @li Following the preparation, the devices can be extracted using \extract_devices.
        This method needs to be called for each device extractor required. Each time,
        a device extractor needs to be given plus a map of device layers. The device
        layers are device extractor specific. Either original or derived layers
        may be specified here. Layer preparation may happen between calls to \extract_devices.
    @/li
    @li Once the devices are derived, the netlist connectivity can be defined and the
        netlist extracted. The connectivity is defined with \connect and it's
        flavours. The actual netlist extraction happens with \extract_netlist.
    @/li
    @li After netlist extraction, the information is ready to be retrieved.
        The produced netlist is available with \netlist. The Shapes of a
        specific net are available with \shapes_of_net. \probe_net allows
        finding a net by probing a specific location.
    @/li
    @/ul

    You can also use the extractor with an existing \DeepShapeStore object or even flat data. In this case, preparation means importing existing regions with the \register method.
    If you want to use the \LayoutToNetlist object with flat data, use the 'LayoutToNetlist(topcell, dbu)' constructor. If you want to use it with hierarchical data and an existing DeepShapeStore object, use the 'LayoutToNetlist(dss)' constructor.

    This class has been introduced in version 0.26.
    """
    class BuildNetHierarchyMode:
        r"""
        @brief This class represents the LayoutToNetlist::BuildNetHierarchyMode enum
        This enum is used for \LayoutToNetlist#build_all_nets and \LayoutToNetlist#build_net.
        """
        BNH_Disconnected: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
        r"""
        @brief This constant tells \build_net and \build_all_nets to produce local nets without connections to subcircuits (used for the "hier_mode" parameter).
        """
        BNH_Flatten: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
        r"""
        @brief This constant tells \build_net and \build_all_nets to flatten the nets (used for the "hier_mode" parameter).
        """
        BNH_SubcircuitCells: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
        r"""
        @brief This constant tells \build_net and \build_all_nets to produce a hierarchy of subcircuit cells per net (used for the "hier_mode" parameter).
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: LayoutToNetlist.BuildNetHierarchyMode) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    BNH_Disconnected: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
    r"""
    @brief This constant tells \build_net and \build_all_nets to produce local nets without connections to subcircuits (used for the "hier_mode" parameter).
    """
    BNH_Flatten: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
    r"""
    @brief This constant tells \build_net and \build_all_nets to flatten the nets (used for the "hier_mode" parameter).
    """
    BNH_SubcircuitCells: ClassVar[LayoutToNetlist.BuildNetHierarchyMode]
    r"""
    @brief This constant tells \build_net and \build_all_nets to produce a hierarchy of subcircuit cells per net (used for the "hier_mode" parameter).
    """
    area_ratio: float
    r"""
    @brief Gets the area_ratio parameter for the hierarchical network processor
    See \area_ratio= for details about this attribute.@brief Sets the area_ratio parameter for the hierarchical network processor
    This parameter controls splitting of large polygons in order to reduce the
    error made by the bounding box approximation.
    """
    description: str
    r"""
    @brief Gets the description of the database
    @brief Sets the description of the database
    """
    device_scaling: float
    r"""
    @brief Gets the device scaling factor
    See \device_scaling= for details about this attribute.@brief Sets the device scaling factor
    This factor will scale the physical properties of the extracted devices
    accordingly. The scale factor applies an isotropic shrink (<1) or expansion (>1).
    """
    generator: str
    r"""
    @brief Gets the generator string.
    The generator is the script that created this database.
    @brief Sets the generator string.
    """
    include_floating_subcircuits: bool
    r"""
    @brief Gets a flag indicating whether to include floating subcircuits in the netlist.
    See \include_floating_subcircuits= for details.

    This attribute has been introduced in version 0.27.
    @brief Sets a flag indicating whether to include floating subcircuits in the netlist.

    With 'include_floating_subcircuits' set to true, subcircuits with no connection to their parent circuit are still included in the circuit as floating subcircuits. Specifically on flattening this means that these subcircuits are properly propagated to their parent instead of appearing as additional top circuits.

    This attribute has been introduced in version 0.27 and replaces the arguments of \extract_netlist.
    """
    max_vertex_count: int
    r"""
    See \max_vertex_count= for details about this attribute.@brief Sets the max_vertex_count parameter for the hierarchical network processor
    This parameter controls splitting of large polygons in order to enhance performance
    for very big polygons.
    """
    name: str
    r"""
    @brief Gets the name of the database
    @brief Sets the name of the database
    """
    original_file: str
    r"""
    @brief Gets the original file name of the database
    The original filename is the layout file from which the netlist DB was created.@brief Sets the original file name of the database
    """
    threads: int
    r"""
    @brief Gets the number of threads to use for operations which support multiple threads
    @brief Sets the number of threads to use for operations which support multiple threads
    """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a new and empty extractor object
        The main objective for this constructor is to create an object suitable for reading an annotated netlist.
        """
    @overload
    def __init__(self, dss: DeepShapeStore) -> None:
        r"""
        @brief Creates a new extractor object reusing an existing \DeepShapeStore object
        This constructor can be used if there is a DSS object already from which the shapes can be taken. This version can only be used with \register to add layers (regions) inside the 'dss' object.

        The make_... methods will not create new layers as there is no particular place defined where to create the layers.

        The extractor will not take ownership of the dss object unless you call \keep_dss.
        """
    @overload
    def __init__(self, iter: RecursiveShapeIterator) -> None:
        r"""
        @brief Creates a new extractor connected to an original layout
        This constructor will attach the extractor to an original layout through the shape iterator.
        """
    @overload
    def __init__(self, dss: DeepShapeStore, layout_index: int) -> None:
        r"""
        @brief Creates a new extractor object reusing an existing \DeepShapeStore object
        This constructor can be used if there is a DSS object already from which the shapes can be taken. NOTE: in this case, the make_... functions will create new layers inside this DSS. To register existing layers (regions) use \register.
        """
    @overload
    def __init__(self, topcell_name: str, dbu: float) -> None:
        r"""
        @brief Creates a new extractor object with a flat DSS
        @param topcell_name The name of the top cell of the internal flat layout
        @param dbu The database unit to use for the internal flat layout

        This constructor will create an extractor for flat extraction. Layers registered with \register will be flattened. New layers created with make_... will be flat layers.

        The database unit is mandatory because the physical parameter extraction for devices requires this unit for translation of layout to physical dimensions.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    @overload
    def antenna_check(self, gate: Region, metal: Region, ratio: float, diodes: Optional[Sequence[Any]] = ..., texts: Optional[Texts] = ...) -> Region:
        r"""
        @brief Runs an antenna check on the extracted clusters

        The antenna check will traverse all clusters and run an antenna check
        for all root clusters. The antenna ratio is defined by the total
        area of all "metal" shapes divided by the total area of all "gate" shapes
        on the cluster. Of all clusters where the antenna ratio is larger than
        the limit ratio all metal shapes are copied to the output region as
        error markers.

        The simple call is:

        @code
        l2n = ... # a LayoutToNetlist object
        l2n.extract_netlist
        # check for antenna ratio 10.0 of metal vs. poly:
        errors = l2n.antenna(poly, metal, 10.0)
        @/code

        You can include diodes which rectify the antenna effect. Provide recognition layers for theses diodes and include them in the connections. Then specify the diode layers in the antenna call:

        @code
        ...
        # include diode_layer1:
        errors = l2n.antenna(poly, metal, 10.0, [ diode_layer1 ])
        # include diode_layer1 and diode_layer2:errors = l2n.antenna(poly, metal, 10.0, [ diode_layer1, diode_layer2 ])
        @/code

        Diodes can be configured to partially reduce the antenna effect depending on their area. This will make the diode_layer1 increase the ratio by 50.0 per square micrometer area of the diode:

        @code
        ...
        # diode_layer1 increases the ratio by 50 per square micrometer area:
        errors = l2n.antenna(poly, metal, 10.0 [ [ diode_layer, 50.0 ] ])
        @/code

        If 'texts' is non-nil, this text collection will receive labels explaining the error in terms of area values and relevant ratio.

        The 'texts' parameter has been added in version 0.27.11.
        """
    @overload
    def antenna_check(self, gate: Region, gate_perimeter_factor: float, metal: Region, metal_perimeter_factor: float, ratio: float, diodes: Optional[Sequence[Any]] = ..., texts: Optional[Texts] = ...) -> Region:
        r"""
        @brief Runs an antenna check on the extracted clusters taking the perimeter into account

        This version of the \antenna_check method allows taking the perimeter of gate or metal into account. The effective area is computed using:

        @code
        Aeff = A + P * t
        @/code

        Here Aeff is the area used in the check, A is the polygon area, P the perimeter and t the perimeter factor. This formula applies to gate polygon area/perimeter with 'gate_perimeter_factor' for t and metal polygon area/perimeter with 'metal_perimeter_factor'. The perimeter_factor has the dimension of micrometers and can be thought of as the width of the material. Essentially the side walls of the material are taking into account for the surface area as well.

        This variant has been introduced in version 0.26.6.
        """
    @overload
    def antenna_check(self, gate: Region, gate_area_factor: float, gate_perimeter_factor: float, metal: Region, metal_area_factor: float, metal_perimeter_factor: float, ratio: float, diodes: Optional[Sequence[Any]] = ..., texts: Optional[Texts] = ...) -> Region:
        r"""
        @brief Runs an antenna check on the extracted clusters taking the perimeter into account and providing an area factor

        This (most generic) version of the \antenna_check method allows taking the perimeter of gate or metal into account and also provides a scaling factor for the area part.
        The effective area is computed using:

        @code
        Aeff = A * f + P * t
        @/code

        Here f is the area factor and t the perimeter factor. A is the polygon area and P the polygon perimeter. A use case for this variant is to set the area factor to zero. This way, only perimeter contributions are considered.

        This variant has been introduced in version 0.26.6.
        """
    def build_all_nets(self, cmap: CellMapping, target: Layout, lmap: Dict[int, Region], net_cell_name_prefix: Optional[Any] = ..., netname_prop: Optional[Any] = ..., hier_mode: Optional[LayoutToNetlist.BuildNetHierarchyMode] = ..., circuit_cell_name_prefix: Optional[Any] = ..., device_cell_name_prefix: Optional[Any] = ...) -> None:
        r"""
        @brief Builds a full hierarchical representation of the nets

        This method copies all nets into cells corresponding to the circuits. It uses the 'cmap'
        object to determine the target cell (create it with "cell_mapping_into" or "const_cell_mapping_into").
        If no mapping is provided for a specific circuit cell, the nets are copied into the next mapped parent as many times as the circuit cell appears there (circuit flattening).

        The method has three net annotation modes:
        @ul
         @li No annotation (net_cell_name_prefix == nil and netname_prop == nil): the shapes will be put
             into the target cell simply. @/li
         @li Net name property (net_cell_name_prefix == nil and netname_prop != nil): the shapes will be
             annotated with a property named with netname_prop and containing the net name string. @/li
         @li Individual subcells per net (net_cell_name_prefix != 0): for each net, a subcell is created
             and the net shapes will be put there (name of the subcell = net_cell_name_prefix + net name).
             (this mode can be combined with netname_prop too). @/li
        @/ul

        In addition, net hierarchy is covered in three ways:
        @ul
         @li No connection indicated (hier_mode == \BNH_Disconnected: the net shapes are simply put into their
             respective circuits. The connections are not indicated. @/li
         @li Subnet hierarchy (hier_mode == \BNH_SubcircuitCells): for each root net, a full hierarchy is built
             to accommodate the subnets (see build_net in recursive mode). @/li
         @li Flat (hier_mode == \BNH_Flatten): each net is flattened and put into the circuit it
             belongs to. @/li
        @/ul

        If a device cell name prefix is given, cells will be produced for each device abstract
        using a name like device_cell_name_prefix + device name. Otherwise the device shapes are
        treated as part of the net.

        @param cmap The mapping of internal layout to target layout for the circuit mapping
        @param target The target layout
        @param lmap Target layer indexes (keys) and net regions (values)
        @param hier_mode See description of this method
        @param netname_prop An (optional) property name to which to attach the net name
        @param circuit_cell_name_prefix See method description
        @param net_cell_name_prefix See method description
        @param device_cell_name_prefix See above
        """
    def build_net(self, net: Net, target: Layout, target_cell: Cell, lmap: Dict[int, Region], netname_prop: Optional[Any] = ..., hier_mode: Optional[LayoutToNetlist.BuildNetHierarchyMode] = ..., circuit_cell_name_prefix: Optional[Any] = ..., device_cell_name_prefix: Optional[Any] = ...) -> None:
        r"""
        @brief Builds a net representation in the given layout and cell

        This method puts the shapes of a net into the given target cell using a variety of options
        to represent the net name and the hierarchy of the net.

        If the netname_prop name is not nil, a property with the given name is created and assigned
        the net name.

        Net hierarchy is covered in three ways:
        @ul
         @li No connection indicated (hier_mode == \BNH_Disconnected: the net shapes are simply put into their
             respective circuits. The connections are not indicated. @/li
         @li Subnet hierarchy (hier_mode == \BNH_SubcircuitCells): for each root net, a full hierarchy is built
             to accommodate the subnets (see build_net in recursive mode). @/li
         @li Flat (hier_mode == \BNH_Flatten): each net is flattened and put into the circuit it
             belongs to. @/li
        @/ul
        If a device cell name prefix is given, cells will be produced for each device abstract
        using a name like device_cell_name_prefix + device name. Otherwise the device shapes are
        treated as part of the net.

        @param target The target layout
        @param target_cell The target cell
        @param lmap Target layer indexes (keys) and net regions (values)
        @param hier_mode See description of this method
        @param netname_prop An (optional) property name to which to attach the net name
        @param cell_name_prefix Chooses recursive mode if non-null
        @param device_cell_name_prefix See above
        """
    def build_nets(self, nets: Sequence[Net], cmap: CellMapping, target: Layout, lmap: Dict[int, Region], net_cell_name_prefix: Optional[Any] = ..., netname_prop: Optional[Any] = ..., hier_mode: Optional[LayoutToNetlist.BuildNetHierarchyMode] = ..., circuit_cell_name_prefix: Optional[Any] = ..., device_cell_name_prefix: Optional[Any] = ...) -> None:
        r"""
        @brief Like \build_all_nets, but with the ability to select some nets.
        """
    @overload
    def cell_mapping_into(self, layout: Layout, cell: Cell, with_device_cells: Optional[bool] = ...) -> CellMapping:
        r"""
        @brief Creates a cell mapping for copying shapes from the internal layout to the given target layout.
        If 'with_device_cells' is true, cells will be produced for devices. These are cells not corresponding to circuits, so they are disabled normally.
        Use this option, if you want to access device terminal shapes per device.

        CAUTION: this function may create new cells in 'layout'. Use \const_cell_mapping_into if you want to use the target layout's hierarchy and not modify it.
        """
    @overload
    def cell_mapping_into(self, layout: Layout, cell: Cell, nets: Sequence[Net], with_device_cells: Optional[bool] = ...) -> CellMapping:
        r"""
        @brief Creates a cell mapping for copying shapes from the internal layout to the given target layout.
        This version will only create cells which are required to represent the nets from the 'nets' argument.

        If 'with_device_cells' is true, cells will be produced for devices. These are cells not corresponding to circuits, so they are disabled normally.
        Use this option, if you want to access device terminal shapes per device.

        CAUTION: this function may create new cells in 'layout'. Use \const_cell_mapping_into if you want to use the target layout's hierarchy and not modify it.
        """
    def clear_join_net_names(self) -> None:
        r"""
        @brief Clears all implicit net joining expressions.
        See \extract_netlist for more details about this feature.

        This method has been introduced in version 0.27 and replaces the arguments of \extract_netlist.
        """
    def clear_join_nets(self) -> None:
        r"""
        @brief Clears all explicit net joining expressions.
        See \extract_netlist for more details about this feature.

        Explicit net joining has been introduced in version 0.27.
        """
    @overload
    def connect(self, l: Region) -> None:
        r"""
        @brief Defines an intra-layer connection for the given layer.
        The layer is either an original layer created with \make_includelayer and it's variants or
        a derived layer. Certain limitations apply. It's safe to use
        boolean operations for deriving layers. Other operations are applicable as long as they are
        capable of delivering hierarchical layers.
        """
    @overload
    def connect(self, a: Region, b: Region) -> None:
        r"""
        @brief Defines an inter-layer connection for the given layers.
        The conditions mentioned with intra-layer \connect apply for this method too.
        """
    @overload
    def connect(self, a: Region, b: Texts) -> None:
        r"""
        @brief Defines an inter-layer connection for the given layers.
        The conditions mentioned with intra-layer \connect apply for this method too.
        As one argument is a (hierarchical) text collection, this method is used to attach net labels to polygons.

        This variant has been introduced in version 0.27.
        """
    @overload
    def connect(self, a: Texts, b: Region) -> None:
        r"""
        @brief Defines an inter-layer connection for the given layers.
        The conditions mentioned with intra-layer \connect apply for this method too.
        As one argument is a (hierarchical) text collection, this method is used to attach net labels to polygons.

        This variant has been introduced in version 0.27.
        """
    @overload
    def connect_global(self, l: Region, global_net_name: str) -> int:
        r"""
        @brief Defines a connection of the given layer with a global net.
        This method returns the ID of the global net. Use \global_net_name to get the name back from the ID.
        """
    @overload
    def connect_global(self, l: Texts, global_net_name: str) -> int:
        r"""
        @brief Defines a connection of the given text layer with a global net.
        This method returns the ID of the global net. Use \global_net_name to get the name back from the ID.
        This variant has been introduced in version 0.27.
        """
    def const_cell_mapping_into(self, layout: Layout, cell: Cell) -> CellMapping:
        r"""
        @brief Creates a cell mapping for copying shapes from the internal layout to the given target layout.
        This version will not create new cells in the target layout.
        If the required cells do not exist there yet, flatting will happen.
        """
    def dss(self) -> DeepShapeStore:
        r"""
        @brief Gets a reference to the internal DSS object.
        """
    def dump_joined_net_names(self) -> str:
        r"""
        @hide
        """
    def dump_joined_net_names_per_cell(self) -> str:
        r"""
        @hide
        """
    def dump_joined_nets(self) -> str:
        r"""
        @hide
        """
    def dump_joined_nets_per_cell(self) -> str:
        r"""
        @hide
        """
    def extract_devices(self, extractor: DeviceExtractorBase, layers: Dict[str, ShapeCollection]) -> None:
        r"""
        @brief Extracts devices
        See the class description for more details.
        This method will run device extraction for the given extractor. The layer map is specific
        for the extractor and uses the region objects derived with \make_layer and it's variants.

        In addition, derived regions can be passed too. Certain limitations apply. It's safe to use
        boolean operations for deriving layers. Other operations are applicable as long as they are
        capable of delivering hierarchical layers.

        If errors occur, the device extractor will contain theses errors.
        """
    def extract_netlist(self) -> None:
        r"""
        @brief Runs the netlist extraction

        See the class description for more details.

        This method has been made parameter-less in version 0.27. Use \include_floating_subcircuits= and \join_net_names as substitutes for the arguments of previous versions.
        """
    def filename(self) -> str:
        r"""
        @brief Gets the file name of the database
        The filename is the name under which the database is stored or empty if it is not associated with a file.
        """
    def global_net_name(self, global_net_id: int) -> str:
        r"""
        @brief Gets the global net name for the given global net ID.
        """
    def internal_layout(self) -> Layout:
        r"""
        @brief Gets the internal layout
        Usually it should not be required to obtain the internal layout. If you need to do so, make sure not to modify the layout as
        the functionality of the netlist extractor depends on it.
        """
    def internal_top_cell(self) -> Cell:
        r"""
        @brief Gets the internal top cell
        Usually it should not be required to obtain the internal cell. If you need to do so, make sure not to modify the cell as
        the functionality of the netlist extractor depends on it.
        """
    def is_extracted(self) -> bool:
        r"""
        @brief Gets a value indicating whether the netlist has been extracted

        This method has been introduced in version 0.27.1.
        """
    @overload
    def is_persisted(self, layer: Region) -> bool:
        r"""
        @brief Returns true, if the given layer is a persisted region.
        Persisted layers are kept inside the LayoutToNetlist object and are not released if their object is destroyed. Named layers are persisted, unnamed layers are not. Only persisted, named layers can be put into \connect.
        """
    @overload
    def is_persisted(self, layer: Texts) -> bool:
        r"""
        @brief Returns true, if the given layer is a persisted texts collection.
        Persisted layers are kept inside the LayoutToNetlist object and are not released if their object is destroyed. Named layers are persisted, unnamed layers are not. Only persisted, named layers can be put into \connect.

        The variant for Texts collections has been added in version 0.27.
        """
    @overload
    def join_net_names(self, pattern: str) -> None:
        r"""
        @brief Specifies another pattern for implicit joining of nets for the top level cell.
        Use this method to register a pattern for net labels considered in implicit net joining. Implicit net joining allows connecting multiple parts of the same nets (e.g. supply rails) without need for a physical connection. The pattern specifies labels to look for. When parts are labelled with a name matching the expression, the parts carrying the same name are joined.

        This method adds a new pattern. Use \clear_join_net_names to clear the registered pattern.

        Each pattern is a glob expression. Valid glob expressions are:
        @ul
        @li "" no implicit connections.@/li
        @li "*" to make all labels candidates for implicit connections.@/li
        @li "VDD" to make all 'VDD'' nets candidates for implicit connections.@/li
        @li "VDD" to make all 'VDD'+suffix nets candidates for implicit connections.@/li
        @li "{VDD,VSS}" to all VDD and VSS nets candidates for implicit connections.@/li
        @/ul

        Label matching is case sensitive.

        This method has been introduced in version 0.27 and replaces the arguments of \extract_netlist.
        """
    @overload
    def join_net_names(self, cell_pattern: str, pattern: str) -> None:
        r"""
        @brief Specifies another pattern for implicit joining of nets for the cells from the given cell pattern.
        This method allows applying implicit net joining for specific cells, not only for the top cell.

        This method adds a new pattern. Use \clear_join_net_names to clear the registered pattern.

        This method has been introduced in version 0.27 and replaces the arguments of \extract_netlist.
        """
    @overload
    def join_nets(self, net_names: Sequence[str]) -> None:
        r"""
        @brief Specifies another name list for explicit joining of nets for the top level cell.
        Use this method to join nets from the set of net names. All these nets will be connected together forming a single net.
        Explicit joining will imply implicit joining for the involved nets - partial nets involved will be connected too (intra-net joining).

        This method adds a new name list. Use \clear_join_nets to clear the registered pattern.

        Explicit net joining has been introduced in version 0.27.
        """
    @overload
    def join_nets(self, cell_pattern: str, net_names: Sequence[str]) -> None:
        r"""
        @brief Specifies another name list for explicit joining of nets for the cells from the given cell pattern.
        This method allows applying explicit net joining for specific cells, not only for the top cell.

        This method adds a new name list. Use \clear_join_nets to clear the registered pattern.

        Explicit net joining has been introduced in version 0.27.
        """
    def keep_dss(self) -> None:
        r"""
        @brief Resumes ownership over the DSS object if created with an external one.
        """
    def layer_by_index(self, index: int) -> Region:
        r"""
        @brief Gets a layer object for the given index.
        Only named layers can be retrieved with this method. The returned object is a copy which represents the named layer.
        """
    def layer_by_name(self, name: str) -> Region:
        r"""
        @brief Gets a layer object for the given name.
        The returned object is a copy which represents the named layer.
        """
    @overload
    def layer_name(self, l: int) -> str:
        r"""
        @brief Gets the name of the given layer (by index)
        """
    @overload
    def layer_name(self, l: ShapeCollection) -> str:
        r"""
        @brief Gets the name of the given layer
        """
    def layer_names(self) -> List[str]:
        r"""
        @brief Returns a list of names of the layer kept inside the LayoutToNetlist object.
        """
    @overload
    def layer_of(self, l: Region) -> int:
        r"""
        @brief Gets the internal layer for a given extraction layer
        This method is required to derive the internal layer index - for example for
        investigating the cluster tree.
        """
    @overload
    def layer_of(self, l: Texts) -> int:
        r"""
        @brief Gets the internal layer for a given text collection
        This method is required to derive the internal layer index - for example for
        investigating the cluster tree.

        The variant for Texts collections has been added in version 0.27.
        """
    @overload
    def make_layer(self, name: Optional[str] = ...) -> Region:
        r"""
        @brief Creates a new, empty hierarchical region

        The name is optional. If given, the layer will already be named accordingly (see \register).
        """
    @overload
    def make_layer(self, layer_index: int, name: Optional[str] = ...) -> Region:
        r"""
        @brief Creates a new hierarchical region representing an original layer
        'layer_index' is the layer index of the desired layer in the original layout.
        This variant produces polygons and takes texts for net name annotation.
        A variant not taking texts is \make_polygon_layer. A Variant only taking
        texts is \make_text_layer.

        The name is optional. If given, the layer will already be named accordingly (see \register).
        """
    def make_polygon_layer(self, layer_index: int, name: Optional[str] = ...) -> Region:
        r"""
        @brief Creates a new region representing an original layer taking polygons and texts
        See \make_layer for details.

        The name is optional. If given, the layer will already be named accordingly (see \register).
        """
    def make_text_layer(self, layer_index: int, name: Optional[str] = ...) -> Texts:
        r"""
        @brief Creates a new region representing an original layer taking texts only
        See \make_layer for details.

        The name is optional. If given, the layer will already be named accordingly (see \register).

        Starting with version 0.27, this method returns a \Texts object.
        """
    def netlist(self) -> Netlist:
        r"""
        @brief gets the netlist extracted (0 if no extraction happened yet)
        """
    @overload
    def probe_net(self, of_layer: Region, point: DPoint, sc_path_out: Optional[Sequence[SubCircuit]] = ..., initial_circuit: Optional[Circuit] = ...) -> Net:
        r"""
        @brief Finds the net by probing a specific location on the given layer

        This method will find a net looking at the given layer at the specific position.
        It will traverse the hierarchy below if no shape in the requested layer is found
        in the specified location. The function will report the topmost net from far above the
        hierarchy of circuits as possible.

        If \initial_circuit is given, the probing will start from this circuit and from the cell this circuit represents. By default, the probing will start from the top circuit.

        If no net is found at all, 0 is returned.

        It is recommended to use \probe_net on the netlist right after extraction.
        Optimization functions such as \Netlist#purge will remove parts of the net which means
        shape to net probing may no longer work for these nets.

        If non-null and an array, 'sc_path_out' will receive a list of \SubCircuits objects which lead to the net from the top circuit of the database.

        This variant accepts a micrometer-unit location. The location is given in the
        coordinate space of the initial cell.

        The \sc_path_out and \initial_circuit parameters have been added in version 0.27.
        """
    @overload
    def probe_net(self, of_layer: Region, point: Point, sc_path_out: Optional[Sequence[SubCircuit]] = ..., initial_circuit: Optional[Circuit] = ...) -> Net:
        r"""
        @brief Finds the net by probing a specific location on the given layer
        See the description of the other \probe_net variant.
        This variant accepts a database-unit location. The location is given in the
        coordinate space of the initial cell.

        The \sc_path_out and \initial_circuit parameters have been added in version 0.27.
        """
    def read(self, path: str) -> None:
        r"""
        @brief Reads the extracted netlist from the file.
        This method employs the native format of KLayout.
        """
    def read_l2n(self, path: str) -> None:
        r"""
        Note: This is an alias of 'read'.
        @brief Reads the extracted netlist from the file.
        This method employs the native format of KLayout.
        """
    def register(self, l: ShapeCollection, n: str) -> None:
        r"""
        @brief Names the given layer
        'l' must be a hierarchical \Region or \Texts object derived with \make_layer, \make_text_layer or \make_polygon_layer or a region derived from those by boolean operations or other hierarchical operations.

        Naming a layer allows the system to indicate the layer in various contexts, i.e. when writing the data to a file. Named layers are also persisted inside the LayoutToNetlist object. They are not discarded when the Region object is destroyed.

        If required, the system will assign a name automatically.
        This method has been generalized in version 0.27.
        """
    def reset_extracted(self) -> None:
        r"""
        @brief Resets the extracted netlist and enables re-extraction
        This method is implicitly called when using \connect or \connect_global after a netlist has been extracted.
        This enables incremental connect with re-extraction.

        This method has been introduced in version 0.27.1.
        """
    @overload
    def shapes_of_net(self, net: Net, of_layer: Region, recursive: bool) -> Region:
        r"""
        @brief Returns all shapes of a specific net and layer.
        If 'recursive'' is true, the returned region will contain the shapes of
        all subcircuits too.
        """
    @overload
    def shapes_of_net(self, net: Net, of_layer: Region, recursive: bool, to: Shapes, propid: Optional[int] = ...) -> None:
        r"""
        @brief Sends all shapes of a specific net and layer to the given Shapes container.
        If 'recursive'' is true, the returned region will contain the shapes of
        all subcircuits too.
        "prop_id" is an optional properties ID. If given, this property set will be attached to the shapes.
        """
    def write(self, path: str, short_format: Optional[bool] = ...) -> None:
        r"""
        @brief Writes the extracted netlist to a file.
        This method employs the native format of KLayout.
        """
    def write_l2n(self, path: str, short_format: Optional[bool] = ...) -> None:
        r"""
        Note: This is an alias of 'write'.
        @brief Writes the extracted netlist to a file.
        This method employs the native format of KLayout.
        """

class LayoutVsSchematic(LayoutToNetlist):
    r"""
    @brief A generic framework for doing LVS (layout vs. schematic)

    This class extends the concept of the netlist extraction from a layout to LVS verification. It does so by adding these concepts to the \LayoutToNetlist class:

    @ul
    @li A reference netlist. This will be the netlist against which the layout-derived netlist is compared against. See \reference and \reference=.
    @/li
    @li A compare step. During the compare the layout-derived netlist and the reference netlists are compared. The compare results are captured in the cross-reference object. See \compare and \NetlistComparer for the comparer object.
    @/li
    @li A cross-reference. This object (of class \NetlistCrossReference) will keep the relations between the objects of the two netlists. It also lists the differences between the netlists. See \xref about how to access this object.@/li
    @/ul

    The LVS object can be persisted to and from a file in a specific format, so it is sometimes referred to as the "LVS database".

    LVS objects can be attached to layout views with \LayoutView#add_lvsdb so they become available in the netlist database browser.

    This class has been introduced in version 0.26.
    """
    reference: Netlist
    r"""
    @brief Gets the reference netlist.
    @brief Sets the reference netlist.
    This will set the reference netlist used inside \compare as the second netlist to compare against the layout-extracted netlist.

    The LVS object will take ownership over the netlist - i.e. if it goes out of scope, the reference netlist is deleted.
    """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a new LVS object
        The main objective for this constructor is to create an object suitable for reading and writing LVS database files.
        """
    @overload
    def __init__(self, dss: DeepShapeStore) -> None:
        r"""
        @brief Creates a new LVS object with the extractor object reusing an existing \DeepShapeStore object
        See the corresponding constructor of the \LayoutToNetlist object for more details.
        """
    @overload
    def __init__(self, iter: RecursiveShapeIterator) -> None:
        r"""
        @brief Creates a new LVS object with the extractor connected to an original layout
        This constructor will attach the extractor of the LVS object to an original layout through the shape iterator.
        """
    @overload
    def __init__(self, dss: DeepShapeStore, layout_index: int) -> None:
        r"""
        @brief Creates a new LVS object with the extractor object reusing an existing \DeepShapeStore object
        See the corresponding constructor of the \LayoutToNetlist object for more details.
        """
    @overload
    def __init__(self, topcell_name: str, dbu: float) -> None:
        r"""
        @brief Creates a new LVS object with the extractor object taking a flat DSS
        See the corresponding constructor of the \LayoutToNetlist object for more details.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def compare(self, comparer: NetlistComparer) -> bool:
        r"""
        @brief Compare the layout-extracted netlist against the reference netlist using the given netlist comparer.
        """
    def read(self, path: str) -> None:
        r"""
        @brief Reads the LVS object from the file.
        This method employs the native format of KLayout.
        """
    def read_l2n(self, path: str) -> None:
        r"""
        @brief Reads the \LayoutToNetlist part of the object from a file.
        This method employs the native format of KLayout.
        """
    def write(self, path: str, short_format: Optional[bool] = ...) -> None:
        r"""
        @brief Writes the LVS object to a file.
        This method employs the native format of KLayout.
        """
    def write_l2n(self, path: str, short_format: Optional[bool] = ...) -> None:
        r"""
        @brief Writes the \LayoutToNetlist part of the object to a file.
        This method employs the native format of KLayout.
        """
    def xref(self) -> NetlistCrossReference:
        r"""
        @brief Gets the cross-reference object
        The cross-reference object is created while comparing the layout-extracted netlist against the reference netlist - i.e. during \compare. Before \compare is called, this object is nil.
        It holds the results of the comparison - a cross-reference between the nets and other objects in the match case and a listing of non-matching nets and other objects for the non-matching cases.
        See \NetlistCrossReference for more details.
        """

class Library:
    r"""
    @brief A Library 

    A library is basically a wrapper around a layout object. The layout object
    provides cells and potentially PCells that can be imported into other layouts.

    The library provides a name which is used to identify the library and a description
    which is used for identifying the library in a user interface. 

    After a library is created and the layout is filled, it must be registered using the register method.

    This class has been introduced in version 0.22.
    """
    description: str
    r"""
    @brief Returns the libraries' description text
    @brief Sets the libraries' description text
    """
    technology: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief sets the name of the technology the library is associated with

    See \technology for details. This attribute has been introduced in version 0.25. In version 0.27, a library can be associated with multiple technologies and this method will revert the selection to a single one. Passing an empty string is equivalent to \clear_technologies.
    """
    @classmethod
    def library_ids(cls) -> List[int]:
        r"""
        @brief Returns a list of valid library IDs.
        See \library_names for the reasoning behind this method.
        This method has been introduced in version 0.27.
        """
    @classmethod
    def library_names(cls) -> List[str]:
        r"""
        @brief Returns a list of the names of all libraries registered in the system.

        NOTE: starting with version 0.27, the name of a library does not need to be unique if libraries are associated with specific technologies. This method will only return the names and it's not possible not unambiguously derive the library object. It is recommended to use \library_ids and \library_by_id to obtain the library unambiguously.
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new, empty library
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_technology(self, tech: str) -> None:
        r"""
        @brief Additionally associates the library with the given technology.
        See also \clear_technologies.

        This method has been introduced in version 0.27
        """
    def clear_technologies(self) -> None:
        r"""
        @brief Clears the list of technologies the library is associated with.
        See also \add_technology.

        This method has been introduced in version 0.27
        """
    def delete(self) -> None:
        r"""
        @brief Deletes the library

        This method will delete the library object. Library proxies pointing to this library will become invalid and the library object cannot be used any more after calling this method.

        This method has been introduced in version 0.25.
        """
    def for_technologies(self) -> bool:
        r"""
        @brief Returns a value indicating whether the library is associated with any technology.
        The method is equivalent to checking whether the \technologies list is empty.

        This method has been introduced in version 0.27
        """
    def id(self) -> int:
        r"""
        @brief Returns the library's ID
        The ID is set when the library is registered and cannot be changed 
        """
    def is_for_technology(self, tech: str) -> bool:
        r"""
        @brief Returns a value indicating whether the library is associated with the given technology.
        This method has been introduced in version 0.27
        """
    def layout(self) -> Layout:
        r"""
        @brief The layout object where the cells reside that this library defines
        """
    def layout_const(self) -> Layout:
        r"""
        @brief The layout object where the cells reside that this library defines (const version)
        """
    def library_by_id(self, id: int) -> Library:
        r"""
        @brief Gets the library object for the given ID
        If the ID is not valid, nil is returned.

        This method has been introduced in version 0.27.
        """
    def library_by_name(self, name: str, for_technology: Optional[str] = ...) -> Library:
        r"""
        @brief Gets a library by name
        Returns the library object for the given name. If the name is not a valid
        library name, nil is returned.

        Different libraries can be registered under the same names for different technologies. When a technology name is given in 'for_technologies', the first library matching this technology is returned. If no technology is given, the first library is returned.

        The technology selector has been introduced in version 0.27.
        """
    def name(self) -> str:
        r"""
        @brief Returns the libraries' name
        The name is set when the library is registered and cannot be changed
        """
    def refresh(self) -> None:
        r"""
        @brief Updates all layouts using this library.
        This method will retire cells or update layouts in the attached clients.
        It will also recompute the PCells inside the library. 
        This method has been introduced in version 0.27.8.
        """
    def register(self, name: str) -> None:
        r"""
        @brief Registers the library with the given name

        This method can be called in the constructor to register the library after 
        the layout object has been filled with content. If a library with that name
        already exists for the same technologies, it will be replaced with this library. 

        This method will set the libraries' name.

        The technology specific behaviour has been introduced in version 0.27.
        """
    def technologies(self) -> List[str]:
        r"""
        @brief Gets the list of technologies this library is associated with.
        This method has been introduced in version 0.27
        """

class PCellDeclaration_Native:
    r"""
    @hide
    @alias PCellDeclaration
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def can_create_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> bool:
        r"""
        """
    def coerce_parameters(self, arg0: Layout, arg1: Sequence[Any]) -> List[Any]:
        r"""
        """
    def display_text(self, arg0: Sequence[Any]) -> str:
        r"""
        """
    def get_layers(self, arg0: Sequence[Any]) -> List[LayerInfo]:
        r"""
        """
    def get_parameters(self) -> List[PCellParameterDeclaration]:
        r"""
        """
    def id(self) -> int:
        r"""
        @brief Gets the integer ID of the PCell declaration
        This ID is used to identify the PCell in the context of a Layout object for example
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets the Layout object the PCell is registered in or nil if it is not registered yet.
        This attribute has been added in version 0.27.5.
        """
    def name(self) -> str:
        r"""
        @brief Gets the name of the PCell
        """
    def parameters_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> List[Any]:
        r"""
        """
    def produce(self, arg0: Layout, arg1: Sequence[int], arg2: Sequence[Any], arg3: Cell) -> None:
        r"""
        """
    def transformation_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> Trans:
        r"""
        """
    def wants_lazy_evaluation(self) -> bool:
        r"""
        """

class PCellDeclaration(PCellDeclaration_Native):
    r"""
    @brief A PCell declaration providing the parameters and code to produce the PCell

    A PCell declaration is basically the recipe of how to create a PCell layout from
    a parameter set. The declaration includes

    @ul
    @li Parameters: names, types, default values @/li
    @li Layers: the layers the PCell wants to create @/li
    @li Code: a production callback that is called whenever a PCell is instantiated with a certain parameter set @/li
    @li Display name: the name that is shown for a given PCell instance @/li
    @/ul

    All these declarations are implemented by deriving from the PCellDeclaration class
    and reimplementing the specific methods. Reimplementing the \display_name method is 
    optional. The default implementation creates a name from the PCell name plus the 
    parameters.

    By supplying the information about the layers it wants to create, KLayout is able to
    call the production callback with a defined set of the layer ID's which are already
    mapped to valid actual layout layers.

    This class has been introduced in version 0.22.
    """
    def __copy__(self) -> PCellDeclaration:
        r"""
        @brief Creates a copy of self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: PCellDeclaration_Native) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def can_create_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> bool:
        r"""
        @hide
        """
    @overload
    def can_create_from_shape(self, layout: Layout, shape: Shape, layer: int) -> bool:
        r"""
        @brief Returns true, if the PCell can be created from the given shape
        @param layout The layout the shape lives in
        @param shape The shape from which a PCell shall be created
        @param layer The layer index (in layout) of the shape
        KLayout offers a way to convert a shape into a PCell. To test whether the PCell can be created from a shape, it will call this method. If this method returns true, KLayout will use \parameters_from_shape and \transformation_from_shape to derive the parameters and instance transformation for the new PCell instance that will replace the shape.
        """
    def coerce_parameters(self, layout: Layout, input: Sequence[Any]) -> List[Any]:
        r"""
        @brief Modifies the parameters to match the requirements
        @param layout The layout object in which the PCell will be produced
        @param input The parameters before the modification
        @return The modified parameters or an empty array, indicating that no modification was done
        This method can be reimplemented to change the parameter set according to some
        constraints for example. The reimplementation may modify the parameters in a way
        that they are usable for the \produce method.

        The method receives a reference to the layout so it is able to verify
        the parameters against layout properties.

        It can raise an exception to indicate that something is not correct.
        """
    @overload
    def display_text(self, arg0: Sequence[Any]) -> str:
        r"""
        @hide
        """
    @overload
    def display_text(self, parameters: Sequence[Any]) -> str:
        r"""
        @brief Returns the display text for this PCell given a certain parameter set
        Reimplement this method to create a distinct display text for a PCell variant with 
        the given parameter set. If this method is not implemented, a default text is created. 
        """
    def dup(self) -> PCellDeclaration:
        r"""
        @brief Creates a copy of self
        """
    def get_layers(self, parameters: Sequence[Any]) -> List[LayerInfo]:
        r"""
        @brief Returns a list of layer declarations
        Reimplement this method to return a list of layers this PCell wants to create.
        The layer declarations are returned as a list of LayerInfo objects which are
        used as match expressions to look up the layer in the actual layout.

        This method receives the PCell parameters which allows it to deduce layers
        from the parameters.
        """
    def get_parameters(self) -> List[PCellParameterDeclaration]:
        r"""
        @hide
        """
    @overload
    def parameters_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> List[Any]:
        r"""
        @hide
        """
    @overload
    def parameters_from_shape(self, layout: Layout, shape: Shape, layer: int) -> List[Any]:
        r"""
        @brief Gets the parameters for the PCell which can replace the given shape
        @param layout The layout the shape lives in
        @param shape The shape from which a PCell shall be created
        @param layer The layer index (in layout) of the shape
        KLayout offers a way to convert a shape into a PCell. If \can_create_from_shape returns true, it will use this method to derive the parameters for the PCell instance that will replace the shape. See also \transformation_from_shape and \can_create_from_shape.
        """
    @overload
    def produce(self, arg0: Layout, arg1: Sequence[int], arg2: Sequence[Any], arg3: Cell) -> None:
        r"""
        @hide
        """
    @overload
    def produce(self, layout: Layout, layer_ids: Sequence[int], parameters: Sequence[Any], cell: Cell) -> None:
        r"""
        @brief The production callback
        @param layout The layout object where the cell resides
        @param layer_ids A list of layer ID's which correspond to the layers declared with get_layers
        @param parameters A list of parameter values which correspond to the parameters declared with get_parameters
        @param cell The cell where the layout will be created
        Reimplement this method to provide the code that implements the PCell.
        The code is supposed to create the layout in the target cell using the provided 
        parameters and the layers passed in the layer_ids list.
        """
    @overload
    def transformation_from_shape(self, arg0: Layout, arg1: Shape, arg2: int) -> Trans:
        r"""
        @hide
        """
    @overload
    def transformation_from_shape(self, layout: Layout, shape: Shape, layer: int) -> Trans:
        r"""
        @brief Gets the instance transformation for the PCell which can replace the given shape
        @param layout The layout the shape lives in
        @param shape The shape from which a PCell shall be created
        @param layer The layer index (in layout) of the shape
        KLayout offers a way to convert a shape into a PCell. If \can_create_from_shape returns true, it will use this method to derive the transformation for the PCell instance that will replace the shape. See also \parameters_from_shape and \can_create_from_shape.
        """
    def wants_lazy_evaluation(self) -> bool:
        r"""
        @hide
        """

class PCellParameterDeclaration:
    r"""
    @brief A PCell parameter declaration

    This class declares a PCell parameter by providing a name, the type and a value 
    and additional 
    information like description, unit string and default value. It is used in the \PCellDeclaration class to 
    deliver the necessary information.

    This class has been introduced in version 0.22.
    """
    TypeBoolean: ClassVar[int]
    r"""
    @brief Type code: boolean data
    """
    TypeDouble: ClassVar[int]
    r"""
    @brief Type code: floating-point data
    """
    TypeInt: ClassVar[int]
    r"""
    @brief Type code: integer data
    """
    TypeLayer: ClassVar[int]
    r"""
    @brief Type code: a layer (a \LayerInfo object)
    """
    TypeList: ClassVar[int]
    r"""
    @brief Type code: a list of variants
    """
    TypeNone: ClassVar[int]
    r"""
    @brief Type code: unspecific type
    """
    TypeShape: ClassVar[int]
    r"""
    @brief Type code: a guiding shape (Box, Edge, Point, Polygon or Path)
    """
    TypeString: ClassVar[int]
    r"""
    @brief Type code: string data
    """
    default: Any
    r"""
    @brief Gets the default value
    @brief Sets the default value
    If a default value is defined, it will be used to initialize the parameter value
    when a PCell is created.
    """
    description: str
    r"""
    @brief Gets the description text
    @brief Sets the description
    """
    hidden: bool
    r"""
    @brief Returns true, if the parameter is a hidden parameter that should not be shown in the user interface
    By making a parameter hidden, it is possible to create internal parameters which cannot be
    edited.
    @brief Makes the parameter hidden if this attribute is set to true
    """
    name: str
    r"""
    @brief Gets the name
    @brief Sets the name
    """
    readonly: bool
    r"""
    @brief Returns true, if the parameter is a read-only parameter
    By making a parameter read-only, it is shown but cannot be
    edited.
    @brief Makes the parameter read-only if this attribute is set to true
    """
    type: int
    r"""
    @brief Gets the type
    The type is one of the T... constants.@brief Sets the type
    """
    unit: str
    r"""
    @brief Gets the unit string
    @brief Sets the unit string
    The unit string is shown right to the edit fields for numeric parameters.
    """
    def __copy__(self) -> PCellParameterDeclaration:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self, name: str, type: int, description: str) -> None:
        r"""
        @brief Create a new parameter declaration with the given name and type
        @param name The parameter name
        @param type One of the Type... constants describing the type of the parameter
        @param description The description text
        """
    @overload
    def __init__(self, name: str, type: int, description: str, default: Any) -> None:
        r"""
        @brief Create a new parameter declaration with the given name, type and default value
        @param name The parameter name
        @param type One of the Type... constants describing the type of the parameter
        @param description The description text
        @param default The default (initial) value
        """
    @overload
    def __init__(self, name: str, type: int, description: str, default: Any, unit: str) -> None:
        r"""
        @brief Create a new parameter declaration with the given name, type, default value and unit string
        @param name The parameter name
        @param type One of the Type... constants describing the type of the parameter
        @param description The description text
        @param default The default (initial) value
        @param unit The unit string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_choice(self, description: str, value: Any) -> None:
        r"""
        @brief Add a new value to the list of choices
        This method will add the given value with the given description to the list of
        choices. If choices are defined, KLayout will show a drop-down box instead of an
        entry field in the parameter user interface.
        """
    def assign(self, other: PCellParameterDeclaration) -> None:
        r"""
        @brief Assigns another object to self
        """
    def choice_descriptions(self) -> List[str]:
        r"""
        @brief Returns a list of choice descriptions
        """
    def choice_values(self) -> List[Any]:
        r"""
        @brief Returns a list of choice values
        """
    def clear_choices(self) -> None:
        r"""
        @brief Clears the list of choices
        """
    def dup(self) -> PCellParameterDeclaration:
        r"""
        @brief Creates a copy of self
        """

class Manager:
    r"""
    @brief A transaction manager class

    Manager objects control layout and potentially other objects in the layout database and queue operations to form transactions. A transaction is a sequence of operations that can be undone or redone.

    In order to equip a layout object with undo/redo support, instantiate the layout object with a manager attached and embrace the operations to undo/redo with transaction/commit calls.

    The use of transactions is subject to certain constraints, i.e. transacted sequences may not be mixed with non-transacted ones.

    This class has been introduced in version 0.19.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def commit(self) -> None:
        r"""
        @brief Close a transaction.
        """
    def has_redo(self) -> bool:
        r"""
        @brief Determine if a transaction is available for 'redo'

        @return True, if a transaction is available.
        """
    def has_undo(self) -> bool:
        r"""
        @brief Determine if a transaction is available for 'undo'

        @return True, if a transaction is available.
        """
    def redo(self) -> None:
        r"""
        @brief Redo the next available transaction

        The next transaction is redone with this method.
        The 'has_redo' method can be used to determine whether
        there are transactions to undo.
        """
    @overload
    def transaction(self, description: str) -> int:
        r"""
        @brief Begin a transaction


        This call will open a new transaction. A transaction consists
        of a set of operations issued with the 'queue' method.
        A transaction is closed with the 'commit' method.

        @param description The description for this transaction.

        @return The ID of the transaction (can be used to join other transactions with this one)
        """
    @overload
    def transaction(self, description: str, join_with: int) -> int:
        r"""
        @brief Begin a joined transaction


        This call will open a new transaction and join if with the previous transaction.
        The ID of the previous transaction must be equal to the ID given with 'join_with'.

        This overload was introduced in version 0.22.

        @param description The description for this transaction (ignored if joined).
        @param description The ID of the previous transaction.

        @return The ID of the new transaction (can be used to join more)
        """
    def transaction_for_redo(self) -> str:
        r"""
        @brief Return the description of the next transaction for 'redo'
        """
    def transaction_for_undo(self) -> str:
        r"""
        @brief Return the description of the next transaction for 'undo'
        """
    def undo(self) -> None:
        r"""
        @brief Undo the current transaction

        The current transaction is undone with this method.
        The 'has_undo' method can be used to determine whether
        there are transactions to undo.
        """

class Matrix2d:
    r"""
    @brief A 2d matrix object used mainly for representing rotation and shear transformations.

    This object represents a 2x2 matrix. This matrix is used to implement affine transformations in the 2d space mainly. It can be decomposed into basic transformations: mirroring, rotation and shear. In that case, the assumed execution order of the basic transformations is mirroring at the x axis, rotation, magnification and shear.

    The matrix is a generalization of the transformations and is of limited use in a layout database context. It is useful however to implement shear transformations on polygons, edges and polygon or edge collections.

    This class was introduced in version 0.22.
    """
    @overload
    @classmethod
    def newc(cls, mag: float, rotation: float, mirror: bool) -> Matrix2d:
        r"""
        @brief Create a new Matrix2d representing an isotropic magnification, rotation and mirroring
        @param mag The magnification in x direction
        @param rotation The rotation angle (in degree)
        @param mirror The mirror flag (at x axis)

        This constructor is provided to construct a matrix similar to the complex transformation.
        This constructor is called 'newc' to distinguish it from the constructors taking matrix coefficients ('c' is for composite).
        The order of execution of the operations is mirror, magnification, rotation (as for complex transformations).
        """
    @overload
    @classmethod
    def newc(cls, shear: float, mx: float, my: float, rotation: float, mirror: bool) -> Matrix2d:
        r"""
        @brief Create a new Matrix2d representing a shear, anisotropic magnification, rotation and mirroring
        @param shear The shear angle
        @param mx The magnification in x direction
        @param my The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirror The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, shear and rotation.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).
        """
    def __add__(self, m: Matrix2d) -> Matrix2d:
        r"""
        @brief Sum of two matrices.
        @param m The other matrix.
        @return The (element-wise) sum of self+m
        """
    def __copy__(self) -> Matrix2d:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Create a new Matrix2d representing a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Create a new Matrix2d representing an isotropic magnification
        @param m The magnification
        """
    @overload
    def __init__(self, t: DCplxTrans) -> None:
        r"""
        @brief Create a new Matrix2d from the given complex transformation@param t The transformation from which to create the matrix (not taking into account the displacement)
        """
    @overload
    def __init__(self, mx: float, my: float) -> None:
        r"""
        @brief Create a new Matrix2d representing an anisotropic magnification
        @param mx The magnification in x direction
        @param my The magnification in y direction
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float) -> None:
        r"""
        @brief Create a new Matrix2d from the four coefficients
        """
    @overload
    def __mul__(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __mul__(self, e: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __mul__(self, m: Matrix2d) -> Matrix2d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __mul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __mul__(self, p: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __mul__(self, p: DSimplePolygon) -> DSimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __mul__(self, v: DVector) -> DVector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    @overload
    def __rmul__(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __rmul__(self, e: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __rmul__(self, m: Matrix2d) -> Matrix2d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __rmul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __rmul__(self, p: DSimplePolygon) -> DSimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __rmul__(self, v: DVector) -> DVector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def angle(self) -> float:
        r"""
        @brief Returns the rotation angle of the rotation component of this matrix.
        @return The angle in degree.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        """
    def assign(self, other: Matrix2d) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cplx_trans(self) -> DCplxTrans:
        r"""
        @brief Converts this matrix to a complex transformation (if possible).
        @return The complex transformation.
        This method is successful only if the matrix does not contain shear components and the magnification must be isotropic.
        """
    def dup(self) -> Matrix2d:
        r"""
        @brief Creates a copy of self
        """
    def inverted(self) -> Matrix2d:
        r"""
        @brief The inverse of this matrix.
        @return The inverse of this matrix
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Returns the mirror flag of this matrix.
        @return True if this matrix has a mirror component.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        """
    def m(self, i: int, j: int) -> float:
        r"""
        @brief Gets the m coefficient with the given index.
        @return The coefficient [i,j]
        """
    def m11(self) -> float:
        r"""
        @brief Gets the m11 coefficient.
        @return The value of the m11 coefficient
        """
    def m12(self) -> float:
        r"""
        @brief Gets the m12 coefficient.
        @return The value of the m12 coefficient
        """
    def m21(self) -> float:
        r"""
        @brief Gets the m21 coefficient.
        @return The value of the m21 coefficient
        """
    def m22(self) -> float:
        r"""
        @brief Gets the m22 coefficient.
        @return The value of the m22 coefficient
        """
    def mag_x(self) -> float:
        r"""
        @brief Returns the x magnification of the magnification component of this matrix.
        @return The magnification factor.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, magnification, shear and rotation.
        """
    def mag_y(self) -> float:
        r"""
        @brief Returns the y magnification of the magnification component of this matrix.
        @return The magnification factor.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, magnification, shear and rotation.
        """
    def shear_angle(self) -> float:
        r"""
        @brief Returns the magnitude of the shear component of this matrix.
        @return The shear angle in degree.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        The shear basic transformation will tilt the x axis towards the y axis and vice versa. The shear angle gives the tilt angle of the axes towards the other one. The possible range for this angle is -45 to 45 degree.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def trans(self, p: DPoint) -> DPoint:
        r"""
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """

class IMatrix2d:
    r"""
    @brief A 2d matrix object used mainly for representing rotation and shear transformations (integer coordinate version).

    This object represents a 2x2 matrix. This matrix is used to implement affine transformations in the 2d space mainly. It can be decomposed into basic transformations: mirroring, rotation and shear. In that case, the assumed execution order of the basic transformations is mirroring at the x axis, rotation, magnification and shear.

    The integer variant was introduced in version 0.27.
    """
    @overload
    @classmethod
    def newc(cls, mag: float, rotation: float, mirror: bool) -> IMatrix2d:
        r"""
        @brief Create a new Matrix2d representing an isotropic magnification, rotation and mirroring
        @param mag The magnification in x direction
        @param rotation The rotation angle (in degree)
        @param mirror The mirror flag (at x axis)

        This constructor is provided to construct a matrix similar to the complex transformation.
        This constructor is called 'newc' to distinguish it from the constructors taking matrix coefficients ('c' is for composite).
        The order of execution of the operations is mirror, magnification, rotation (as for complex transformations).
        """
    @overload
    @classmethod
    def newc(cls, shear: float, mx: float, my: float, rotation: float, mirror: bool) -> IMatrix2d:
        r"""
        @brief Create a new Matrix2d representing a shear, anisotropic magnification, rotation and mirroring
        @param shear The shear angle
        @param mx The magnification in x direction
        @param my The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirror The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, shear and rotation.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).
        """
    def __add__(self, m: IMatrix2d) -> IMatrix2d:
        r"""
        @brief Sum of two matrices.
        @param m The other matrix.
        @return The (element-wise) sum of self+m
        """
    def __copy__(self) -> IMatrix2d:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Create a new Matrix2d representing a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Create a new Matrix2d representing an isotropic magnification
        @param m The magnification
        """
    @overload
    def __init__(self, t: DCplxTrans) -> None:
        r"""
        @brief Create a new Matrix2d from the given complex transformation@param t The transformation from which to create the matrix (not taking into account the displacement)
        """
    @overload
    def __init__(self, mx: float, my: float) -> None:
        r"""
        @brief Create a new Matrix2d representing an anisotropic magnification
        @param mx The magnification in x direction
        @param my The magnification in y direction
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float) -> None:
        r"""
        @brief Create a new Matrix2d from the four coefficients
        """
    @overload
    def __mul__(self, box: Box) -> Box:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __mul__(self, e: Edge) -> Edge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __mul__(self, m: IMatrix2d) -> IMatrix2d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __mul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __mul__(self, p: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __mul__(self, p: SimplePolygon) -> SimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __mul__(self, v: Vector) -> Vector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    @overload
    def __rmul__(self, box: Box) -> Box:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __rmul__(self, e: Edge) -> Edge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __rmul__(self, m: IMatrix2d) -> IMatrix2d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __rmul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __rmul__(self, p: SimplePolygon) -> SimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __rmul__(self, v: Vector) -> Vector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def angle(self) -> float:
        r"""
        @brief Returns the rotation angle of the rotation component of this matrix.
        @return The angle in degree.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        """
    def assign(self, other: IMatrix2d) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cplx_trans(self) -> ICplxTrans:
        r"""
        @brief Converts this matrix to a complex transformation (if possible).
        @return The complex transformation.
        This method is successful only if the matrix does not contain shear components and the magnification must be isotropic.
        """
    def dup(self) -> IMatrix2d:
        r"""
        @brief Creates a copy of self
        """
    def inverted(self) -> IMatrix2d:
        r"""
        @brief The inverse of this matrix.
        @return The inverse of this matrix
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Returns the mirror flag of this matrix.
        @return True if this matrix has a mirror component.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        """
    def m(self, i: int, j: int) -> float:
        r"""
        @brief Gets the m coefficient with the given index.
        @return The coefficient [i,j]
        """
    def m11(self) -> float:
        r"""
        @brief Gets the m11 coefficient.
        @return The value of the m11 coefficient
        """
    def m12(self) -> float:
        r"""
        @brief Gets the m12 coefficient.
        @return The value of the m12 coefficient
        """
    def m21(self) -> float:
        r"""
        @brief Gets the m21 coefficient.
        @return The value of the m21 coefficient
        """
    def m22(self) -> float:
        r"""
        @brief Gets the m22 coefficient.
        @return The value of the m22 coefficient
        """
    def mag_x(self) -> float:
        r"""
        @brief Returns the x magnification of the magnification component of this matrix.
        @return The magnification factor.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, magnification, shear and rotation.
        """
    def mag_y(self) -> float:
        r"""
        @brief Returns the y magnification of the magnification component of this matrix.
        @return The magnification factor.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, magnification, shear and rotation.
        """
    def shear_angle(self) -> float:
        r"""
        @brief Returns the magnitude of the shear component of this matrix.
        @return The shear angle in degree.
        The matrix is decomposed into basic transformations assuming an execution order of mirroring at the x axis, rotation, magnification and shear.
        The shear basic transformation will tilt the x axis towards the y axis and vice versa. The shear angle gives the tilt angle of the axes towards the other one. The possible range for this angle is -45 to 45 degree.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def trans(self, p: Point) -> Point:
        r"""
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """

class Matrix3d:
    r"""
    @brief A 3d matrix object used mainly for representing rotation, shear, displacement and perspective transformations.

    This object represents a 3x3 matrix. This matrix is used to implement generic geometrical transformations in the 2d space mainly. It can be decomposed into basic transformations: mirroring, rotation, shear, displacement and perspective distortion. In that case, the assumed execution order of the basic transformations is mirroring at the x axis, rotation, magnification, shear, displacement and perspective distortion.

    This class was introduced in version 0.22.
    """
    AdjustAll: ClassVar[int]
    r"""
    @brief Mode for \adjust: currently equivalent to \adjust_perspective
    """
    AdjustDisplacement: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust displacement only
    """
    AdjustMagnification: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust rotation, mirror option and magnification
    """
    AdjustNone: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust nothing
    """
    AdjustPerspective: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust whole matrix including perspective transformation
    """
    AdjustRotation: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust rotation only
    """
    AdjustRotationMirror: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust rotation and mirror option
    """
    AdjustShear: ClassVar[int]
    r"""
    @brief Mode for \adjust: adjust rotation, mirror option, magnification and shear
    """
    @overload
    @classmethod
    def newc(cls, mag: float, rotation: float, mirrx: bool) -> Matrix3d:
        r"""
        @brief Create a new Matrix3d representing a isotropic magnification, rotation and mirroring
        @param mag The magnification
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification and rotation.
        This constructor is called 'newc' to distinguish it from the constructors taking coefficients ('c' is for composite).
        """
    @overload
    @classmethod
    def newc(cls, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> Matrix3d:
        r"""
        @brief Create a new Matrix3d representing a shear, anisotropic magnification, rotation and mirroring
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation and shear.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).
        """
    @overload
    @classmethod
    def newc(cls, u: DVector, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> Matrix3d:
        r"""
        @brief Create a new Matrix3d representing a displacement, shear, anisotropic magnification, rotation and mirroring
        @param u The displacement
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation, shear and displacement.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).

        Starting with version 0.25 the displacement is of vector type.
        """
    @overload
    @classmethod
    def newc(cls, tx: float, ty: float, z: float, u: DVector, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> Matrix3d:
        r"""
        @brief Create a new Matrix3d representing a perspective distortion, displacement, shear, anisotropic magnification, rotation and mirroring
        @param tx The perspective tilt angle x (around the y axis)
        @param ty The perspective tilt angle y (around the x axis)
        @param z The observer distance at which the tilt angles are given
        @param u The displacement
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation, shear, perspective distortion and displacement.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).

        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles for different observer distances. Hence, the observer distance must be given at which the tilt angles are given. If the magnitude of the tilt angle is not important, z can be set to 1.

        Starting with version 0.25 the displacement is of vector type.
        """
    def __add__(self, m: Matrix3d) -> Matrix3d:
        r"""
        @brief Sum of two matrices.
        @param m The other matrix.
        @return The (element-wise) sum of self+m
        """
    def __copy__(self) -> Matrix3d:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Create a new Matrix3d representing a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Create a new Matrix3d representing a magnification
        @param m The magnification
        """
    @overload
    def __init__(self, t: DCplxTrans) -> None:
        r"""
        @brief Create a new Matrix3d from the given complex transformation@param t The transformation from which to create the matrix
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float) -> None:
        r"""
        @brief Create a new Matrix3d from the four coefficients of a Matrix2d
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float) -> None:
        r"""
        @brief Create a new Matrix3d from the four coefficients of a Matrix2d plus a displacement
        """
    @overload
    def __init__(self, m11: float, m12: float, m13: float, m21: float, m22: float, m23: float, m31: float, m32: float, m33: float) -> None:
        r"""
        @brief Create a new Matrix3d from the nine matrix coefficients
        """
    @overload
    def __mul__(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __mul__(self, e: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __mul__(self, m: Matrix3d) -> Matrix3d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __mul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __mul__(self, p: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __mul__(self, p: DSimplePolygon) -> DSimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __mul__(self, v: DVector) -> DVector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    @overload
    def __rmul__(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __rmul__(self, e: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __rmul__(self, m: Matrix3d) -> Matrix3d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __rmul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __rmul__(self, p: DSimplePolygon) -> DSimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __rmul__(self, v: DVector) -> DVector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def adjust(self, landmarks_before: Sequence[DPoint], landmarks_after: Sequence[DPoint], flags: int, fixed_point: int) -> None:
        r"""
        @brief Adjust a 3d matrix to match the given set of landmarks

        This function tries to adjust the matrix
        such, that either the matrix is changed as little as possible (if few landmarks are given) 
        or that the "after" landmarks will match as close as possible to the "before" landmarks 
        (if the problem is overdetermined).

        @param landmarks_before The points before the transformation.
        @param landmarks_after The points after the transformation.
        @param mode Selects the adjustment mode. Must be one of the Adjust... constants.
        @param fixed_point The index of the fixed point (one that is definitely mapped to the target) or -1 if there is none
        """
    def angle(self) -> float:
        r"""
        @brief Returns the rotation angle of the rotation component of this matrix.
        @return The angle in degree.
        See the description of this class for details about the basic transformations.
        """
    def assign(self, other: Matrix3d) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cplx_trans(self) -> DCplxTrans:
        r"""
        @brief Converts this matrix to a complex transformation (if possible).
        @return The complex transformation.
        This method is successful only if the matrix does not contain shear or perspective distortion components and the magnification must be isotropic.
        """
    def disp(self) -> DVector:
        r"""
        @brief Returns the displacement vector of this transformation.

        Starting with version 0.25 this method returns a vector type instead of a point.
        @return The displacement vector.
        """
    def dup(self) -> Matrix3d:
        r"""
        @brief Creates a copy of self
        """
    def inverted(self) -> Matrix3d:
        r"""
        @brief The inverse of this matrix.
        @return The inverse of this matrix
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Returns the mirror flag of this matrix.
        @return True if this matrix has a mirror component.
        See the description of this class for details about the basic transformations.
        """
    def m(self, i: int, j: int) -> float:
        r"""
        @brief Gets the m coefficient with the given index.
        @return The coefficient [i,j]
        """
    def mag_x(self) -> float:
        r"""
        @brief Returns the x magnification of the magnification component of this matrix.
        @return The magnification factor.
        """
    def mag_y(self) -> float:
        r"""
        @brief Returns the y magnification of the magnification component of this matrix.
        @return The magnification factor.
        """
    def shear_angle(self) -> float:
        r"""
        @brief Returns the magnitude of the shear component of this matrix.
        @return The shear angle in degree.
        The shear basic transformation will tilt the x axis towards the y axis and vice versa. The shear angle gives the tilt angle of the axes towards the other one. The possible range for this angle is -45 to 45 degree.See the description of this class for details about the basic transformations.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def trans(self, p: DPoint) -> DPoint:
        r"""
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    def tx(self, z: float) -> float:
        r"""
        @brief Returns the perspective tilt angle tx.
        @param z The observer distance at which the tilt angle is computed.
        @return The tilt angle tx.
        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at different observer distances. Hence, the observer distance must be specified at which the tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to 1.
        """
    def ty(self, z: float) -> float:
        r"""
        @brief Returns the perspective tilt angle ty.
        @param z The observer distance at which the tilt angle is computed.
        @return The tilt angle ty.
        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at different observer distances. Hence, the observer distance must be specified at which the tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to 1.
        """

class IMatrix3d:
    r"""
    @brief A 3d matrix object used mainly for representing rotation, shear, displacement and perspective transformations (integer coordinate version).

    This object represents a 3x3 matrix. This matrix is used to implement generic geometrical transformations in the 2d space mainly. It can be decomposed into basic transformations: mirroring, rotation, shear, displacement and perspective distortion. In that case, the assumed execution order of the basic transformations is mirroring at the x axis, rotation, magnification, shear, displacement and perspective distortion.

    The integer variant was introduced in version 0.27.
    """
    @overload
    @classmethod
    def newc(cls, mag: float, rotation: float, mirrx: bool) -> IMatrix3d:
        r"""
        @brief Create a new Matrix3d representing a isotropic magnification, rotation and mirroring
        @param mag The magnification
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification and rotation.
        This constructor is called 'newc' to distinguish it from the constructors taking coefficients ('c' is for composite).
        """
    @overload
    @classmethod
    def newc(cls, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> IMatrix3d:
        r"""
        @brief Create a new Matrix3d representing a shear, anisotropic magnification, rotation and mirroring
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation and shear.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).
        """
    @overload
    @classmethod
    def newc(cls, u: Vector, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> IMatrix3d:
        r"""
        @brief Create a new Matrix3d representing a displacement, shear, anisotropic magnification, rotation and mirroring
        @param u The displacement
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation, shear and displacement.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).

        Starting with version 0.25 the displacement is of vector type.
        """
    @overload
    @classmethod
    def newc(cls, tx: float, ty: float, z: float, u: Vector, shear: float, mx: float, my: float, rotation: float, mirrx: bool) -> IMatrix3d:
        r"""
        @brief Create a new Matrix3d representing a perspective distortion, displacement, shear, anisotropic magnification, rotation and mirroring
        @param tx The perspective tilt angle x (around the y axis)
        @param ty The perspective tilt angle y (around the x axis)
        @param z The observer distance at which the tilt angles are given
        @param u The displacement
        @param shear The shear angle
        @param mx The magnification in x direction
        @param mx The magnification in y direction
        @param rotation The rotation angle (in degree)
        @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation, shear, perspective distortion and displacement.
        This constructor is called 'newc' to distinguish it from the constructor taking the four matrix coefficients ('c' is for composite).

        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles for different observer distances. Hence, the observer distance must be given at which the tilt angles are given. If the magnitude of the tilt angle is not important, z can be set to 1.

        Starting with version 0.25 the displacement is of vector type.
        """
    def __add__(self, m: IMatrix3d) -> IMatrix3d:
        r"""
        @brief Sum of two matrices.
        @param m The other matrix.
        @return The (element-wise) sum of self+m
        """
    def __copy__(self) -> IMatrix3d:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Create a new Matrix3d representing a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Create a new Matrix3d representing a magnification
        @param m The magnification
        """
    @overload
    def __init__(self, t: ICplxTrans) -> None:
        r"""
        @brief Create a new Matrix3d from the given complex transformation@param t The transformation from which to create the matrix
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float) -> None:
        r"""
        @brief Create a new Matrix3d from the four coefficients of a Matrix2d
        """
    @overload
    def __init__(self, m11: float, m12: float, m21: float, m22: float, dx: float, dy: float) -> None:
        r"""
        @brief Create a new Matrix3d from the four coefficients of a Matrix2d plus a displacement
        """
    @overload
    def __init__(self, m11: float, m12: float, m13: float, m21: float, m22: float, m23: float, m31: float, m32: float, m33: float) -> None:
        r"""
        @brief Create a new Matrix3d from the nine matrix coefficients
        """
    @overload
    def __mul__(self, box: Box) -> Box:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __mul__(self, e: Edge) -> Edge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __mul__(self, m: IMatrix3d) -> IMatrix3d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __mul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __mul__(self, p: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __mul__(self, p: SimplePolygon) -> SimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __mul__(self, v: Vector) -> Vector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    @overload
    def __rmul__(self, box: Box) -> Box:
        r"""
        @brief Transforms a box with this matrix.
        @param box The box to transform.
        @return The transformed box

        Please note that the box remains a box, even though the matrix supports shear and rotation. The returned box will be the bounding box of the sheared and rotated rectangle.
        """
    @overload
    def __rmul__(self, e: Edge) -> Edge:
        r"""
        @brief Transforms an edge with this matrix.
        @param e The edge to transform.
        @return The transformed edge
        """
    @overload
    def __rmul__(self, m: IMatrix3d) -> IMatrix3d:
        r"""
        @brief Product of two matrices.
        @param m The other matrix.
        @return The matrix product self*m
        """
    @overload
    def __rmul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon with this matrix.
        @param p The polygon to transform.
        @return The transformed polygon
        """
    @overload
    def __rmul__(self, p: SimplePolygon) -> SimplePolygon:
        r"""
        @brief Transforms a simple polygon with this matrix.
        @param p The simple polygon to transform.
        @return The transformed simple polygon
        """
    @overload
    def __rmul__(self, v: Vector) -> Vector:
        r"""
        @brief Transforms a vector with this matrix.
        @param v The vector to transform.
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def angle(self) -> float:
        r"""
        @brief Returns the rotation angle of the rotation component of this matrix.
        @return The angle in degree.
        See the description of this class for details about the basic transformations.
        """
    def assign(self, other: IMatrix3d) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cplx_trans(self) -> DCplxTrans:
        r"""
        @brief Converts this matrix to a complex transformation (if possible).
        @return The complex transformation.
        This method is successful only if the matrix does not contain shear or perspective distortion components and the magnification must be isotropic.
        """
    def disp(self) -> Vector:
        r"""
        @brief Returns the displacement vector of this transformation.

        Starting with version 0.25 this method returns a vector type instead of a point.
        @return The displacement vector.
        """
    def dup(self) -> IMatrix3d:
        r"""
        @brief Creates a copy of self
        """
    def inverted(self) -> IMatrix3d:
        r"""
        @brief The inverse of this matrix.
        @return The inverse of this matrix
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Returns the mirror flag of this matrix.
        @return True if this matrix has a mirror component.
        See the description of this class for details about the basic transformations.
        """
    def m(self, i: int, j: int) -> float:
        r"""
        @brief Gets the m coefficient with the given index.
        @return The coefficient [i,j]
        """
    def mag_x(self) -> float:
        r"""
        @brief Returns the x magnification of the magnification component of this matrix.
        @return The magnification factor.
        """
    def mag_y(self) -> float:
        r"""
        @brief Returns the y magnification of the magnification component of this matrix.
        @return The magnification factor.
        """
    def shear_angle(self) -> float:
        r"""
        @brief Returns the magnitude of the shear component of this matrix.
        @return The shear angle in degree.
        The shear basic transformation will tilt the x axis towards the y axis and vice versa. The shear angle gives the tilt angle of the axes towards the other one. The possible range for this angle is -45 to 45 degree.See the description of this class for details about the basic transformations.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert the matrix to a string.
        @return The string representing this matrix
        """
    def trans(self, p: Point) -> Point:
        r"""
        @brief Transforms a point with this matrix.
        @param p The point to transform.
        @return The transformed point
        """
    def tx(self, z: float) -> float:
        r"""
        @brief Returns the perspective tilt angle tx.
        @param z The observer distance at which the tilt angle is computed.
        @return The tilt angle tx.
        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at different observer distances. Hence, the observer distance must be specified at which the tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to 1.
        """
    def ty(self, z: float) -> float:
        r"""
        @brief Returns the perspective tilt angle ty.
        @param z The observer distance at which the tilt angle is computed.
        @return The tilt angle ty.
        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at different observer distances. Hence, the observer distance must be specified at which the tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to 1.
        """

class NetlistObject:
    r"""
    @brief The base class for some netlist objects.
    The main purpose of this class is to supply user properties for netlist objects.

    This class has been introduced in version 0.26.2
    """
    def __copy__(self) -> NetlistObject:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetlistObject:
        r"""
        @brief Creates a copy of self
        """
    def property(self, key: Any) -> Any:
        r"""
        @brief Gets the property value for the given key or nil if there is no value with this key.
        """
    def property_keys(self) -> List[Any]:
        r"""
        @brief Gets the keys for the properties stored in this object.
        """
    def set_property(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the property value for the given key.
        Use a nil value to erase the property with this key.
        """

class Pin(NetlistObject):
    r"""
    @brief A pin of a circuit.
    Pin objects are used to describe the outgoing pins of a circuit. To create a new pin of a circuit, use \Circuit#create_pin.

    This class has been added in version 0.26.
    """
    def _assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> Pin:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def expanded_name(self) -> str:
        r"""
        @brief Gets the expanded name of the pin.
        The expanded name is the name or a generic identifier made from the ID if the name is empty.
        """
    def id(self) -> int:
        r"""
        @brief Gets the ID of the pin.
        """
    def name(self) -> str:
        r"""
        @brief Gets the name of the pin.
        """

class DeviceReconnectedTerminal:
    r"""
    @brief Describes a terminal rerouting in combined devices.
    Combined devices are implemented as a generalization of the device abstract concept in \Device. For combined devices, multiple \DeviceAbstract references are present. To support different combination schemes, device-to-abstract routing is supported. Parallel combinations will route all outer terminals to corresponding terminals of all device abstracts (because of terminal swapping these may be different ones).

    This object describes one route to an abstract's terminal. The device index is 0 for the main device abstract and 1 for the first combined device abstract.

    This class has been introduced in version 0.26.
    """
    device_index: int
    r"""
    @brief The device abstract index getter.
    See the class description for details.@brief The device abstract index setter.
    See the class description for details.
    """
    other_terminal_id: int
    r"""
    @brief The getter for the abstract's connected terminal.
    See the class description for details.@brief The setter for the abstract's connected terminal.
    See the class description for details.
    """
    def __copy__(self) -> DeviceReconnectedTerminal:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceReconnectedTerminal) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DeviceReconnectedTerminal:
        r"""
        @brief Creates a copy of self
        """

class DeviceAbstractRef:
    r"""
    @brief Describes an additional device abstract reference for combined devices.
    Combined devices are implemented as a generalization of the device abstract concept in \Device. For combined devices, multiple \DeviceAbstract references are present. This class describes such an additional reference. A reference is a pointer to an abstract plus a transformation by which the abstract is transformed geometrically as compared to the first (initial) abstract.

    This class has been introduced in version 0.26.
    """
    device_abstract: DeviceAbstract
    r"""
    @brief The getter for the device abstract reference.
    See the class description for details.@brief The setter for the device abstract reference.
    See the class description for details.
    """
    trans: DCplxTrans
    r"""
    @brief The getter for the relative transformation of the instance.
    See the class description for details.@brief The setter for the relative transformation of the instance.
    See the class description for details.
    """
    def __copy__(self) -> DeviceAbstractRef:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceAbstractRef) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DeviceAbstractRef:
        r"""
        @brief Creates a copy of self
        """

class Device(NetlistObject):
    r"""
    @brief A device inside a circuit.
    Device object represent atomic devices such as resistors, diodes or transistors. The \Device class represents a particular device with specific parameters. The type of device is represented by a \DeviceClass object. Device objects live in \Circuit objects, the device class objects live in the \Netlist object.

    Devices connect to nets through terminals. Terminals are described by a terminal ID which is essentially the zero-based index of the terminal. Terminal definitions can be obtained from the device class using the \DeviceClass#terminal_definitions method.

    Devices connect to nets through the \Device#connect_terminal method. Device terminals can be disconnected using \Device#disconnect_terminal.

    Device objects are created inside a circuit with \Circuit#create_device.

    This class has been added in version 0.26.
    """
    device_abstract: DeviceAbstract
    r"""
    @brief Gets the device abstract for this device instance.
    See \DeviceAbstract for more details.
    @hide
    Provided for test purposes mainly. Be careful with pointers!
    """
    name: str
    r"""
    @brief Gets the name of the device.
    @brief Sets the name of the device.
    Device names are used to name a device inside a netlist file. Device names should be unique within a circuit.
    """
    trans: DCplxTrans
    r"""
    @brief Gets the location of the device.
    See \trans= for details about this method.@brief Sets the location of the device.
    The device location is essentially describing the position of the device. The position is typically the center of some recognition shape. In this case the transformation is a plain displacement to the center of this shape.
    """
    def _assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> Device:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_combined_abstract(self, ref: DeviceAbstractRef) -> None:
        r"""
        @hide
        Provided for test purposes mainly.
        """
    def add_reconnected_terminal_for(self, outer_terminal: int, descriptor: DeviceReconnectedTerminal) -> None:
        r"""
        @hide
        Provided for test purposes mainly.
        """
    def circuit(self) -> Circuit:
        r"""
        @brief Gets the circuit the device lives in.
        """
    def clear_combined_abstracts(self) -> None:
        r"""
        @hide
        Provided for test purposes mainly.
        """
    def clear_reconnected_terminals(self) -> None:
        r"""
        @hide
        Provided for test purposes mainly.
        """
    @overload
    def connect_terminal(self, terminal_id: int, net: Net) -> None:
        r"""
        @brief Connects the given terminal to the specified net.
        """
    @overload
    def connect_terminal(self, terminal_name: str, net: Net) -> None:
        r"""
        @brief Connects the given terminal to the specified net.
        This version accepts a terminal name. If the name is not a valid terminal name, an exception is raised.
        If the terminal has been connected to a global net, it will be disconnected from there.
        """
    def device_class(self) -> DeviceClass:
        r"""
        @brief Gets the device class the device belongs to.
        """
    @overload
    def disconnect_terminal(self, terminal_id: int) -> None:
        r"""
        @brief Disconnects the given terminal from any net.
        If the terminal has been connected to a global, this connection will be disconnected too.
        """
    @overload
    def disconnect_terminal(self, terminal_name: str) -> None:
        r"""
        @brief Disconnects the given terminal from any net.
        This version accepts a terminal name. If the name is not a valid terminal name, an exception is raised.
        """
    def each_combined_abstract(self) -> Iterator[DeviceAbstractRef]:
        r"""
        @brief Iterates over the combined device specifications.
        This feature applies to combined devices. This iterator will deliver all device abstracts present in addition to the default device abstract.
        """
    def each_reconnected_terminal_for(self, terminal_id: int) -> Iterator[DeviceReconnectedTerminal]:
        r"""
        @brief Iterates over the reconnected terminal specifications for a given outer terminal.
        This feature applies to combined devices. This iterator will deliver all device-to-abstract terminal reroutings.
        """
    def expanded_name(self) -> str:
        r"""
        @brief Gets the expanded name of the device.
        The expanded name takes the name of the device. If the name is empty, the numeric ID will be used to build a name. 
        """
    def id(self) -> int:
        r"""
        @brief Gets the device ID.
        The ID is a unique integer which identifies the device.
        It can be used to retrieve the device from the circuit using \Circuit#device_by_id.
        When assigned, the device ID is not 0.
        """
    def is_combined_device(self) -> bool:
        r"""
        @brief Returns true, if the device is a combined device.
        Combined devices feature multiple device abstracts and device-to-abstract terminal connections.
        See \each_reconnected_terminal and \each_combined_abstract for more details.
        """
    @overload
    def net_for_terminal(self, terminal_id: int) -> Net:
        r"""
        @brief Gets the net connected to the specified terminal.
        If the terminal is not connected, nil is returned for the net.
        """
    @overload
    def net_for_terminal(self, terminal_name: str) -> Net:
        r"""
        @brief Gets the net connected to the specified terminal.
        If the terminal is not connected, nil is returned for the net.

        This convenience method has been introduced in version 0.27.3.
        """
    @overload
    def parameter(self, param_id: int) -> float:
        r"""
        @brief Gets the parameter value for the given parameter ID.
        """
    @overload
    def parameter(self, param_name: str) -> float:
        r"""
        @brief Gets the parameter value for the given parameter name.
        If the parameter name is not valid, an exception is thrown.
        """
    @overload
    def set_parameter(self, param_id: int, value: float) -> None:
        r"""
        @brief Sets the parameter value for the given parameter ID.
        """
    @overload
    def set_parameter(self, param_name: str, value: float) -> None:
        r"""
        @brief Sets the parameter value for the given parameter name.
        If the parameter name is not valid, an exception is thrown.
        """

class DeviceAbstract:
    r"""
    @brief A geometrical device abstract
    This class represents the geometrical model for the device. It links into the extracted layout to a cell which holds the terminal shapes for the device.

    This class has been added in version 0.26.
    """
    name: str
    r"""
    @brief Gets the name of the device abstract.
    @brief Sets the name of the device abstract.
    Device names are used to name a device abstract inside a netlist file. Device names should be unique within a netlist.
    """
    def __copy__(self) -> DeviceAbstract:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceAbstract) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cell_index(self) -> int:
        r"""
        @brief Gets the cell index of the device abstract.
        This is the cell that represents the device.
        """
    def cluster_id_for_terminal(self, terminal_id: int) -> int:
        r"""
        @brief Gets the cluster ID for the given terminal.
        The cluster ID links the terminal to geometrical shapes within the clusters of the cell (see \cell_index)
        """
    def device_class(self) -> DeviceClass:
        r"""
        @brief Gets the device class of the device.
        """
    def dup(self) -> DeviceAbstract:
        r"""
        @brief Creates a copy of self
        """
    def netlist(self) -> Netlist:
        r"""
        @brief Gets the netlist the device abstract lives in.
        """

class SubCircuit(NetlistObject):
    r"""
    @brief A subcircuit inside a circuit.
    Circuits may instantiate other circuits as subcircuits similar to cells in layouts. Such an instance is a subcircuit. A subcircuit refers to a circuit implementation (a \Circuit object), and presents connections through pins. The pins of a subcircuit can be connected to nets. The subcircuit pins are identical to the outgoing pins of the circuit the subcircuit refers to.

    Subcircuits connect to nets through the \SubCircuit#connect_pin method. SubCircuit pins can be disconnected using \SubCircuit#disconnect_pin.

    Subcircuit objects are created inside a circuit with \Circuit#create_subcircuit.

    This class has been added in version 0.26.
    """
    name: str
    r"""
    @brief Gets the name of the subcircuit.
    @brief Sets the name of the subcircuit.
    SubCircuit names are used to name a subcircuits inside a netlist file. SubCircuit names should be unique within a circuit.
    """
    trans: DCplxTrans
    r"""
    @brief Gets the physical transformation for the subcircuit.

    This property applies to subcircuits derived from a layout. It specifies the placement of the respective cell.

    This property has been introduced in version 0.27.@brief Sets the physical transformation for the subcircuit.

    See \trans for details about this property.

    This property has been introduced in version 0.27.
    """
    def _assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> SubCircuit:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def circuit(self) -> Circuit:
        r"""
        @brief Gets the circuit the subcircuit lives in.
        This is NOT the circuit which is referenced. For getting the circuit that the subcircuit references, use \circuit_ref.
        """
    def circuit_ref(self) -> Circuit:
        r"""
        @brief Gets the circuit referenced by the subcircuit.
        """
    @overload
    def connect_pin(self, pin: Pin, net: Net) -> None:
        r"""
        @brief Connects the given pin to the specified net.
        This version takes a \Pin reference instead of a pin ID.
        """
    @overload
    def connect_pin(self, pin_id: int, net: Net) -> None:
        r"""
        @brief Connects the given pin to the specified net.
        """
    @overload
    def disconnect_pin(self, pin: Pin) -> None:
        r"""
        @brief Disconnects the given pin from any net.
        This version takes a \Pin reference instead of a pin ID.
        """
    @overload
    def disconnect_pin(self, pin_id: int) -> None:
        r"""
        @brief Disconnects the given pin from any net.
        """
    def expanded_name(self) -> str:
        r"""
        @brief Gets the expanded name of the subcircuit.
        The expanded name takes the name of the subcircuit. If the name is empty, the numeric ID will be used to build a name. 
        """
    def id(self) -> int:
        r"""
        @brief Gets the subcircuit ID.
        The ID is a unique integer which identifies the subcircuit.
        It can be used to retrieve the subcircuit from the circuit using \Circuit#subcircuit_by_id.
        When assigned, the subcircuit ID is not 0.
        """
    def net_for_pin(self, pin_id: int) -> Net:
        r"""
        @brief Gets the net connected to the specified pin of the subcircuit.
        If the pin is not connected, nil is returned for the net.
        """

class NetTerminalRef:
    r"""
    @brief A connection to a terminal of a device.
    This object is used inside a net (see \Net) to describe the connections a net makes.

    This class has been added in version 0.26.
    """
    def __copy__(self) -> NetTerminalRef:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetTerminalRef) -> None:
        r"""
        @brief Assigns another object to self
        """
    def device(self) -> Device:
        r"""
        @brief Gets the device reference.
        Gets the device object that this connection is made to.
        """
    def device_class(self) -> DeviceClass:
        r"""
        @brief Gets the class of the device which is addressed.
        """
    def dup(self) -> NetTerminalRef:
        r"""
        @brief Creates a copy of self
        """
    def net(self) -> Net:
        r"""
        @brief Gets the net this terminal reference is attached to.
        """
    def terminal_def(self) -> DeviceTerminalDefinition:
        r"""
        @brief Gets the terminal definition of the terminal that is connected
        """
    def terminal_id(self) -> int:
        r"""
        @brief Gets the ID of the terminal of the device the connection is made to.
        """

class NetPinRef:
    r"""
    @brief A connection to an outgoing pin of the circuit.
    This object is used inside a net (see \Net) to describe the connections a net makes.

    This class has been added in version 0.26.
    """
    def __copy__(self) -> NetPinRef:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetPinRef) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetPinRef:
        r"""
        @brief Creates a copy of self
        """
    def net(self) -> Net:
        r"""
        @brief Gets the net this pin reference is attached to.
        """
    def pin(self) -> Pin:
        r"""
        @brief Gets the \Pin object of the pin the connection is made to.
        """
    def pin_id(self) -> int:
        r"""
        @brief Gets the ID of the pin the connection is made to.
        """

class NetSubcircuitPinRef:
    r"""
    @brief A connection to a pin of a subcircuit.
    This object is used inside a net (see \Net) to describe the connections a net makes.

    This class has been added in version 0.26.
    """
    def __copy__(self) -> NetSubcircuitPinRef:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetSubcircuitPinRef) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetSubcircuitPinRef:
        r"""
        @brief Creates a copy of self
        """
    def net(self) -> Net:
        r"""
        @brief Gets the net this pin reference is attached to.
        """
    def pin(self) -> Pin:
        r"""
        @brief Gets the \Pin object of the pin the connection is made to.
        """
    def pin_id(self) -> int:
        r"""
        @brief Gets the ID of the pin the connection is made to.
        """
    def subcircuit(self) -> SubCircuit:
        r"""
        @brief Gets the subcircuit reference.
        This attribute indicates the subcircuit the net attaches to. The subcircuit lives in the same circuit than the net. 
        """

class Net(NetlistObject):
    r"""
    @brief A single net.
    A net connects multiple pins or terminals together. Pins are either pin or subcircuits of outgoing pins of the circuit the net lives in. Terminals are connections made to specific terminals of devices.

    Net objects are created inside a circuit with \Circuit#create_net.

    To connect a net to an outgoing pin of a circuit, use \Circuit#connect_pin, to disconnect a net from an outgoing pin use \Circuit#disconnect_pin. To connect a net to a pin of a subcircuit, use \SubCircuit#connect_pin, to disconnect a net from a pin of a subcircuit, use \SubCircuit#disconnect_pin. To connect a net to a terminal of a device, use \Device#connect_terminal, to disconnect a net from a terminal of a device, use \Device#disconnect_terminal.

    This class has been added in version 0.26.
    """
    cluster_id: int
    r"""
    @brief Gets the cluster ID of the net.
    See \cluster_id= for details about the cluster ID.@brief Sets the cluster ID of the net.
    The cluster ID connects the net with a layout cluster. It is set when the net is extracted from a layout.
    """
    name: str
    r"""
    @brief Gets the name of the net.
    See \name= for details about the name.@brief Sets the name of the net.
    The name of the net is used for naming the net in schematic files for example. The name of the net has to be unique.
    """
    def __repr__(self) -> str:
        r"""
        Note: This is an alias of 'qname'.
        @brief Gets the qualified name.
        The qualified name is like the expanded name, but the circuit's name is preceded
        (i.e. 'CIRCUIT:NET') if available.
        """
    def __str__(self) -> str:
        r"""
        Note: This is an alias of 'qname'.
        @brief Gets the qualified name.
        The qualified name is like the expanded name, but the circuit's name is preceded
        (i.e. 'CIRCUIT:NET') if available.
        """
    def _assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> Net:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def circuit(self) -> Circuit:
        r"""
        @brief Gets the circuit the net lives in.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the net.
        """
    def each_pin(self) -> Iterator[NetPinRef]:
        r"""
        @brief Iterates over all outgoing pins the net connects.
        Pin connections are described by \NetPinRef objects. Pin connections are connections to outgoing pins of the circuit the net lives in.
        """
    def each_subcircuit_pin(self) -> Iterator[NetSubcircuitPinRef]:
        r"""
        @brief Iterates over all subcircuit pins the net connects.
        Subcircuit pin connections are described by \NetSubcircuitPinRef objects. These are connections to specific pins of subcircuits.
        """
    def each_terminal(self) -> Iterator[NetTerminalRef]:
        r"""
        @brief Iterates over all terminals the net connects.
        Terminals connect devices. Terminal connections are described by \NetTerminalRef objects.
        """
    def expanded_name(self) -> str:
        r"""
        @brief Gets the expanded name of the net.
        The expanded name takes the name of the net. If the name is empty, the cluster ID will be used to build a name. 
        """
    def is_floating(self) -> bool:
        r"""
        @brief Returns true, if the net is floating.
        Floating nets are those which don't have any device or subcircuit on it and are not connected through a pin.
        """
    def is_internal(self) -> bool:
        r"""
        @brief Returns true, if the net is an internal net.
        Internal nets are those which connect exactly two terminals and nothing else (pin_count = 0 and  terminal_count == 2).
        """
    def is_passive(self) -> bool:
        r"""
        @brief Returns true, if the net is passive.
        Passive nets don't have devices or subcircuits on it. They can be exposed through a pin.
        \is_floating? implies \is_passive?.

        This method has been introduced in version 0.26.1.
        """
    def pin_count(self) -> int:
        r"""
        @brief Returns the number of outgoing pins connected by this net.
        """
    def qname(self) -> str:
        r"""
        @brief Gets the qualified name.
        The qualified name is like the expanded name, but the circuit's name is preceded
        (i.e. 'CIRCUIT:NET') if available.
        """
    def subcircuit_pin_count(self) -> int:
        r"""
        @brief Returns the number of subcircuit pins connected by this net.
        """
    def terminal_count(self) -> int:
        r"""
        @brief Returns the number of terminals connected by this net.
        """
    def to_s(self) -> str:
        r"""
        Note: This is an alias of 'qname'.
        @brief Gets the qualified name.
        The qualified name is like the expanded name, but the circuit's name is preceded
        (i.e. 'CIRCUIT:NET') if available.
        """

class DeviceTerminalDefinition:
    r"""
    @brief A terminal descriptor
    This class is used inside the \DeviceClass class to describe a terminal of the device.

    This class has been added in version 0.26.
    """
    description: str
    r"""
    @brief Gets the description of the terminal.@brief Sets the description of the terminal.
    """
    name: str
    r"""
    @brief Gets the name of the terminal.@brief Sets the name of the terminal.
    """
    def __copy__(self) -> DeviceTerminalDefinition:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self, name: str, description: Optional[str] = ...) -> None:
        r"""
        @brief Creates a new terminal definition.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceTerminalDefinition) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DeviceTerminalDefinition:
        r"""
        @brief Creates a copy of self
        """
    def id(self) -> int:
        r"""
        @brief Gets the ID of the terminal.
        The ID of the terminal is used in some places to refer to a specific terminal (e.g. in the \NetTerminalRef object).
        """

class DeviceParameterDefinition:
    r"""
    @brief A parameter descriptor
    This class is used inside the \DeviceClass class to describe a parameter of the device.

    This class has been added in version 0.26.
    """
    default_value: float
    r"""
    @brief Gets the default value of the parameter.@brief Sets the default value of the parameter.
    The default value is used to initialize parameters of \Device objects.
    """
    description: str
    r"""
    @brief Gets the description of the parameter.@brief Sets the description of the parameter.
    """
    is_primary: bool
    r"""
    @brief Gets a value indicating whether the parameter is a primary parameter
    See \is_primary= for details about this predicate.@brief Sets a value indicating whether the parameter is a primary parameter
    If this flag is set to true (the default), the parameter is considered a primary parameter.
    Only primary parameters are compared by default.
    """
    name: str
    r"""
    @brief Gets the name of the parameter.@brief Sets the name of the parameter.
    """
    def __copy__(self) -> DeviceParameterDefinition:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self, name: str, description: Optional[str] = ..., default_value: Optional[float] = ..., is_primary: Optional[bool] = ..., si_scaling: Optional[float] = ...) -> None:
        r"""
        @brief Creates a new parameter definition.
        @param name The name of the parameter
        @param description The human-readable description
        @param default_value The initial value
        @param is_primary True, if the parameter is a primary parameter (see \is_primary=)
        @param si_scaling The scaling factor to SI units
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceParameterDefinition) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DeviceParameterDefinition:
        r"""
        @brief Creates a copy of self
        """
    def id(self) -> int:
        r"""
        @brief Gets the ID of the parameter.
        The ID of the parameter is used in some places to refer to a specific parameter (e.g. in the \NetParameterRef object).
        """
    def si_scaling(self) -> float:
        r"""
        @brief Gets the scaling factor to SI units.
        For parameters in micrometers for example, this factor will be 1e-6.
        """

class EqualDeviceParameters:
    r"""
    @brief A device parameter equality comparer.
    Attach this object to a device class with \DeviceClass#equal_parameters= to make the device class use this comparer:

    @code
    # 20nm tolerance for length:
    equal_device_parameters = RBA::EqualDeviceParameters::new(RBA::DeviceClassMOS4Transistor::PARAM_L, 0.02, 0.0)
    # one percent tolerance for width:
    equal_device_parameters += RBA::EqualDeviceParameters::new(RBA::DeviceClassMOS4Transistor::PARAM_W, 0.0, 0.01)
    # applies the compare delegate:
    netlist.device_class_by_name("NMOS").equal_parameters = equal_device_parameters
    @/code

    You can use this class to specify fuzzy equality criteria for the comparison of device parameters in netlist verification or to confine the equality of devices to certain parameters only.

    This class has been added in version 0.26.
    """
    @classmethod
    def ignore(cls, param_id: int) -> EqualDeviceParameters:
        r"""
        @brief Creates a device parameter comparer which ignores the parameter.

        This specification can be used to make a parameter ignored. Starting with version 0.27.4, all primary parameters are compared. Before 0.27.4, giving a tolerance meant only those parameters are compared. To exclude a primary parameter from the compare, use the 'ignore' specification for that parameter.

        This constructor has been introduced in version 0.27.4.
        """
    def __add__(self, other: EqualDeviceParameters) -> EqualDeviceParameters:
        r"""
        @brief Combines two parameters for comparison.
        The '+' operator will join the parameter comparers and produce one that checks the combined parameters.
        """
    def __copy__(self) -> EqualDeviceParameters:
        r"""
        @brief Creates a copy of self
        """
    def __iadd__(self, other: EqualDeviceParameters) -> EqualDeviceParameters:
        r"""
        @brief Combines two parameters for comparison (in-place).
        The '+=' operator will join the parameter comparers and produce one that checks the combined parameters.
        """
    def __init__(self, param_id: int, absolute: Optional[float] = ..., relative: Optional[float] = ...) -> None:
        r"""
        @brief Creates a device parameter comparer for a single parameter.
        'absolute' is the absolute deviation allowed for the parameter values. 'relative' is the relative deviation allowed for the parameter values (a value between 0 and 1).

        A value of 0 for both absolute and relative deviation means the parameters have to match exactly.

        If 'absolute' and 'relative' are both given, their deviations will add to the allowed difference between two parameter values. The relative deviation will be applied to the mean value of both parameter values. For example, when comparing parameter values of 40 and 60, a relative deviation of 0.35 means an absolute deviation of 17.5 (= 0.35 * average of 40 and 60) which does not make both values match.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: EqualDeviceParameters) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> EqualDeviceParameters:
        r"""
        @brief Creates a copy of self
        """
    def to_string(self) -> str:
        r"""
        @hide
        """

class GenericDeviceParameterCompare(EqualDeviceParameters):
    r"""
    @brief A class implementing the comparison of device parameters.
    Reimplement this class to provide a custom device parameter compare scheme.
    Attach this object to a device class with \DeviceClass#equal_parameters= to make the device class use this comparer.

    This class is intended for special cases. In most scenarios it is easier to use \EqualDeviceParameters instead of implementing a custom comparer class.

    This class has been added in version 0.26. The 'equal' method has been dropped in 0.27.1 as it can be expressed as !less(a,b) && !less(b,a).
    """
    def _assign(self, other: EqualDeviceParameters) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> GenericDeviceParameterCompare:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def less(self, device_a: Device, device_b: Device) -> bool:
        r"""
        @brief Compares the parameters of two devices for a begin less than b. Returns true, if the parameters of device a are considered less than those of device b.The 'less' implementation needs to ensure strict weak ordering. Specifically, less(a,b) == false and less(b,a) implies that a is equal to b and less(a,b) == true implies that less(b,a) is false and vice versa. If not, an internal error will be encountered on netlist compare.
        """

class GenericDeviceCombiner:
    r"""
    @brief A class implementing the combination of two devices (parallel or serial mode).
    Reimplement this class to provide a custom device combiner.
    Device combination requires 'supports_paralell_combination' or 'supports_serial_combination' to be set to true for the device class. In the netlist device combination step, the algorithm will try to identify devices which can be combined into single devices and use the combiner object to implement the actual joining of such devices.

    Attach this object to a device class with \DeviceClass#combiner= to make the device class use this combiner.

    This class has been added in version 0.27.3.
    """
    def __copy__(self) -> GenericDeviceCombiner:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: GenericDeviceCombiner) -> None:
        r"""
        @brief Assigns another object to self
        """
    def combine_devices(self, device_a: Device, device_b: Device) -> bool:
        r"""
        @brief Combines two devices if possible.
        This method needs to test, whether the two devices can be combined. Both devices are guaranteed to share the same device class. If they cannot be combined, this method shall do nothing and return false. If they can be combined, this method shall reconnect the nets of the first device and entirely disconnect the nets of the second device. The second device will be deleted afterwards. 
        """
    def dup(self) -> GenericDeviceCombiner:
        r"""
        @brief Creates a copy of self
        """

class DeviceClass:
    r"""
    @brief A class describing a specific type of device.
    Device class objects live in the context of a \Netlist object. After a device class is created, it must be added to the netlist using \Netlist#add. The netlist will own the device class object. When the netlist is destroyed, the device class object will become invalid.

    The \DeviceClass class is the base class for other device classes.

    This class has been added in version 0.26. In version 0.27.3, the 'GenericDeviceClass' has been integrated with \DeviceClass and the device class was made writeable in most respects. This enables manipulating built-in device classes.
    """
    combiner: GenericDeviceCombiner
    r"""
    @brief Gets a device combiner or nil if none is registered.

    This method has been added in version 0.27.3.
    @brief Specifies a device combiner (parallel or serial device combination).

    You can assign nil for the combiner to remove it.

    In special cases, you can even implement a custom combiner by deriving your own comparer from the \GenericDeviceCombiner class.

    This method has been added in version 0.27.3.
    """
    description: str
    r"""
    @brief Gets the description text of the device class.@brief Sets the description of the device class.
    """
    equal_parameters: EqualDeviceParameters
    r"""
    @brief Gets the device parameter comparer for netlist verification or nil if no comparer is registered.
    See \equal_parameters= for the setter.

    This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
    @brief Specifies a device parameter comparer for netlist verification.
    By default, all devices are compared with all parameters. If you want to select only certain parameters for comparison or use a fuzzy compare criterion, use an \EqualDeviceParameters object and assign it to the device class of one netlist. You can also chain multiple \EqualDeviceParameters objects with the '+' operator for specifying multiple parameters in the equality check.

    You can assign nil for the parameter comparer to remove it.

    In special cases, you can even implement a custom compare scheme by deriving your own comparer from the \GenericDeviceParameterCompare class.

    This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
    """
    name: str
    r"""
    @brief Gets the name of the device class.@brief Sets the name of the device class.
    """
    strict: bool
    r"""
    @brief Gets a value indicating whether this class performs strict terminal mapping
    See \strict= for details about this attribute.@brief Sets a value indicating whether this class performs strict terminal mapping

    Classes with this flag set never allow terminal swapping, even if the device symmetry supports that. If two classes are involved in a netlist compare,
    terminal swapping will be disabled if one of the classes is in strict mode.

    By default, device classes are not strict and terminal swapping is allowed as far as the device symmetry supports that.
    """
    supports_parallel_combination: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Specifies whether the device supports parallel device combination.
    Parallel device combination means that all terminals of two combination candidates are connected to the same nets. If the device does not support this combination mode, this predicate can be set to false. This will make the device extractor skip the combination test in parallel mode and improve performance somewhat.

    This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
    """
    supports_serial_combination: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Specifies whether the device supports serial device combination.
    Serial device combination means that the devices are connected by internal nodes. If the device does not support this combination mode, this predicate can be set to false. This will make the device extractor skip the combination test in serial mode and improve performance somewhat.

    This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
    """
    def __copy__(self) -> DeviceClass:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def add_parameter(self, parameter_def: DeviceParameterDefinition) -> None:
        r"""
        @brief Adds the given parameter definition to the device class
        This method will define a new parameter. The new parameter is added at the end of existing parameters. The parameter definition object passed as the argument is modified to contain the new ID of the parameter.
        The parameter is copied into the device class. Modifying the parameter object later does not have the effect of changing the parameter definition.

        This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
        """
    def add_terminal(self, terminal_def: DeviceTerminalDefinition) -> None:
        r"""
        @brief Adds the given terminal definition to the device class
        This method will define a new terminal. The new terminal is added at the end of existing terminals. The terminal definition object passed as the argument is modified to contain the new ID of the terminal.

        The terminal is copied into the device class. Modifying the terminal object later does not have the effect of changing the terminal definition.

        This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
        """
    def assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear_equivalent_terminal_ids(self) -> None:
        r"""
        @brief Clears all equivalent terminal ids

        This method has been added in version 0.27.3.
        """
    def clear_parameters(self) -> None:
        r"""
        @brief Clears the list of parameters

        This method has been added in version 0.27.3.
        """
    def clear_terminals(self) -> None:
        r"""
        @brief Clears the list of terminals

        This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
        """
    def dup(self) -> DeviceClass:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def enable_parameter(self, parameter_id: int, enable: bool) -> None:
        r"""
        @brief Enables or disables a parameter.
        Some parameters are 'secondary' parameters which are extracted but not handled in device compare and are not shown in the netlist browser. For example, the 'W' parameter of the resistor is such a secondary parameter. This method allows turning a parameter in a primary one ('enable') or into a secondary one ('disable').

        This method has been introduced in version 0.27.3.
        """
    @overload
    def enable_parameter(self, parameter_name: str, enable: bool) -> None:
        r"""
        @brief Enables or disables a parameter.
        Some parameters are 'secondary' parameters which are extracted but not handled in device compare and are not shown in the netlist browser. For example, the 'W' parameter of the resistor is such a secondary parameter. This method allows turning a parameter in a primary one ('enable') or into a secondary one ('disable').

        This version accepts a parameter name.

        This method has been introduced in version 0.27.3.
        """
    def equivalent_terminal_id(self, original_id: int, equivalent_id: int) -> None:
        r"""
        @brief Specifies a terminal to be equivalent to another.
        Use this method to specify two terminals to be exchangeable. For example to make S and D of a MOS transistor equivalent, call this method with S and D terminal IDs. In netlist matching, S will be translated to D and thus made equivalent to D.

        Note that terminal equivalence is not effective if the device class operates in strict mode (see \DeviceClass#strict=).

        This method has been moved from 'GenericDeviceClass' to 'DeviceClass' in version 0.27.3.
        """
    def has_parameter(self, name: str) -> bool:
        r"""
        @brief Returns true, if the device class has a parameter with the given name.
        """
    def has_terminal(self, name: str) -> bool:
        r"""
        @brief Returns true, if the device class has a terminal with the given name.
        """
    def id(self) -> int:
        r"""
        @brief Gets the unique ID of the device class
        The ID is a unique integer that identifies the device class. Use the ID to check for object identity - i.e. to determine whether two devices share the same device class.
        """
    def netlist(self) -> Netlist:
        r"""
        @brief Gets the netlist the device class lives in.
        """
    @overload
    def parameter_definition(self, parameter_id: int) -> DeviceParameterDefinition:
        r"""
        @brief Gets the parameter definition object for a given ID.
        Parameter definition IDs are used in some places to reference a specific parameter of a device. This method obtains the corresponding definition object.
        """
    @overload
    def parameter_definition(self, parameter_name: str) -> DeviceParameterDefinition:
        r"""
        @brief Gets the parameter definition object for a given ID.
        Parameter definition IDs are used in some places to reference a specific parameter of a device. This method obtains the corresponding definition object.
        This version accepts a parameter name.

        This method has been introduced in version 0.27.3.
        """
    def parameter_definitions(self) -> List[DeviceParameterDefinition]:
        r"""
        @brief Gets the list of parameter definitions of the device.
        See the \DeviceParameterDefinition class description for details.
        """
    def parameter_id(self, name: str) -> int:
        r"""
        @brief Returns the parameter ID of the parameter with the given name.
        An exception is thrown if there is no parameter with the given name. Use \has_parameter to check whether the name is a valid parameter name.
        """
    def terminal_definition(self, terminal_id: int) -> DeviceTerminalDefinition:
        r"""
        @brief Gets the terminal definition object for a given ID.
        Terminal definition IDs are used in some places to reference a specific terminal of a device. This method obtains the corresponding definition object.
        """
    def terminal_definitions(self) -> List[DeviceTerminalDefinition]:
        r"""
        @brief Gets the list of terminal definitions of the device.
        See the \DeviceTerminalDefinition class description for details.
        """
    def terminal_id(self, name: str) -> int:
        r"""
        @brief Returns the terminal ID of the terminal with the given name.
        An exception is thrown if there is no terminal with the given name. Use \has_terminal to check whether the name is a valid terminal name.
        """

class Circuit(NetlistObject):
    r"""
    @brief Circuits are the basic building blocks of the netlist
    A circuit has pins by which it can connect to the outside. Pins are created using \create_pin and are represented by the \Pin class.

    Furthermore, a circuit manages the components of the netlist. Components are devices (class \Device) and subcircuits (class \SubCircuit). Devices are basic devices such as resistors or transistors. Subcircuits are other circuits to which nets from this circuit connect. Devices are created using the \create_device method. Subcircuits are created using the \create_subcircuit method.

    Devices are connected through 'terminals', subcircuits are connected through their pins. Terminals and pins are described by integer ID's in the context of most methods.

    Finally, the circuit consists of the nets. Nets connect terminals of devices and pins of subcircuits or the circuit itself. Nets are created using \create_net and are represented by objects of the \Net class.
    See there for more about nets.

    The Circuit object is only valid if the netlist object is alive. Circuits must be added to a netlist using \Netlist#add to become part of the netlist.

    The Circuit class has been introduced in version 0.26.
    """
    boundary: DPolygon
    r"""
    @brief Gets the boundary of the circuit@brief Sets the boundary of the circuit
    """
    cell_index: int
    r"""
    @brief Gets the cell index of the circuit
    See \cell_index= for details.
    @brief Sets the cell index
    The cell index relates a circuit with a cell from a layout. It's intended to hold a cell index number if the netlist was extracted from a layout.
    """
    dont_purge: bool
    r"""
    @brief Gets a value indicating whether the circuit can be purged on \Netlist#purge.
    @brief Sets a value indicating whether the circuit can be purged on \Netlist#purge.
    If this attribute is set to true, \Netlist#purge will never delete this circuit.
    This flag therefore marks this circuit as 'precious'.
    """
    name: str
    r"""
    @brief Gets the name of the circuit@brief Sets the name of the circuit
    """
    def _assign(self, other: NetlistObject) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> Circuit:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def blank(self) -> None:
        r"""
        @brief Blanks out the circuit
        This method will remove all the innards of the circuit and just leave the pins. The pins won't be connected to inside nets anymore, but the circuit can still be called by subcircuit references. This method will eventually create a 'circuit abstract' (or black box). It will set the \dont_purge flag to mark this circuit as 'intentionally empty'.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the circuit
        This method removes all objects and clears the other attributes.
        """
    def combine_devices(self) -> None:
        r"""
        @brief Combines devices where possible
        This method will combine devices that can be combined according to their device classes 'combine_devices' method.
        For example, serial or parallel resistors can be combined into a single resistor.
        """
    @overload
    def connect_pin(self, pin: Pin, net: Net) -> None:
        r"""
        @brief Connects the given pin with the given net.
        The net and the pin must be objects from inside the circuit. Any previous connected is resolved before this connection is made. A pin can only be connected to one net at a time.
        """
    @overload
    def connect_pin(self, pin_id: int, net: Net) -> None:
        r"""
        @brief Connects the given pin with the given net.
        The net must be one inside the circuit. Any previous connected is resolved before this connection is made. A pin can only be connected to one net at a time.
        """
    def create_device(self, device_class: DeviceClass, name: Optional[str] = ...) -> Device:
        r"""
        @brief Creates a new bound \Device object inside the circuit
        This object describes a device of the circuit. The device is already attached to the device class. The name is optional and is used to identify the device in a netlist file.

        For more details see the \Device class.
        """
    def create_net(self, name: Optional[str] = ...) -> Net:
        r"""
        @brief Creates a new \Net object inside the circuit
        This object will describe a net of the circuit. The nets are basically connections between the different components of the circuit (subcircuits, devices and pins).

        A net needs to be filled with references to connect to specific objects. See the \Net class for more details.
        """
    def create_pin(self, name: str) -> Pin:
        r"""
        @brief Creates a new \Pin object inside the circuit
        This object will describe a pin of the circuit. A circuit connects to the outside through such a pin. The pin is added after all existing pins. For more details see the \Pin class.

        Starting with version 0.26.8, this method returns a reference to a \Pin object rather than a copy.
        """
    def create_subcircuit(self, circuit: Circuit, name: Optional[str] = ...) -> SubCircuit:
        r"""
        @brief Creates a new bound \SubCircuit object inside the circuit
        This object describes an instance of another circuit inside the circuit. The subcircuit is already attached to the other circuit. The name is optional and is used to identify the subcircuit in a netlist file.

        For more details see the \SubCircuit class.
        """
    def device_by_id(self, id: int) -> Device:
        r"""
        @brief Gets the device object for a given ID.
        If the ID is not a valid device ID, nil is returned.
        """
    def device_by_name(self, name: str) -> Device:
        r"""
        @brief Gets the device object for a given name.
        If the ID is not a valid device name, nil is returned.
        """
    @overload
    def disconnect_pin(self, pin: Pin) -> None:
        r"""
        @brief Disconnects the given pin from any net.
        """
    @overload
    def disconnect_pin(self, pin_id: int) -> None:
        r"""
        @brief Disconnects the given pin from any net.
        """
    def each_child(self) -> Iterator[Circuit]:
        r"""
        @brief Iterates over the child circuits of this circuit
        Child circuits are the ones that are referenced from this circuit via subcircuits.
        """
    def each_device(self) -> Iterator[Device]:
        r"""
        @brief Iterates over the devices of the circuit
        """
    def each_net(self) -> Iterator[Net]:
        r"""
        @brief Iterates over the nets of the circuit
        """
    def each_parent(self) -> Iterator[Circuit]:
        r"""
        @brief Iterates over the parent circuits of this circuit
        Child circuits are the ones that are referencing this circuit via subcircuits.
        """
    def each_pin(self) -> Iterator[Pin]:
        r"""
        @brief Iterates over the pins of the circuit
        """
    def each_ref(self) -> Iterator[SubCircuit]:
        r"""
        @brief Iterates over the subcircuit objects referencing this circuit
        """
    def each_subcircuit(self) -> Iterator[SubCircuit]:
        r"""
        @brief Iterates over the subcircuits of the circuit
        """
    def flatten_subcircuit(self, subcircuit: SubCircuit) -> None:
        r"""
        @brief Flattens a subcircuit
        This method will substitute the given subcircuit by it's contents. The subcircuit is removed after this.
        """
    def has_refs(self) -> bool:
        r"""
        @brief Returns a value indicating whether the circuit has references
        A circuit has references if there is at least one subcircuit referring to it.
        """
    def join_nets(self, net: Net, with_: Net) -> None:
        r"""
        @brief Joins (connects) two nets into one
        This method will connect the 'with' net with 'net' and remove 'with'.

        This method has been introduced in version 0.26.4.
        """
    def net_by_cluster_id(self, cluster_id: int) -> Net:
        r"""
        @brief Gets the net object corresponding to a specific cluster ID
        If the ID is not a valid pin cluster ID, nil is returned.
        """
    def net_by_name(self, name: str) -> Net:
        r"""
        @brief Gets the net object for a given name.
        If the ID is not a valid net name, nil is returned.
        """
    @overload
    def net_for_pin(self, pin: Pin) -> Net:
        r"""
        @brief Gets the net object attached to a specific pin.
        This is the net object inside the circuit which attaches to the given outward-bound pin.
        This method returns nil if the pin is not connected or the pin object is nil.
        """
    @overload
    def net_for_pin(self, pin_id: int) -> Net:
        r"""
        @brief Gets the net object attached to a specific pin.
        This is the net object inside the circuit which attaches to the given outward-bound pin.
        This method returns nil if the pin is not connected or the pin ID is invalid.
        """
    def netlist(self) -> Netlist:
        r"""
        @brief Gets the netlist object the circuit lives in
        """
    def nets_by_name(self, name_pattern: str) -> List[Net]:
        r"""
        @brief Gets the net objects for a given name filter.
        The name filter is a glob pattern. This method will return all \Net objects matching the glob pattern.

        This method has been introduced in version 0.27.3.
        """
    def pin_by_id(self, id: int) -> Pin:
        r"""
        @brief Gets the \Pin object corresponding to a specific ID
        If the ID is not a valid pin ID, nil is returned.
        """
    def pin_by_name(self, name: str) -> Pin:
        r"""
        @brief Gets the \Pin object corresponding to a specific name
        If the ID is not a valid pin name, nil is returned.
        """
    def pin_count(self) -> int:
        r"""
        @brief Gets the number of pins in the circuit
        """
    def purge_nets(self) -> None:
        r"""
        @brief Purges floating nets.
        Floating nets are nets with no device or subcircuit attached to. Such floating nets are removed in this step. If these nets are connected outward to a circuit pin, this circuit pin is also removed.
        """
    def purge_nets_keep_pins(self) -> None:
        r"""
        @brief Purges floating nets but keep pins.
        This method will remove floating nets like \purge_nets, but if these nets are attached to a pin, the pin will be left disconnected from any net.

        This method has been introduced in version 0.26.2.
        """
    def remove_device(self, device: Device) -> None:
        r"""
        @brief Removes the given device from the circuit
        """
    def remove_net(self, net: Net) -> None:
        r"""
        @brief Removes the given net from the circuit
        """
    def remove_pin(self, id: int) -> None:
        r"""
        @brief Removes the pin with the given ID from the circuit

        This method has been introduced in version 0.26.2.
        """
    def remove_subcircuit(self, subcircuit: SubCircuit) -> None:
        r"""
        @brief Removes the given subcircuit from the circuit
        """
    def rename_pin(self, id: int, new_name: str) -> None:
        r"""
        @brief Renames the pin with the given ID to 'new_name'

        This method has been introduced in version 0.26.8.
        """
    def subcircuit_by_id(self, id: int) -> SubCircuit:
        r"""
        @brief Gets the subcircuit object for a given ID.
        If the ID is not a valid subcircuit ID, nil is returned.
        """
    def subcircuit_by_name(self, name: str) -> SubCircuit:
        r"""
        @brief Gets the subcircuit object for a given name.
        If the ID is not a valid subcircuit name, nil is returned.
        """

class Netlist:
    r"""
    @brief The netlist top-level class
    A netlist is a hierarchical structure of circuits. At least one circuit is the top-level circuit, other circuits may be referenced as subcircuits.
    Circuits are created with \create_circuit and are represented by objects of the \Circuit class.

    Beside circuits, the netlist manages device classes. Device classes describe specific types of devices. Device classes are represented by objects of the \DeviceClass class and are created using \create_device_class.

    The netlist class has been introduced with version 0.26.
    """
    case_sensitive: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets a value indicating whether the netlist names are case sensitive
    This method has been added in version 0.27.3.
    """
    def __copy__(self) -> Netlist:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the netlist to a string representation.
        This method is intended for test purposes mainly.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the netlist to a string representation.
        This method is intended for test purposes mainly.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    @overload
    def add(self, circuit: Circuit) -> None:
        r"""
        @brief Adds the circuit to the netlist
        This method will add the given circuit object to the netlist. After the circuit has been added, it will be owned by the netlist.
        """
    @overload
    def add(self, device_class: DeviceClass) -> None:
        r"""
        @brief Adds the device class to the netlist
        This method will add the given device class object to the netlist. After the device class has been added, it will be owned by the netlist.
        """
    def assign(self, other: Netlist) -> None:
        r"""
        @brief Assigns another object to self
        """
    def blank_circuit(self, pattern: str) -> None:
        r"""
        @brief Blanks circuits matching a certain pattern
        This method will erase everything from inside the circuits matching the given pattern. It will only leave pins which are not connected to any net. Hence, this method forms 'abstract' or black-box circuits which can be instantiated through subcircuits like the former ones, but are empty shells.
        The name pattern is a glob expression. For example, 'blank_circuit("np*")' will blank out all circuits with names starting with 'np'.

        For more details see \Circuit#blank which is the corresponding method on the actual object.
        """
    def circuit_by_cell_index(self, cell_index: int) -> Circuit:
        r"""
        @brief Gets the circuit object for a given cell index.
        If the cell index is not valid or no circuit is registered with this index, nil is returned.
        """
    def circuit_by_name(self, name: str) -> Circuit:
        r"""
        @brief Gets the circuit object for a given name.
        If the name is not a valid circuit name, nil is returned.
        """
    def circuits_by_name(self, name_pattern: str) -> List[Circuit]:
        r"""
        @brief Gets the circuit objects for a given name filter.
        The name filter is a glob pattern. This method will return all \Circuit objects matching the glob pattern.

        This method has been introduced in version 0.26.4.
        """
    def combine_devices(self) -> None:
        r"""
        @brief Combines devices where possible
        This method will combine devices that can be combined according to their device classes 'combine_devices' method.
        For example, serial or parallel resistors can be combined into a single resistor.
        """
    def device_class_by_name(self, name: str) -> DeviceClass:
        r"""
        @brief Gets the device class for a given name.
        If the name is not a valid device class name, nil is returned.
        """
    def dup(self) -> Netlist:
        r"""
        @brief Creates a copy of self
        """
    def each_circuit(self) -> Iterator[Circuit]:
        r"""
        @brief Iterates over the circuits of the netlist
        """
    def each_circuit_bottom_up(self) -> Iterator[Circuit]:
        r"""
        @brief Iterates over the circuits bottom-up
        Iterating bottom-up means the parent circuits come after the child circuits. This is the basically the reverse order as delivered by \each_circuit_top_down.
        """
    def each_circuit_top_down(self) -> Iterator[Circuit]:
        r"""
        @brief Iterates over the circuits top-down
        Iterating top-down means the parent circuits come before the child circuits. The first \top_circuit_count circuits are top circuits - i.e. those which are not referenced by other circuits.
        """
    def each_device_class(self) -> Iterator[DeviceClass]:
        r"""
        @brief Iterates over the device classes of the netlist
        """
    def flatten(self) -> None:
        r"""
        @brief Flattens all circuits of the netlist
        After calling this method, only the top circuits will remain.
        """
    @overload
    def flatten_circuit(self, circuit: Circuit) -> None:
        r"""
        @brief Flattens a subcircuit
        This method will substitute all instances (subcircuits) of the given circuit by it's contents. After this, the circuit is removed.
        """
    @overload
    def flatten_circuit(self, pattern: str) -> None:
        r"""
        @brief Flattens circuits matching a certain pattern
        This method will substitute all instances (subcircuits) of all circuits with names matching the given name pattern. The name pattern is a glob expression. For example, 'flatten_circuit("np*")' will flatten all circuits with names starting with 'np'.
        """
    def flatten_circuits(self, arg0: Sequence[Circuit]) -> None:
        r"""
        @brief Flattens all given circuits of the netlist
        This method is equivalent to calling \flatten_circuit for all given circuits, but more efficient.

        This method has been introduced in version 0.26.1
        """
    def from_s(self, str: str) -> None:
        r"""
        @brief Reads the netlist from a string representation.
        This method is intended for test purposes mainly. It turns a string returned by \to_s back into a netlist. Note that the device classes must be created before as they are not persisted inside the string.
        """
    def is_case_sensitive(self) -> bool:
        r"""
        @brief Returns a value indicating whether the netlist names are case sensitive
        This method has been added in version 0.27.3.
        """
    def make_top_level_pins(self) -> None:
        r"""
        @brief Creates pins for top-level circuits.
        This method will turn all named nets of top-level circuits (such that are not referenced by subcircuits) into pins. This method can be used before purge to avoid that purge will remove nets which are directly connecting to subcircuits.
        """
    def purge(self) -> None:
        r"""
        @brief Purge unused nets, circuits and subcircuits.
        This method will purge all nets which return \floating == true. Circuits which don't have any nets (or only floating ones) and removed. Their subcircuits are disconnected.
        This method respects the \Circuit#dont_purge attribute and will never delete circuits with this flag set.
        """
    def purge_circuit(self, circuit: Circuit) -> None:
        r"""
        @brief Removes the given circuit object and all child circuits which are not used otherwise from the netlist
        After the circuit has been removed, the object becomes invalid and cannot be used further. A circuit with references (see \has_refs?) should not be removed as the subcircuits calling it would afterwards point to nothing.
        """
    def purge_nets(self) -> None:
        r"""
        @brief Purges floating nets.
        Floating nets can be created as effect of reconnections of devices or pins. This method will eliminate all nets that make less than two connections.
        """
    def read(self, file: str, reader: NetlistReader) -> None:
        r"""
        @brief Writes the netlist to the given file using the given reader object to parse the file
        See \NetlistSpiceReader for an example for a parser. 
        """
    @overload
    def remove(self, circuit: Circuit) -> None:
        r"""
        @brief Removes the given circuit object from the netlist
        After the circuit has been removed, the object becomes invalid and cannot be used further. A circuit with references (see \has_refs?) should not be removed as the subcircuits calling it would afterwards point to nothing.
        """
    @overload
    def remove(self, device_class: DeviceClass) -> None:
        r"""
        @brief Removes the given device class object from the netlist
        After the object has been removed, it becomes invalid and cannot be used further. Use this method with care as it may corrupt the internal structure of the netlist. Only use this method when device refers to this device class.
        """
    def simplify(self) -> None:
        r"""
        @brief Convenience method that combines the simplification.
        This method is a convenience method that runs \make_top_level_pins, \purge, \combine_devices and \purge_nets.
        """
    def to_s(self) -> str:
        r"""
        @brief Converts the netlist to a string representation.
        This method is intended for test purposes mainly.
        """
    def top_circuit_count(self) -> int:
        r"""
        @brief Gets the number of top circuits.
        Top circuits are those which are not referenced by other circuits via subcircuits. A well-formed netlist has a single top circuit.
        """
    def write(self, file: str, writer: NetlistWriter, description: Optional[str] = ...) -> None:
        r"""
        @brief Writes the netlist to the given file using the given writer object to format the file
        See \NetlistSpiceWriter for an example for a formatter. The description is an arbitrary text which will be put into the file somewhere at the beginning.
        """

class NetlistSpiceWriterDelegate:
    r"""
    @brief Provides a delegate for the SPICE writer for doing special formatting for devices
    Supply a customized class to provide a specialized writing scheme for devices. You need a customized class if you want to implement special devices or you want to use subcircuits rather than the built-in devices.

    See \NetlistSpiceWriter for more details.

    This class has been introduced in version 0.26.
    """
    def __copy__(self) -> NetlistSpiceWriterDelegate:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistSpiceWriterDelegate) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetlistSpiceWriterDelegate:
        r"""
        @brief Creates a copy of self
        """
    def emit_comment(self, comment: str) -> None:
        r"""
        @brief Writes the given comment into the file
        """
    def emit_line(self, line: str) -> None:
        r"""
        @brief Writes the given line into the file
        """
    def format_name(self, name: str) -> str:
        r"""
        @brief Formats the given name in a SPICE-compatible way
        """
    def net_to_string(self, net: Net) -> str:
        r"""
        @brief Gets the node ID for the given net
        The node ID is a numeric string instead of the full name of the net. Numeric IDs are used within SPICE netlist because they are usually shorter.
        """
    def write_device(self, device: Device) -> None:
        r"""
        @hide
        """
    @overload
    def write_device_intro(self, arg0: DeviceClass) -> None:
        r"""
        @hide
        """
    @overload
    def write_device_intro(self, device_class: DeviceClass) -> None:
        r"""
        @brief Inserts a text for the given device class
        Reimplement this method to insert your own text at the beginning of the file for the given device class
        """
    def write_header(self) -> None:
        r"""
        @hide
        """

class NetlistWriter:
    r"""
    @brief Base class for netlist writers
    This class is provided as a base class for netlist writers. It is not intended for reimplementation on script level, but used internally as an interface.

    This class has been introduced in version 0.26.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class NetlistSpiceWriter(NetlistWriter):
    r"""
    @brief Implements a netlist writer for the SPICE format.
    Provide a delegate for customizing the way devices are written.

    Use the SPICE writer like this:

    @code
    writer = RBA::NetlistSpiceWriter::new
    netlist.write(path, writer)
    @/code

    You can give a custom description for the headline:

    @code
    writer = RBA::NetlistSpiceWriter::new
    netlist.write(path, writer, "A custom description")
    @/code

    To customize the output, you can use a device writer delegate.
    The delegate is an object of a class derived from \NetlistSpiceWriterDelegate which reimplements several methods to customize the following parts:

    @ul
    @li A global header (\NetlistSpiceWriterDelegate#write_header): this method is called to print the part right after the headline @/li
    @li A per-device class header (\NetlistSpiceWriterDelegate#write_device_intro): this method is called for every device class and may print device-class specific headers (e.g. model definitions) @/li
    @li Per-device output: this method (\NetlistSpiceWriterDelegate#write_device): this method is called for every device and may print the device statement(s) in a specific way. @/li
    @/ul

    The delegate must use \NetlistSpiceWriterDelegate#emit_line to print a line, \NetlistSpiceWriterDelegate#emit_comment to print a comment etc.
    For more method see \NetlistSpiceWriterDelegate.

    A sample with a delegate is this:

    @code
    class MyDelegate < RBA::NetlistSpiceWriterDelegate

      def write_header
        emit_line("*** My special header")
      end

      def write_device_intro(cls)
        emit_comment("My intro for class " + cls.name)
      end

      def write_device(dev)
        if dev.device_class.name != "MYDEVICE"
          emit_comment("Terminal #1: " + net_to_string(dev.net_for_terminal(0)))
          emit_comment("Terminal #2: " + net_to_string(dev.net_for_terminal(1)))
          super(dev)
          emit_comment("After device " + dev.expanded_name)
        else
          super(dev)
        end
      end

    end

    # write the netlist with delegate:
    writer = RBA::NetlistSpiceWriter::new(MyDelegate::new)
    netlist.write(path, writer)
    @/code

    This class has been introduced in version 0.26.
    """
    use_net_names: bool
    r"""
    @brief Gets a value indicating whether to use net names (true) or net numbers (false).
    @brief Sets a value indicating whether to use net names (true) or net numbers (false).
    The default is to use net numbers.
    """
    with_comments: bool
    r"""
    @brief Gets a value indicating whether to embed comments for position etc. (true) or not (false).
    @brief Sets a value indicating whether to embed comments for position etc. (true) or not (false).
    The default is to embed comments.
    """
    def __copy__(self) -> NetlistSpiceWriter:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a new writer without delegate.
        """
    @overload
    def __init__(self, arg0: NetlistSpiceWriterDelegate) -> None:
        r"""
        @brief Creates a new writer with a delegate.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistWriter) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetlistSpiceWriter:
        r"""
        @brief Creates a copy of self
        """

class NetlistReader:
    r"""
    @brief Base class for netlist readers
    This class is provided as a base class for netlist readers. It is not intended for reimplementation on script level, but used internally as an interface.

    This class has been introduced in version 0.26.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class ParseElementComponentsData:
    r"""
    @brief Supplies the return value for \NetlistSpiceReaderDelegate#parse_element_components.
    This is a structure with two members: 'strings' for the string arguments and 'parameters' for the named numerical arguments.

    This helper class has been introduced in version 0.27.1.
    """
    parameters: Dict[str, float]
    r"""
    @brief Gets the (named) numerical parameters
    @brief Sets the (named) numerical parameters
    """
    strings: List[str]
    r"""
    @brief Gets the string parameters
    @brief Sets the string parameters
    """
    def __copy__(self) -> ParseElementComponentsData:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ParseElementComponentsData) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> ParseElementComponentsData:
        r"""
        @brief Creates a copy of self
        """

class ParseElementData:
    r"""
    @brief Supplies the return value for \NetlistSpiceReaderDelegate#parse_element.
    This is a structure with four members: 'model_name' for the model name, 'value' for the default numerical value, 'net_names' for the net names and 'parameters' for the named numerical parameters.

    This helper class has been introduced in version 0.27.1.
    """
    model_name: str
    r"""
    @brief Gets the model name
    @brief Sets the model name
    """
    net_names: List[str]
    r"""
    @brief Gets the net names
    @brief Sets the net names
    """
    parameters: Dict[str, float]
    r"""
    @brief Gets the (named) numerical parameters
    @brief Sets the (named) numerical parameters
    """
    value: float
    r"""
    @brief Gets the value
    @brief Sets the value
    """
    def __copy__(self) -> ParseElementData:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ParseElementData) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> ParseElementData:
        r"""
        @brief Creates a copy of self
        """

class NetlistSpiceReaderDelegate:
    r"""
    @brief Provides a delegate for the SPICE reader for translating device statements
    Supply a customized class to provide a specialized reading scheme for devices. You need a customized class if you want to implement device reading from model subcircuits or to translate device parameters.

    See \NetlistSpiceReader for more details.

    This class has been introduced in version 0.26.
    """
    def __copy__(self) -> NetlistSpiceReaderDelegate:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistSpiceReaderDelegate) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def control_statement(self, arg0: str) -> bool:
        r"""
        @hide
        """
    @overload
    def control_statement(self, line: str) -> bool:
        r"""
        @brief Receives control statements not understood by the standard reader
        When the reader encounters a control statement not understood by the parser, it will pass the line to the delegate using this method.
        The delegate can decide if it wants to read this statement. It should return true in this case.

        This method has been introduced in version 0.27.1
        """
    def dup(self) -> NetlistSpiceReaderDelegate:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def element(self, arg0: Circuit, arg1: str, arg2: str, arg3: str, arg4: float, arg5: Sequence[Net], arg6: Dict[str, float]) -> bool:
        r"""
        @hide
        """
    @overload
    def element(self, circuit: Circuit, element: str, name: str, model: str, value: float, nets: Sequence[Net], parameters: Dict[str, float]) -> bool:
        r"""
        @brief Makes a device from an element line
        @param circuit The circuit that is currently read.
        @param element The upper-case element code ("M", "R", ...).
        @param name The element's name.
        @param model The upper-case model name (may be empty).
        @param value The default value (e.g. resistance for resistors) and may be zero.
        @param nets The nets given in the element line.
        @param parameters The parameters of the element statement (parameter names are upper case).

        The default implementation will create corresponding devices for
        some known elements using the Spice writer's parameter conventions.

        The method must return true, if the element was was understood and false otherwise.
        """
    def error(self, msg: str) -> None:
        r"""
        @brief Issues an error with the given message.
        Use this method to generate an error.
        """
    @overload
    def finish(self, arg0: Netlist) -> None:
        r"""
        @hide
        """
    @overload
    def finish(self, netlist: Netlist) -> None:
        r"""
        @brief This method is called when the reader is done reading a netlist successfully
        """
    @overload
    def parse_element(self, arg0: str, arg1: str) -> ParseElementData:
        r"""
        @hide
        """
    @overload
    def parse_element(self, s: str, element: str) -> ParseElementData:
        r"""
        @brief Parses an element card
        @param s The specification part of the element line (the part after element code and name).
        @param element The upper-case element code ("M", "R", ...).
        @return A \ParseElementData object with the parts of the element.

        This method receives a string with the element specification and the element code. It is supposed to parse the element line and return a model name, a value, a list of net names and a parameter value dictionary.

        'parse_element' is called on every element card. The results of this call go into the \element method to actually create the device. This method can be reimplemented to support other flavors of SPICE.

        This method has been introduced in version 0.27.1
        """
    def parse_element_components(self, s: str) -> ParseElementComponentsData:
        r"""
        @brief Parses a string into string and parameter components.
        This method is provided to simplify the implementation of 'parse_element'. It takes a string and splits it into string arguments and parameter values. For example, 'a b c=6' renders two string arguments in 'nn' and one parameter ('C'->6.0). It returns data \ParseElementComponentsData object with the strings and parameters.
        The parameter names are already translated to upper case.

        This method has been introduced in version 0.27.1
        """
    @overload
    def start(self, arg0: Netlist) -> None:
        r"""
        @hide
        """
    @overload
    def start(self, netlist: Netlist) -> None:
        r"""
        @brief This method is called when the reader starts reading a netlist
        """
    @overload
    def translate_net_name(self, arg0: str) -> str:
        r"""
        @hide
        """
    @overload
    def translate_net_name(self, net_name: str) -> str:
        r"""
        @brief Translates a net name from the raw net name to the true net name
        The default implementation will replace backslash sequences by the corresponding character.
        'translate_net_name' is called before a net name is turned into a net object.
        The method can be reimplemented to supply a different translation scheme for net names. For example, to translate special characters.

        This method has been introduced in version 0.27.1
        """
    def value_from_string(self, s: str) -> Any:
        r"""
        @brief Translates a string into a value
        This function simplifies the implementation of SPICE readers by providing a translation of a unit-annotated string into double values. For example, '1k' is translated to 1000.0. In addition, simple formula evaluation is supported, e.g '(1+3)*2' is translated into 8.0.

        This method has been introduced in version 0.27.1
        """
    @overload
    def wants_subcircuit(self, arg0: str) -> bool:
        r"""
        @hide
        """
    @overload
    def wants_subcircuit(self, circuit_name: str) -> bool:
        r"""
        @brief Returns true, if the delegate wants subcircuit elements with this name
        The name is always upper case.
        """

class NetlistSpiceReader(NetlistReader):
    r"""
    @brief Implements a netlist Reader for the SPICE format.
    Use the SPICE reader like this:

    @code
    writer = RBA::NetlistSpiceReader::new
    netlist = RBA::Netlist::new
    netlist.read(path, reader)
    @/code

    The translation of SPICE elements can be tailored by providing a \NetlistSpiceReaderDelegate class. This allows translating of device parameters and mapping of some subcircuits to devices.

    The following example is a delegate that turns subcircuits called HVNMOS and HVPMOS into MOS4 devices with the parameters scaled by 1.5:

    @code
    class MyDelegate < RBA::NetlistSpiceReaderDelegate

      # says we want to catch these subcircuits as devices
      def wants_subcircuit(name)
        name == "HVNMOS" || name == "HVPMOS"
      end

      # translate the element
      def element(circuit, el, name, model, value, nets, params)

        if el != "X"
          # all other elements are left to the standard implementation
          return super
        end

        if nets.size != 4
          error("Subcircuit #{model} needs four nodes")
        end

        # provide a device class
        cls = circuit.netlist.device_class_by_name(model)
        if ! cls
          cls = RBA::DeviceClassMOS4Transistor::new
          cls.name = model
          circuit.netlist.add(cls)
        end

        # create a device
        device = circuit.create_device(cls, name)

        # and configure the device
        [ "S", "G", "D", "B" ].each_with_index do |t,index|
          device.connect_terminal(t, nets[index])
        end
        params.each do |p,value|
          device.set_parameter(p, value * 1.5)
        end

      end

    end

    # usage:

    mydelegate = MyDelegate::new
    reader = RBA::NetlistSpiceReader::new(mydelegate)

    nl = RBA::Netlist::new
    nl.read(input_file, reader)
    @/code

    A somewhat contrived example for using the delegate to translate net names is this:

    @code
    class MyDelegate < RBA::NetlistSpiceReaderDelegate

      # translates 'VDD' to 'VXX' and leave all other net names as is:
      alias translate_net_name_org translate_net_name
      def translate_net_name(n)
        return n == "VDD" ? "VXX" : translate_net_name_org(n)}
      end

    end
    @/code

    This class has been introduced in version 0.26. It has been extended in version 0.27.1.
    """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a new reader.
        """
    @overload
    def __init__(self, delegate: NetlistSpiceReaderDelegate) -> None:
        r"""
        @brief Creates a new reader with a delegate.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class NetlistCompareLogger:
    r"""
    @brief A base class for netlist comparer event receivers
    See \GenericNetlistCompareLogger for custom implementations of such receivers.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class GenericNetlistCompareLogger(NetlistCompareLogger):
    r"""
    @brief An event receiver for the netlist compare feature.
    The \NetlistComparer class will send compare events to a logger derived from this class. Use this class to implement your own logger class. You can override on of it's methods to receive certain kind of events.
    This class has been introduced in version 0.26.
    """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def begin_circuit(self, a: Circuit, b: Circuit) -> None:
        r"""
        @brief This function is called when a new circuit is compared.
        This compare procedure will run the netlist compare circuit vs. circuit in a bottom-up fashion.
        Before each circuit is compared, this method is called once with the circuits that are about to be compared.
        After the circuit has been compared, \end_circuit will be called.

        In some cases, the compare algorithm will decide that circuits can't be compared. This happens if for some or all subcircuits the pin assignment can't be derived. In this case, \circuit_skipped will be called once instead of \begin_circuit and \end_circuit.
        """
    def begin_netlist(self, a: Netlist, b: Netlist) -> None:
        r"""
        @brief This function is called at the beginning of the compare process.
        This method is called once when the compare run begins.
        """
    def circuit_mismatch(self, a: Circuit, b: Circuit, msg: str) -> None:
        r"""
        @brief This function is called when circuits can't be compared.
        This method is called when a circuit can't be mapped to a partner in the other netlist. In this case, this method is called with the one circuit and nil for the other circuit.

        This method is called instead of \begin_circuit and \end_circuit.
        """
    def circuit_skipped(self, a: Circuit, b: Circuit, msg: str) -> None:
        r"""
        @brief This function is called when circuits can't be compared.
        If there is a known circuit pair, but the circuits can be compared - for example because subcircuits can't be identified - this method will be called with both circuits.

        This method is called instead of \begin_circuit and \end_circuit.
        """
    def device_class_mismatch(self, a: DeviceClass, b: DeviceClass, msg: str) -> None:
        r"""
        @brief This function is called when device classes can't be compared.
        This method is called when a device class can't be mapped to a partner in the other netlist. In this case, this method is called with the one device class and nil for the other class.
        """
    def device_mismatch(self, a: Device, b: Device, msg: str) -> None:
        r"""
        @brief This function is called when two devices can't be paired.
        This will report the device considered in a or b. The other argument is nil. See \match_devices for details.
        """
    def end_circuit(self, a: Circuit, b: Circuit, matching: bool, msg: str) -> None:
        r"""
        @brief This function is called at the end of the compare process.
        The 'matching' argument indicates whether the circuits have been identified as identical.
        See \begin_circuit for details.
        """
    def end_netlist(self, a: Netlist, b: Netlist) -> None:
        r"""
        @brief This function is called at the end of the compare process.
        This method is called once when the compare run ended.
        """
    def match_ambiguous_nets(self, a: Net, b: Net, msg: str) -> None:
        r"""
        @brief This function is called when two nets are identified, but this choice is ambiguous.
        This choice is a last-resort fallback to allow continuation of the compare procedure. It is likely that this compare will fail later. Looking for ambiguous nets allows deduction of the origin of this faulty decision. See \match_nets for more details.
        """
    def match_devices(self, a: Device, b: Device) -> None:
        r"""
        @brief This function is called when two devices are identified.
        If two devices are identified as a corresponding pair, this method will be called with both devices.
        If the devices can be paired, but the device parameters don't match, \match_devices_with_different_parameters will be called instead.
        If the devices can be paired, but the device classes don't match, \match_devices_with_different_device_classes will be called instead.
        If devices can't be matched, \device_mismatch will be called with the one device considered and the other device being nil.
        """
    def match_devices_with_different_device_classes(self, a: Device, b: Device) -> None:
        r"""
        @brief This function is called when two devices are identified but have different device classes.
        See \match_devices for details.
        """
    def match_devices_with_different_parameters(self, a: Device, b: Device) -> None:
        r"""
        @brief This function is called when two devices are identified but have different parameters.
        See \match_devices for details.
        """
    def match_nets(self, a: Net, b: Net) -> None:
        r"""
        @brief This function is called when two nets are identified.
        If two nets are identified as a corresponding pair, this method will be called with both nets.
        If the nets can be paired, but this match is ambiguous, \match_ambiguous_nets will be called instead.
        If nets can't be matched to a partner, \net_mismatch will be called.
        """
    def match_pins(self, a: Pin, b: Pin) -> None:
        r"""
        @brief This function is called when two pins are identified.
        If two pins are identified as a corresponding pair, this method will be called with both pins.
        If pins can't be matched, \pin_mismatch will be called with the one pin considered and the other pin being nil.
        """
    def match_subcircuits(self, a: SubCircuit, b: SubCircuit) -> None:
        r"""
        @brief This function is called when two subcircuits are identified.
        If two subcircuits are identified as a corresponding pair, this method will be called with both subcircuits.
        If subcircuits can't be matched, \subcircuit_mismatch will be called with the one subcircuit considered and the other subcircuit being nil.
        """
    def net_mismatch(self, a: Net, b: Net, msg: str) -> None:
        r"""
        @brief This function is called when a net can't be paired.
        This method will be called, if a net cannot be identified as identical with another net. The corresponding argument will identify the net and source netlist. The other argument will be nil.

        In some cases, a mismatch is reported with two nets given. This means,
        nets are known not to match. Still the compare algorithm will proceed as
        if these nets were equivalent to derive further matches.
        """
    def pin_mismatch(self, a: Pin, b: Pin, msg: str) -> None:
        r"""
        @brief This function is called when two pins can't be paired.
        This will report the pin considered in a or b. The other argument is nil. See \match_pins for details.
        """
    def subcircuit_mismatch(self, a: SubCircuit, b: SubCircuit, msg: str) -> None:
        r"""
        @brief This function is called when two subcircuits can't be paired.
        This will report the subcircuit considered in a or b. The other argument is nil. See \match_subcircuits for details.
        """

class NetlistComparer:
    r"""
    @brief Compares two netlists
    This class performs a comparison of two netlists.
    It can be used with an event receiver (logger) to track the errors and net mismatches. Event receivers are derived from class \GenericNetlistCompareLogger.
    The netlist comparer can be configured in different ways. Specific hints can be given for nets, device classes or circuits to improve efficiency and reliability of the graph equivalence deduction algorithm. For example, objects can be marked as equivalent using \same_nets, \same_circuits etc. The compare algorithm will then use these hints to derive further equivalences. This way, ambiguities can be resolved.

    Another configuration option relates to swappable pins of subcircuits. If pins are marked this way, the compare algorithm may swap them to achieve net matching. Swappable pins belong to an 'equivalence group' and can be defined with \equivalent_pins.

    This class has been introduced in version 0.26.
    """
    dont_consider_net_names: bool
    r"""
    @brief Gets a value indicating whether net names shall not be considered
    See \dont_consider_net_names= for details.@brief Sets a value indicating whether net names shall not be considered
    If this value is set to true, net names will not be considered when resolving ambiguities.
    Not considering net names usually is more expensive. The default is 'false' indicating that
    net names will be considered for ambiguity resolution.

    This property has been introduced in version 0.26.7.
    """
    max_branch_complexity: int
    r"""
    @brief Gets the maximum branch complexity
    See \max_branch_complexity= for details.@brief Sets the maximum branch complexity
    This value limits the maximum branch complexity of the backtracking algorithm.
    The complexity is the accumulated number of branch options with ambiguous
    net matches. Backtracking will stop when the maximum number of options
    has been exceeded.

    By default, from version 0.27 on the complexity is unlimited and can be reduced in cases where runtimes need to be limited at the cost less elaborate matching evaluation.

    As the computational complexity is the square of the branch count,
    this value should be adjusted carefully.
    """
    max_depth: int
    r"""
    @brief Gets the maximum search depth
    See \max_depth= for details.@brief Sets the maximum search depth
    This value limits the search depth of the backtracking algorithm to the
    given number of jumps.

    By default, from version 0.27 on the depth is unlimited and can be reduced in cases where runtimes need to be limited at the cost less elaborate matching evaluation.
    """
    max_resistance: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Excludes all resistor devices with a resistance values higher than the given threshold.
    To reset this constraint, set this attribute to zero.
    """
    min_capacitance: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Excludes all capacitor devices with a capacitance values less than the given threshold.
    To reset this constraint, set this attribute to zero.
    """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a new comparer object.
        See the class description for more details.
        """
    @overload
    def __init__(self, logger: GenericNetlistCompareLogger) -> None:
        r"""
        @brief Creates a new comparer object.
        The logger is a delegate or event receiver which the comparer will send compare events to. See the class description for more details.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    @overload
    def compare(self, netlist_a: Netlist, netlist_b: Netlist) -> bool:
        r"""
        @brief Compares two netlists.
        This method will perform the actual netlist compare. It will return true if both netlists are identical. If the comparer has been configured with \same_nets or similar methods, the objects given there must be located inside 'circuit_a' and 'circuit_b' respectively.
        """
    @overload
    def compare(self, netlist_a: Netlist, netlist_b: Netlist, logger: NetlistCompareLogger) -> bool:
        r"""
        @brief Compares two netlists.
        This method will perform the actual netlist compare using the given logger. It will return true if both netlists are identical. If the comparer has been configured with \same_nets or similar methods, the objects given there must be located inside 'circuit_a' and 'circuit_b' respectively.
        """
    @overload
    def equivalent_pins(self, circuit_b: Circuit, pin_ids: Sequence[int]) -> None:
        r"""
        @brief Marks several pins of the given circuit as equivalent (i.e. they can be swapped).
        Only circuits from the second input can be given swappable pins. This will imply the same swappable pins on the equivalent circuit of the first input. This version is a generic variant of the two-pin version of this method.
        """
    @overload
    def equivalent_pins(self, circuit_b: Circuit, pin_id1: int, pin_id2: int) -> None:
        r"""
        @brief Marks two pins of the given circuit as equivalent (i.e. they can be swapped).
        Only circuits from the second input can be given swappable pins. This will imply the same swappable pins on the equivalent circuit of the first input. To mark multiple pins as swappable, use the version that takes a list of pins.
        """
    def join_symmetric_nets(self, circuit: Circuit) -> None:
        r"""
        @brief Joins symmetric nodes in the given circuit.

        Nodes are symmetrical if swapping them would not modify the circuit.
        Hence they will carry the same potential and can be connected (joined).
        This will simplify the circuit and can be applied before device combination
        to render a schematic-equivalent netlist in some cases (split gate option).

        This algorithm will apply the comparer's settings to the symmetry
        condition (device filtering, device compare tolerances, device class
        equivalence etc.).

        This method has been introduced in version 0.26.4.
        """
    def same_circuits(self, circuit_a: Circuit, circuit_b: Circuit) -> None:
        r"""
        @brief Marks two circuits as identical.
        This method makes a circuit circuit_a in netlist a identical to the corresponding
        circuit circuit_b in netlist b (see \compare). By default circuits with the same name are identical.
        """
    def same_device_classes(self, dev_cls_a: DeviceClass, dev_cls_b: DeviceClass) -> None:
        r"""
        @brief Marks two device classes as identical.
        This makes a device class dev_cls_a in netlist a identical to the corresponding
        device class dev_cls_b in netlist b (see \compare).
        By default device classes with the same name are identical.
        """
    @overload
    def same_nets(self, net_a: Net, net_b: Net, must_match: Optional[bool] = ...) -> None:
        r"""
        @brief Marks two nets as identical.
        This makes a net net_a in netlist a identical to the corresponding
        net net_b in netlist b (see \compare).
        Otherwise, the algorithm will try to identify nets according to their topology. This method can be used to supply hints to the compare algorithm. It will use these hints to derive further identities.

        If 'must_match' is true, the nets are required to match. If they don't, an error is reported.

        The 'must_match' optional argument has been added in version 0.27.3.
        """
    @overload
    def same_nets(self, circuit_a: Circuit, circuit_b: Circuit, net_a: Net, net_b: Net, must_match: Optional[bool] = ...) -> None:
        r"""
        @brief Marks two nets as identical.
        This makes a net net_a in netlist a identical to the corresponding
        net net_b in netlist b (see \compare).
        Otherwise, the algorithm will try to identify nets according to their topology. This method can be used to supply hints to the compare algorithm. It will use these hints to derive further identities.

        If 'must_match' is true, the nets are required to match. If they don't, an error is reported.

        This variant allows specifying nil for the nets indicating the nets are mismatched by definition. with 'must_match' this will render a net mismatch error.

        This variant has been added in version 0.27.3.
        """
    def unmatched_circuits_a(self, a: Netlist, b: Netlist) -> List[Circuit]:
        r"""
        @brief Returns a list of circuits in A for which there is not corresponding circuit in B
        This list can be used to flatten these circuits so they do not participate in the compare process.
        """
    def unmatched_circuits_b(self, a: Netlist, b: Netlist) -> List[Circuit]:
        r"""
        @brief Returns a list of circuits in B for which there is not corresponding circuit in A
        This list can be used to flatten these circuits so they do not participate in the compare process.
        """

class NetlistCrossReference(NetlistCompareLogger):
    r"""
    @brief Represents the identity mapping between the objects of two netlists.

    The NetlistCrossReference object is a container for the results of a netlist comparison. It implemented the \NetlistCompareLogger interface, hence can be used as output for a netlist compare operation (\NetlistComparer#compare). It's purpose is to store the results of the compare. It is used in this sense inside the \LayoutVsSchematic framework.

    The basic idea of the cross reference object is pairing: the netlist comparer will try to identify matching items and store them as pairs inside the cross reference object. If no match is found, a single-sided pair is generated: one item is nil in this case.
    Beside the items, a status is kept which gives more details about success or failure of the match operation.

    Item pairing happens on different levels, reflecting the hierarchy of the netlists. On the top level there are circuits. Inside circuits nets, devices, subcircuits and pins are paired. Nets further contribute their connected items through terminals (for devices), pins (outgoing) and subcircuit pins.

    This class has been introduced in version 0.26.
    """
    class NetPairData:
        r"""
        @brief A net match entry.
        This object is used to describe the relationship of two nets in a netlist match.

        Upon successful match, the \first and \second members are the matching objects and \status is 'Match'.
        This object is also used to describe non-matches or match errors. In this case, \first or \second may be nil and \status further describes the case.
        """
        def first(self) -> Net:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> Net:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
        def status(self) -> NetlistCrossReference.Status:
            r"""
            @brief Gets the status of the relation.
            This enum described the match status of the relation pair. 
            """
    class DevicePairData:
        r"""
        @brief A device match entry.
        This object is used to describe the relationship of two devices in a netlist match.

        Upon successful match, the \first and \second members are the matching objects and \status is 'Match'.
        This object is also used to describe non-matches or match errors. In this case, \first or \second may be nil and \status further describes the case.
        """
        def first(self) -> Device:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> Device:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
        def status(self) -> NetlistCrossReference.Status:
            r"""
            @brief Gets the status of the relation.
            This enum described the match status of the relation pair. 
            """
    class PinPairData:
        r"""
        @brief A pin match entry.
        This object is used to describe the relationship of two circuit pins in a netlist match.

        Upon successful match, the \first and \second members are the matching objects and \status is 'Match'.
        This object is also used to describe non-matches or match errors. In this case, \first or \second may be nil and \status further describes the case.
        """
        def first(self) -> Pin:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> Pin:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
        def status(self) -> NetlistCrossReference.Status:
            r"""
            @brief Gets the status of the relation.
            This enum described the match status of the relation pair. 
            """
    class SubCircuitPairData:
        r"""
        @brief A subcircuit match entry.
        This object is used to describe the relationship of two subcircuits in a netlist match.

        Upon successful match, the \first and \second members are the matching objects and \status is 'Match'.
        This object is also used to describe non-matches or match errors. In this case, \first or \second may be nil and \status further describes the case.
        """
        def first(self) -> SubCircuit:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> SubCircuit:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
        def status(self) -> NetlistCrossReference.Status:
            r"""
            @brief Gets the status of the relation.
            This enum described the match status of the relation pair. 
            """
    class CircuitPairData:
        r"""
        @brief A circuit match entry.
        This object is used to describe the relationship of two circuits in a netlist match.

        Upon successful match, the \first and \second members are the matching objects and \status is 'Match'.
        This object is also used to describe non-matches or match errors. In this case, \first or \second may be nil and \status further describes the case.
        """
        def first(self) -> Circuit:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> Circuit:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
        def status(self) -> NetlistCrossReference.Status:
            r"""
            @brief Gets the status of the relation.
            This enum described the match status of the relation pair. 
            """
    class NetTerminalRefPair:
        r"""
        @brief A match entry for a net terminal pair.
        This object is used to describe the matching terminal pairs or non-matching terminals on a net.

        Upon successful match, the \first and \second members are the matching net objects.Otherwise, either \first or \second is nil and the other member is the object for which no match was found.
        """
        def first(self) -> NetTerminalRef:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> NetTerminalRef:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
    class NetPinRefPair:
        r"""
        @brief A match entry for a net pin pair.
        This object is used to describe the matching pin pairs or non-matching pins on a net.

        Upon successful match, the \first and \second members are the matching net objects.Otherwise, either \first or \second is nil and the other member is the object for which no match was found.
        """
        def first(self) -> NetPinRef:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> NetPinRef:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
    class NetSubcircuitPinRefPair:
        r"""
        @brief A match entry for a net subcircuit pin pair.
        This object is used to describe the matching subcircuit pin pairs or non-matching subcircuit pins on a net.

        Upon successful match, the \first and \second members are the matching net objects.Otherwise, either \first or \second is nil and the other member is the object for which no match was found.
        """
        def first(self) -> NetSubcircuitPinRef:
            r"""
            @brief Gets the first object of the relation pair.
            The first object is usually the one obtained from the layout-derived netlist. This member can be nil if the pair is describing a non-matching reference object. In this case, the \second member is the reference object for which no match was found.
            """
        def second(self) -> NetSubcircuitPinRef:
            r"""
            @brief Gets the second object of the relation pair.
            The first object is usually the one obtained from the reference netlist. This member can be nil if the pair is describing a non-matching layout object. In this case, the \first member is the layout-derived object for which no match was found.
            """
    class Status:
        r"""
        @brief This class represents the NetlistCrossReference::Status enum
        """
        Match: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::Match
        An exact match exists if this code is present.
        """
        MatchWithWarning: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::MatchWithWarning
        If this code is present, a match was found but a warning is issued. For nets, this means that the choice is ambiguous and one, unspecific candidate has been chosen. For devices, this means a device match was established, but parameters or the device class are not matching exactly.
        """
        Mismatch: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::Mismatch
        This code means there is a match candidate, but exact identity could not be confirmed.
        """
        NoMatch: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::NoMatch
        If this code is present, no match could be found.
        There is also 'Mismatch' which means there is a candidate, but exact identity could not be confirmed.
        """
        None_: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::None
        No specific status is implied if this code is present.
        """
        Skipped: ClassVar[NetlistCrossReference.Status]
        r"""
        @brief Enum constant NetlistCrossReference::Skipped
        On circuits this code means that a match has not been attempted because subcircuits of this circuits were not matched. As circuit matching happens bottom-up, all subcircuits must match at least with respect to their pins to allow any parent circuit to be matched.
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: NetlistCrossReference.Status) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    Match: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::Match
    An exact match exists if this code is present.
    """
    MatchWithWarning: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::MatchWithWarning
    If this code is present, a match was found but a warning is issued. For nets, this means that the choice is ambiguous and one, unspecific candidate has been chosen. For devices, this means a device match was established, but parameters or the device class are not matching exactly.
    """
    Mismatch: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::Mismatch
    This code means there is a match candidate, but exact identity could not be confirmed.
    """
    NoMatch: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::NoMatch
    If this code is present, no match could be found.
    There is also 'Mismatch' which means there is a candidate, but exact identity could not be confirmed.
    """
    None_: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::None
    No specific status is implied if this code is present.
    """
    Skipped: ClassVar[NetlistCrossReference.Status]
    r"""
    @brief Enum constant NetlistCrossReference::Skipped
    On circuits this code means that a match has not been attempted because subcircuits of this circuits were not matched. As circuit matching happens bottom-up, all subcircuits must match at least with respect to their pins to allow any parent circuit to be matched.
    """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def circuit_count(self) -> int:
        r"""
        @brief Gets the number of circuit pairs in the cross-reference object.
        """
    def clear(self) -> None:
        r"""
        @hide
        """
    def each_circuit_pair(self) -> Iterator[NetlistCrossReference.CircuitPairData]:
        r"""
        @brief Delivers the circuit pairs and their status.
        See the class description for details.
        """
    def each_device_pair(self, circuit_pair: NetlistCrossReference.CircuitPairData) -> Iterator[NetlistCrossReference.DevicePairData]:
        r"""
        @brief Delivers the device pairs and their status for the given circuit pair.
        See the class description for details.
        """
    def each_net_pair(self, circuit_pair: NetlistCrossReference.CircuitPairData) -> Iterator[NetlistCrossReference.NetPairData]:
        r"""
        @brief Delivers the net pairs and their status for the given circuit pair.
        See the class description for details.
        """
    def each_net_pin_pair(self, net_pair: NetlistCrossReference.NetPairData) -> Iterator[NetlistCrossReference.NetPinRefPair]:
        r"""
        @brief Delivers the pin pairs for the given net pair.
        For the net pair, lists the pin pairs identified on this net.
        """
    def each_net_subcircuit_pin_pair(self, net_pair: NetlistCrossReference.NetPairData) -> Iterator[NetlistCrossReference.NetSubcircuitPinRefPair]:
        r"""
        @brief Delivers the subcircuit pin pairs for the given net pair.
        For the net pair, lists the subcircuit pin pairs identified on this net.
        """
    def each_net_terminal_pair(self, net_pair: NetlistCrossReference.NetPairData) -> Iterator[NetlistCrossReference.NetTerminalRefPair]:
        r"""
        @brief Delivers the device terminal pairs for the given net pair.
        For the net pair, lists the device terminal pairs identified on this net.
        """
    def each_pin_pair(self, circuit_pair: NetlistCrossReference.CircuitPairData) -> Iterator[NetlistCrossReference.PinPairData]:
        r"""
        @brief Delivers the pin pairs and their status for the given circuit pair.
        See the class description for details.
        """
    def each_subcircuit_pair(self, circuit_pair: NetlistCrossReference.CircuitPairData) -> Iterator[NetlistCrossReference.SubCircuitPairData]:
        r"""
        @brief Delivers the subcircuit pairs and their status for the given circuit pair.
        See the class description for details.
        """
    def netlist_a(self) -> Netlist:
        r"""
        @brief Gets the first netlist which participated in the compare.
        This member may be nil, if the respective netlist is no longer valid. In this case, the netlist cross-reference object cannot be used.
        """
    def netlist_b(self) -> Netlist:
        r"""
        @brief Gets the second netlist which participated in the compare.
        This member may be nil, if the respective netlist is no longer valid.In this case, the netlist cross-reference object cannot be used.
        """
    def other_circuit_for(self, circuit: Circuit) -> Circuit:
        r"""
        @brief Gets the matching other circuit for a given primary circuit.
        The return value will be nil if no match is found. Otherwise it is the 'b' circuit for circuits from the 'a' netlist and vice versa.

        This method has been introduced in version 0.27.
        """
    def other_device_for(self, device: Device) -> Device:
        r"""
        @brief Gets the matching other device for a given primary device.
        The return value will be nil if no match is found. Otherwise it is the 'b' device for devices from the 'a' netlist and vice versa.

        This method has been introduced in version 0.27.
        """
    def other_net_for(self, net: Net) -> Net:
        r"""
        @brief Gets the matching other net for a given primary net.
        The return value will be nil if no match is found. Otherwise it is the 'b' net for nets from the 'a' netlist and vice versa.
        """
    def other_pin_for(self, pin: Pin) -> Pin:
        r"""
        @brief Gets the matching other pin for a given primary pin.
        The return value will be nil if no match is found. Otherwise it is the 'b' pin for pins from the 'a' netlist and vice versa.

        This method has been introduced in version 0.27.
        """
    def other_subcircuit_for(self, subcircuit: SubCircuit) -> SubCircuit:
        r"""
        @brief Gets the matching other subcircuit for a given primary subcircuit.
        The return value will be nil if no match is found. Otherwise it is the 'b' subcircuit for subcircuits from the 'a' netlist and vice versa.

        This method has been introduced in version 0.27.
        """

class DeviceClassResistor(DeviceClass):
    r"""
    @brief A device class for a resistor.
    This class describes a resistor. Resistors are defined by their combination behavior and the basic parameter 'R' which is the resistance in Ohm.

    A resistor has two terminals, A and B.
    The parameters of a resistor are R (the value in Ohms), L and W (length and width in micrometers) and A and P (area and perimeter in square micrometers and micrometers respectively).

    This class has been introduced in version 0.26.
    """
    PARAM_A: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter A
    """
    PARAM_L: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter L
    """
    PARAM_P: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter P
    """
    PARAM_R: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter R
    """
    PARAM_W: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter W
    """
    TERMINAL_A: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal A
    """
    TERMINAL_B: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal B
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassResistor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassResistorWithBulk(DeviceClassResistor):
    r"""
    @brief A device class for a resistor with a bulk terminal (substrate, well).
    This class is similar to \DeviceClassResistor, but provides an additional terminal (BULK) for the well or substrate the resistor is embedded in.

    The additional terminal is 'W' for the well/substrate terminal.

    This class has been introduced in version 0.26.
    """
    TERMINAL_W: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal W (well, bulk)
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassResistorWithBulk:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassCapacitor(DeviceClass):
    r"""
    @brief A device class for a capacitor.
    This describes a capacitor. Capacitors are defined by their combination behavior and the basic parameter 'C' which is the capacitance in Farad.

    A capacitor has two terminals, A and B.
    The parameters of a capacitor are C (the value in Farad) and A and P (area and perimeter in square micrometers and micrometers respectively).

    This class has been introduced in version 0.26.
    """
    PARAM_A: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter A
    """
    PARAM_C: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter C
    """
    PARAM_P: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter P
    """
    TERMINAL_A: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal A
    """
    TERMINAL_B: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal B
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassCapacitor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassCapacitorWithBulk(DeviceClassCapacitor):
    r"""
    @brief A device class for a capacitor with a bulk terminal (substrate, well).
    This class is similar to \DeviceClassCapacitor, but provides an additional terminal (BULK) for the well or substrate the capacitor is embedded in.

    The additional terminal is 'W' for the well/substrate terminal.

    This class has been introduced in version 0.26.
    """
    TERMINAL_W: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal W (well, bulk)
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassCapacitorWithBulk:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassInductor(DeviceClass):
    r"""
    @brief A device class for an inductor.
    This class describes an inductor. Inductors are defined by their combination behavior and the basic parameter 'L' which is the inductance in Henry.

    An inductor has two terminals, A and B.

    This class has been introduced in version 0.26.
    """
    PARAM_L: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter L
    """
    TERMINAL_A: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal A
    """
    TERMINAL_B: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal B
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassInductor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassDiode(DeviceClass):
    r"""
    @brief A device class for a diode.
    This class describes a diode.
    A diode has two terminals, A (anode) and C (cathode).
    It has two parameters: The diode area in square micrometers (A) and the diode area perimeter in micrometers (P).

    Diodes only combine when parallel and in the same direction. In this case, their areas and perimeters are added.
    This class has been introduced in version 0.26.
    """
    PARAM_A: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter A
    """
    PARAM_P: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter P
    """
    TERMINAL_A: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal A
    """
    TERMINAL_C: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal C
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassDiode:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassBJT3Transistor(DeviceClass):
    r"""
    @brief A device class for a bipolar transistor.
    This class describes a bipolar transistor. Bipolar transistors have tree terminals: the collector (C), the base (B) and the emitter (E).
    Multi-emitter transistors are resolved in individual devices.
    The parameters are AE, AB and AC for the emitter, base and collector areas in square micrometers and PE, PB and PC for the emitter, base and collector perimeters in micrometers.
    In addition, the emitter count (NE) is given. The emitter count is 1 always for a transistor extracted initially. Upon combination of devices, the emitter counts are added, thus forming multi-emitter devices.

    This class has been introduced in version 0.26.
    """
    PARAM_AB: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter AB (base area)
    """
    PARAM_AC: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter AC (collector area)
    """
    PARAM_AE: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter AE (emitter area)
    """
    PARAM_NE: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter NE (emitter count)
    """
    PARAM_PB: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter PB (base perimeter)
    """
    PARAM_PC: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter PC (collector perimeter)
    """
    PARAM_PE: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter PE (emitter perimeter)
    """
    TERMINAL_B: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal B (base)
    """
    TERMINAL_C: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal C (collector)
    """
    TERMINAL_E: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal E (emitter)
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassBJT3Transistor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassBJT4Transistor(DeviceClassBJT3Transistor):
    r"""
    @brief A device class for a 4-terminal bipolar transistor.
    This class describes a bipolar transistor with a substrate terminal. A device class for a bipolar transistor without a substrate terminal is \DeviceClassBJT3Transistor. 
    The additional terminal is 'S' for the substrate terminal.
    BJT4 transistors combine in parallel if both substrate terminals are connected to the same net.

    This class has been introduced in version 0.26.
    """
    TERMINAL_S: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal S
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassBJT4Transistor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassMOS3Transistor(DeviceClass):
    r"""
    @brief A device class for a 3-terminal MOS transistor.
    This class describes a MOS transistor without a bulk terminal. A device class for a MOS transistor with a bulk terminal is \DeviceClassMOS4Transistor. MOS transistors are defined by their combination behavior and the basic parameters.

    The parameters are L, W, AS, AD, PS and PD for the gate length and width in micrometers, source and drain area in square micrometers and the source and drain perimeter in micrometers.

    The terminals are S, G and D for source, gate and drain.

    MOS transistors combine in parallel mode, when both gate lengths are identical and their gates are connected (source and drain can be swapped). In this case, their widths and source and drain areas are added.

    This class has been introduced in version 0.26.
    """
    PARAM_AD: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter AD
    """
    PARAM_AS: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter AS
    """
    PARAM_L: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter L
    """
    PARAM_PD: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter PD
    """
    PARAM_PS: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter PS
    """
    PARAM_W: ClassVar[int]
    r"""
    @brief A constant giving the parameter ID for parameter W
    """
    TERMINAL_D: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal D
    """
    TERMINAL_G: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal G
    """
    TERMINAL_S: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal S
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassMOS3Transistor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def join_split_gates(self, circuit: Circuit) -> None:
        r"""
        @brief Joins source/drain nets from 'split gate' transistor strings on the given circuit
        This method has been introduced in version 0.27.9
        """

class DeviceClassMOS4Transistor(DeviceClassMOS3Transistor):
    r"""
    @brief A device class for a 4-terminal MOS transistor.
    This class describes a MOS transistor with a bulk terminal. A device class for a MOS transistor without a bulk terminal is \DeviceClassMOS3Transistor. MOS transistors are defined by their combination behavior and the basic parameters.

    The additional terminal is 'B' for the bulk terminal.
    MOS4 transistors combine in parallel if both bulk terminals are connected to the same net.

    This class has been introduced in version 0.26.
    """
    TERMINAL_B: ClassVar[int]
    r"""
    @brief A constant giving the terminal ID for terminal B
    """
    def _assign(self, other: DeviceClass) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> DeviceClassMOS4Transistor:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceClassFactory:
    r"""
    @brief A factory for creating specific device classes for the standard device extractors
    Use a reimplementation of this class to provide a device class generator for built-in device extractors such as \DeviceExtractorMOS3Transistor. The constructor of this extractor has a 'factory' parameter which takes an object of \DeviceClassFactory type.

    If such an object is provided, this factory is used to create the actual device class. The following code shows an example:

    @code
    class MyClass < RBA::DeviceClassMOS3Transistor
      ... overrides some methods ...
    end

    class MyFactory < RBA::DeviceClassFactory
      def create_class
        MyClass.new
      end
    end

    extractor = RBA::DeviceExtractorMOS3Transistor::new("NMOS", false, MyFactory.new)
    @/code

    When using a factory with a device extractor, make sure it creates a corresponding device class, e.g. for the \DeviceExtractorMOS3Transistor extractor create a device class derived from \DeviceClassMOS3Transistor.

    This class has been introduced in version 0.27.3.
    """
    def __copy__(self) -> DeviceClassFactory:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DeviceClassFactory) -> None:
        r"""
        @brief Assigns another object to self
        """
    def create_class(self) -> DeviceClass:
        r"""
        @brief Creates the DeviceClass object
        Reimplement this method to create the desired device class.
        """
    def dup(self) -> DeviceClassFactory:
        r"""
        @brief Creates a copy of self
        """

class NetlistDeviceExtractorError:
    r"""
    @brief An error that occurred during device extraction
    The device extractor will keep errors that occurred during extraction of the devices. It does not by using this error class.

    An error is basically described by the cell/circuit it occurs in and the message. In addition, a geometry may be attached forming a marker that can be shown when the error is selected. The geometry is given as a \DPolygon object. If no geometry is specified, this polygon is empty.

    For categorization of the errors, a category name and description may be specified. If given, the errors will be shown in the specified category. The category description is optional.

    This class has been introduced in version 0.26.
    """
    category_description: str
    r"""
    @brief Gets the category description.
    See \category_name= for details about categories.@brief Sets the category description.
    See \category_name= for details about categories.
    """
    category_name: str
    r"""
    @brief Gets the category name.
    See \category_name= for more details.@brief Sets the category name.
    The category name is optional. If given, it specifies a formal category name. Errors with the same category name are shown in that category. If in addition a category description is specified (see \category_description), this description will be displayed as the title of.
    """
    cell_name: str
    r"""
    @brief Gets the cell name.
    See \cell_name= for details about this attribute.@brief Sets the cell name.
    The cell name is the name of the layout cell which was treated. This is also the name of the circuit the device should have appeared in (it may be dropped because of this error). If netlist hierarchy manipulation happens however, the circuit may not exist any longer or may be renamed.
    """
    geometry: DPolygon
    r"""
    @brief Gets the geometry.
    See \geometry= for more details.@brief Sets the geometry.
    The geometry is optional. If given, a marker will be shown when selecting this error.
    """
    message: str
    r"""
    @brief Gets the message text.
    @brief Sets the message text.
    """
    def __copy__(self) -> NetlistDeviceExtractorError:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistDeviceExtractorError) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> NetlistDeviceExtractorError:
        r"""
        @brief Creates a copy of self
        """

class NetlistDeviceExtractorLayerDefinition:
    r"""
    @brief Describes a layer used in the device extraction
    This read-only structure is used to describe a layer in the device extraction.
    Every device has specific layers used in the device extraction process.
    Layer definitions can be retrieved using \NetlistDeviceExtractor#each_layer.

    This class has been introduced in version 0.26.
    """
    def __copy__(self) -> NetlistDeviceExtractorLayerDefinition:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetlistDeviceExtractorLayerDefinition) -> None:
        r"""
        @brief Assigns another object to self
        """
    def description(self) -> str:
        r"""
        @brief Gets the description of the layer.
        """
    def dup(self) -> NetlistDeviceExtractorLayerDefinition:
        r"""
        @brief Creates a copy of self
        """
    def fallback_index(self) -> int:
        r"""
        @brief Gets the index of the fallback layer.
        This is the index of the layer to be used when this layer isn't specified for input or (more important) output.
        """
    def index(self) -> int:
        r"""
        @brief Gets the index of the layer.
        """
    def name(self) -> str:
        r"""
        @brief Gets the name of the layer.
        """

class DeviceExtractorBase:
    r"""
    @brief The base class for all device extractors.
    This is an abstract base class for device extractors. See \GenericDeviceExtractor for a generic class which you can reimplement to supply your own customized device extractor. In many cases using one of the preconfigured specific device extractors may be useful already and it's not required to implement a custom one. For an example about a preconfigured device extractor see \DeviceExtractorMOS3Transistor.

    This class cannot and should not be instantiated explicitly. Use one of the subclasses instead.

    This class has been introduced in version 0.26.
    """
    name: str
    r"""
    @brief Gets the name of the device extractor and the device class.@brief Sets the name of the device extractor and the device class.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def device_class(self) -> DeviceClass:
        r"""
        @brief Gets the device class used during extraction
        The attribute will hold the actual device class used in the device extraction. It is valid only after 'extract_devices'.

        This method has been added in version 0.27.3.
        """
    def each_error(self) -> Iterator[NetlistDeviceExtractorError]:
        r"""
        @brief Iterates over all errors collected in the device extractor.
        """
    def each_layer_definition(self) -> Iterator[NetlistDeviceExtractorLayerDefinition]:
        r"""
        @brief Iterates over all layer definitions.
        """
    def test_initialize(self, netlist: Netlist) -> None:
        r"""
        @hide
        """

class GenericDeviceExtractor(DeviceExtractorBase):
    r"""
    @brief The basic class for implementing custom device extractors.

    This class serves as a base class for implementing customized device extractors. This class does not provide any extraction functionality, so you have to implement every detail.

    Device extraction requires a few definitions. The definitions are made in the reimplementation of the \setup
    method. Required definitions to be made are:

    @ul
      @li The name of the extractor. This will also be the name of the device class produced by the extractor.       The name is set using \name=. @/li
      @li The device class of the devices to produce. The device class is registered using \register_device_class. @/li
      @li The layers used for the device extraction. These are input layers for the extraction as well as       output layers for defining the terminals. Terminals are the points at which the nets connect to the devices.
          Layers are defined using \define_layer. Initially, layers are abstract definitions with a name and a description.
          Concrete layers will be given when defining the connectivity. @/li
    @/ul

    When the device extraction is started, the device extraction algorithm will first ask the device extractor for the 'connectivity'. This is not a connectivity in a sense of electrical connections. The connectivity defines are logical compound that makes up the device. 'Connected' shapes are collected and presented to the device extractor.
    The connectivity is obtained by calling \get_connectivity. This method must be implemented to produce the connectivity.

    Finally, the individual devices need to be extracted. Each cluster of connected shapes is presented to the device extractor. A cluster may include more than one device. It's the device extractor's responsibility to extract the devices from this cluster and deliver the devices through \create_device. In addition, terminals have to be defined, so the net extractor can connect to the devices. Terminal definitions are made through \define_terminal. The device extraction is implemented in the \extract_devices method.

    If errors occur during device extraction, the \error method may be used to issue such errors. Errors reported this way are kept in the error log.

    This class has been introduced in version 0.26.
    """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def create_device(self) -> Device:
        r"""
        @brief Creates a device.
        The device object returned can be configured by the caller, e.g. set parameters.
        It will be owned by the netlist and must not be deleted by the caller.
        """
    def dbu(self) -> float:
        r"""
        @brief Gets the database unit
        """
    def define_layer(self, name: str, description: str) -> NetlistDeviceExtractorLayerDefinition:
        r"""
        @brief Defines a layer.
        @return The layer descriptor object created for this layer (use 'index' to get the layer's index)
        Each call will define one more layer for the device extraction.
        This method shall be used inside the implementation of \setup to define
        the device layers. The actual geometries are later available to \extract_devices
        in the order the layers are defined.
        """
    def define_opt_layer(self, name: str, fallback: int, description: str) -> NetlistDeviceExtractorLayerDefinition:
        r"""
        @brief Defines a layer with a fallback layer.
        @return The layer descriptor object created for this layer (use 'index' to get the layer's index)
        As \define_layer, this method allows specification of device extraction layer. In addition to \define_layout, it features a fallback layer. If in the device extraction statement, the primary layer is not given, the fallback layer will be used. Hence, this layer is optional. The fallback layer is given by it's index and must be defined before the layer using the fallback layer is defined. For the index, 0 is the first layer defined, 1 the second and so forth.
        """
    @overload
    def define_terminal(self, device: Device, terminal_id: int, layer_index: int, point: Point) -> None:
        r"""
        @brief Defines a device terminal.
        This method will define a terminal to the given device and the given terminal ID. 
        The terminal will be placed on the layer given by "layer_index". The layer index 
        is the index of the layer during layer definition. The first layer is 0, the second layer 1 etc.

        This version produces a point-like terminal. Note that the point is
        specified in database units.
        """
    @overload
    def define_terminal(self, device: Device, terminal_id: int, layer_index: int, shape: Box) -> None:
        r"""
        @brief Defines a device terminal.
        This method will define a terminal to the given device and the given terminal ID. 
        The terminal will be placed on the layer given by "layer_index". The layer index 
        is the index of the layer during layer definition. The first layer is 0, the second layer 1 etc.

        This version produces a terminal with a shape given by the box. Note that the box is
        specified in database units.
        """
    @overload
    def define_terminal(self, device: Device, terminal_id: int, layer_index: int, shape: Polygon) -> None:
        r"""
        @brief Defines a device terminal.
        This method will define a terminal to the given device and the given terminal ID. 
        The terminal will be placed on the layer given by "layer_index". The layer index 
        is the index of the layer during layer definition. The first layer is 0, the second layer 1 etc.

        This version produces a terminal with a shape given by the polygon. Note that the polygon is
        specified in database units.
        """
    @overload
    def error(self, message: str) -> None:
        r"""
        @brief Issues an error with the given message
        """
    @overload
    def error(self, message: str, geometry: DPolygon) -> None:
        r"""
        @brief Issues an error with the given message and micrometer-units polygon geometry
        """
    @overload
    def error(self, message: str, geometry: Polygon) -> None:
        r"""
        @brief Issues an error with the given message and database-unit polygon geometry
        """
    @overload
    def error(self, category_name: str, category_description: str, message: str) -> None:
        r"""
        @brief Issues an error with the given category name and description, message
        """
    @overload
    def error(self, category_name: str, category_description: str, message: str, geometry: DPolygon) -> None:
        r"""
        @brief Issues an error with the given category name and description, message and micrometer-units polygon geometry
        """
    @overload
    def error(self, category_name: str, category_description: str, message: str, geometry: Polygon) -> None:
        r"""
        @brief Issues an error with the given category name and description, message and database-unit polygon geometry
        """
    def extract_devices(self, layer_geometry: Sequence[Region]) -> None:
        r"""
        @brief Extracts the devices from the given shape cluster.

        The shape cluster is a set of geometries belonging together in terms of the
        connectivity defined by "get_connectivity". The cluster might cover multiple devices,
        so the implementation needs to consider this case. The geometries are already merged.

        The implementation of this method shall use "create_device" to create new
        devices based on the geometry found. It shall use "define_terminal" to define
        terminals by which the nets extracted in the network extraction step connect
        to the new devices.
        """
    def get_connectivity(self, layout: Layout, layers: Sequence[int]) -> Connectivity:
        r"""
        @brief Gets the connectivity object used to extract the device geometry.
        This method shall raise an error, if the input layer are not properly defined (e.g.
        too few etc.)

        This is not a connectivity definition in the electrical sense, but defines the cluster of shapes which generates a specific device. In this case, 'connectivity' means 'definition of shapes that need to touch to form the device'.

        The 'layers' argument specifies the actual layer layouts for the logical device layers (see \define_layer). The list of layers corresponds to the number of layers defined. Use the layer indexes from this list to build the connectivity with \Connectivity#connect. Note, that in order to capture a connected cluster of shapes on the same layer you'll need to include a self-connection like 'connectivity.connect(layers[0], layers[0])'.
        """
    def register_device_class(self, device_class: DeviceClass) -> None:
        r"""
        @brief Registers a device class.
        The device class object will become owned by the netlist and must not be deleted by
        the caller. The name of the device class will be changed to the name given to
        the device extractor.
        This method shall be used inside the implementation of \setup to register
        the device classes.
        """
    def sdbu(self) -> float:
        r"""
        @brief Gets the scaled database unit
        Use this unit to compute device properties. It is the database unit multiplied with the
        device scaling factor.
        """
    def setup(self) -> None:
        r"""
        @brief Sets up the extractor.
        This method is supposed to set up the device extractor. This involves three basic steps:
        defining the name, the device class and setting up the device layers.

        Use \name= to give the extractor and it's device class a name.
        Use \register_device_class to register the device class you need.
        Defined the layers by calling \define_layer once or several times.
        """

class DeviceExtractorMOS3Transistor(DeviceExtractorBase):
    r"""
    @brief A device extractor for a three-terminal MOS transistor

    This class supplies the generic extractor for a MOS device.
    The device is defined by two basic input layers: the diffusion area
    (source and drain) and the gate area. It requires a third layer
    (poly) to put the gate terminals on. The separation between poly
    and allows separating the device recognition layer (gate) from the
    conductive layer.

    The device class produced by this extractor is \DeviceClassMOS3Transistor.

    The extractor delivers six parameters:

    @ul
    @li 'L' - the gate length in micrometer units @/li
    @li 'W' - the gate width in micrometer units @/li
    @li 'AS' and 'AD' - the source and drain region areas in square micrometers @/li
    @li 'PS' and 'PD' - the source and drain region perimeters in micrometer units @/li
    @/ul

    The device layer names are:

    @ul
    @li In strict mode: 'S' (source), 'D' (drain) and 'G' (gate). @/li
    @li In non-strict mode: 'SD' (source and drain) and 'G' (gate). @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tS' - source. Default output is 'S' (strict mode) or 'SD' (otherwise). @/li
    @li 'tD' - drain. Default output is 'D' (strict mode) or 'SD' (otherwise). @/li
    @li 'tG' - gate. Default output is 'G'. @/li
    @/ul

    The source/drain (diffusion) area is distributed on the number of gates connecting to
    the particular source or drain area.

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, strict: Optional[bool] = ..., factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name.
        If \strict is true, the MOS device extraction will happen in strict mode. That is, source and drain are not interchangeable.

        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def strict(self) -> bool:
        r"""
        @brief Returns a value indicating whether extraction happens in strict mode.
        """

class DeviceExtractorMOS4Transistor(DeviceExtractorBase):
    r"""
    @brief A device extractor for a four-terminal MOS transistor

    This class supplies the generic extractor for a MOS device.
    It is based on the \DeviceExtractorMOS3Transistor class with the extension of a bulk terminal and corresponding bulk terminal output (annotation) layer.

    The parameters of a MOS4 device are the same than for MOS3 devices. For the device layers the bulk layer is added.

    @ul
    @li 'B' (bulk) - currently this layer is not used and can be empty. @/li
    @/ul

    The bulk terminals are output on this layer:
    @ul
    @li 'tB' - bulk terminal (a copy of the gate shape). Default output is 'B'. @/li
    @/ul

    The bulk terminal layer can be empty. In this case, it needs 
    to be connected to a global net to establish the net connection.

    The device class produced by this extractor is \DeviceClassMOS4Transistor.

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, strict: Optional[bool] = ..., factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorResistor(DeviceExtractorBase):
    r"""
    @brief A device extractor for a two-terminal resistor

    This class supplies the generic extractor for a resistor device.
    The device is defined by two geometry layers: the resistor 'wire' and two contacts per wire. The contacts should be attached to the ends of the wire. The wire length and width is computed from the edge lengths between the contacts and along the contacts respectively.

    This simple computation is precise only when the resistor shape is a rectangle.

    Using the given sheet resistance, the resistance value is computed by 'R = L / W * sheet_rho'.

    The device class produced by this extractor is \DeviceClassResistor.
    The extractor produces three parameters:

    @ul
    @li 'R' - the resistance in Ohm @/li
    @li 'A' - the resistor's area in square micrometer units @/li
    @li 'P' - the resistor's perimeter in micrometer units @/li
    @/ul

    The device layer names are:

    @ul
    @li 'R' - resistor path. This is the geometry that defines the resistor's current path. @/li
    @li 'C' - contacts. These areas form the contact regions at the ends of the resistor path. @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tA', 'tB' - the two terminals of the resistor. @/li
    @/ul

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, sheet_rho: float, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorResistorWithBulk(DeviceExtractorBase):
    r"""
    @brief A device extractor for a resistor with a bulk terminal

    This class supplies the generic extractor for a resistor device including a bulk terminal.
    The device is defined the same way than devices are defined for \DeviceExtractorResistor.

    The device class produced by this extractor is \DeviceClassResistorWithBulk.
    The extractor produces three parameters:

    @ul
    @li 'R' - the resistance in Ohm @/li
    @li 'A' - the resistor's area in square micrometer units @/li
    @li 'P' - the resistor's perimeter in micrometer units @/li
    @/ul

    The device layer names are:

    @ul
    @li 'R' - resistor path. This is the geometry that defines the resistor's current path. @/li
    @li 'C' - contacts. These areas form the contact regions at the ends of the resistor path. @/li
    @li 'W' - well, bulk. Currently this layer is ignored for the extraction and can be empty. @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tA', 'tB' - the two terminals of the resistor. @/li
    @li 'tW' - the bulk terminal (copy of the resistor area). @/li
    @/ul

    The bulk terminal layer can be an empty layer representing the substrate. In this case, it needs to be connected globally.

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, sheet_rho: float, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorCapacitor(DeviceExtractorBase):
    r"""
    @brief A device extractor for a two-terminal capacitor

    This class supplies the generic extractor for a capacitor device.
    The device is defined by two geometry layers forming the 'plates' of the capacitor.
    The capacitance is computed from the overlapping area of the plates using 'C = A * area_cap' (area_cap is the capacitance per square micrometer area).

    Although 'area_cap' can be given in any unit, Farad should be preferred as this is the convention used for output into a netlist.

    The device class produced by this extractor is \DeviceClassCapacitor.
    The extractor produces three parameters:

    @ul
    @li 'C' - the capacitance @/li
    @li 'A' - the capacitor's area in square micrometer units @/li
    @li 'P' - the capacitor's perimeter in micrometer units @/li
    @/ul

    The device layer names are:

    @ul
    @li 'P1', 'P2' - the two plates. @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tA', 'tB' - the two terminals. Defaults to 'P1' and 'P2'. @/li
    @/ul

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, area_cap: float, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorCapacitorWithBulk(DeviceExtractorBase):
    r"""
    @brief A device extractor for a capacitor with a bulk terminal

    This class supplies the generic extractor for a capacitor device including a bulk terminal.
    The device is defined the same way than devices are defined for \DeviceExtractorCapacitor.

    The device class produced by this extractor is \DeviceClassCapacitorWithBulk.
    The extractor produces three parameters:

    @ul
    @li 'C' - the capacitance @/li
    @li 'A' - the capacitor's area in square micrometer units @/li
    @li 'P' - the capacitor's perimeter in micrometer units @/li
    @/ul

    The device layer names are:

    @ul
    @li 'P1', 'P2' - the two plates. @/li
    @li 'W' - well, bulk. Currently this layer is ignored for the extraction and can be empty. @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tA', 'tB' - the two terminals. Defaults to 'P1' and 'P2'. @/li
    @li 'tW' - the bulk terminal (copy of the resistor area). @/li
    @/ul

    The bulk terminal layer can be an empty layer representing the substrate. In this case, it needs to be connected globally.

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, sheet_rho: float, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorBJT3Transistor(DeviceExtractorBase):
    r"""
    @brief A device extractor for a bipolar transistor (BJT)

    This class supplies the generic extractor for a bipolar transistor device.

    Extraction of vertical and lateral transistors is supported through a generic geometry model: The basic area is the base area. A marker shape must be provided for this area. The emitter of the transistor is defined by emitter layer shapes inside the base area. Multiple emitter shapes can be present. In this case, multiple transistor devices sharing the same base and collector are generated.
    Finally, a collector layer can be given. If non-empty, the parts inside the base region will define the collector terminals. If empty, the collector is formed by the substrate. In this case, the base region will be output to the 'tC' terminal output layer. This layer then needs to be connected to a global net to form the net connection.

    The device class produced by this extractor is \DeviceClassBJT3Transistor.
    The extractor delivers these parameters:

    @ul
    @li 'AE', 'AB' and 'AC' - the emitter, base and collector areas in square micrometer units @/li
    @li 'PE', 'PB' and 'PC' - the emitter, base and collector perimeters in micrometer units @/li
    @li 'NE' - emitter count (initially 1 but increases when devices are combined) @/li
    @/ul

    The device layer names are:

    @ul
    @li 'E' - emitter. @/li
    @li 'B' - base. @/li
    @li 'C' - collector. @/li
    @/ul

    The terminals are output on these layers:
    @ul
    @li 'tE' - emitter. Default output is 'E'. @/li
    @li 'tB' - base. Default output is 'B'. @/li
    @li 'tC' - collector. Default output is 'C'. @/li
    @/ul

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorBJT4Transistor(DeviceExtractorBJT3Transistor):
    r"""
    @brief A device extractor for a four-terminal bipolar transistor (BJT)

    This class supplies the generic extractor for a bipolar transistor device.
    It is based on the \DeviceExtractorBJT3Transistor class with the extension of a substrate terminal and corresponding substrate terminal output (annotation) layer.

    Two new layers are introduced:

    @ul
    @li 'S' - the bulk (substrate) layer. Currently this layer is ignored and can be empty. @/li@li 'tS' - the bulk terminal output layer (defaults to 'S'). @/li@/ul

    The bulk terminal layer ('tS') can be an empty layer representing the wafer substrate.
    In this use mode the substrate terminal shapes will be produced on the 'tS' layer. This
    layer then needs to be connected to a global net to establish the net connection.

    The device class produced by this extractor is \DeviceClassBJT4Transistor.
    The This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class DeviceExtractorDiode(DeviceExtractorBase):
    r"""
    @brief A device extractor for a planar diode

    This class supplies the generic extractor for a planar diode.
    The diode is defined by two layers whose overlap area forms
    the diode. The p-type layer forms the anode, the n-type layer
    the cathode.

    The device class produced by this extractor is \DeviceClassDiode.
    The extractor extracts the two parameters of this class:

    @ul
    @li 'A' - the diode area in square micrometer units. @/li
    @li 'P' - the diode perimeter in micrometer units. @/li
    @/ul

    The device layers are:

    @ul
    @li 'P' - the p doped area. @/li
    @li 'N' - the n doped area. @/li
    @/ul

    The diode region is defined by the overlap of p and n regions.

    The terminal output layers are:

    @ul
    @li 'tA' - anode. Defaults to 'P'. @/li
    @li 'tC' - cathode. Defaults to 'N'. @/li
    @/ul

    This class is a closed one and methods cannot be reimplemented. To reimplement specific methods, see \DeviceExtractor.

    This class has been introduced in version 0.26.
    """
    def __init__(self, name: str, factory: Optional[DeviceClassFactory] = ...) -> None:
        r"""
        @brief Creates a new device extractor with the given name
        For the 'factory' parameter see \DeviceClassFactory. It has been added in version 0.27.3.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class Path:
    r"""
    @brief A path class

    A path consists of an sequence of line segments forming the 'spine' of the path and a width. In addition, the starting point can be drawn back by a certain extent (the 'begin extension') and the end point can be pulled forward somewhat (by the 'end extension').

    A path may have round ends for special purposes. In particular, a round-ended path with a single point can represent a circle. Round-ended paths should have being and end extensions equal to half the width. Non-round-ended paths with a single point are allowed but the definition of the resulting shape in not well defined and may differ in other tools.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    bgn_ext: int
    r"""
    @brief Get the begin extension
    @brief Set the begin extension
    """
    end_ext: int
    r"""
    @brief Get the end extension
    @brief Set the end extension
    """
    points: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Set the points of the path
    @param p An array of points to assign to the path's spine
    """
    round: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Set the 'round ends' flag
    A path with round ends show half circles at the ends, instead of square or rectangular ends. Paths with this flag set should use a begin and end extension of half the width (see \bgn_ext and \end_ext). The interpretation of such paths in other tools may differ otherwise.
    """
    width: int
    r"""
    @brief Get the width
    @brief Set the width
    """
    @classmethod
    def from_s(cls, s: str) -> Path:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> Path:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Equality test
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates an empty (invalid) path with width 0
        """
    @overload
    def __init__(self, dpath: DPath) -> None:
        r"""
        @brief Creates an integer coordinate path from a floating-point coordinate path

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dpath'.
        """
    @overload
    def __init__(self, pts: Sequence[Point], width: int) -> None:
        r"""
        @brief Constructor given the points of the path's spine and the width


        @param pts The points forming the spine of the path
        @param width The width of the path
        """
    @overload
    def __init__(self, pts: Sequence[Point], width: int, bgn_ext: int, end_ext: int) -> None:
        r"""
        @brief Constructor given the points of the path's spine, the width and the extensions


        @param pts The points forming the spine of the path
        @param width The width of the path
        @param bgn_ext The begin extension of the path
        @param end_ext The end extension of the path
        """
    @overload
    def __init__(self, pts: Sequence[Point], width: int, bgn_ext: int, end_ext: int, round: bool) -> None:
        r"""
        @brief Constructor given the points of the path's spine, the width, the extensions and the round end flag


        @param pts The points forming the spine of the path
        @param width The width of the path
        @param bgn_ext The begin extension of the path
        @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends
        """
    def __lt__(self, p: Path) -> bool:
        r"""
        @brief Less operator
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __mul__(self, f: float) -> Path:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Inequality test
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def __rmul__(self, f: float) -> Path:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> int:
        r"""
        @brief Returns the approximate area of the path
        This method returns the approximate value of the area. It is computed from the length times the width. end extensions are taken into account correctly, but not effects of the corner interpolation.
        This method was added in version 0.22.
        """
    def assign(self, other: Path) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box of the path
        """
    def dup(self) -> Path:
        r"""
        @brief Creates a copy of self
        """
    def each_point(self) -> Iterator[Point]:
        r"""
        @brief Get the points that make up the path's spine
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def is_round(self) -> bool:
        r"""
        @brief Returns true, if the path has round ends
        """
    def length(self) -> int:
        r"""
        @brief Returns the length of the path
        the length of the path is determined by summing the lengths of the segments and adding begin and end extensions. For round-ended paths the length of the paths between the tips of the ends.

        This method was added in version 0.23.
        """
    @overload
    def move(self, p: Vector) -> Path:
        r"""
        @brief Moves the path.

        Moves the path by the given offset and returns the 
        moved path. The path is overwritten.

        @param p The distance to move the path.

        @return The moved path.
        """
    @overload
    def move(self, dx: int, dy: int) -> Path:
        r"""
        @brief Moves the path.

        Moves the path by the given offset and returns the 
        moved path. The path is overwritten.

        @param dx The x distance to move the path.
        @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.
        """
    @overload
    def moved(self, p: Vector) -> Path:
        r"""
        @brief Returns the moved path (does not change self)

        Moves the path by the given offset and returns the 
        moved path. The path is not modified.

        @param p The distance to move the path.

        @return The moved path.
        """
    @overload
    def moved(self, dx: int, dy: int) -> Path:
        r"""
        @brief Returns the moved path (does not change self)

        Moves the path by the given offset and returns the 
        moved path. The path is not modified.

        @param dx The x distance to move the path.
        @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Get the number of points
        """
    def perimeter(self) -> int:
        r"""
        @brief Returns the approximate perimeter of the path
        This method returns the approximate value of the perimeter. It is computed from the length and the width. end extensions are taken into account correctly, but not effects of the corner interpolation.
        This method was added in version 0.24.4.
        """
    def polygon(self) -> Polygon:
        r"""
        @brief Convert the path to a polygon
        The returned polygon is not guaranteed to be non-self overlapping. This may happen if the path overlaps itself or contains very short segments.
        """
    def round_corners(self, radius: float, npoints: int) -> Path:
        r"""
        @brief Creates a new path whose corners are interpolated with circular bends

        @param radius The radius of the bends
        @param npoints The number of points (per full circle) used for interpolating the bends

        This method has been introduced in version 0.25.
        """
    def simple_polygon(self) -> SimplePolygon:
        r"""
        @brief Convert the path to a simple polygon
        The returned polygon is not guaranteed to be non-selfoverlapping. This may happen if the path overlaps itself or contains very short segments.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DPath:
        r"""
        @brief Converts the path to a floating-point coordinate path

        The database unit can be specified to translate the integer-coordinate path into a floating-point coordinate path in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert to a string
        """
    @overload
    def transformed(self, t: CplxTrans) -> DPath:
        r"""
        @brief Transform the path.

        Transforms the path with the given complex transformation.
        Does not modify the path but returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Path:
        r"""
        @brief Transform the path.

        Transforms the path with the given complex transformation.
        Does not modify the path but returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path (in this case an integer coordinate path).

        This method has been introduced in version 0.18.
        """
    @overload
    def transformed(self, t: Trans) -> Path:
        r"""
        @brief Transform the path.

        Transforms the path with the given transformation.
        Does not modify the path but returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.
        """

class DPath:
    r"""
    @brief A path class

    A path consists of an sequence of line segments forming the 'spine' of the path and a width. In addition, the starting point can be drawn back by a certain extent (the 'begin extension') and the end point can be pulled forward somewhat (by the 'end extension').

    A path may have round ends for special purposes. In particular, a round-ended path with a single point can represent a circle. Round-ended paths should have being and end extensions equal to half the width. Non-round-ended paths with a single point are allowed but the definition of the resulting shape in not well defined and may differ in other tools.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    bgn_ext: float
    r"""
    @brief Get the begin extension
    @brief Set the begin extension
    """
    end_ext: float
    r"""
    @brief Get the end extension
    @brief Set the end extension
    """
    points: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Set the points of the path
    @param p An array of points to assign to the path's spine
    """
    round: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Set the 'round ends' flag
    A path with round ends show half circles at the ends, instead of square or rectangular ends. Paths with this flag set should use a begin and end extension of half the width (see \bgn_ext and \end_ext). The interpretation of such paths in other tools may differ otherwise.
    """
    width: float
    r"""
    @brief Get the width
    @brief Set the width
    """
    @classmethod
    def from_s(cls, s: str) -> DPath:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DPath:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Equality test
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates an empty (invalid) path with width 0
        """
    @overload
    def __init__(self, path: Path) -> None:
        r"""
        @brief Creates a floating-point coordinate path from an integer coordinate path

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_ipath'.
        """
    @overload
    def __init__(self, pts: Sequence[DPoint], width: float) -> None:
        r"""
        @brief Constructor given the points of the path's spine and the width


        @param pts The points forming the spine of the path
        @param width The width of the path
        """
    @overload
    def __init__(self, pts: Sequence[DPoint], width: float, bgn_ext: float, end_ext: float) -> None:
        r"""
        @brief Constructor given the points of the path's spine, the width and the extensions


        @param pts The points forming the spine of the path
        @param width The width of the path
        @param bgn_ext The begin extension of the path
        @param end_ext The end extension of the path
        """
    @overload
    def __init__(self, pts: Sequence[DPoint], width: float, bgn_ext: float, end_ext: float, round: bool) -> None:
        r"""
        @brief Constructor given the points of the path's spine, the width, the extensions and the round end flag


        @param pts The points forming the spine of the path
        @param width The width of the path
        @param bgn_ext The begin extension of the path
        @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends
        """
    def __lt__(self, p: DPath) -> bool:
        r"""
        @brief Less operator
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __mul__(self, f: float) -> DPath:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Inequality test
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def __rmul__(self, f: float) -> DPath:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> float:
        r"""
        @brief Returns the approximate area of the path
        This method returns the approximate value of the area. It is computed from the length times the width. end extensions are taken into account correctly, but not effects of the corner interpolation.
        This method was added in version 0.22.
        """
    def assign(self, other: DPath) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> DBox:
        r"""
        @brief Returns the bounding box of the path
        """
    def dup(self) -> DPath:
        r"""
        @brief Creates a copy of self
        """
    def each_point(self) -> Iterator[DPoint]:
        r"""
        @brief Get the points that make up the path's spine
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def is_round(self) -> bool:
        r"""
        @brief Returns true, if the path has round ends
        """
    def length(self) -> float:
        r"""
        @brief Returns the length of the path
        the length of the path is determined by summing the lengths of the segments and adding begin and end extensions. For round-ended paths the length of the paths between the tips of the ends.

        This method was added in version 0.23.
        """
    @overload
    def move(self, p: DVector) -> DPath:
        r"""
        @brief Moves the path.

        Moves the path by the given offset and returns the 
        moved path. The path is overwritten.

        @param p The distance to move the path.

        @return The moved path.
        """
    @overload
    def move(self, dx: float, dy: float) -> DPath:
        r"""
        @brief Moves the path.

        Moves the path by the given offset and returns the 
        moved path. The path is overwritten.

        @param dx The x distance to move the path.
        @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.
        """
    @overload
    def moved(self, p: DVector) -> DPath:
        r"""
        @brief Returns the moved path (does not change self)

        Moves the path by the given offset and returns the 
        moved path. The path is not modified.

        @param p The distance to move the path.

        @return The moved path.
        """
    @overload
    def moved(self, dx: float, dy: float) -> DPath:
        r"""
        @brief Returns the moved path (does not change self)

        Moves the path by the given offset and returns the 
        moved path. The path is not modified.

        @param dx The x distance to move the path.
        @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Get the number of points
        """
    def perimeter(self) -> float:
        r"""
        @brief Returns the approximate perimeter of the path
        This method returns the approximate value of the perimeter. It is computed from the length and the width. end extensions are taken into account correctly, but not effects of the corner interpolation.
        This method was added in version 0.24.4.
        """
    def polygon(self) -> DPolygon:
        r"""
        @brief Convert the path to a polygon
        The returned polygon is not guaranteed to be non-self overlapping. This may happen if the path overlaps itself or contains very short segments.
        """
    def round_corners(self, radius: float, npoints: int, accuracy: float) -> DPath:
        r"""
        @brief Creates a new path whose corners are interpolated with circular bends

        @param radius The radius of the bends
        @param npoints The number of points (per full circle) used for interpolating the bends
        @param accuracy The numerical accuracy of the computation

        The accuracy parameter controls the numerical resolution of the approximation process and should be in the order of half the database unit. This accuracy is used for suppressing redundant points and simplification of the resulting path.

        This method has been introduced in version 0.25.
        """
    def simple_polygon(self) -> DSimplePolygon:
        r"""
        @brief Convert the path to a simple polygon
        The returned polygon is not guaranteed to be non-selfoverlapping. This may happen if the path overlaps itself or contains very short segments.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Path:
        r"""
        @brief Converts the path to an integer coordinate path

        The database unit can be specified to translate the floating-point coordinate path in micron units to an integer-coordinate path in database units. The path's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert to a string
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DPath:
        r"""
        @brief Transform the path.

        Transforms the path with the given complex transformation.
        Does not modify the path but returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.
        """
    @overload
    def transformed(self, t: DTrans) -> DPath:
        r"""
        @brief Transform the path.

        Transforms the path with the given transformation.
        Does not modify the path but returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.
        """
    @overload
    def transformed(self, t: VCplxTrans) -> Path:
        r"""
        @brief Transforms the polygon with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed path (in this case an integer coordinate path)

        This method has been introduced in version 0.25.
        """

class DPoint:
    r"""
    @brief A point class with double (floating-point) coordinates
    Points represent a coordinate in the two-dimensional coordinate space of layout. They are not geometrical objects by itself. But they are frequently used in the database API for various purposes. Other than the integer variant (\Point), points with floating-point coordinates can represent fractions of a database unit.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    x: float
    r"""
    @brief Accessor to the x coordinate
    @brief Write accessor to the x coordinate
    """
    y: float
    r"""
    @brief Accessor to the y coordinate
    @brief Write accessor to the y coordinate
    """
    @classmethod
    def from_s(cls, s: str) -> DPoint:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __add__(self, v: DVector) -> DPoint:
        r"""
        @brief Adds a vector to a point


        Adds vector v to self by adding the coordinates.

        Starting with version 0.25, this method expects a vector argument.
        """
    def __copy__(self) -> DPoint:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Equality test operator

        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given point. This method enables points as hash keys.

        This method has been introduced in version 0.25.
        """
    def __imul__(self, f: float) -> DPoint:
        r"""
        @brief Scaling by some factor


        Scales object in place. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a point at 0,0
        """
    @overload
    def __init__(self, point: Point) -> None:
        r"""
        @brief Creates a floating-point coordinate point from an integer coordinate point

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_ipoint'.
        """
    @overload
    def __init__(self, v: DVector) -> None:
        r"""
        @brief Default constructor: creates a point at from an vector
        This constructor is equivalent to computing point(0,0)+v.
        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self, x: float, y: float) -> None:
        r"""
        @brief Constructor for a point from two coordinate values

        """
    def __itruediv__(self, d: float) -> DPoint:
        r"""
        @brief Division by some divisor


        Divides the object in place. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def __lt__(self, p: DPoint) -> bool:
        r"""
        @brief "less" comparison operator


        This operator is provided to establish a sorting
        order
        """
    def __mul__(self, f: float) -> DPoint:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Inequality test operator

        """
    def __neg__(self) -> DPoint:
        r"""
        @brief Compute the negative of a point


        Returns a new point with -x, -y.

        This method has been added in version 0.23.
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    def __rmul__(self, f: float) -> DPoint:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __sub__(self, p: DPoint) -> DVector:
        r"""
        @brief Subtract one point from another


        Subtract point p from self by subtracting the coordinates. This renders a vector.

        Starting with version 0.25, this method renders a vector.
        """
    @overload
    def __sub__(self, v: DVector) -> DPoint:
        r"""
        @brief Subtract one vector from a point


        Subtract vector v from from self by subtracting the coordinates. This renders a point.

        This method has been added in version 0.27.
        """
    def __truediv__(self, d: float) -> DPoint:
        r"""
        @brief Division by some divisor


        Returns the scaled object. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def abs(self) -> float:
        r"""
        @brief The absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'sqrt(x*x+y*y)'.

        This method has been introduced in version 0.23.
        """
    def assign(self, other: DPoint) -> None:
        r"""
        @brief Assigns another object to self
        """
    def distance(self, d: DPoint) -> float:
        r"""
        @brief The Euclidian distance to another point


        @param d The other point to compute the distance to.
        """
    def dup(self) -> DPoint:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given point. This method enables points as hash keys.

        This method has been introduced in version 0.25.
        """
    def sq_abs(self) -> float:
        r"""
        @brief The square of the absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'x*x+y*y'.

        This method has been introduced in version 0.23.
        """
    def sq_distance(self, d: DPoint) -> float:
        r"""
        @brief The square Euclidian distance to another point


        @param d The other point to compute the distance to.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Point:
        r"""
        @brief Converts the point to an integer coordinate point

        The database unit can be specified to translate the floating-point coordinate point in micron units to an integer-coordinate point in database units. The point's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_v(self) -> DVector:
        r"""
        @brief Turns the point into a vector
        This method returns a vector representing the distance from (0,0) to the point.This method has been introduced in version 0.25.
        """

class Point:
    r"""
    @brief An integer point class
    Points represent a coordinate in the two-dimensional coordinate space of layout. They are not geometrical objects by itself. But they are frequently used in the database API for various purposes.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    x: int
    r"""
    @brief Accessor to the x coordinate
    @brief Write accessor to the x coordinate
    """
    y: int
    r"""
    @brief Accessor to the y coordinate
    @brief Write accessor to the y coordinate
    """
    @classmethod
    def from_s(cls, s: str) -> Point:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __add__(self, v: Vector) -> Point:
        r"""
        @brief Adds a vector to a point


        Adds vector v to self by adding the coordinates.

        Starting with version 0.25, this method expects a vector argument.
        """
    def __copy__(self) -> Point:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Equality test operator

        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given point. This method enables points as hash keys.

        This method has been introduced in version 0.25.
        """
    def __imul__(self, f: float) -> Point:
        r"""
        @brief Scaling by some factor


        Scales object in place. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a point at 0,0
        """
    @overload
    def __init__(self, dpoint: DPoint) -> None:
        r"""
        @brief Creates an integer coordinate point from a floating-point coordinate point

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dpoint'.
        """
    @overload
    def __init__(self, v: Vector) -> None:
        r"""
        @brief Default constructor: creates a point at from an vector
        This constructor is equivalent to computing point(0,0)+v.
        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self, x: int, y: int) -> None:
        r"""
        @brief Constructor for a point from two coordinate values

        """
    def __itruediv__(self, d: float) -> Point:
        r"""
        @brief Division by some divisor


        Divides the object in place. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def __lt__(self, p: Point) -> bool:
        r"""
        @brief "less" comparison operator


        This operator is provided to establish a sorting
        order
        """
    def __mul__(self, f: float) -> Point:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Inequality test operator

        """
    def __neg__(self) -> Point:
        r"""
        @brief Compute the negative of a point


        Returns a new point with -x, -y.

        This method has been added in version 0.23.
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    def __rmul__(self, f: float) -> Point:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __sub__(self, p: Point) -> Vector:
        r"""
        @brief Subtract one point from another


        Subtract point p from self by subtracting the coordinates. This renders a vector.

        Starting with version 0.25, this method renders a vector.
        """
    @overload
    def __sub__(self, v: Vector) -> Point:
        r"""
        @brief Subtract one vector from a point


        Subtract vector v from from self by subtracting the coordinates. This renders a point.

        This method has been added in version 0.27.
        """
    def __truediv__(self, d: float) -> Point:
        r"""
        @brief Division by some divisor


        Returns the scaled object. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def abs(self) -> float:
        r"""
        @brief The absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'sqrt(x*x+y*y)'.

        This method has been introduced in version 0.23.
        """
    def assign(self, other: Point) -> None:
        r"""
        @brief Assigns another object to self
        """
    def distance(self, d: Point) -> float:
        r"""
        @brief The Euclidian distance to another point


        @param d The other point to compute the distance to.
        """
    def dup(self) -> Point:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given point. This method enables points as hash keys.

        This method has been introduced in version 0.25.
        """
    def sq_abs(self) -> float:
        r"""
        @brief The square of the absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'x*x+y*y'.

        This method has been introduced in version 0.23.
        """
    def sq_distance(self, d: Point) -> float:
        r"""
        @brief The square Euclidian distance to another point


        @param d The other point to compute the distance to.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DPoint:
        r"""
        @brief Converts the point to a floating-point coordinate point

        The database unit can be specified to translate the integer-coordinate point into a floating-point coordinate point in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_v(self) -> Vector:
        r"""
        @brief Turns the point into a vector
        This method returns a vector representing the distance from (0,0) to the point.This method has been introduced in version 0.25.
        """

class SimplePolygon:
    r"""
    @brief A simple polygon class

    A simple polygon consists of an outer hull only. To support polygons with holes, use \Polygon.
    The hull contour consists of several points. The point
    list is normalized such that the leftmost, lowest point is 
    the first one. The orientation is normalized such that
    the orientation of the hull contour is clockwise.

    It is in no way checked that the contours are not overlapping
    This must be ensured by the user of the object
    when filling the contours.

    The \SimplePolygon class stores coordinates in integer format. A class that stores floating-point coordinates is \DSimplePolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    points: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the points of the simple polygon

    @param pts An array of points to assign to the simple polygon

    See the constructor description for details about raw mode.
    """
    @classmethod
    def ellipse(cls, box: Box, n: int) -> SimplePolygon:
        r"""
        @brief Creates a simple polygon approximating an ellipse

        @param box The bounding box of the ellipse
        @param n The number of points that will be used to approximate the ellipse

        This method has been introduced in version 0.23.
        """
    @classmethod
    def from_s(cls, s: str) -> SimplePolygon:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> SimplePolygon:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether self is equal to p
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates an empty (invalid) polygon
        """
    @overload
    def __init__(self, box: Box) -> None:
        r"""
        @brief Constructor converting a box to a polygon

        @param box The box to convert to a polygon
        """
    @overload
    def __init__(self, dpolygon: DSimplePolygon) -> None:
        r"""
        @brief Creates an integer coordinate polygon from a floating-point coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dpoly'.
        """
    @overload
    def __init__(self, pts: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor given the points of the simple polygon

        @param pts The points forming the simple polygon
        @param raw If true, the points are taken as they are (see below)

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no removal of redundant points or joining of coincident edges will take place. In effect, polygons consisting of a single point or two points can be constructed as well as polygons with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the lowest-leftmost one and the orientation is clockwise always.

        The 'raw' argument has been added in version 0.24.
        """
    def __lt__(self, p: SimplePolygon) -> bool:
        r"""
        @brief Returns a value indicating whether self is less than p
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order

        This method has been introduced in version 0.25.
        """
    def __mul__(self, f: float) -> SimplePolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether self is not equal to p
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def __rmul__(self, f: float) -> SimplePolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> int:
        r"""
        @brief Gets the area of the polygon
        The area is correct only if the polygon is not self-overlapping and the polygon is oriented clockwise.
        """
    def area2(self) -> int:
        r"""
        @brief Gets the double area of the polygon
        This method is provided because the area for an integer-type polygon is a multiple of 1/2. Hence the double area can be expresses precisely as an integer for these types.

        This method has been introduced in version 0.26.1
        """
    def assign(self, other: SimplePolygon) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box of the simple polygon
        """
    def compress(self, remove_reflected: bool) -> None:
        r"""
        @brief Compressed the simple polygon.

        This method removes redundant points from the polygon, such as points being on a line formed by two other points.
        If remove_reflected is true, points are also removed if the two adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.
        """
    def dup(self) -> SimplePolygon:
        r"""
        @brief Creates a copy of self
        """
    def each_edge(self) -> Iterator[Edge]:
        r"""
        @brief Iterates over the edges that make up the simple polygon
        """
    def each_point(self) -> Iterator[Point]:
        r"""
        @brief Iterates over the points that make up the simple polygon
        """
    def extract_rad(self) -> List[Any]:
        r"""
        @brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of the \round_corners method. If this method succeeds, if will return an array of four elements: @ul
        @li The polygon with the rounded corners replaced by edgy ones @/li
        @li The radius of the inner corners @/li
        @li The radius of the outer corners @/li
        @li The number of points per full circle @/li
        @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is returned.

        If successful, the following code will more or less render the original polygon and parameters

        @code
        p = ...   # some polygon
        p.round_corners(ri, ro, n)
        (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits)
        @/code

        This method was introduced in version 0.25.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def inside(self, p: Point) -> bool:
        r"""
        @brief Gets a value indicating whether the given point is inside the polygon
        If the given point is inside or on the edge the polygon, true is returned. This tests works well only if the polygon is not self-overlapping and oriented clockwise. 
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is empty
        """
    def is_halfmanhattan(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is half-manhattan
        Half-manhattan polygons have edges which are multiples of 45 degree. These polygons can be clipped at a rectangle without potential grid snapping.

        This predicate was introduced in version 0.27.
        """
    def is_rectilinear(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is rectilinear
        """
    @overload
    def minkowski_sum(self, b: Box, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of a polygon and a box

        @param b The box.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and b.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, c: Sequence[Point], resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of a polygon and a contour of points (a trace)

        @param c The contour (a series of points forming the trace).
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and c.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, e: Edge, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of a polygon and an edge

        @param e The edge.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and e.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, p: SimplePolygon, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of a polygon and a polygon

        @param p The other polygon.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and p.

        This method was introduced in version 0.22.
        """
    @overload
    def move(self, p: Vector) -> SimplePolygon:
        r"""
        @brief Moves the simple polygon.

        Moves the simple polygon by the given offset and returns the 
        moved simple polygon. The polygon is overwritten.

        @param p The distance to move the simple polygon.

        @return The moved simple polygon.
        """
    @overload
    def move(self, x: int, y: int) -> SimplePolygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon (self).
        """
    @overload
    def moved(self, p: Vector) -> SimplePolygon:
        r"""
        @brief Returns the moved simple polygon

        Moves the simple polygon by the given offset and returns the 
        moved simple polygon. The polygon is not modified.

        @param p The distance to move the simple polygon.

        @return The moved simple polygon.
        """
    @overload
    def moved(self, x: int, y: int) -> SimplePolygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Gets the number of points
        """
    def perimeter(self) -> int:
        r"""
        @brief Gets the perimeter of the polygon
        The perimeter is sum of the lengths of all edges making up the polygon.
        """
    def point(self, p: int) -> Point:
        r"""
        @brief Gets a specific point of the contour@param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned.
        This method was introduced in version 0.18.
        """
    def round_corners(self, rinner: float, router: float, n: int) -> SimplePolygon:
        r"""
        @brief Rounds the corners of the polygon

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units).
        @param router The circle radius of outer corners (in database units).
        @param n The number of points per full circle.

        @return The new polygon.

        This method was introduced in version 0.22 for integer coordinates and in 0.25 for all coordinate types.
        """
    def set_points(self, pts: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the simple polygon

        @param pts An array of points to assign to the simple polygon
        @param raw If true, the points are taken as they are

        See the constructor description for details about raw mode.

        This method has been added in version 0.24.
        """
    def split(self) -> List[SimplePolygon]:
        r"""
        @brief Splits the polygon into two or more parts
        This method will break the polygon into parts. The exact breaking algorithm is unspecified, the result are smaller polygons of roughly equal number of points and 'less concave' nature. Usually the returned polygon set consists of two polygons, but there can be more. The merged region of the resulting polygons equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some maximum number of points limit.

        This method has been introduced in version 0.25.3.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DSimplePolygon:
        r"""
        @brief Converts the polygon to a floating-point coordinate polygon

        The database unit can be specified to translate the integer-coordinate polygon into a floating-point coordinate polygon in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    @overload
    def touches(self, box: Box) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given box.
        The box and the polygon touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, edge: Edge) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given edge.
        The edge and the polygon touch if they overlap or the edge shares at least one point with the polygon's contour.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, polygon: Polygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, simple_polygon: SimplePolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def transform(self, t: ICplxTrans) -> SimplePolygon:
        r"""
        @brief Transforms the simple polygon with a complex transformation (in-place)

        Transforms the simple polygon with the given complex transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transform(self, t: Trans) -> SimplePolygon:
        r"""
        @brief Transforms the simple polygon (in-place)

        Transforms the simple polygon with the given transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transformed(self, t: CplxTrans) -> DSimplePolygon:
        r"""
        @brief Transforms the simple polygon.

        Transforms the simple polygon with the given complex transformation.
        Does not modify the simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed' takes both simple and complex transformations.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> SimplePolygon:
        r"""
        @brief Transforms the simple polygon.

        Transforms the simple polygon with the given complex transformation.
        Does not modify the simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon (in this case an integer coordinate object).

        This method has been introduced in version 0.18.
        """
    @overload
    def transformed(self, t: Trans) -> SimplePolygon:
        r"""
        @brief Transforms the simple polygon.

        Transforms the simple polygon with the given transformation.
        Does not modify the simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.
        """

class DSimplePolygon:
    r"""
    @brief A simple polygon class

    A simple polygon consists of an outer hull only. To support polygons with holes, use \DPolygon.
    The contour consists of several points. The point
    list is normalized such that the leftmost, lowest point is 
    the first one. The orientation is normalized such that
    the orientation of the hull contour is clockwise.

    It is in no way checked that the contours are not over-
    lapping. This must be ensured by the user of the object
    when filling the contours.

    The \DSimplePolygon class stores coordinates in floating-point format which gives a higher precision for some operations. A class that stores integer coordinates is \SimplePolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    points: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the points of the simple polygon

    @param pts An array of points to assign to the simple polygon

    See the constructor description for details about raw mode.
    """
    @classmethod
    def ellipse(cls, box: DBox, n: int) -> DSimplePolygon:
        r"""
        @brief Creates a simple polygon approximating an ellipse

        @param box The bounding box of the ellipse
        @param n The number of points that will be used to approximate the ellipse

        This method has been introduced in version 0.23.
        """
    @classmethod
    def from_s(cls, s: str) -> DSimplePolygon:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DSimplePolygon:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether self is equal to p
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates an empty (invalid) polygon
        """
    @overload
    def __init__(self, box: DBox) -> None:
        r"""
        @brief Constructor converting a box to a polygon

        @param box The box to convert to a polygon
        """
    @overload
    def __init__(self, polygon: SimplePolygon) -> None:
        r"""
        @brief Creates a floating-point coordinate polygon from an integer coordinate polygon
        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_ipoly'.
        """
    @overload
    def __init__(self, pts: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Constructor given the points of the simple polygon

        @param pts The points forming the simple polygon
        @param raw If true, the points are taken as they are (see below)

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no removal of redundant points or joining of coincident edges will take place. In effect, polygons consisting of a single point or two points can be constructed as well as polygons with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the lowest-leftmost one and the orientation is clockwise always.

        The 'raw' argument has been added in version 0.24.
        """
    def __lt__(self, p: DSimplePolygon) -> bool:
        r"""
        @brief Returns a value indicating whether self is less than p
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order

        This method has been introduced in version 0.25.
        """
    def __mul__(self, f: float) -> DSimplePolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether self is not equal to p
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def __rmul__(self, f: float) -> DSimplePolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> float:
        r"""
        @brief Gets the area of the polygon
        The area is correct only if the polygon is not self-overlapping and the polygon is oriented clockwise.
        """
    def area2(self) -> float:
        r"""
        @brief Gets the double area of the polygon
        This method is provided because the area for an integer-type polygon is a multiple of 1/2. Hence the double area can be expresses precisely as an integer for these types.

        This method has been introduced in version 0.26.1
        """
    def assign(self, other: DSimplePolygon) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> DBox:
        r"""
        @brief Returns the bounding box of the simple polygon
        """
    def compress(self, remove_reflected: bool) -> None:
        r"""
        @brief Compressed the simple polygon.

        This method removes redundant points from the polygon, such as points being on a line formed by two other points.
        If remove_reflected is true, points are also removed if the two adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.
        """
    def dup(self) -> DSimplePolygon:
        r"""
        @brief Creates a copy of self
        """
    def each_edge(self) -> Iterator[DEdge]:
        r"""
        @brief Iterates over the edges that make up the simple polygon
        """
    def each_point(self) -> Iterator[DPoint]:
        r"""
        @brief Iterates over the points that make up the simple polygon
        """
    def extract_rad(self) -> List[Any]:
        r"""
        @brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of the \round_corners method. If this method succeeds, if will return an array of four elements: @ul
        @li The polygon with the rounded corners replaced by edgy ones @/li
        @li The radius of the inner corners @/li
        @li The radius of the outer corners @/li
        @li The number of points per full circle @/li
        @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is returned.

        If successful, the following code will more or less render the original polygon and parameters

        @code
        p = ...   # some polygon
        p.round_corners(ri, ro, n)
        (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits)
        @/code

        This method was introduced in version 0.25.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def inside(self, p: DPoint) -> bool:
        r"""
        @brief Gets a value indicating whether the given point is inside the polygon
        If the given point is inside or on the edge the polygon, true is returned. This tests works well only if the polygon is not self-overlapping and oriented clockwise. 
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is empty
        """
    def is_halfmanhattan(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is half-manhattan
        Half-manhattan polygons have edges which are multiples of 45 degree. These polygons can be clipped at a rectangle without potential grid snapping.

        This predicate was introduced in version 0.27.
        """
    def is_rectilinear(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is rectilinear
        """
    @overload
    def move(self, p: DVector) -> DSimplePolygon:
        r"""
        @brief Moves the simple polygon.

        Moves the simple polygon by the given offset and returns the 
        moved simple polygon. The polygon is overwritten.

        @param p The distance to move the simple polygon.

        @return The moved simple polygon.
        """
    @overload
    def move(self, x: float, y: float) -> DSimplePolygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon (self).
        """
    @overload
    def moved(self, p: DVector) -> DSimplePolygon:
        r"""
        @brief Returns the moved simple polygon

        Moves the simple polygon by the given offset and returns the 
        moved simple polygon. The polygon is not modified.

        @param p The distance to move the simple polygon.

        @return The moved simple polygon.
        """
    @overload
    def moved(self, x: float, y: float) -> DSimplePolygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Gets the number of points
        """
    def perimeter(self) -> float:
        r"""
        @brief Gets the perimeter of the polygon
        The perimeter is sum of the lengths of all edges making up the polygon.
        """
    def point(self, p: int) -> DPoint:
        r"""
        @brief Gets a specific point of the contour@param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned.
        This method was introduced in version 0.18.
        """
    def round_corners(self, rinner: float, router: float, n: int) -> DSimplePolygon:
        r"""
        @brief Rounds the corners of the polygon

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units).
        @param router The circle radius of outer corners (in database units).
        @param n The number of points per full circle.

        @return The new polygon.

        This method was introduced in version 0.22 for integer coordinates and in 0.25 for all coordinate types.
        """
    def set_points(self, pts: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the simple polygon

        @param pts An array of points to assign to the simple polygon
        @param raw If true, the points are taken as they are

        See the constructor description for details about raw mode.

        This method has been added in version 0.24.
        """
    def split(self) -> List[DSimplePolygon]:
        r"""
        @brief Splits the polygon into two or more parts
        This method will break the polygon into parts. The exact breaking algorithm is unspecified, the result are smaller polygons of roughly equal number of points and 'less concave' nature. Usually the returned polygon set consists of two polygons, but there can be more. The merged region of the resulting polygons equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some maximum number of points limit.

        This method has been introduced in version 0.25.3.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> SimplePolygon:
        r"""
        @brief Converts the polygon to an integer coordinate polygon
        The database unit can be specified to translate the floating-point coordinate polygon in micron units to an integer-coordinate polygon in database units. The polygon's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    @overload
    def touches(self, box: DBox) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given box.
        The box and the polygon touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, edge: DEdge) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given edge.
        The edge and the polygon touch if they overlap or the edge shares at least one point with the polygon's contour.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, polygon: DPolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, simple_polygon: DSimplePolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def transform(self, t: DCplxTrans) -> DSimplePolygon:
        r"""
        @brief Transforms the simple polygon with a complex transformation (in-place)

        Transforms the simple polygon with the given complex transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transform(self, t: DTrans) -> DSimplePolygon:
        r"""
        @brief Transforms the simple polygon (in-place)

        Transforms the simple polygon with the given transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DSimplePolygon:
        r"""
        @brief Transforms the simple polygon.

        Transforms the simple polygon with the given complex transformation.
        Does not modify the simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed' takes both simple and complex transformations.
        """
    @overload
    def transformed(self, t: DTrans) -> DSimplePolygon:
        r"""
        @brief Transforms the simple polygon.

        Transforms the simple polygon with the given transformation.
        Does not modify the simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.
        """
    @overload
    def transformed(self, t: VCplxTrans) -> SimplePolygon:
        r"""
        @brief Transforms the polygon with the given complex transformation

        @param t The magnifying transformation to apply
        @return The transformed polygon (in this case an integer coordinate polygon)

        This method has been introduced in version 0.25.
        """

class Polygon:
    r"""
    @brief A polygon class

    A polygon consists of an outer hull and zero to many
    holes. Each contour consists of several points. The point
    list is normalized such that the leftmost, lowest point is 
    the first one. The orientation is normalized such that
    the orientation of the hull contour is clockwise, while
    the orientation of the holes is counterclockwise.

    It is in no way checked that the contours are not overlapping.
    This must be ensured by the user of the object
    when filling the contours.

    A polygon can be asked for the number of holes using the \holes method. \each_point_hull delivers the points of the hull contour. \each_point_hole delivers the points of a specific hole. \each_edge delivers the edges (point-to-point connections) of both hull and holes. \bbox delivers the bounding box, \area the area and \perimeter the perimeter of the polygon.

    Here's an example of how to create a polygon:

    @code
    hull =  [ RBA::Point::new(0, 0),       RBA::Point::new(6000, 0), 
              RBA::Point::new(6000, 3000), RBA::Point::new(0, 3000) ]
    hole1 = [ RBA::Point::new(1000, 1000), RBA::Point::new(2000, 1000), 
              RBA::Point::new(2000, 2000), RBA::Point::new(1000, 2000) ]
    hole2 = [ RBA::Point::new(3000, 1000), RBA::Point::new(4000, 1000), 
              RBA::Point::new(4000, 2000), RBA::Point::new(3000, 2000) ]
    poly = RBA::Polygon::new(hull)
    poly.insert_hole(hole1)
    poly.insert_hole(hole2)

    # ask the polygon for some properties
    poly.holes      # -> 2
    poly.area       # -> 16000000
    poly.perimeter  # -> 26000
    poly.bbox       # -> (0,0;6000,3000)
    @/code

    The \Polygon class stores coordinates in integer format. A class that stores floating-point coordinates is \DPolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    PO_any: ClassVar[int]
    r"""
    @brief A value for the preferred orientation parameter of \decompose_convex
    This value indicates that there is not cut preference
    This constant has been introduced in version 0.25.
    """
    PO_horizontal: ClassVar[int]
    r"""
    @brief A value for the preferred orientation parameter of \decompose_convex
    This value indicates that there only horizontal cuts are allowed
    This constant has been introduced in version 0.25.
    """
    PO_htrapezoids: ClassVar[int]
    r"""
    @brief A value for the preferred orientation parameter of \decompose_convex
    This value indicates that cuts shall favor decomposition into horizontal trapezoids
    This constant has been introduced in version 0.25.
    """
    PO_vertical: ClassVar[int]
    r"""
    @brief A value for the preferred orientation parameter of \decompose_convex
    This value indicates that there only vertical cuts are allowed
    This constant has been introduced in version 0.25.
    """
    PO_vtrapezoids: ClassVar[int]
    r"""
    @brief A value for the preferred orientation parameter of \decompose_convex
    This value indicates that cuts shall favor decomposition into vertical trapezoids
    This constant has been introduced in version 0.25.
    """
    TD_htrapezoids: ClassVar[int]
    r"""
    @brief A value for the mode parameter of \decompose_trapezoids
    This value indicates simple decomposition mode. This mode produces horizontal trapezoids and tries to minimize the number of trapezoids.
    This constant has been introduced in version 0.25.
    """
    TD_simple: ClassVar[int]
    r"""
    @brief A value for the mode parameter of \decompose_trapezoids
    This value indicates simple decomposition mode. This mode is fast but does not make any attempts to produce less trapezoids.
    This constant has been introduced in version 0.25.
    """
    TD_vtrapezoids: ClassVar[int]
    r"""
    @brief A value for the mode parameter of \decompose_trapezoids
    This value indicates simple decomposition mode. This mode produces vertical trapezoids and tries to minimize the number of trapezoids.
    """
    hull: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the points of the hull of polygon
    @param p An array of points to assign to the polygon's hull
    The 'assign_hull' variant is provided in analogy to 'assign_hole'.
    """
    @classmethod
    def ellipse(cls, box: Box, n: int) -> Polygon:
        r"""
        @brief Creates a simple polygon approximating an ellipse

        @param box The bounding box of the ellipse
        @param n The number of points that will be used to approximate the ellipse

        This method has been introduced in version 0.23.
        """
    @classmethod
    def from_s(cls, s: str) -> Polygon:
        r"""
        @brief Creates a polygon from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> Polygon:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether the polygons are equal
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates an empty (invalid) polygon
        """
    @overload
    def __init__(self, box: Box) -> None:
        r"""
        @brief Creates a polygon from a box

        @param box The box to convert to a polygon
        """
    @overload
    def __init__(self, dpolygon: DPolygon) -> None:
        r"""
        @brief Creates an integer coordinate polygon from a floating-point coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dpolygon'.
        """
    @overload
    def __init__(self, sp: SimplePolygon) -> None:
        r"""
        @brief Creates a polygon from a simple polygon
        @param sp The simple polygon that is converted into the polygon
        This method was introduced in version 0.22.
        """
    @overload
    def __init__(self, pts: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a polygon from a point array for the hull

        @param pts The points forming the polygon hull
        @param raw If true, the point list won't be modified (see \assign_hull)

        The 'raw' argument was added in version 0.24.
        """
    def __lt__(self, p: Polygon) -> bool:
        r"""
        @brief Returns a value indicating whether self is less than p
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __mul__(self, f: float) -> Polygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether the polygons are not equal
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def __rmul__(self, f: float) -> Polygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> int:
        r"""
        @brief Gets the area of the polygon
        The area is correct only if the polygon is not self-overlapping and the polygon is oriented clockwise.Orientation is ensured automatically in most cases.
        """
    def area2(self) -> int:
        r"""
        @brief Gets the double area of the polygon
        This method is provided because the area for an integer-type polygon is a multiple of 1/2. Hence the double area can be expresses precisely as an integer for these types.

        This method has been introduced in version 0.26.1
        """
    def assign(self, other: Polygon) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def assign_hole(self, n: int, b: Box) -> None:
        r"""
        @brief Sets the box as the given hole of the polygon
        @param n The index of the hole to which the points should be assigned
        @param b The box to assign to the polygon's hole
        If the hole index is not valid, this method does nothing.
        This method was introduced in version 0.23.
        """
    @overload
    def assign_hole(self, n: int, p: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the given hole of the polygon
        @param n The index of the hole to which the points should be assigned
        @param p An array of points to assign to the polygon's hole
        @param raw If true, the points won't be compressed (see \assign_hull)
        If the hole index is not valid, this method does nothing.

        This method was introduced in version 0.18.
        The 'raw' argument was added in version 0.24.
        """
    def assign_hull(self, p: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the hull of polygon
        @param p An array of points to assign to the polygon's hull
        @param raw If true, the points won't be compressed

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no removal of redundant points or joining of coincident edges will take place. In effect, polygons consisting of a single point or two points can be constructed as well as polygons with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the lowest-leftmost one and the orientation is clockwise always.

        The 'assign_hull' variant is provided in analogy to 'assign_hole'.

        The 'raw' argument was added in version 0.24.
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box of the polygon
        The bounding box is the box enclosing all points of the polygon.
        """
    def compress(self, remove_reflected: bool) -> None:
        r"""
        @brief Compresses the polygon.

        This method removes redundant points from the polygon, such as points being on a line formed by two other points.
        If remove_reflected is true, points are also removed if the two adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.
        """
    def decompose_convex(self, preferred_orientation: Optional[int] = ...) -> List[SimplePolygon]:
        r"""
        @brief Decomposes the polygon into convex pieces

        This method returns a decomposition of the polygon that contains convex pieces only.
        If the polygon was convex already, the list returned has a single element which is the
        original polygon.

        @param preferred_orientation One of the PO_... constants

        This method was introduced in version 0.25.
        """
    def decompose_trapezoids(self, mode: Optional[int] = ...) -> List[SimplePolygon]:
        r"""
        @brief Decomposes the polygon into trapezoids

        This method returns a decomposition of the polygon into trapezoid pieces.
        It supports different modes for various applications. See the TD_... constants for details.

        @param mode One of the TD_... constants

        This method was introduced in version 0.25.
        """
    def dup(self) -> Polygon:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def each_edge(self) -> Iterator[Edge]:
        r"""
        @brief Iterates over the edges that make up the polygon

        This iterator will deliver all edges, including those of the holes. Hole edges are oriented counterclockwise while hull edges are oriented clockwise.
        """
    @overload
    def each_edge(self, contour: int) -> Iterator[Edge]:
        r"""
        @brief Iterates over the edges of one contour of the polygon

        @param contour The contour number (0 for hull, 1 for first hole ...)

        This iterator will deliver all edges of the contour specified by the contour parameter. The hull has contour number 0, the first hole has contour 1 etc.
        Hole edges are oriented counterclockwise while hull edges are oriented clockwise.

        This method was introduced in version 0.24.
        """
    def each_point_hole(self, n: int) -> Iterator[Point]:
        r"""
        @brief Iterates over the points that make up the nth hole
        The hole number must be less than the number of holes (see \holes)
        """
    def each_point_hull(self) -> Iterator[Point]:
        r"""
        @brief Iterates over the points that make up the hull
        """
    def extract_rad(self) -> List[Any]:
        r"""
        @brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of the \round_corners method. If this method succeeds, if will return an array of four elements: @ul
        @li The polygon with the rounded corners replaced by edgy ones @/li
        @li The radius of the inner corners @/li
        @li The radius of the outer corners @/li
        @li The number of points per full circle @/li
        @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is returned.

        If successful, the following code will more or less render the original polygon and parameters

        @code
        p = ...   # some polygon
        p.round_corners(ri, ro, n)
        (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits)
        @/code

        This method was introduced in version 0.25.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def holes(self) -> int:
        r"""
        @brief Returns the number of holes
        """
    @overload
    def insert_hole(self, b: Box) -> None:
        r"""
        @brief Inserts a hole from the given box
        @param b The box to insert as a new hole
        This method was introduced in version 0.23.
        """
    @overload
    def insert_hole(self, p: Sequence[Point], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Inserts a hole with the given points
        @param p An array of points to insert as a new hole
        @param raw If true, the points won't be compressed (see \assign_hull)

        The 'raw' argument was added in version 0.24.
        """
    def inside(self, p: Point) -> bool:
        r"""
        @brief Tests, if the given point is inside the polygon
        If the given point is inside or on the edge of the polygon, true is returned. This tests works well only if the polygon is not self-overlapping and oriented clockwise. 
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.
        """
    def is_convex(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is convex

        This method will return true, if the polygon is convex.

        This method was introduced in version 0.25.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is empty
        """
    def is_halfmanhattan(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is half-manhattan
        Half-manhattan polygons have edges which are multiples of 45 degree. These polygons can be clipped at a rectangle without potential grid snapping.

        This predicate was introduced in version 0.27.
        """
    def is_rectilinear(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is rectilinear
        """
    @overload
    def minkowski_sum(self, b: Box, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of the polygon and a box

        @param b The box.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and the box.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, b: Polygon, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of the polygon and a polygon

        @param p The first argument.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and p.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, b: Sequence[Point], resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of the polygon and a contour of points (a trace)

        @param b The contour (a series of points forming the trace).
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum of self and the contour.

        This method was introduced in version 0.22.
        """
    @overload
    def minkowski_sum(self, e: Edge, resolve_holes: bool) -> Polygon:
        r"""
        @brief Computes the Minkowski sum of the polygon and an edge

        @param e The edge.
        @param resolve_holes If true, the output polygon will not contain holes, but holes are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowski sum with the edge e.

        The Minkowski sum of a polygon and an edge basically results in the area covered when "dragging" the polygon along the line given by the edge. The effect is similar to drawing the line with a pencil that has the shape of the given polygon.

        This method was introduced in version 0.22.
        """
    @overload
    def move(self, p: Vector) -> Polygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param p The distance to move the polygon.

        @return The moved polygon (self).

        This method has been introduced in version 0.23.
        """
    @overload
    def move(self, x: int, y: int) -> Polygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon (self).
        """
    @overload
    def moved(self, p: Vector) -> Polygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param p The distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    @overload
    def moved(self, x: int, y: int) -> Polygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Gets the total number of points (hull plus holes)
        This method was introduced in version 0.18.
        """
    def num_points_hole(self, n: int) -> int:
        r"""
        @brief Gets the number of points of the given hole
        The argument gives the index of the hole of which the number of points are requested. The index must be less than the number of holes (see \holes). 
        """
    def num_points_hull(self) -> int:
        r"""
        @brief Gets the number of points of the hull
        """
    def perimeter(self) -> int:
        r"""
        @brief Gets the perimeter of the polygon
        The perimeter is sum of the lengths of all edges making up the polygon.

        This method has been introduce in version 0.23.
        """
    def point_hole(self, n: int, p: int) -> Point:
        r"""
        @brief Gets a specific point of a hole
        @param n The index of the hole to which the points should be assigned
        @param p The index of the point to get
        If the index of the point or of the hole is not valid, a default value is returned.
        This method was introduced in version 0.18.
        """
    def point_hull(self, p: int) -> Point:
        r"""
        @brief Gets a specific point of the hull
        @param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned.
        This method was introduced in version 0.18.
        """
    def resolve_holes(self) -> None:
        r"""
        @brief Resolve holes by inserting cut lines and joining the holes with the hull

        This method modifies the polygon. The out-of-place version is \resolved_holes.
        This method was introduced in version 0.22.
        """
    def resolved_holes(self) -> Polygon:
        r"""
        @brief Returns a polygon without holes

        @return The new polygon without holes.

        This method does not modify the polygon but return a new polygon.
        This method was introduced in version 0.22.
        """
    def round_corners(self, rinner: float, router: float, n: int) -> Polygon:
        r"""
        @brief Rounds the corners of the polygon

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units).
        @param router The circle radius of outer corners (in database units).
        @param n The number of points per full circle.

        @return The new polygon.

        This method was introduced in version 0.20 for integer coordinates and in 0.25 for all coordinate types.
        """
    @overload
    def size(self, d: int) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        size(d, d, 2)
        @/code

        See \size for a detailed description.
        """
    @overload
    def size(self, d: int, mode: int) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        size(d, d, mode)
        @/code

        See \size for a detailed description.

        This method has been introduced in version 0.23.
        """
    @overload
    def size(self, dx: int, dy: int, mode: int) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (dx,dy>0) or inwards (dx,dy<0).
        dx is the sizing in x-direction and dy is the sizing in y-direction. The sign of dx and dy should be identical.
        The sizing operation create invalid (self-overlapping, reverse oriented) contours. 

        The mode defines at which bending angle cutoff occurs 
        (0:>0, 1:>45, 2:>90, 3:>135, 4:>approx. 168, other:>approx. 179)

        In order to obtain a proper polygon in the general case, the
        sized polygon must be merged in 'greater than zero' wrap count mode. This is necessary since in the general case,
        sizing can be complicated operation which lets a single polygon fall apart into disjoint pieces for example.
        This can be achieved using the \EdgeProcessor class for example:

        @code
        poly = ... # a RBA::Polygon
        poly.size(-50, 2)
        ep = RBA::EdgeProcessor::new
        # result is an array of RBA::Polygon objects
        result = ep.simple_merge_p2p([ poly ], false, false, 1)
        @/code
        """
    @overload
    def sized(self, d: int) -> Polygon:
        r"""
        @brief Sizes the polygon (biasing)

        @brief Sizing (biasing) without modifying self
        This method is equivalent to
        @code
        sized(d, d, 2)
        @/code

        See \size and \sized for a detailed description.
        """
    @overload
    def sized(self, d: int, mode: int) -> Polygon:
        r"""
        @brief Sizes the polygon (biasing) without modifying self

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        sized(d, d, mode)
        @/code

        See \size and \sized for a detailed description.
        """
    @overload
    def sized(self, dx: int, dy: int, mode: int) -> Polygon:
        r"""
        @brief Sizes the polygon (biasing) without modifying self

        This method applies sizing to the polygon but does not modify self. Instead a sized copy is returned.
        See \size for a description of the operation.

        This method has been introduced in version 0.23.
        """
    def smooth(self, d: int, keep_hv: Optional[bool] = ...) -> Polygon:
        r"""
        @brief Smooths a polygon

        Remove vertices that deviate by more than the distance d from the average contour.
        The value d is basically the roughness which is removed.

        @param d The smoothing "roughness".
        @param keep_hv If true, horizontal and vertical edges will be preserved always.

        @return The smoothed polygon.

        This method was introduced in version 0.23. The 'keep_hv' optional parameter was added in version 0.27.
        """
    def split(self) -> List[Polygon]:
        r"""
        @brief Splits the polygon into two or more parts
        This method will break the polygon into parts. The exact breaking algorithm is unspecified, the result are smaller polygons of roughly equal number of points and 'less concave' nature. Usually the returned polygon set consists of two polygons, but there can be more. The merged region of the resulting polygons equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some maximum number of points limit.

        This method has been introduced in version 0.25.3.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DPolygon:
        r"""
        @brief Converts the polygon to a floating-point coordinate polygon

        The database unit can be specified to translate the integer-coordinate polygon into a floating-point coordinate polygon in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def to_simple_polygon(self) -> SimplePolygon:
        r"""
        @brief Converts a polygon to a simple polygon

        @return The simple polygon.

        If the polygon contains holes, these will be resolved.
        This operation requires a well-formed polygon. Reflecting edges, self-intersections and coincident points will be removed.

        This method was introduced in version 0.22.
        """
    @overload
    def touches(self, box: Box) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given box.
        The box and the polygon touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, edge: Edge) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given edge.
        The edge and the polygon touch if they overlap or the edge shares at least one point with the polygon's contour.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, polygon: Polygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, simple_polygon: SimplePolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def transform(self, t: ICplxTrans) -> Polygon:
        r"""
        @brief Transforms the polygon with a complex transformation (in-place)

        Transforms the polygon with the given complex transformation.
        This version modifies self and will return self as the modified polygon. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method was introduced in version 0.24.
        """
    @overload
    def transform(self, t: Trans) -> Polygon:
        r"""
        @brief Transforms the polygon (in-place)

        Transforms the polygon with the given transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transformed(self, t: CplxTrans) -> DPolygon:
        r"""
        @brief Transforms the polygon with a complex transformation

        Transforms the polygon with the given complex transformation.
        Does not modify the polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed' takes both simple and complex transformations.
        """
    @overload
    def transformed(self, t: Trans) -> Polygon:
        r"""
        @brief Transforms the polygon

        Transforms the polygon with the given transformation.
        Does not modify the polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.
        """

class DPolygon:
    r"""
    @brief A polygon class

    A polygon consists of an outer hull and zero to many
    holes. Each contour consists of several points. The point
    list is normalized such that the leftmost, lowest point is 
    the first one. The orientation is normalized such that
    the orientation of the hull contour is clockwise, while
    the orientation of the holes is counterclockwise.

    It is in no way checked that the contours are not overlapping.
    This must be ensured by the user of the object
    when filling the contours.

    A polygon can be asked for the number of holes using the \holes method. \each_point_hull delivers the points of the hull contour. \each_point_hole delivers the points of a specific hole. \each_edge delivers the edges (point-to-point connections) of both hull and holes. \bbox delivers the bounding box, \area the area and \perimeter the perimeter of the polygon.

    Here's an example of how to create a polygon:

    @code
    hull =  [ RBA::DPoint::new(0, 0),       RBA::DPoint::new(6000, 0), 
              RBA::DPoint::new(6000, 3000), RBA::DPoint::new(0, 3000) ]
    hole1 = [ RBA::DPoint::new(1000, 1000), RBA::DPoint::new(2000, 1000), 
              RBA::DPoint::new(2000, 2000), RBA::DPoint::new(1000, 2000) ]
    hole2 = [ RBA::DPoint::new(3000, 1000), RBA::DPoint::new(4000, 1000), 
              RBA::DPoint::new(4000, 2000), RBA::DPoint::new(3000, 2000) ]
    poly = RBA::DPolygon::new(hull)
    poly.insert_hole(hole1)
    poly.insert_hole(hole2)

    # ask the polygon for some properties
    poly.holes      # -> 2
    poly.area       # -> 16000000.0
    poly.perimeter  # -> 26000.0
    poly.bbox       # -> (0,0;6000,3000)
    @/code

    The \DPolygon class stores coordinates in floating-point format which gives a higher precision for some operations. A class that stores integer coordinates is \Polygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    hull: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the points of the hull of polygon
    @param p An array of points to assign to the polygon's hull
    The 'assign_hull' variant is provided in analogy to 'assign_hole'.
    """
    @classmethod
    def ellipse(cls, box: DBox, n: int) -> DPolygon:
        r"""
        @brief Creates a simple polygon approximating an ellipse

        @param box The bounding box of the ellipse
        @param n The number of points that will be used to approximate the ellipse

        This method has been introduced in version 0.23.
        """
    @classmethod
    def from_s(cls, s: str) -> DPolygon:
        r"""
        @brief Creates a polygon from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DPolygon:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether the polygons are equal
        @param p The object to compare against
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates an empty (invalid) polygon
        """
    @overload
    def __init__(self, box: DBox) -> None:
        r"""
        @brief Creates a polygon from a box

        @param box The box to convert to a polygon
        """
    @overload
    def __init__(self, polygon: Polygon) -> None:
        r"""
        @brief Creates a floating-point coordinate polygon from an integer coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_ipolygon'.
        """
    @overload
    def __init__(self, sp: DSimplePolygon) -> None:
        r"""
        @brief Creates a polygon from a simple polygon
        @param sp The simple polygon that is converted into the polygon
        This method was introduced in version 0.22.
        """
    @overload
    def __init__(self, pts: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a polygon from a point array for the hull

        @param pts The points forming the polygon hull
        @param raw If true, the point list won't be modified (see \assign_hull)

        The 'raw' argument was added in version 0.24.
        """
    def __lt__(self, p: DPolygon) -> bool:
        r"""
        @brief Returns a value indicating whether self is less than p
        @param p The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __mul__(self, f: float) -> DPolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __ne__(self, p: object) -> bool:
        r"""
        @brief Returns a value indicating whether the polygons are not equal
        @param p The object to compare against
        """
    def __repr__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def __rmul__(self, f: float) -> DPolygon:
        r"""
        @brief Scales the polygon by some factor

        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    def __str__(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> float:
        r"""
        @brief Gets the area of the polygon
        The area is correct only if the polygon is not self-overlapping and the polygon is oriented clockwise.Orientation is ensured automatically in most cases.
        """
    def area2(self) -> float:
        r"""
        @brief Gets the double area of the polygon
        This method is provided because the area for an integer-type polygon is a multiple of 1/2. Hence the double area can be expresses precisely as an integer for these types.

        This method has been introduced in version 0.26.1
        """
    def assign(self, other: DPolygon) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def assign_hole(self, n: int, b: DBox) -> None:
        r"""
        @brief Sets the box as the given hole of the polygon
        @param n The index of the hole to which the points should be assigned
        @param b The box to assign to the polygon's hole
        If the hole index is not valid, this method does nothing.
        This method was introduced in version 0.23.
        """
    @overload
    def assign_hole(self, n: int, p: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the given hole of the polygon
        @param n The index of the hole to which the points should be assigned
        @param p An array of points to assign to the polygon's hole
        @param raw If true, the points won't be compressed (see \assign_hull)
        If the hole index is not valid, this method does nothing.

        This method was introduced in version 0.18.
        The 'raw' argument was added in version 0.24.
        """
    def assign_hull(self, p: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Sets the points of the hull of polygon
        @param p An array of points to assign to the polygon's hull
        @param raw If true, the points won't be compressed

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no removal of redundant points or joining of coincident edges will take place. In effect, polygons consisting of a single point or two points can be constructed as well as polygons with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the lowest-leftmost one and the orientation is clockwise always.

        The 'assign_hull' variant is provided in analogy to 'assign_hole'.

        The 'raw' argument was added in version 0.24.
        """
    def bbox(self) -> DBox:
        r"""
        @brief Returns the bounding box of the polygon
        The bounding box is the box enclosing all points of the polygon.
        """
    def compress(self, remove_reflected: bool) -> None:
        r"""
        @brief Compresses the polygon.

        This method removes redundant points from the polygon, such as points being on a line formed by two other points.
        If remove_reflected is true, points are also removed if the two adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.
        """
    def dup(self) -> DPolygon:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def each_edge(self) -> Iterator[DEdge]:
        r"""
        @brief Iterates over the edges that make up the polygon

        This iterator will deliver all edges, including those of the holes. Hole edges are oriented counterclockwise while hull edges are oriented clockwise.
        """
    @overload
    def each_edge(self, contour: int) -> Iterator[DEdge]:
        r"""
        @brief Iterates over the edges of one contour of the polygon

        @param contour The contour number (0 for hull, 1 for first hole ...)

        This iterator will deliver all edges of the contour specified by the contour parameter. The hull has contour number 0, the first hole has contour 1 etc.
        Hole edges are oriented counterclockwise while hull edges are oriented clockwise.

        This method was introduced in version 0.24.
        """
    def each_point_hole(self, n: int) -> Iterator[DPoint]:
        r"""
        @brief Iterates over the points that make up the nth hole
        The hole number must be less than the number of holes (see \holes)
        """
    def each_point_hull(self) -> Iterator[DPoint]:
        r"""
        @brief Iterates over the points that make up the hull
        """
    def extract_rad(self) -> List[Any]:
        r"""
        @brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of the \round_corners method. If this method succeeds, if will return an array of four elements: @ul
        @li The polygon with the rounded corners replaced by edgy ones @/li
        @li The radius of the inner corners @/li
        @li The radius of the outer corners @/li
        @li The number of points per full circle @/li
        @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is returned.

        If successful, the following code will more or less render the original polygon and parameters

        @code
        p = ...   # some polygon
        p.round_corners(ri, ro, n)
        (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits)
        @/code

        This method was introduced in version 0.25.
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given polygon. This method enables polygons as hash keys.

        This method has been introduced in version 0.25.
        """
    def holes(self) -> int:
        r"""
        @brief Returns the number of holes
        """
    @overload
    def insert_hole(self, b: DBox) -> None:
        r"""
        @brief Inserts a hole from the given box
        @param b The box to insert as a new hole
        This method was introduced in version 0.23.
        """
    @overload
    def insert_hole(self, p: Sequence[DPoint], raw: Optional[bool] = ...) -> None:
        r"""
        @brief Inserts a hole with the given points
        @param p An array of points to insert as a new hole
        @param raw If true, the points won't be compressed (see \assign_hull)

        The 'raw' argument was added in version 0.24.
        """
    def inside(self, p: DPoint) -> bool:
        r"""
        @brief Tests, if the given point is inside the polygon
        If the given point is inside or on the edge of the polygon, true is returned. This tests works well only if the polygon is not self-overlapping and oriented clockwise. 
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is empty
        """
    def is_halfmanhattan(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is half-manhattan
        Half-manhattan polygons have edges which are multiples of 45 degree. These polygons can be clipped at a rectangle without potential grid snapping.

        This predicate was introduced in version 0.27.
        """
    def is_rectilinear(self) -> bool:
        r"""
        @brief Returns a value indicating whether the polygon is rectilinear
        """
    @overload
    def move(self, p: DVector) -> DPolygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param p The distance to move the polygon.

        @return The moved polygon (self).

        This method has been introduced in version 0.23.
        """
    @overload
    def move(self, x: float, y: float) -> DPolygon:
        r"""
        @brief Moves the polygon.

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is overwritten.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon (self).
        """
    @overload
    def moved(self, p: DVector) -> DPolygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param p The distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    @overload
    def moved(self, x: float, y: float) -> DPolygon:
        r"""
        @brief Returns the moved polygon (does not modify self)

        Moves the polygon by the given offset and returns the 
        moved polygon. The polygon is not modified.

        @param x The x distance to move the polygon.
        @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.
        """
    def num_points(self) -> int:
        r"""
        @brief Gets the total number of points (hull plus holes)
        This method was introduced in version 0.18.
        """
    def num_points_hole(self, n: int) -> int:
        r"""
        @brief Gets the number of points of the given hole
        The argument gives the index of the hole of which the number of points are requested. The index must be less than the number of holes (see \holes). 
        """
    def num_points_hull(self) -> int:
        r"""
        @brief Gets the number of points of the hull
        """
    def perimeter(self) -> float:
        r"""
        @brief Gets the perimeter of the polygon
        The perimeter is sum of the lengths of all edges making up the polygon.

        This method has been introduce in version 0.23.
        """
    def point_hole(self, n: int, p: int) -> DPoint:
        r"""
        @brief Gets a specific point of a hole
        @param n The index of the hole to which the points should be assigned
        @param p The index of the point to get
        If the index of the point or of the hole is not valid, a default value is returned.
        This method was introduced in version 0.18.
        """
    def point_hull(self, p: int) -> DPoint:
        r"""
        @brief Gets a specific point of the hull
        @param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned.
        This method was introduced in version 0.18.
        """
    def round_corners(self, rinner: float, router: float, n: int) -> DPolygon:
        r"""
        @brief Rounds the corners of the polygon

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units).
        @param router The circle radius of outer corners (in database units).
        @param n The number of points per full circle.

        @return The new polygon.

        This method was introduced in version 0.20 for integer coordinates and in 0.25 for all coordinate types.
        """
    @overload
    def size(self, d: float) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        size(d, d, 2)
        @/code

        See \size for a detailed description.
        """
    @overload
    def size(self, d: float, mode: int) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        size(d, d, mode)
        @/code

        See \size for a detailed description.

        This method has been introduced in version 0.23.
        """
    @overload
    def size(self, dx: float, dy: float, mode: int) -> None:
        r"""
        @brief Sizes the polygon (biasing)

        Shifts the contour outwards (dx,dy>0) or inwards (dx,dy<0).
        dx is the sizing in x-direction and dy is the sizing in y-direction. The sign of dx and dy should be identical.
        The sizing operation create invalid (self-overlapping, reverse oriented) contours. 

        The mode defines at which bending angle cutoff occurs 
        (0:>0, 1:>45, 2:>90, 3:>135, 4:>approx. 168, other:>approx. 179)

        In order to obtain a proper polygon in the general case, the
        sized polygon must be merged in 'greater than zero' wrap count mode. This is necessary since in the general case,
        sizing can be complicated operation which lets a single polygon fall apart into disjoint pieces for example.
        This can be achieved using the \EdgeProcessor class for example:

        @code
        poly = ... # a RBA::Polygon
        poly.size(-50, 2)
        ep = RBA::EdgeProcessor::new
        # result is an array of RBA::Polygon objects
        result = ep.simple_merge_p2p([ poly ], false, false, 1)
        @/code
        """
    @overload
    def sized(self, d: float) -> DPolygon:
        r"""
        @brief Sizes the polygon (biasing)

        @brief Sizing (biasing) without modifying self
        This method is equivalent to
        @code
        sized(d, d, 2)
        @/code

        See \size and \sized for a detailed description.
        """
    @overload
    def sized(self, d: float, mode: int) -> DPolygon:
        r"""
        @brief Sizes the polygon (biasing) without modifying self

        Shifts the contour outwards (d>0) or inwards (d<0).
        This method is equivalent to
        @code
        sized(d, d, mode)
        @/code

        See \size and \sized for a detailed description.
        """
    @overload
    def sized(self, dx: float, dy: float, mode: int) -> DPolygon:
        r"""
        @brief Sizes the polygon (biasing) without modifying self

        This method applies sizing to the polygon but does not modify self. Instead a sized copy is returned.
        See \size for a description of the operation.

        This method has been introduced in version 0.23.
        """
    def split(self) -> List[DPolygon]:
        r"""
        @brief Splits the polygon into two or more parts
        This method will break the polygon into parts. The exact breaking algorithm is unspecified, the result are smaller polygons of roughly equal number of points and 'less concave' nature. Usually the returned polygon set consists of two polygons, but there can be more. The merged region of the resulting polygons equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some maximum number of points limit.

        This method has been introduced in version 0.25.3.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Polygon:
        r"""
        @brief Converts the polygon to an integer coordinate polygon

        The database unit can be specified to translate the floating-point coordinate polygon in micron units to an integer-coordinate polygon in database units. The polygons coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Returns a string representing the polygon
        """
    @overload
    def touches(self, box: DBox) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given box.
        The box and the polygon touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, edge: DEdge) -> bool:
        r"""
        @brief Returns true, if the polygon touches the given edge.
        The edge and the polygon touch if they overlap or the edge shares at least one point with the polygon's contour.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, polygon: DPolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def touches(self, simple_polygon: DSimplePolygon) -> bool:
        r"""
        @brief Returns true, if the polygon touches the other polygon.
        The polygons touch if they overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.
        """
    @overload
    def transform(self, t: DCplxTrans) -> DPolygon:
        r"""
        @brief Transforms the polygon with a complex transformation (in-place)

        Transforms the polygon with the given complex transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transform(self, t: DTrans) -> DPolygon:
        r"""
        @brief Transforms the polygon (in-place)

        Transforms the polygon with the given transformation.
        Modifies self and returns self. An out-of-place version which does not modify self is \transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DPolygon:
        r"""
        @brief Transforms the polygon with a complex transformation

        Transforms the polygon with the given complex transformation.
        Does not modify the polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed' takes both simple and complex transformations.
        """
    @overload
    def transformed(self, t: DTrans) -> DPolygon:
        r"""
        @brief Transforms the polygon

        Transforms the polygon with the given transformation.
        Does not modify the polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.
        """
    @overload
    def transformed(self, t: VCplxTrans) -> Polygon:
        r"""
        @brief Transforms the polygon with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed polygon (in this case an integer coordinate polygon)

        This method has been introduced in version 0.25.
        """

class LayerMap:
    r"""
    @brief An object representing an arbitrary mapping of physical layers to logical layers

    "Physical" layers are stream layers or other separated layers in a CAD file. "Logical" layers are the layers present in a \Layout object. Logical layers are represented by an integer index while physical layers are given by a layer and datatype number or name. A logical layer is created automatically in the layout on reading if it does not exist yet.

    The mapping describes an association of a set of physical layers to a set of logical ones, where multiple
    physical layers can be mapped to a single logical one, which effectively merges the layers.

    For each logical layer, a target layer can be specified. A target layer is the layer/datatype/name combination
    as which the logical layer appears in the layout. By using a target layer different from the source layer
    renaming a layer can be achieved while loading a layout. Another use case for that feature is to assign
    layer names to GDS layer/datatype combinations which are numerical only.

    LayerMap objects are used in two ways: as input for the reader (inside a \LoadLayoutOptions class) and
    as output from the reader (i.e. Layout::read method). For layer map objects used as input, the layer indexes
    (logical layers) can be consecutive numbers. They do not need to correspond with real layer indexes from
    a layout object. When used as output, the layer map's logical layers correspond to the layer indexes inside
    the layout that the layer map was used upon.

    This is a sample how to use the LayerMap object. It maps all datatypes of layers 1, 2 and 3 to datatype 0 and
    assigns the names 'ONE', 'TWO' and 'THREE' to these layout layers:

    @codelm = RBA::LayerMap::new
    lm.map("1/0-255 : ONE (1/0)", 0)
    lm.map("2/0-255 : TWO (2/0)", 1)
    lm.map("3/0-255 : THREE (3/0)", 2)

    # read the layout using the layer map
    lo = RBA::LoadLayoutOptions::new
    lo.layer_map.assign(lm)
    ly = RBA::Layout::new
    ly.read("input.gds", lo)
    @/code

    1:n mapping is supported: a physical layer can be mapped to multiple logical layers using 'mmap' instead of 'map'. When using this variant, mapping acts additive.
    The following example will map layer 1, datatypes 0 to 255 to logical layer 0, and layer 1, datatype 17 to logical layers 0 plus 1:
    @codelm = RBA::LayerMap::new
    lm.map("1/0-255", 0)   # (can be 'mmap' too)
    lm.mmap("1/17", 1)
    @/code

    'unmapping' allows removing a mapping. This allows creating 'holes' in mapping ranges. The following example maps layer 1, datatypes 0 to 16 and 18 to 255 to logical layer 0:
    @codelm = RBA::LayerMap::new
    lm.map("1/0-255", 0)
    lm.unmap("1/17")
    @/code

    The LayerMap class has been introduced in version 0.18. Target layer have been introduced in version 0.20. 1:n mapping and unmapping has been introduced in version 0.27.
    """
    def __copy__(self) -> LayerMap:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: LayerMap) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear(self) -> None:
        r"""
        @brief Clears the map
        """
    def dup(self) -> LayerMap:
        r"""
        @brief Creates a copy of self
        """
    def from_string(self, arg0: str) -> LayerMap:
        r"""
        @brief Creates a layer map from the given string
        The format of the string is that used in layer mapping files: one mapping entry per line, comments are allowed using '#' or '//'. The format of each line is that used in the 'map(string, index)' method.

        This method has been introduced in version 0.23.
        """
    def is_mapped(self, layer: LayerInfo) -> bool:
        r"""
        @brief Check, if a given physical layer is mapped
        @param layer The physical layer specified with an \LayerInfo object.
        @return True, if the layer is mapped.
        """
    def logicals(self, layer: LayerInfo) -> List[int]:
        r"""
        @brief Returns the logical layers for a given physical layer.n@param layer The physical layer specified with an \LayerInfo object.
        @return This list of logical layers this physical layer as mapped to or empty if there is no mapping.
        This method has been introduced in version 0.27.
        """
    @overload
    def map(self, map_expr: str, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer given by a string to a logical one
        @param map_expr The string describing the physical layer to map.
        @param log_layer The logical layer to which the physical layers are mapped.

        The string expression is constructed using the syntax: 
        "list[/list][;..]" for layer/datatype pairs. "list" is a 
        sequence of numbers, separated by comma values or a range 
        separated by a hyphen. Examples are: "1/2", "1-5/0", "1,2,5/0",
        "1/5;5/6".

        layer/datatype wildcards can be specified with "*". When "*" is used
        for the upper limit, it is equivalent to "all layer above". When used
        alone, it is equivalent to "all layers". Examples: "1 / *", "* / 10-*"

        Named layers are specified simply by specifying the name, if
        necessary in single or double quotes (if the name begins with a digit or
        contains non-word characters). layer/datatype and name descriptions can
        be mixed, i.e. "AA;1/5" (meaning: name "AA" or layer 1/datatype 5).

        A target layer can be specified with the ":<target>" notation, where
        target is a valid string for a LayerProperties() object.

        A target can include relative layer/datatype specifications and wildcards.
        For example, "1-10/0: *+1/0" will add 1 to the original layer number.
        "1-10/0-50: * / *" will use the original layers.

        Target mapping has been added in version 0.20.
        """
    @overload
    def map(self, phys_layer: LayerInfo, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer to a logical one
        @param phys_layer The physical layer (a \LayerInfo object).
        @param log_layer The logical layer to which the physical layer is mapped.

        In general, there may be more than one physical layer mapped
        to one logical layer. This method will add the given physical layer to the mapping for the logical layer.
        """
    @overload
    def map(self, phys_layer: LayerInfo, log_layer: int, target_layer: LayerInfo) -> None:
        r"""
        @brief Maps a physical layer to a logical one with a target layer
        @param phys_layer The physical layer (a \LayerInfo object).
        @param log_layer The logical layer to which the physical layer is mapped.
        @param target_layer The properties of the layer that will be created unless it already exists.

        In general, there may be more than one physical layer mapped
        to one logical layer. This method will add the given physical layer to the mapping for the logical layer.

        This method has been added in version 0.20.
        """
    @overload
    def map(self, pl_start: LayerInfo, pl_stop: LayerInfo, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer interval to a logical one
        @param pl_start The first physical layer (a \LayerInfo object).
        @param pl_stop The last physical layer (a \LayerInfo object).
        @param log_layer The logical layer to which the physical layers are mapped.

        This method maps an interval of layers l1..l2 and datatypes d1..d2 to the mapping for the given logical layer. l1 and d1 are given by the pl_start argument, while l2 and d2 are given by the pl_stop argument.
        """
    @overload
    def map(self, pl_start: LayerInfo, pl_stop: LayerInfo, log_layer: int, layer_properties: LayerInfo) -> None:
        r"""
        @brief Maps a physical layer interval to a logical one with a target layer
        @param pl_start The first physical layer (a \LayerInfo object).
        @param pl_stop The last physical layer (a \LayerInfo object).
        @param log_layer The logical layer to which the physical layers are mapped.
        @param target_layer The properties of the layer that will be created unless it already exists.

        This method maps an interval of layers l1..l2 and datatypes d1..d2 to the mapping for the given logical layer. l1 and d1 are given by the pl_start argument, while l2 and d2 are given by the pl_stop argument.
        This method has been added in version 0.20.
        """
    def mapping(self, log_layer: int) -> LayerInfo:
        r"""
        @brief Returns the mapped physical (or target if one is specified) layer for a given logical layer
        @param log_layer The logical layer for which the mapping is requested.
        @return A \LayerInfo object which is the physical layer mapped to the logical layer.
        In general, there may be more than one physical layer mapped
        to one logical layer. This method will return a single one of
        them. It will return the one with the lowest layer and datatype.
        """
    def mapping_str(self, log_layer: int) -> str:
        r"""
        @brief Returns the mapping string for a given logical layer
        @param log_layer The logical layer for which the mapping is requested.
        @return A string describing the mapping.
        The mapping string is compatible with the string that the "map" method accepts.
        """
    @overload
    def mmap(self, map_expr: str, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer given by an expression to a logical one and adds to existing mappings

        This method acts like the corresponding 'map' method, but adds the logical layer to the receivers of the given physical one. Hence this method implements 1:n mapping capabilities.
        For backward compatibility, 'map' still substitutes mapping.

        Multi-mapping has been added in version 0.27.
        """
    @overload
    def mmap(self, phys_layer: LayerInfo, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer to a logical one and adds to existing mappings

        This method acts like the corresponding 'map' method, but adds the logical layer to the receivers of the given physical one. Hence this method implements 1:n mapping capabilities.
        For backward compatibility, 'map' still substitutes mapping.

        Multi-mapping has been added in version 0.27.
        """
    @overload
    def mmap(self, phys_layer: LayerInfo, log_layer: int, target_layer: LayerInfo) -> None:
        r"""
        @brief Maps a physical layer to a logical one, adds to existing mappings and specifies a target layer

        This method acts like the corresponding 'map' method, but adds the logical layer to the receivers of the given physical one. Hence this method implements 1:n mapping capabilities.
        For backward compatibility, 'map' still substitutes mapping.

        Multi-mapping has been added in version 0.27.
        """
    @overload
    def mmap(self, pl_start: LayerInfo, pl_stop: LayerInfo, log_layer: int) -> None:
        r"""
        @brief Maps a physical layer from the given interval to a logical one and adds to existing mappings

        This method acts like the corresponding 'map' method, but adds the logical layer to the receivers of the given physical one. Hence this method implements 1:n mapping capabilities.
        For backward compatibility, 'map' still substitutes mapping.

        Multi-mapping has been added in version 0.27.
        """
    @overload
    def mmap(self, pl_start: LayerInfo, pl_stop: LayerInfo, log_layer: int, layer_properties: LayerInfo) -> None:
        r"""
        @brief Maps a physical layer from the given interval to a logical one, adds to existing mappings and specifies a target layer

        This method acts like the corresponding 'map' method, but adds the logical layer to the receivers of the given physical one. Hence this method implements 1:n mapping capabilities.
        For backward compatibility, 'map' still substitutes mapping.

        Multi-mapping has been added in version 0.27.
        """
    def to_string(self) -> str:
        r"""
        @brief Converts a layer mapping object to a string
        This method is the inverse of the \from_string method.

        This method has been introduced in version 0.23.
        """
    @overload
    def unmap(self, expr: str) -> None:
        r"""
        @brief Unmaps the layers from the given expression
        This method has been introduced in version 0.27.
        """
    @overload
    def unmap(self, phys_layer: LayerInfo) -> None:
        r"""
        @brief Unmaps the given layer
        Unmapping will remove the specific layer from the mapping. This method allows generating 'mapping holes' by first mapping a range and then unmapping parts of it.

        This method has been introduced in version 0.27.
        """
    @overload
    def unmap(self, pl_start: LayerInfo, pl_stop: LayerInfo) -> None:
        r"""
        @brief Unmaps the layers from the given interval
        This method has been introduced in version 0.27.
        """

class LoadLayoutOptions:
    r"""
    @brief Layout reader options

    This object describes various layer reader options used for loading layouts.

    This class has been introduced in version 0.18.
    """
    class CellConflictResolution:
        r"""
        @brief This enum specifies how cell conflicts are handled if a layout read into another layout and a cell name conflict arises.
        Until version 0.26.8 and before, the mode was always 'AddToCell'. On reading, a cell was 'reopened' when encountering a cell name which already existed. This mode is still the default. The other modes are made available to support other ways of merging layouts.

        Proxy cells are never modified in the existing layout. Proxy cells are always local to their layout file. So if the existing cell is a proxy cell, the new cell will be renamed.

        If the new or existing cell is a ghost cell, both cells are merged always.

        This enum was introduced in version 0.27.
        """
        AddToCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
        r"""
        @brief Add content to existing cell
        This is the mode use in before version 0.27. Content of new cells is simply added to existing cells with the same name.
        """
        OverwriteCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
        r"""
        @brief The old cell is overwritten entirely (including child cells which are not used otherwise)
        """
        RenameCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
        r"""
        @brief The new cell will be renamed to become unique
        """
        SkipNewCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
        r"""
        @brief The new cell is skipped entirely (including child cells which are not used otherwise)
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: LoadLayoutOptions.CellConflictResolution) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    AddToCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
    r"""
    @brief Add content to existing cell
    This is the mode use in before version 0.27. Content of new cells is simply added to existing cells with the same name.
    """
    OverwriteCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
    r"""
    @brief The old cell is overwritten entirely (including child cells which are not used otherwise)
    """
    RenameCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
    r"""
    @brief The new cell will be renamed to become unique
    """
    SkipNewCell: ClassVar[LoadLayoutOptions.CellConflictResolution]
    r"""
    @brief The new cell is skipped entirely (including child cells which are not used otherwise)
    """
    cell_conflict_resolution: LoadLayoutOptions.CellConflictResolution
    r"""
    @brief Gets the cell conflict resolution mode

    Multiple layout files can be collected into a single Layout object by reading file after file into the Layout object. Cells with same names are considered a conflict. This mode indicates how such conflicts are resolved. See \LoadLayoutOptions::CellConflictResolution for the values allowed. The default mode is \LoadLayoutOptions::CellConflictResolution#AddToCell.

    This option has been introduced in version 0.27.@brief Sets the cell conflict resolution mode

    See \cell_conflict_resolution for details about this option.

    This option has been introduced in version 0.27.
    """
    cif_create_other_layers: bool
    r"""
    @brief Gets a value indicating whether other layers shall be created
    @return True, if other layers will be created.
    This attribute acts together with a layer map (see \cif_layer_map=). Layers not listed in this map are created as well when \cif_create_other_layers? is true. Otherwise they are ignored.

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.@brief Specifies whether other layers shall be created
    @param create True, if other layers will be created.
    See \cif_create_other_layers? for a description of this attribute.

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
    """
    cif_dbu: float
    r"""
    @brief Specifies the database unit which the reader uses and produces
    See \cif_dbu= method for a description of this property.
    This property has been added in version 0.21.
    @brief Specifies the database unit which the reader uses and produces

    This property has been added in version 0.21.
    """
    cif_keep_layer_names: bool
    r"""
    @brief Gets a value indicating whether layer names are kept
    @return True, if layer names are kept.

    When set to true, no attempt is made to translate layer names to GDS layer/datatype numbers. If set to false (the default), a layer named "L2D15" will be translated to GDS layer 2, datatype 15.

    This method has been added in version 0.25.3.@brief Gets a value indicating whether layer names are kept
    @param keep True, if layer names are to be kept.

    See \cif_keep_layer_names? for a description of this property.

    This method has been added in version 0.25.3.
    """
    cif_layer_map: LayerMap
    r"""
    @brief Gets the layer map
    @return A reference to the layer map

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.

    Python note: this method has been turned into a property in version 0.26.@brief Sets the layer map
    This sets a layer mapping for the reader. Unlike \cif_set_layer_map, the 'create_other_layers' flag is not changed.
    @param map The layer map to set.

    This convenience method has been added in version 0.26.
    """
    cif_wire_mode: int
    r"""
    @brief Specifies how to read 'W' objects
    See \cif_wire_mode= method for a description of this mode.
    This property has been added in version 0.21 and was renamed to cif_wire_mode in 0.25.
    @brief How to read 'W' objects

    This property specifies how to read 'W' (wire) objects.
    Allowed values are 0 (as square ended paths), 1 (as flush ended paths), 2 (as round paths)

    This property has been added in version 0.21.
    """
    create_other_layers: bool
    r"""
    @brief Gets a value indicating whether other layers shall be created
    @return True, if other layers should be created.
    This attribute acts together with a layer map (see \layer_map=). Layers not listed in this map are created as well when \create_other_layers? is true. Otherwise they are ignored.

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.@brief Specifies whether other layers shall be created
    @param create True, if other layers should be created.
    See \create_other_layers? for a description of this attribute.

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.
    """
    dxf_circle_accuracy: float
    r"""
    @brief Gets the accuracy of the circle approximation

    This property has been added in version 0.24.9.
    @brief Specifies the accuracy of the circle approximation

    In addition to the number of points per circle, the circle accuracy can be specified. If set to a value larger than the database unit, the number of points per circle will be chosen such that the deviation from the ideal circle becomes less than this value.

    The actual number of points will not become bigger than the points specified through \dxf_circle_points=. The accuracy value is given in the DXF file units (see \dxf_unit) which is usually micrometers.

    \dxf_circle_points and \dxf_circle_accuracy also apply to other "round" structures such as arcs, ellipses and splines in the same sense than for circles.


    This property has been added in version 0.24.9.
    """
    dxf_circle_points: int
    r"""
    @brief Gets the number of points used per full circle for arc interpolation

    This property has been added in version 0.21.6.
    @brief Specifies the number of points used per full circle for arc interpolation
    See also \dxf_circle_accuracy for how to specify the number of points based on an approximation accuracy.

    \dxf_circle_points and \dxf_circle_accuracy also apply to other "round" structures such as arcs, ellipses and splines in the same sense than for circles.


    This property has been added in version 0.21.6.
    """
    dxf_contour_accuracy: float
    r"""
    @brief Gets the accuracy for contour closing


    This property has been added in version 0.25.3.
    @brief Specifies the accuracy for contour closing

    When polylines need to be connected or closed, this
    value is used to indicate the accuracy. This is the value (in DXF units)
    by which points may be separated and still be considered
    connected. The default is 0.0 which implies exact
    (within one DBU) closing.

    This value is effective in polyline mode 3 and 4.


    This property has been added in version 0.25.3.
    """
    dxf_create_other_layers: bool
    r"""
    @brief Gets a value indicating whether other layers shall be created
    @return True, if other layers will be created.
    This attribute acts together with a layer map (see \dxf_layer_map=). Layers not listed in this map are created as well when \dxf_create_other_layers? is true. Otherwise they are ignored.

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.@brief Specifies whether other layers shall be created
    @param create True, if other layers will be created.
    See \dxf_create_other_layers? for a description of this attribute.

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
    """
    dxf_dbu: float
    r"""
    @brief Specifies the database unit which the reader uses and produces

    This property has been added in version 0.21.
    @brief Specifies the database unit which the reader uses and produces

    This property has been added in version 0.21.
    """
    dxf_keep_layer_names: bool
    r"""
    @brief Gets a value indicating whether layer names are kept
    @return True, if layer names are kept.

    When set to true, no attempt is made to translate layer names to GDS layer/datatype numbers. If set to false (the default), a layer named "L2D15" will be translated to GDS layer 2, datatype 15.

    This method has been added in version 0.25.3.@brief Gets a value indicating whether layer names are kept
    @param keep True, if layer names are to be kept.

    See \cif_keep_layer_names? for a description of this property.

    This method has been added in version 0.25.3.
    """
    dxf_keep_other_cells: bool
    r"""
    @brief If this option is true, all cells are kept, not only the top cell and it's children

    This property has been added in version 0.21.15.
    @brief If this option is set to true, all cells are kept, not only the top cell and it's children

    This property has been added in version 0.21.15.
    """
    dxf_layer_map: LayerMap
    r"""
    @brief Gets the layer map
    @return A reference to the layer map

    This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
    Python note: this method has been turned into a property in version 0.26.@brief Sets the layer map
    This sets a layer mapping for the reader. Unlike \dxf_set_layer_map, the 'create_other_layers' flag is not changed.
    @param map The layer map to set.

    This convenience method has been added in version 0.26.
    """
    dxf_polyline_mode: int
    r"""
    @brief Specifies whether closed POLYLINE and LWPOLYLINE entities with width 0 are converted to polygons.
    See \dxf_polyline_mode= for a description of this property.

    This property has been added in version 0.21.3.
    @brief Specifies how to treat POLYLINE/LWPOLYLINE entities.
    The mode is 0 (automatic), 1 (keep lines), 2 (create polygons from closed polylines with width = 0), 3 (merge all lines with width = 0 into polygons), 4 (as 3 plus auto-close open contours).

    This property has been added in version 0.21.3.
    """
    dxf_render_texts_as_polygons: bool
    r"""
    @brief If this option is true, text objects are rendered as polygons

    This property has been added in version 0.21.15.
    @brief If this option is set to true, text objects are rendered as polygons

    This property has been added in version 0.21.15.
    """
    dxf_text_scaling: float
    r"""
    @brief Gets the text scaling factor (see \dxf_text_scaling=)

    This property has been added in version 0.21.20.
    @brief Specifies the text scaling in percent of the default scaling

    The default value 100, meaning that the letter pitch is roughly 92 percent of the specified text height. Decrease this value to get smaller fonts and increase it to get larger fonts.

    This property has been added in version 0.21.20.
    """
    dxf_unit: float
    r"""
    @brief Specifies the unit in which the DXF file is drawn

    This property has been added in version 0.21.3.
    @brief Specifies the unit in which the DXF file is drawn.

    This property has been added in version 0.21.3.
    """
    gds2_allow_big_records: bool
    r"""
    @brief Gets a value specifying whether to allow big records with a length of 32768 to 65535 bytes.
    See \gds2_allow_big_records= method for a description of this property.
    This property has been added in version 0.18.
    @brief Allows big records with more than 32767 bytes

    Setting this property to true allows larger records by treating the record length as unsigned short, which for example allows larger polygons (~8000 points rather than ~4000 points) without using multiple XY records.
    For strict compatibility with the standard, this property should be set to false. The default is true.

    This property has been added in version 0.18.
    """
    gds2_allow_multi_xy_records: bool
    r"""
    @brief Gets a value specifying whether to allow big polygons with multiple XY records.
    See \gds2_allow_multi_xy_records= method for a description of this property.
    This property has been added in version 0.18.
    @brief Allows the use of multiple XY records in BOUNDARY elements for unlimited large polygons

    Setting this property to true allows big polygons that span over multiple XY records.
    For strict compatibility with the standard, this property should be set to false. The default is true.

    This property has been added in version 0.18.
    """
    gds2_box_mode: int
    r"""
    @brief Gets a value specifying how to treat BOX records
    See \gds2_box_mode= method for a description of this mode.
    This property has been added in version 0.18.
    @brief Sets a value specifying how to treat BOX records
    This property specifies how BOX records are treated.
    Allowed values are 0 (ignore), 1 (treat as rectangles), 2 (treat as boundaries) or 3 (treat as errors). The default is 1.

    This property has been added in version 0.18.
    """
    layer_map: LayerMap
    r"""
    @brief Gets the layer map
    @return A reference to the layer map

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.
    Python note: this method has been turned into a property in version 0.26.@brief Sets the layer map, but does not affect the "create_other_layers" flag.
    Use \create_other_layers? to enable or disable other layers not listed in the layer map.
    @param map The layer map to set.
    This convenience method has been introduced with version 0.26.
    """
    lefdef_config: LEFDEFReaderConfiguration
    r"""
    @brief Gets a copy of the LEF/DEF reader configuration
    The LEF/DEF reader configuration is wrapped in a separate object of class \LEFDEFReaderConfiguration. See there for details.
    This method will return a copy of the reader configuration. To modify the configuration, modify the copy and set the modified configuration with \lefdef_config=.


    This method has been added in version 0.25.
    @brief Sets the LEF/DEF reader configuration


    This method has been added in version 0.25.
    """
    mag_create_other_layers: bool
    r"""
    @brief Gets a value indicating whether other layers shall be created
    @return True, if other layers will be created.
    This attribute acts together with a layer map (see \mag_layer_map=). Layers not listed in this map are created as well when \mag_create_other_layers? is true. Otherwise they are ignored.

    This method has been added in version 0.26.2.@brief Specifies whether other layers shall be created
    @param create True, if other layers will be created.
    See \mag_create_other_layers? for a description of this attribute.

    This method has been added in version 0.26.2.
    """
    mag_dbu: float
    r"""
    @brief Specifies the database unit which the reader uses and produces
    See \mag_dbu= method for a description of this property.

    This property has been added in version 0.26.2.
    @brief Specifies the database unit which the reader uses and produces
    The database unit is the final resolution of the produced layout. This physical resolution is usually defined by the layout system - GDS for example typically uses 1nm (mag_dbu=0.001).
    All geometry in the MAG file will first be scaled to \mag_lambda and is then brought to the database unit.

    This property has been added in version 0.26.2.
    """
    mag_keep_layer_names: bool
    r"""
    @brief Gets a value indicating whether layer names are kept
    @return True, if layer names are kept.

    When set to true, no attempt is made to translate layer names to GDS layer/datatype numbers. If set to false (the default), a layer named "L2D15" will be translated to GDS layer 2, datatype 15.

    This method has been added in version 0.26.2.@brief Gets a value indicating whether layer names are kept
    @param keep True, if layer names are to be kept.

    See \mag_keep_layer_names? for a description of this property.

    This method has been added in version 0.26.2.
    """
    mag_lambda: float
    r"""
    @brief Gets the lambda value
    See \mag_lambda= method for a description of this attribute.

    This property has been added in version 0.26.2.
    @brief Specifies the lambda value to used for reading

    The lambda value is the basic unit of the layout. Magic draws layout as multiples of this basic unit. The layout read by the MAG reader will use the database unit specified by \mag_dbu, but the physical layout coordinates will be multiples of \mag_lambda.

    This property has been added in version 0.26.2.
    """
    mag_layer_map: LayerMap
    r"""
    @brief Gets the layer map
    @return A reference to the layer map

    This method has been added in version 0.26.2.@brief Sets the layer map
    This sets a layer mapping for the reader. Unlike \mag_set_layer_map, the 'create_other_layers' flag is not changed.
    @param map The layer map to set.

    This method has been added in version 0.26.2.
    """
    mag_library_paths: List[str]
    r"""
    @brief Gets the locations where to look up libraries (in this order)
    See \mag_library_paths= method for a description of this attribute.

    This property has been added in version 0.26.2.
    @brief Specifies the locations where to look up libraries (in this order)

    The reader will look up library reference in these paths when it can't find them locally.
    Relative paths in this collection are resolved relative to the initial file's path.
    Expression interpolation is supported in the path strings.

    This property has been added in version 0.26.2.
    """
    mag_merge: bool
    r"""
    @brief Gets a value indicating whether boxes are merged into polygons
    @return True, if boxes are merged.

    When set to true, the boxes and triangles of the Magic layout files are merged into polygons where possible.

    This method has been added in version 0.26.2.@brief Sets a value indicating whether boxes are merged into polygons
    @param merge True, if boxes and triangles will be merged into polygons.

    See \mag_merge? for a description of this property.

    This method has been added in version 0.26.2.
    """
    oasis_expect_strict_mode: int
    r"""
    @hide@hide
    """
    oasis_read_all_properties: int
    r"""
    @hide@hide
    """
    properties_enabled: bool
    r"""
    @brief Gets a value indicating whether properties shall be read
    @return True, if properties should be read.
    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.@brief Specifies whether properties should be read
    @param enabled True, if properties should be read.
    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.
    """
    text_enabled: bool
    r"""
    @brief Gets a value indicating whether text objects shall be read
    @return True, if text objects should be read.
    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.@brief Specifies whether text objects shall be read
    @param enabled True, if text objects should be read.
    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.
    """
    def __copy__(self) -> LoadLayoutOptions:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: LoadLayoutOptions) -> None:
        r"""
        @brief Assigns another object to self
        """
    def cif_select_all_layers(self) -> None:
        r"""
        @brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers.
        New layers will be created when required.

        This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
        """
    def cif_set_layer_map(self, map: LayerMap, create_other_layers: bool) -> None:
        r"""
        @brief Sets the layer map
        This sets a layer mapping for the reader. The layer map allows selection and translation of the original layers, for example to assign layer/datatype numbers to the named layers.
        @param map The layer map to set.
        @param create_other_layers The flag indicating whether other layers will be created as well. Set to false to read only the layers in the layer map.

        This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
        """
    def dup(self) -> LoadLayoutOptions:
        r"""
        @brief Creates a copy of self
        """
    def dxf_select_all_layers(self) -> None:
        r"""
        @brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers.
        New layers will be created when required.

        This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
        """
    def dxf_set_layer_map(self, map: LayerMap, create_other_layers: bool) -> None:
        r"""
        @brief Sets the layer map
        This sets a layer mapping for the reader. The layer map allows selection and translation of the original layers, for example to assign layer/datatype numbers to the named layers.
        @param map The layer map to set.
        @param create_other_layers The flag indicating whether other layers will be created as well. Set to false to read only the layers in the layer map.

        This method has been added in version 0.25 and replaces the respective global option in \LoadLayoutOptions in a format-specific fashion.
        """
    def mag_select_all_layers(self) -> None:
        r"""
        @brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers.
        New layers will be created when required.

        This method has been added in version 0.26.2.
        """
    def mag_set_layer_map(self, map: LayerMap, create_other_layers: bool) -> None:
        r"""
        @brief Sets the layer map
        This sets a layer mapping for the reader. The layer map allows selection and translation of the original layers, for example to assign layer/datatype numbers to the named layers.
        @param map The layer map to set.
        @param create_other_layers The flag indicating whether other layers will be created as well. Set to false to read only the layers in the layer map.

        This method has been added in version 0.26.2.
        """
    def select_all_layers(self) -> None:
        r"""
        @brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers.
        New layers will be created when required.

        Starting with version 0.25 this method only applies to GDS2 and OASIS format. Other formats provide their own configuration.
        """
    def set_layer_map(self, map: LayerMap, create_other_layers: bool) -> None:
        r"""
        @brief Sets the layer map
        This sets a layer mapping for the reader. The layer map allows selection and translation of the original layers, for example to add a layer name.
        @param map The layer map to set.@param create_other_layers The flag telling whether other layer should be created as well. Set to false if just the layers in the mapping table should be read.

        Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats provide their own configuration.
        """

class RecursiveInstanceIterator:
    r"""
    @brief An iterator delivering instances recursively

    The iterator can be obtained from a cell and optionally a region.
    It simplifies retrieval of instances while considering
    subcells as well.
    Some options can be specified in addition, i.e. the hierarchy level to which to look into.
    The search can be confined to instances of certain cells (see \targets=) or to certain regions. Subtrees can be selected for traversal or excluded from it (see \select_cells).

    This is some sample code:

    @code
    # prints the effective instances of cell "A" as seen from the initial cell "cell"
    iter = cell.begin_instances_rec
    iter.targets = "A"
    while !iter.at_end?
      puts "Instance of #{iter.inst_cell.name} in #{cell.name}: " + (iter.dtrans * iter.inst_dtrans).to_s
      iter.next
    end
    @/code

    Here, a target cell is specified which confines the search to instances of this particular cell.
    'iter.dtrans' gives us the accumulated transformation of all parents up to the top cell. 'iter.inst_dtrans' gives us the transformation from the current instance. 'iter.inst_cell' finally gives us the target cell of the current instance (which is always 'A' in our case).

    \Cell offers three methods to get these iterators: begin_instances_rec, begin_instances_rec_touching and begin_instances_rec_overlapping.
    \Cell#begin_instances_rec will deliver a standard recursive instance iterator which starts from the given cell and iterates over all child cells. \Cell#begin_instances_rec_touching creates a RecursiveInstanceIterator which delivers the instances whose bounding boxed touch the given search box. \Cell#begin_instances_rec_overlapping gives an iterator which delivers all instances whose bounding box overlaps the search box.

    A RecursiveInstanceIterator object can also be created directly, like this:

    @code
    iter = RBA::RecursiveInstanceIterator::new(layout, cell [, options ])
    @/code

    "layout" is the layout object, "cell" the \Cell object of the initial cell.

    The recursive instance iterator can be confined to a maximum hierarchy depth. By using \max_depth=, the iterator will restrict the search depth to the given depth in the cell tree.
    In the same way, the iterator can be configured to start from a certain hierarchy depth using \min_depth=. The hierarchy depth always applies to the parent of the instances iterated.

    In addition, the recursive instance iterator supports selection and exclusion of subtrees. For that purpose it keeps flags per cell telling it for which cells to turn instance delivery on and off. The \select_cells method sets the "start delivery" flag while \unselect_cells sets the "stop delivery" flag. In effect, using \unselect_cells will exclude that cell plus the subtree from delivery. Parts of that subtree can be turned on again using \select_cells. For the cells selected that way, the instances of these cells and their child cells are delivered, even if their parent was unselected.

    To get instances from a specific cell, i.e. "MACRO" plus its child cells, unselect the top cell first and the select the desired cell again:

    @code
    # deliver all instances inside "MACRO" and the sub-hierarchy:
    iter = RBA::RecursiveInstanceIterator::new(layout, cell)
    iter.unselect_cells(cell.cell_index)
    iter.select_cells("MACRO")
    ...
    @/code

    The \unselect_all_cells and \select_all_cells methods turn on the "stop" and "start" flag for all cells respectively. If you use \unselect_all_cells and use \select_cells for a specific cell, the iterator will deliver only the instances of the selected cell, not its children. Those are still unselected by \unselect_all_cells:

    @code
    # deliver all instance inside "MACRO" but not of child cells:
    iter = RBA::RecursiveInstanceIterator::new(layout, cell)
    iter.unselect_all_cells
    iter.select_cells("MACRO")
    ...
    @/code

    Cell selection is done using cell indexes or glob pattern. Glob pattern are equivalent to the usual file name wildcards used on various command line shells. For example "A*" matches all cells starting with an "A". The curly brace notation and character classes are supported as well. For example "C{125,512}" matches "C125" and "C512" and "[ABC]*" matches all cells starting with an "A", a "B" or "C". "[^ABC]*" matches all cells not starting with one of that letters.

    To confine instance iteration to instances of certain cells, use the \targets feature:

    @code
    # deliver all instance of "INV1":
    iter = RBA::RecursiveInstanceIterator::new(layout, cell)
    iter.targets = "INV1"
    ...
    @/code

    Targets can be specified either as lists of cell indexes or through a glob pattern.

    Instances are always delivered depth-first with child instances before their parents. A default recursive instance iterator will first deliver leaf cells, followed by the parent of these cells.

    When a search region is used, instances whose bounding box touch or overlap (depending on 'overlapping' flag) will be reported. The instance bounding box taken as reference is computed using all layers of the layout.

    The iterator will deliver the individual elements of instance arrays, confined to the search region if one is given. Consequently the return value (\current_inst_element) is an \InstElement object which is basically a combination of an \Instance object and information about the current array element.
    \inst_cell, \inst_trans and \inst_dtrans are methods provided for convenience to access the current array member's transformation and the target cell of the current instance.

    The RecursiveInstanceIterator class has been introduced in version 0.27.
    """
    max_depth: int
    r"""
    @brief Gets the maximum hierarchy depth

    See \max_depth= for a description of that attribute.
    @brief Specifies the maximum hierarchy depth to look into

    A depth of 0 instructs the iterator to deliver only instances from the initial cell.
    A higher depth instructs the iterator to look deeper.
    The depth must be specified before the instances are being retrieved.
    """
    min_depth: int
    r"""
    @brief Gets the minimum hierarchy depth

    See \min_depth= for a description of that attribute.
    @brief Specifies the minimum hierarchy depth to look into

    A depth of 0 instructs the iterator to deliver instances from the top level.
    1 instructs to deliver instances from the first child level.
    The minimum depth must be specified before the instances are being retrieved.
    """
    overlapping: bool
    r"""
    @brief Gets a flag indicating whether overlapping instances are selected when a region is used
    @brief Sets a flag indicating whether overlapping instances are selected when a region is used

    If this flag is false, instances touching the search region are returned.
    """
    region: Box
    r"""
    @brief Gets the basic region that this iterator is using
    The basic region is the overall box the region iterator iterates over. There may be an additional complex region that confines the region iterator. See \complex_region for this attribute.
    @brief Sets the rectangular region that this iterator is iterating over
    See \region for a description of this attribute.
    Setting a simple region will reset the complex region to a rectangle and reset the iterator to the beginning of the sequence.
    """
    targets: List[int]
    r"""
    @brief Gets the list of target cells
    See \targets= for a description of the target cell concept. This method returns a list of cell indexes of the selected target cells.@brief Specifies the target cells.

    If target cells are specified, only instances of these cells are delivered. This version takes a list of cell indexes for the targets. By default, no target cell list is present and the instances of all cells are delivered by the iterator. See \all_targets_enabled? and \enable_all_targets for a description of this mode. Once a target list is specified, the iteration is confined to the cells from this list.
    The cells are given as a list of cell indexes.

    This method will also reset the iterator.
    """
    def __copy__(self) -> RecursiveInstanceIterator:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Comparison of iterators - equality

        Two iterators are equal if they point to the same instance.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell) -> None:
        r"""
        @brief Creates a recursive instance iterator.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layer The layer (index) from which the shapes are taken

        This constructor creates a new recursive instance iterator which delivers the instances of the given cell plus its children.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, box: Box, overlapping: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a recursive instance iterator with a search region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param box The search region
        @param overlapping If set to true, instances overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive instance iterator which delivers the instances of the given cell plus its children.

        The search is confined to the region given by the "box" parameter. If "overlapping" is true, instances whose bounding box is overlapping the search region are reported. If "overlapping" is false, instances whose bounding box touches the search region are reported. The bounding box of instances is measured taking all layers of the target cell into account.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, region: Region, overlapping: bool) -> None:
        r"""
        @brief Creates a recursive instance iterator with a search region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param region The search region
        @param overlapping If set to true, instances overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive instance iterator which delivers the instances of the given cell plus its children.

        The search is confined to the region given by the "region" parameter. The region needs to be a rectilinear region.
        If "overlapping" is true, instances whose bounding box is overlapping the search region are reported. If "overlapping" is false, instances whose bounding box touches the search region are reported. The bounding box of instances is measured taking all layers of the target cell into account.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Comparison of iterators - inequality

        Two iterators are not equal if they do not point to the same instance.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def all_targets_enabled(self) -> bool:
        r"""
        @brief Gets a value indicating whether instances of all cells are reported
        See \targets= for a description of the target cell concept. 
        """
    def assign(self, other: RecursiveInstanceIterator) -> None:
        r"""
        @brief Assigns another object to self
        """
    def at_end(self) -> bool:
        r"""
        @brief End of iterator predicate

        Returns true, if the iterator is at the end of the sequence
        """
    def cell(self) -> Cell:
        r"""
        @brief Gets the cell the current instance sits in
        """
    def cell_index(self) -> int:
        r"""
        @brief Gets the index of the cell the current instance sits in
        This is equivalent to 'cell.cell_index'.
        """
    def complex_region(self) -> Region:
        r"""
        @brief Gets the complex region that this iterator is using
        The complex region is the effective region (a \Region object) that the iterator is selecting from the layout. This region can be a single box or a complex region.
        """
    @overload
    def confine_region(self, box_region: Box) -> None:
        r"""
        @brief Confines the region that this iterator is iterating over
        This method is similar to setting the region (see \region=), but will confine any region (complex or simple) already set. Essentially it does a logical AND operation between the existing and given region. Hence this method can only reduce a region, not extend it.
        """
    @overload
    def confine_region(self, complex_region: Region) -> None:
        r"""
        @brief Confines the region that this iterator is iterating over
        This method is similar to setting the region (see \region=), but will confine any region (complex or simple) already set. Essentially it does a logical AND operation between the existing and given region. Hence this method can only reduce a region, not extend it.
        """
    def current_inst_element(self) -> InstElement:
        r"""
        @brief Gets the current instance

        This is the instance/array element the iterator currently refers to.
        This is a \InstElement object representing the current instance and the array element the iterator currently points at.

        See \inst_trans, \inst_dtrans and \inst_cell for convenience methods to access the details of the current element.
        """
    def dtrans(self) -> DCplxTrans:
        r"""
        @brief Gets the accumulated transformation of the current instance parent cell to the top cell

        This transformation represents how the current instance is seen in the top cell.
        This version returns the micron-unit transformation.
        """
    def dup(self) -> RecursiveInstanceIterator:
        r"""
        @brief Creates a copy of self
        """
    def enable_all_targets(self) -> None:
        r"""
        @brief Enables 'all targets' mode in which instances of all cells are reported
        See \targets= for a description of the target cell concept. 
        """
    def inst_cell(self) -> Cell:
        r"""
        @brief Gets the target cell of the current instance
        This is the cell the current instance refers to. It is one of the \targets if a target list is given.
        """
    def inst_dtrans(self) -> DCplxTrans:
        r"""
        @brief Gets the micron-unit transformation of the current instance
        This is the transformation of the current instance inside its parent.
        'dtrans * inst_dtrans' gives the full micron-unit transformation how the current cell is seen in the top cell.
        See also \inst_trans and \inst_cell.
        """
    def inst_trans(self) -> ICplxTrans:
        r"""
        @brief Gets the integer-unit transformation of the current instance
        This is the transformation of the current instance inside its parent.
        'trans * inst_trans' gives the full transformation how the current cell is seen in the top cell.
        See also \inst_dtrans and \inst_cell.
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets the layout this iterator is connected to
        """
    def next(self) -> None:
        r"""
        @brief Increments the iterator
        This moves the iterator to the next instance inside the search scope.
        """
    def path(self) -> List[InstElement]:
        r"""
        @brief Gets the instantiation path of the instance addressed currently

        This attribute is a sequence of \InstElement objects describing the cell instance path from the initial cell to the current instance. The path is empty if the current instance is in the top cell.
        """
    def reset(self) -> None:
        r"""
        @brief Resets the iterator to the initial state
        """
    def reset_selection(self) -> None:
        r"""
        @brief Resets the selection to the default state

        In the initial state, the top cell and its children are selected. Child cells can be switched on and off together with their sub-hierarchy using \select_cells and \unselect_cells.

        This method will also reset the iterator.
        """
    def select_all_cells(self) -> None:
        r"""
        @brief Selects all cells.

        This method will set the "selected" mark on all cells. The effect is that subsequent calls of \unselect_cells will unselect only the specified cells, not their children, because they are still unselected.

        This method will also reset the iterator.
        """
    @overload
    def select_cells(self, cells: Sequence[int]) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "selected" mark on the given cells. That means that these cells or their child cells are visited, unless they are marked as "unselected" again with the \unselect_cells method.

        The cells are given as a list of cell indexes.

        This method will also reset the iterator.
        """
    @overload
    def select_cells(self, cells: str) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "selected" mark on the given cells. That means that these cells or their child cells are visited, unless they are marked as "unselected" again with the \unselect_cells method.

        The cells are given as a glob pattern.
        A glob pattern follows the syntax of file names on the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.
        """
    def top_cell(self) -> Cell:
        r"""
        @brief Gets the top cell this iterator is connected to
        """
    def trans(self) -> ICplxTrans:
        r"""
        @brief Gets the accumulated transformation of the current instance parent cell to the top cell

        This transformation represents how the current instance is seen in the top cell.
        """
    def unselect_all_cells(self) -> None:
        r"""
        @brief Unselects all cells.

        This method will set the "unselected" mark on all cells. The effect is that subsequent calls of \select_cells will select only the specified cells, not their children, because they are still unselected.

        This method will also reset the iterator.
        """
    @overload
    def unselect_cells(self, cells: Sequence[int]) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "unselected" mark on the given cells. That means that these cells or their child cells will not be visited, unless they are marked as "selected" again with the \select_cells method.

        The cells are given as a list of cell indexes.

        This method will also reset the iterator.
        """
    @overload
    def unselect_cells(self, cells: str) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "unselected" mark on the given cells. That means that these cells or their child cells will not be visited, unless they are marked as "selected" again with the \select_cells method.

        The cells are given as a glob pattern.
        A glob pattern follows the syntax of file names on the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.
        """

class RecursiveShapeIterator:
    r"""
    @brief An iterator delivering shapes recursively

    The iterator can be obtained from a cell, a layer and optionally a region.
    It simplifies retrieval of shapes from a geometrical region while considering
    subcells as well.
    Some options can be specified in addition, i.e. the level to which to look into or
    shape classes and shape properties. The shapes are retrieved by using the \shape method,
    \next moves to the next shape and \at_end tells, if the iterator has move shapes to deliver.

    This is some sample code:

    @code
    # print the polygon-like objects as seen from the initial cell "cell"
    iter = cell.begin_shapes_rec(layer)
    while !iter.at_end?
      if iter.shape.renders_polygon?
        polygon = iter.shape.polygon.transformed(iter.itrans)
        puts "In cell #{iter.cell.name}: " + polygon.to_s
      end
      iter.next
    end
    @/code

    \Cell offers three methods to get these iterators: begin_shapes_rec, begin_shapes_rec_touching and begin_shapes_rec_overlapping.
    \Cell#begin_shapes_rec will deliver a standard recursive shape iterator which starts from the given cell and iterates over all child cells. \Cell#begin_shapes_rec_touching delivers a RecursiveShapeIterator which delivers the shapes whose bounding boxed touch the given search box. \Cell#begin_shapes_rec_overlapping delivers all shapes whose bounding box overlaps the search box.

    A RecursiveShapeIterator object can also be created explicitly. This allows some more options, i.e. using multiple layers. A multi-layer recursive shape iterator can be created like this:

    @code
    iter = RBA::RecursiveShapeIterator::new(layout, cell, [ layer_index1, layer_index2 .. ])
    @/code

    "layout" is the layout object, "cell" the RBA::Cell object of the initial cell. layer_index1 etc. are the layer indexes of the layers to get the shapes from. While iterating, \RecursiveShapeIterator#layer delivers the layer index of the current shape.

    The recursive shape iterator can be confined to a maximum hierarchy depth. By using \max_depth=, the iterator will restrict the search depth to the given depth in the cell tree.

    In addition, the recursive shape iterator supports selection and exclusion of subtrees. For that purpose it keeps flags per cell telling it for which cells to turn shape delivery on and off. The \select_cells method sets the "start delivery" flag while \unselect_cells sets the "stop delivery" flag. In effect, using \unselect_cells will exclude that cell plus the subtree from delivery. Parts of that subtree can be turned on again using \select_cells. For the cells selected that way, the shapes of these cells and their child cells are delivered, even if their parent was unselected.

    To get shapes from a specific cell, i.e. "MACRO" plus its child cells, unselect the top cell first and the select the desired cell again:

    @code
    # deliver all shapes inside "MACRO" and the sub-hierarchy:
    iter = RBA::RecursiveShapeIterator::new(layout, cell, layer)
    iter.unselect_cells(cell.cell_index)
    iter.select_cells("MACRO")
    @/code

    Note that if "MACRO" uses library cells for example which are used otherwise as well, the iterator will only deliver the shapes for those instances belonging to "MACRO" (directly or indirectly), not those for other instances of these library cells.

    The \unselect_all_cells and \select_all_cells methods turn on the "stop" and "start" flag for all cells respectively. If you use \unselect_all_cells and use \select_cells for a specific cell, the iterator will deliver only the shapes of the selected cell, not its children. Those are still unselected by \unselect_all_cells:

    @code
    # deliver all shapes of "MACRO" but not of child cells:
    iter = RBA::RecursiveShapeIterator::new(layout, cell, layer)
    iter.unselect_all_cells
    iter.select_cells("MACRO")
    @/code

    Cell selection is done using cell indexes or glob pattern. Glob pattern are equivalent to the usual file name wildcards used on various command line shells. For example "A*" matches all cells starting with an "A". The curly brace notation and character classes are supported as well. For example "C{125,512}" matches "C125" and "C512" and "[ABC]*" matches all cells starting with an "A", a "B" or "C". "[^ABC]*" matches all cells not starting with one of that letters.

    The RecursiveShapeIterator class has been introduced in version 0.18 and has been extended substantially in 0.23.
    """
    global_dtrans: DCplxTrans
    r"""
    @brief Gets the global transformation to apply to all shapes delivered (in micrometer units)
    See also \global_dtrans=.

    This method has been introduced in version 0.27.
    @brief Sets the global transformation to apply to all shapes delivered (transformation in micrometer units)
    The global transformation will be applied to all shapes delivered by biasing the "trans" attribute.
    The search regions apply to the coordinate space after global transformation.

    This method has been introduced in version 0.27.
    """
    global_trans: ICplxTrans
    r"""
    @brief Gets the global transformation to apply to all shapes delivered
    See also \global_trans=.

    This method has been introduced in version 0.27.
    @brief Sets the global transformation to apply to all shapes delivered
    The global transformation will be applied to all shapes delivered by biasing the "trans" attribute.
    The search regions apply to the coordinate space after global transformation.

    This method has been introduced in version 0.27.
    """
    max_depth: int
    r"""
    @brief Gets the maximum hierarchy depth

    See \max_depth= for a description of that attribute.

    This method has been introduced in version 0.23.
    @brief Specifies the maximum hierarchy depth to look into

    A depth of 0 instructs the iterator to deliver only shapes from the initial cell.
    The depth must be specified before the shapes are being retrieved.
    Setting the depth resets the iterator.
    """
    min_depth: int
    r"""
    @brief Gets the minimum hierarchy depth

    See \min_depth= for a description of that attribute.

    This method has been introduced in version 0.27.
    @brief Specifies the minimum hierarchy depth to look into

    A depth of 0 instructs the iterator to deliver shapes from the top level.
    1 instructs to deliver shapes from the first child level.
    The minimum depth must be specified before the shapes are being retrieved.

    This method has been introduced in version 0.27.
    """
    overlapping: bool
    r"""
    @brief Gets a flag indicating whether overlapping shapes are selected when a region is used

    This method has been introduced in version 0.23.
    @brief Sets a flag indicating whether overlapping shapes are selected when a region is used

    If this flag is false, shapes touching the search region are returned.

    This method has been introduced in version 0.23.
    """
    region: Box
    r"""
    @brief Gets the basic region that this iterator is using
    The basic region is the overall box the region iterator iterates over. There may be an additional complex region that confines the region iterator. See \complex_region for this attribute.

    This method has been introduced in version 0.23.
    @brief Sets the rectangular region that this iterator is iterating over
    See \region for a description of this attribute.
    Setting a simple region will reset the complex region to a rectangle and reset the iterator to the beginning of the sequence.
    This method has been introduced in version 0.23.
    """
    shape_flags: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Specifies the shape selection flags

    The flags are the same then being defined in \Shapes (the default is RBA::Shapes::SAll).
    The flags must be specified before the shapes are being retrieved.
    Settings the shapes flags will reset the iterator.
    """
    def __copy__(self) -> RecursiveShapeIterator:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Comparison of iterators - equality

        Two iterators are equal if they point to the same shape.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layer: int) -> None:
        r"""
        @brief Creates a recursive, single-layer shape iterator.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layer The layer (index) from which the shapes are taken

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layer given by the layer index in the "layer" parameter.

        This constructor has been introduced in version 0.23.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layers: Sequence[int]) -> None:
        r"""
        @brief Creates a recursive, multi-layer shape iterator.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layers The layer indexes from which the shapes are taken

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layers given by the layer indexes in the "layers" parameter.
        While iterating use the \layer method to retrieve the layer of the current shape.

        This constructor has been introduced in version 0.23.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layer: int, box: Box, overlapping: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a recursive, single-layer shape iterator with a region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layer The layer (index) from which the shapes are taken
        @param box The search region
        @param overlapping If set to true, shapes overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layer given by the layer index in the "layer" parameter.

        The search is confined to the region given by the "box" parameter. If "overlapping" is true, shapes whose bounding box is overlapping the search region are reported. If "overlapping" is false, shapes whose bounding box touches the search region are reported.

        This constructor has been introduced in version 0.23. The 'overlapping' parameter has been made optional in version 0.27.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layer: int, region: Region, overlapping: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a recursive, single-layer shape iterator with a region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layer The layer (index) from which the shapes are taken
        @param region The search region
        @param overlapping If set to true, shapes overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layer given by the layer index in the "layer" parameter.

        The search is confined to the region given by the "region" parameter. The region needs to be a rectilinear region.
        If "overlapping" is true, shapes whose bounding box is overlapping the search region are reported. If "overlapping" is false, shapes whose bounding box touches the search region are reported.

        This constructor has been introduced in version 0.25. The 'overlapping' parameter has been made optional in version 0.27.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layers: Sequence[int], box: Box, overlapping: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a recursive, multi-layer shape iterator with a region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layers The layer indexes from which the shapes are taken
        @param box The search region
        @param overlapping If set to true, shapes overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layers given by the layer indexes in the "layers" parameter.
        While iterating use the \layer method to retrieve the layer of the current shape.

        The search is confined to the region given by the "box" parameter. If "overlapping" is true, shapes whose bounding box is overlapping the search region are reported. If "overlapping" is false, shapes whose bounding box touches the search region are reported.

        This constructor has been introduced in version 0.23. The 'overlapping' parameter has been made optional in version 0.27.
        """
    @overload
    def __init__(self, layout: Layout, cell: Cell, layers: Sequence[int], region: Region, overlapping: Optional[bool] = ...) -> None:
        r"""
        @brief Creates a recursive, multi-layer shape iterator with a region.
        @param layout The layout which shall be iterated
        @param cell The initial cell which shall be iterated (including its children)
        @param layers The layer indexes from which the shapes are taken
        @param region The search region
        @param overlapping If set to true, shapes overlapping the search region are reported, otherwise touching is sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the given cell plus its children from the layers given by the layer indexes in the "layers" parameter.
        While iterating use the \layer method to retrieve the layer of the current shape.

        The search is confined to the region given by the "region" parameter. The region needs to be a rectilinear region.
        If "overlapping" is true, shapes whose bounding box is overlapping the search region are reported. If "overlapping" is false, shapes whose bounding box touches the search region are reported.

        This constructor has been introduced in version 0.23. The 'overlapping' parameter has been made optional in version 0.27.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Comparison of iterators - inequality

        Two iterators are not equal if they do not point to the same shape.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def always_apply_dtrans(self) -> DCplxTrans:
        r"""
        @brief Gets the global transformation if at top level, unity otherwise (micrometer-unit version)
        As the global transformation is only applicable on top level, use this method to transform shapes and instances into their local (cell-level) version while considering the global transformation properly.

        This method has been introduced in version 0.27.
        """
    def always_apply_trans(self) -> ICplxTrans:
        r"""
        @brief Gets the global transformation if at top level, unity otherwise
        As the global transformation is only applicable on top level, use this method to transform shapes and instances into their local (cell-level) version while considering the global transformation properly.

        This method has been introduced in version 0.27.
        """
    def assign(self, other: RecursiveShapeIterator) -> None:
        r"""
        @brief Assigns another object to self
        """
    def at_end(self) -> bool:
        r"""
        @brief End of iterator predicate

        Returns true, if the iterator is at the end of the sequence
        """
    def cell(self) -> Cell:
        r"""
        @brief Gets the current cell's object 

        This method has been introduced in version 0.23.
        """
    def cell_index(self) -> int:
        r"""
        @brief Gets the current cell's index 
        """
    def complex_region(self) -> Region:
        r"""
        @brief Gets the complex region that this iterator is using
        The complex region is the effective region (a \Region object) that the iterator is selecting from the layout layers. This region can be a single box or a complex region.

        This method has been introduced in version 0.25.
        """
    @overload
    def confine_region(self, box_region: Box) -> None:
        r"""
        @brief Confines the region that this iterator is iterating over
        This method is similar to setting the region (see \region=), but will confine any region (complex or simple) already set. Essentially it does a logical AND operation between the existing and given region. Hence this method can only reduce a region, not extend it.

        This method has been introduced in version 0.25.
        """
    @overload
    def confine_region(self, complex_region: Region) -> None:
        r"""
        @brief Confines the region that this iterator is iterating over
        This method is similar to setting the region (see \region=), but will confine any region (complex or simple) already set. Essentially it does a logical AND operation between the existing and given region. Hence this method can only reduce a region, not extend it.

        This method has been introduced in version 0.25.
        """
    def dtrans(self) -> DCplxTrans:
        r"""
        @brief Gets the transformation into the initial cell applicable for floating point types

        This transformation corresponds to the one delivered by \trans, but is applicable for the floating-point shape types in micron unit space.

        This method has been introduced in version 0.25.3.
        """
    def dup(self) -> RecursiveShapeIterator:
        r"""
        @brief Creates a copy of self
        """
    def layer(self) -> int:
        r"""
        @brief Returns the layer index where the current shape is coming from.

        This method has been introduced in version 0.23.
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets the layout this iterator is connected to

        This method has been introduced in version 0.23.
        """
    def next(self) -> None:
        r"""
        @brief Increments the iterator
        This moves the iterator to the next shape inside the search scope.
        """
    def path(self) -> List[InstElement]:
        r"""
        @brief Gets the instantiation path of the shape addressed currently

        This attribute is a sequence of \InstElement objects describing the cell instance path from the initial cell to the current cell containing the current shape.

        This method has been introduced in version 0.25.
        """
    def reset(self) -> None:
        r"""
        @brief Resets the iterator to the initial state

        This method has been introduced in version 0.23.
        """
    def reset_selection(self) -> None:
        r"""
        @brief Resets the selection to the default state

        In the initial state, the top cell and its children are selected. Child cells can be switched on and off together with their sub-hierarchy using \select_cells and \unselect_cells.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    def select_all_cells(self) -> None:
        r"""
        @brief Selects all cells.

        This method will set the "selected" mark on all cells. The effect is that subsequent calls of \unselect_cells will unselect only the specified cells, not their children, because they are still unselected.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    @overload
    def select_cells(self, cells: Sequence[int]) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "selected" mark on the given cells. That means that these cells or their child cells are visited, unless they are marked as "unselected" again with the \unselect_cells method.

        The cells are given as a list of cell indexes.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    @overload
    def select_cells(self, cells: str) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "selected" mark on the given cells. That means that these cells or their child cells are visited, unless they are marked as "unselected" again with the \unselect_cells method.

        The cells are given as a glob pattern.
        A glob pattern follows the syntax of file names on the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    def shape(self) -> Shape:
        r"""
        @brief Gets the current shape

        Returns the shape currently referred to by the recursive iterator. 
        This shape is not transformed yet and is located in the current cell.
        """
    def top_cell(self) -> Cell:
        r"""
        @brief Gets the top cell this iterator is connected to

        This method has been introduced in version 0.23.
        """
    def trans(self) -> ICplxTrans:
        r"""
        @brief Gets the current transformation by which the shapes must be transformed into the initial cell

        The shapes delivered are not transformed. Instead, this transformation must be applied to 
        get the shape in the coordinate system of the top cell.

        Starting with version 0.25, this transformation is a int-to-int transformation the 'itrans' method which was providing this transformation before is deprecated.
        """
    def unselect_all_cells(self) -> None:
        r"""
        @brief Unselects all cells.

        This method will set the "unselected" mark on all cells. The effect is that subsequent calls of \select_cells will select only the specified cells, not their children, because they are still unselected.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    @overload
    def unselect_cells(self, cells: Sequence[int]) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "unselected" mark on the given cells. That means that these cells or their child cells will not be visited, unless they are marked as "selected" again with the \select_cells method.

        The cells are given as a list of cell indexes.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """
    @overload
    def unselect_cells(self, cells: str) -> None:
        r"""
        @brief Unselects the given cells.

        This method will sets the "unselected" mark on the given cells. That means that these cells or their child cells will not be visited, unless they are marked as "selected" again with the \select_cells method.

        The cells are given as a glob pattern.
        A glob pattern follows the syntax of file names on the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.

        This method has been introduced in version 0.23.
        """

class Region(ShapeCollection):
    r"""
    @brief A region (a potentially complex area consisting of multiple polygons)


    This class was introduced to simplify operations on polygon sets like boolean or sizing operations. Regions consist of many polygons and thus are a generalization of single polygons which describes a single coherence set of points. Regions support a variety of operations and have several states. 

    The region's state can be empty (does not contain anything) or box-like, i.e. the region consists of a single box. In that case, some operations can be simplified. Regions can have merged state. In merged state, regions consist of merged (non-touching, non-self overlapping) polygons. Each polygon describes one coherent area in merged state.

    The preferred representation of polygons inside the region are polygons with holes.

    Regions are always expressed in database units. If you want to use regions from different database unit domains, scale the regions accordingly, i.e. by using the \transformed method.


    Regions provide convenient operators for the boolean operations. Hence it is often no longer required to work with the \EdgeProcessor class. For example:

    @code
    r1 = RBA::Region::new(RBA::Box::new(0, 0, 100, 100))
    r2 = RBA::Region::new(RBA::Box::new(20, 20, 80, 80))
    # compute the XOR:
    r1_xor_r2 = r1 ^ r2
    @/code

    Regions can be used in two different flavors: in raw mode or merged semantics. With merged semantics (the default), connected polygons are considered to belong together and are effectively merged.
    Overlapping areas are counted once in that mode. Internal edges (i.e. arising from cut lines) are not considered.
    In raw mode (without merged semantics), each polygon is considered as it is. Overlaps between polygons
    may exists and merging has to be done explicitly using the \merge method. The semantics can be
    selected using \merged_semantics=.


    This class has been introduced in version 0.23.
    """
    class Metrics:
        r"""
        @brief This class represents the metrics type for \Region#width and related checks.

        This enum has been introduced in version 0.27.
        """
        Euclidian: ClassVar[Region.Metrics]
        r"""
        @brief Specifies Euclidian metrics for the check functions
        This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies Euclidian metrics, i.e. the distance between two points is measured by:

        @code
        d = sqrt(dx^2 + dy^2)
        @/code

        All points within a circle with radius d around one point are considered to have a smaller distance than d.
        """
        Projection: ClassVar[Region.Metrics]
        r"""
        @brief Specifies projected distance metrics for the check functions
        This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies projected metrics, i.e. the distance is defined as the minimum distance measured perpendicular to one edge. That implies that the distance is defined only where two edges have a non-vanishing projection onto each other.
        """
        Square: ClassVar[Region.Metrics]
        r"""
        @brief Specifies square metrics for the check functions
        This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies square metrics, i.e. the distance between two points is measured by:

        @code
        d = max(abs(dx), abs(dy))
        @/code

        All points within a square with length 2*d around one point are considered to have a smaller distance than d in this metrics.
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: Region.Metrics) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class RectFilter:
        r"""
        @brief This class represents the error filter mode on rectangles for \Region#separation and related checks.

        This enum has been introduced in version 0.27.
        """
        FourSidesAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors when on all sides
        """
        NoRectFilter: ClassVar[Region.RectFilter]
        r"""
        @brief Specifies no filtering
        """
        OneSideAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors on one side
        """
        ThreeSidesAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors when on three sides
        """
        TwoConnectedSidesAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors on two sides ("L" configuration)
        """
        TwoOppositeSidesAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors on two opposite sides
        """
        TwoSidesAllowed: ClassVar[Region.RectFilter]
        r"""
        @brief Allow errors on two sides (not specified which)
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: Region.RectFilter) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    class OppositeFilter:
        r"""
        @brief This class represents the opposite error filter mode for \Region#separation and related checks.

        This enum has been introduced in version 0.27.
        """
        NoOppositeFilter: ClassVar[Region.OppositeFilter]
        r"""
        @brief No opposite filtering
        """
        NotOpposite: ClassVar[Region.OppositeFilter]
        r"""
        @brief Only errors NOT appearing on opposite sides of a figure will be reported
        """
        OnlyOpposite: ClassVar[Region.OppositeFilter]
        r"""
        @brief Only errors appearing on opposite sides of a figure will be reported
        """
        def __eq__(self, other: object) -> bool:
            r"""
            @brief Compares two enums
            """
        @overload
        def __init__(self, i: int) -> None:
            r"""
            @brief Creates an enum from an integer value
            """
        @overload
        def __init__(self, s: str) -> None:
            r"""
            @brief Creates an enum from a string value
            """
        def __lt__(self, other: Region.OppositeFilter) -> bool:
            r"""
            @brief Returns true if the first enum is less (in the enum symbol order) than the second
            """
        def __ne__(self, other: object) -> bool:
            r"""
            @brief Compares two enums for inequality
            """
        def __repr__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def __str__(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
        def inspect(self) -> str:
            r"""
            @brief Converts an enum to a visual string
            """
        def to_i(self) -> int:
            r"""
            @brief Gets the integer value from the enum
            """
        def to_s(self) -> str:
            r"""
            @brief Gets the symbolic string from an enum
            """
    Euclidian: ClassVar[Region.Metrics]
    r"""
    @brief Specifies Euclidian metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies Euclidian metrics, i.e. the distance between two points is measured by:

    @code
    d = sqrt(dx^2 + dy^2)
    @/code

    All points within a circle with radius d around one point are considered to have a smaller distance than d.
    """
    FourSidesAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors when on all sides
    """
    NoOppositeFilter: ClassVar[Region.OppositeFilter]
    r"""
    @brief No opposite filtering
    """
    NoRectFilter: ClassVar[Region.RectFilter]
    r"""
    @brief Specifies no filtering
    """
    NotOpposite: ClassVar[Region.OppositeFilter]
    r"""
    @brief Only errors NOT appearing on opposite sides of a figure will be reported
    """
    OneSideAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors on one side
    """
    OnlyOpposite: ClassVar[Region.OppositeFilter]
    r"""
    @brief Only errors appearing on opposite sides of a figure will be reported
    """
    Projection: ClassVar[Region.Metrics]
    r"""
    @brief Specifies projected distance metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies projected metrics, i.e. the distance is defined as the minimum distance measured perpendicular to one edge. That implies that the distance is defined only where two edges have a non-vanishing projection onto each other.
    """
    Square: ClassVar[Region.Metrics]
    r"""
    @brief Specifies square metrics for the check functions
    This value can be used for the metrics parameter in the check functions, i.e. \width_check. This value specifies square metrics, i.e. the distance between two points is measured by:

    @code
    d = max(abs(dx), abs(dy))
    @/code

    All points within a square with length 2*d around one point are considered to have a smaller distance than d in this metrics.
    """
    ThreeSidesAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors when on three sides
    """
    TwoConnectedSidesAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors on two sides ("L" configuration)
    """
    TwoOppositeSidesAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors on two opposite sides
    """
    TwoSidesAllowed: ClassVar[Region.RectFilter]
    r"""
    @brief Allow errors on two sides (not specified which)
    """
    base_verbosity: int
    r"""
    @brief Gets the minimum verbosity for timing reports
    See \base_verbosity= for details.

    This method has been introduced in version 0.26.
    @brief Sets the minimum verbosity for timing reports
    Timing reports will be given only if the verbosity is larger than this value. Detailed reports will be given when the verbosity is more than this value plus 10.
    In binary operations, the base verbosity of the first argument is considered.

    This method has been introduced in version 0.26.
    """
    merged_semantics: bool
    r"""
    @brief Gets a flag indicating whether merged semantics is enabled
    See \merged_semantics= for a description of this attribute.
    @brief Enables or disables merged semantics
    If merged semantics is enabled (the default), coherent polygons will be considered
    as single regions and artificial edges such as cut-lines will not be considered.
    Merged semantics thus is equivalent to considering coherent areas rather than
    single polygons
    """
    min_coherence: bool
    r"""
    @brief Gets a flag indicating whether minimum coherence is selected
    See \min_coherence= for a description of this attribute.
    @brief Enable or disable minimum coherence
    If minimum coherence is set, the merge operations (explicit merge with \merge or
    implicit merge through merged_semantics) are performed using minimum coherence mode.
    The coherence mode determines how kissing-corner situations are resolved. If
    minimum coherence is selected, they are resolved such that multiple polygons are 
    created which touch at a corner).

    The default setting is maximum coherence (min_coherence = false).
    """
    strict_handling: bool
    r"""
    @brief Gets a flag indicating whether merged semantics is enabled
    See \strict_handling= for a description of this attribute.

    This method has been introduced in version 0.23.2.@brief Enables or disables strict handling

    Strict handling means to leave away some optimizations. Specifically the 
    output of boolean operations will be merged even if one input is empty.
    Without strict handling, the operation will be optimized and output 
    won't be merged.

    Strict handling is disabled by default and optimization is in place.

    This method has been introduced in version 0.23.2.
    """
    def __add__(self, other: Region) -> Region:
        r"""
        @brief Returns the combined region of self and the other region

        @return The resulting region

        This operator adds the polygons of the other region to self and returns a new combined region. This usually creates unmerged regions and polygons may overlap. Use \merge if you want to ensure the result region is merged.
        """
    def __and__(self, other: Region) -> Region:
        r"""
        @brief Returns the boolean AND between self and the other region

        @return The result of the boolean AND operation

        This method will compute the boolean AND (intersection) between two regions. The result is often but not necessarily always merged.
        """
    def __copy__(self) -> Region:
        r"""
        @brief Creates a copy of self
        """
    def __getitem__(self, n: int) -> Polygon:
        r"""
        @brief Returns the nth polygon of the region

        This method returns nil if the index is out of range. It is available for flat regions only - i.e. those for which \has_valid_polygons? is true. Use \flatten to explicitly flatten a region.
        This method returns the raw polygon (not merged polygons, even if merged semantics is enabled).

        The \each iterator is the more general approach to access the polygons.
        """
    def __iadd__(self, other: Region) -> Region:
        r"""
        @brief Adds the polygons of the other region to self

        @return The region after modification (self)

        This operator adds the polygons of the other region to self. This usually creates unmerged regions and polygons may overlap. Use \merge if you want to ensure the result region is merged.
        """
    def __iand__(self, other: Region) -> Region:
        r"""
        @brief Performs the boolean AND between self and the other region

        @return The region after modification (self)

        This method will compute the boolean AND (intersection) between two regions. The result is often but not necessarily always merged.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an empty region.
        """
    @overload
    def __init__(self, array: Sequence[Polygon]) -> None:
        r"""
        @brief Constructor from a polygon array

        This constructor creates a region from an array of polygons.
        """
    @overload
    def __init__(self, box: Box) -> None:
        r"""
        @brief Box constructor

        This constructor creates a region from a box.
        """
    @overload
    def __init__(self, path: Path) -> None:
        r"""
        @brief Path constructor

        This constructor creates a region from a path.
        """
    @overload
    def __init__(self, polygon: Polygon) -> None:
        r"""
        @brief Polygon constructor

        This constructor creates a region from a polygon.
        """
    @overload
    def __init__(self, polygon: SimplePolygon) -> None:
        r"""
        @brief Simple polygon constructor

        This constructor creates a region from a simple polygon.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator) -> None:
        r"""
        @brief Constructor from a hierarchical shape set

        This constructor creates a region from the shapes delivered by the given recursive shape iterator.
        Text objects and edges are not inserted, because they cannot be converted to polygons.
        This method allows feeding the shapes from a hierarchy of cells into the region.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::Region::new(layout.begin_shapes(cell, layer))
        @/code
        """
    @overload
    def __init__(self, shapes: Shapes) -> None:
        r"""
        @brief Shapes constructor

        This constructor creates a region from a \Shapes collection.

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Constructor from a hierarchical shape set with a transformation

        This constructor creates a region from the shapes delivered by the given recursive shape iterator.
        Text objects and edges are not inserted, because they cannot be converted to polygons.
        On the delivered shapes it applies the given transformation.
        This method allows feeding the shapes from a hierarchy of cells into the region.
        The transformation is useful to scale to a specific database unit for example.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::Region::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, deep_shape_store: DeepShapeStore, area_ratio: Optional[float] = ..., max_vertex_count: Optional[int] = ...) -> None:
        r"""
        @brief Constructor for a deep region from a hierarchical shape set

        This constructor creates a hierarchical region. Use a \DeepShapeStore object to supply the hierarchical heap. See \DeepShapeStore for more details.

        'area_ratio' and 'max_vertex' supply two optimization parameters which control how big polygons are split to reduce the region's polygon complexity.

        @param shape_iterator The recursive shape iterator which delivers the hierarchy to take
        @param deep_shape_store The hierarchical heap (see there)
        @param area_ratio The maximum ratio of bounding box to polygon area before polygons are split

        This method has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, expr: str, as_pattern: Optional[bool] = ..., enl: Optional[int] = ...) -> None:
        r"""
        @brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts
        @param expr The selection string
        @param as_pattern If true, the selection string is treated as a glob pattern. Otherwise the match is exact.
        @param enl The per-side enlargement of the box to mark the text (1 gives a 2x2 DBU box)
        This special constructor will create a region from the text objects delivered by the shape iterator. Each text object will give a small (non-empty) box that represents the text origin.
        Texts can be selected by their strings - either through a glob pattern or by exact comparison with the given string. The following options are available:

        @code
        region = RBA::Region::new(iter, "*")           # all texts
        region = RBA::Region::new(iter, "A*")          # all texts starting with an 'A'
        region = RBA::Region::new(iter, "A*", false)   # all texts exactly matching 'A*'
        @/code

        This method has been introduced in version 0.25. The enlargement parameter has been added in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, deep_shape_store: DeepShapeStore, trans: ICplxTrans, area_ratio: Optional[float] = ..., max_vertex_count: Optional[int] = ...) -> None:
        r"""
        @brief Constructor for a deep region from a hierarchical shape set

        This constructor creates a hierarchical region. Use a \DeepShapeStore object to supply the hierarchical heap. See \DeepShapeStore for more details.

        'area_ratio' and 'max_vertex' supply two optimization parameters which control how big polygons are split to reduce the region's polygon complexity.

        The transformation is useful to scale to a specific database unit for example.

        @param shape_iterator The recursive shape iterator which delivers the hierarchy to take
        @param deep_shape_store The hierarchical heap (see there)
        @param area_ratio The maximum ratio of bounding box to polygon area before polygons are split
        @param trans The transformation to apply when storing the layout data

        This method has been introduced in version 0.26.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, expr: str, as_pattern: Optional[bool] = ..., enl: Optional[int] = ...) -> None:
        r"""
        @brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts
        @param dss The \DeepShapeStore object that acts as a heap for hierarchical operations.
        @param expr The selection string
        @param as_pattern If true, the selection string is treated as a glob pattern. Otherwise the match is exact.
        @param enl The per-side enlargement of the box to mark the text (1 gives a 2x2 DBU box)
        This special constructor will create a deep region from the text objects delivered by the shape iterator. Each text object will give a small (non-empty) box that represents the text origin.
        Texts can be selected by their strings - either through a glob pattern or by exact comparison with the given string. The following options are available:

        @code
        region = RBA::Region::new(iter, dss, "*")           # all texts
        region = RBA::Region::new(iter, dss, "A*")          # all texts starting with an 'A'
        region = RBA::Region::new(iter, dss, "A*", false)   # all texts exactly matching 'A*'
        @/code

        This variant has been introduced in version 0.26.
        """
    def __ior__(self, other: Region) -> Region:
        r"""
        @brief Performs the boolean OR between self and the other region

        @return The region after modification (self)

        The boolean OR is implemented by merging the polygons of both regions. To simply join the regions without merging, the + operator is more efficient.
        """
    def __isub__(self, other: Region) -> Region:
        r"""
        @brief Performs the boolean NOT between self and the other region

        @return The region after modification (self)

        This method will compute the boolean NOT (intersection) between two regions. The result is often but not necessarily always merged.
        """
    def __iter__(self) -> Iterator[Polygon]:
        r"""
        @brief Returns each polygon of the region

        This returns the raw polygons (not merged polygons if merged semantics is enabled).
        """
    def __ixor__(self, other: Region) -> Region:
        r"""
        @brief Performs the boolean XOR between self and the other region

        @return The region after modification (self)

        This method will compute the boolean XOR (intersection) between two regions. The result is often but not necessarily always merged.
        """
    def __or__(self, other: Region) -> Region:
        r"""
        @brief Returns the boolean OR between self and the other region

        @return The resulting region

        The boolean OR is implemented by merging the polygons of both regions. To simply join the regions without merging, the + operator is more efficient.
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the region to a string
        The length of the output is limited to 20 polygons to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the region to a string
        The length of the output is limited to 20 polygons to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    def __sub__(self, other: Region) -> Region:
        r"""
        @brief Returns the boolean NOT between self and the other region

        @return The result of the boolean NOT operation

        This method will compute the boolean NOT (intersection) between two regions. The result is often but not necessarily always merged.
        """
    def __xor__(self, other: Region) -> Region:
        r"""
        @brief Returns the boolean XOR between self and the other region

        @return The result of the boolean XOR operation

        This method will compute the boolean XOR (intersection) between two regions. The result is often but not necessarily always merged.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def andnot(self, other: Region) -> List[Region]:
        r"""
        @brief Returns the boolean AND and NOT between self and the other region

        @return A two-element array of regions with the first one being the AND result and the second one being the NOT result

        This method will compute the boolean AND and NOT between two regions simultaneously. Because this requires a single sweep only, using this method is faster than doing AND and NOT separately.

        This method has been added in version 0.27.
        """
    @overload
    def area(self) -> int:
        r"""
        @brief The area of the region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merged semantics is not enabled, overlapping areas are counted twice.
        """
    @overload
    def area(self, rect: Box) -> int:
        r"""
        @brief The area of the region (restricted to a rectangle)
        This version will compute the area of the shapes, restricting the computation to the given rectangle.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merged semantics is not enabled, overlapping areas are counted twice.
        """
    def assign(self, other: ShapeCollection) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Return the bounding box of the region
        The bounding box is the box enclosing all points of all polygons.
        """
    def break_(self, max_vertex_count: int, max_area_ratio: Optional[float] = ...) -> None:
        r"""
        @brief Breaks the polygons of the region into smaller ones

        There are two criteria for splitting a polygon: a polygon is split into parts with less then 'max_vertex_count' points and an bounding box-to-polygon area ratio less than 'max_area_ratio'. The area ratio is supposed to render polygons whose bounding box is a better approximation. This applies for example to 'L' shape polygons.

        Using a value of 0 for either limit means that the respective limit isn't checked. Breaking happens by cutting the polygons into parts at 'good' locations. The algorithm does not have a specific goal to minimize the number of parts for example. The only goal is to achieve parts within the given limits.

        This method has been introduced in version 0.26.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the region
        """
    def complex_op(self, node: CompoundRegionOperationNode) -> Any:
        r"""
        @brief Executes a complex operation (see \CompoundRegionOperationNode for details)

        This method has been introduced in version 0.27.
        """
    def corners(self, angle_min: Optional[float] = ..., angle_max: Optional[float] = ..., dim: Optional[int] = ..., include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> Region:
        r"""
        @brief This method will select all corners whose attached edges satisfy the angle condition.

        The angle values specify a range of angles: all corners whose attached edges form an angle between angle_min and angle_max will be reported boxes with 2*dim x 2*dim dimension. The default dimension is 2x2 DBU.

        If 'include_angle_min' is true, the angle condition is >= min. angle, otherwise it is > min. angle. Same for 'include_angle_,ax' and the max. angle.

        The angle is measured between the incoming and the outcoming edge in mathematical sense: a positive value is a turn left while a negative value is a turn right. Since polygon contours are oriented clockwise, positive angles will report concave corners while negative ones report convex ones.

        A similar function that reports corners as point-like edges is \corners_dots.

        This method has been introduced in version 0.25. 'include_min_angle' and 'include_max_angle' have been added in version 0.27.
        """
    def corners_dots(self, angle_start: Optional[float] = ..., angle_end: Optional[float] = ..., include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> Edges:
        r"""
        @brief This method will select all corners whose attached edges satisfy the angle condition.

        This method is similar to \corners, but delivers an \Edges collection with dot-like edges for each corner.

        This method has been introduced in version 0.25. 'include_min_angle' and 'include_max_angle' have been added in version 0.27.
        """
    def corners_edge_pairs(self, angle_start: Optional[float] = ..., angle_end: Optional[float] = ..., include_min_angle: Optional[bool] = ..., include_max_angle: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief This method will select all corners whose attached edges satisfy the angle condition.

        This method is similar to \corners, but delivers an \EdgePairs collection with an edge pairs for each corner.
        The first edge is the incoming edge of the corner, the second one the outgoing edge.

        This method has been introduced in version 0.27.1.
        """
    def count(self) -> int:
        r"""
        @brief Returns the (flat) number of polygons in the region

        This returns the number of raw polygons (not merged polygons if merged semantics is enabled).
        The count is computed 'as if flat', i.e. polygons inside a cell are multiplied by the number of times a cell is instantiated.

        The 'count' alias has been provided in version 0.26 to avoid ambiguity with the 'size' method which applies a geometrical bias.
        """
    def covering(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which are completely covering polygons from the other region

        @return A new region containing the polygons which are covering polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This attribute is sometimes called 'enclosing' instead of 'covering', but this term is reserved for the respective DRC function.

        This method has been introduced in version 0.27.
        """
    def data_id(self) -> int:
        r"""
        @brief Returns the data ID (a unique identifier for the underlying data storage)

        This method has been added in version 0.26.
        """
    def decompose_convex(self, preferred_orientation: Optional[int] = ...) -> Shapes:
        r"""
        @brief Decomposes the region into convex pieces.

        This method will return a \Shapes container that holds a decomposition of the region into convex, simple polygons.
        See \Polygon#decompose_convex for details. If you want \Region output, you should use \decompose_convex_to_region.

        This method has been introduced in version 0.25.
        """
    def decompose_convex_to_region(self, preferred_orientation: Optional[int] = ...) -> Region:
        r"""
        @brief Decomposes the region into convex pieces into a region.

        This method is identical to \decompose_convex, but delivers a \Region object.

        This method has been introduced in version 0.25.
        """
    def decompose_trapezoids(self, mode: Optional[int] = ...) -> Shapes:
        r"""
        @brief Decomposes the region into trapezoids.

        This method will return a \Shapes container that holds a decomposition of the region into trapezoids.
        See \Polygon#decompose_trapezoids for details. If you want \Region output, you should use \decompose_trapezoids_to_region.

        This method has been introduced in version 0.25.
        """
    def decompose_trapezoids_to_region(self, mode: Optional[int] = ...) -> Region:
        r"""
        @brief Decomposes the region into trapezoids.

        This method is identical to \decompose_trapezoids, but delivers a \Region object.

        This method has been introduced in version 0.25.
        """
    def disable_progress(self) -> None:
        r"""
        @brief Disable progress reporting
        Calling this method will disable progress reporting. See \enable_progress.
        """
    def dup(self) -> Region:
        r"""
        @brief Creates a copy of self
        """
    def each(self) -> Iterator[Polygon]:
        r"""
        @brief Returns each polygon of the region

        This returns the raw polygons (not merged polygons if merged semantics is enabled).
        """
    def each_merged(self) -> Iterator[Polygon]:
        r"""
        @brief Returns each merged polygon of the region

        This returns the raw polygons if merged semantics is disabled or the merged ones if merged semantics is enabled.
        """
    def edges(self) -> Edges:
        r"""
        @brief Returns an edge collection representing all edges of the polygons in this region
        This method will decompose the polygons into the individual edges. Edges making up the hulls of the polygons are oriented clockwise while edges making up the holes are oriented counterclockwise.

        The edge collection returned can be manipulated in various ways. See \Edges for a description of the possibilities of the edge collection.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def enable_progress(self, label: str) -> None:
        r"""
        @brief Enable progress reporting
        After calling this method, the region will report the progress through a progress bar while expensive operations are running.
        The label is a text which is put in front of the progress bar.
        Using a progress bar will imply a performance penalty of a few percent typically.
        """
    def enclosed_check(self, other: Region, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        Note: This is an alias of 'inside_check'.
        @brief Performs an inside check with options
        @param d The minimum distance for which the polygons are checked
        @param other The other region against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative Negative output from the first input

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        If "negative" is true, only edges from the first input are output as pseudo edge-pairs where the distance is larger or equal to the limit. This is a way to flag the parts of the first input where the distance to the second input is bigger. Note that only the first input's edges are output. The output is still edge pairs, but each edge pair contains one edge from the original input and the reverse version of the edge as the second edge.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27. The interpretation of the 'negative' flag has been restriced to first-layout only output in 0.27.1.
        The 'enclosed_check' alias was introduced in version 0.27.5.
        """
    def enclosing_check(self, other: Region, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs an enclosing check with options
        @param d The minimum enclosing distance for which the polygons are checked
        @param other The other region against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative Negative output from the first input

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        If "negative" is true, only edges from the first input are output as pseudo edge-pairs where the enclosure is larger or equal to the limit. This is a way to flag the parts of the first input where the enclosure vs. the second input is bigger. Note that only the first input's edges are output. The output is still edge pairs, but each edge pair contains one edge from the original input and the reverse version of the edge as the second edge.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27. The interpretation of the 'negative' flag has been restriced to first-layout only output in 0.27.1.
        """
    def extent_refs(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: int, arg5: int) -> Region:
        r"""
        @hide
        This method is provided for DRC implementation.
        """
    def extent_refs_edges(self, arg0: float, arg1: float, arg2: float, arg3: float) -> Edges:
        r"""
        @hide
        This method is provided for DRC implementation.
        """
    @overload
    def extents(self) -> Region:
        r"""
        @brief Returns a region with the bounding boxes of the polygons
        This method will return a region consisting of the bounding boxes of the polygons.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def extents(self, d: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the polygons
        This method will return a region consisting of the bounding boxes of the polygons enlarged by the given distance d.
        The enlargement is specified per edge, i.e the width and height will be increased by 2*d.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def extents(self, dx: int, dy: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the polygons
        This method will return a region consisting of the bounding boxes of the polygons enlarged by the given distance dx in x direction and dy in y direction.
        The enlargement is specified per edge, i.e the width will be increased by 2*dx.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def fill(self, in_cell: Cell, fill_cell_index: int, fc_box: Box, origin: Optional[Point] = ..., remaining_parts: Optional[Region] = ..., fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief A mapping of \Cell#fill_region to the Region class

        This method is equivalent to \Cell#fill_region, but is based on Region (with the cell being the first parameter).

        This method has been introduced in version 0.27.
        """
    @overload
    def fill(self, in_cell: Cell, fill_cell_index: int, fc_origin: Box, row_step: Vector, column_step: Vector, origin: Optional[Point] = ..., remaining_parts: Optional[Region] = ..., fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief A mapping of \Cell#fill_region to the Region class

        This method is equivalent to \Cell#fill_region, but is based on Region (with the cell being the first parameter).

        This method has been introduced in version 0.27.
        """
    def fill_multi(self, in_cell: Cell, fill_cell_index: int, fc_origin: Box, row_step: Vector, column_step: Vector, fill_margin: Optional[Vector] = ..., remaining_polygons: Optional[Region] = ..., glue_box: Optional[Box] = ...) -> None:
        r"""
        @brief A mapping of \Cell#fill_region to the Region class

        This method is equivalent to \Cell#fill_region, but is based on Region (with the cell being the first parameter).

        This method has been introduced in version 0.27.
        """
    def flatten(self) -> Region:
        r"""
        @brief Explicitly flattens a region

        If the region is already flat (i.e. \has_valid_polygons? returns true), this method will not change it.

        Returns 'self', so this method can be used in a dot concatenation.

        This method has been introduced in version 0.26.
        """
    def grid_check(self, gx: int, gy: int) -> EdgePairs:
        r"""
        @brief Returns a marker for all vertices not being on the given grid
        This method will return an edge pair object for every vertex whose x coordinate is not a multiple of gx or whose y coordinate is not a multiple of gy. The edge pair objects contain two edges consisting of the same single point - the original vertex.

        If gx or gy is 0 or less, the grid is not checked in that direction.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def has_valid_polygons(self) -> bool:
        r"""
        @brief Returns true if the region is flat and individual polygons can be accessed randomly

        This method has been introduced in version 0.26.
        """
    def hier_count(self) -> int:
        r"""
        @brief Returns the (hierarchical) number of polygons in the region

        This returns the number of raw polygons (not merged polygons if merged semantics is enabled).
        The count is computed 'hierarchical', i.e. polygons inside a cell are counted once even if the cell is instantiated multiple times.

        This method has been introduced in version 0.27.
        """
    def holes(self) -> Region:
        r"""
        @brief Returns the holes of the region
        This method returns all holes as filled polygons.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merge semantics is not enabled, the holes may not be detected if the polygons are taken from a hole-less representation (i.e. GDS2 file). Use explicit merge (\merge method) in order to merge the polygons and detect holes.
        """
    def hulls(self) -> Region:
        r"""
        @brief Returns the hulls of the region
        This method returns all hulls as polygons. The holes will be removed (filled). 
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merge semantics is not enabled, the hull may also enclose holes if the polygons are taken from a hole-less representation (i.e. GDS2 file). Use explicit merge (\merge method) in order to merge the polygons and detect holes.
        """
    @overload
    def insert(self, array: Sequence[Polygon]) -> None:
        r"""
        @brief Inserts all polygons from the array into this region
        """
    @overload
    def insert(self, box: Box) -> None:
        r"""
        @brief Inserts a box

        Inserts a box into the region.
        """
    @overload
    def insert(self, path: Path) -> None:
        r"""
        @brief Inserts a path

        Inserts a path into the region.
        """
    @overload
    def insert(self, polygon: Polygon) -> None:
        r"""
        @brief Inserts a polygon

        Inserts a polygon into the region.
        """
    @overload
    def insert(self, polygon: SimplePolygon) -> None:
        r"""
        @brief Inserts a simple polygon

        Inserts a simple polygon into the region.
        """
    @overload
    def insert(self, region: Region) -> None:
        r"""
        @brief Inserts all polygons from the other region into this region
        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape_iterator: RecursiveShapeIterator) -> None:
        r"""
        @brief Inserts all shapes delivered by the recursive shape iterator into this region

        This method will insert all shapes delivered by the shape iterator and insert them into the region.
        Text objects and edges are not inserted, because they cannot be converted to polygons.
        """
    @overload
    def insert(self, shapes: Shapes) -> None:
        r"""
        @brief Inserts all polygons from the shape collection into this region
        This method takes each "polygon-like" shape from the shape collection and inserts this shape into the region. Paths and boxes are converted to polygons during this process. Edges and text objects are ignored.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts all shapes delivered by the recursive shape iterator into this region with a transformation

        This method will insert all shapes delivered by the shape iterator and insert them into the region.
        Text objects and edges are not inserted, because they cannot be converted to polygons.
        This variant will apply the given transformation to the shapes. This is useful to scale the shapes to a specific database unit for example.
        """
    @overload
    def insert(self, shapes: Shapes, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts all polygons from the shape collection into this region with complex transformation
        This method takes each "polygon-like" shape from the shape collection and inserts this shape into the region after applying the given complex transformation. Paths and boxes are converted to polygons during this process. Edges and text objects are ignored.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shapes: Shapes, trans: Trans) -> None:
        r"""
        @brief Inserts all polygons from the shape collection into this region with transformation
        This method takes each "polygon-like" shape from the shape collection and inserts this shape into the region after applying the given transformation. Paths and boxes are converted to polygons during this process. Edges and text objects are ignored.

        This method has been introduced in version 0.25.
        """
    def insert_into(self, layout: Layout, cell_index: int, layer: int) -> None:
        r"""
        @brief Inserts this region into the given layout, below the given cell and into the given layer.
        If the region is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.

        This method has been introduced in version 0.26.
        """
    def inside(self, other: Region) -> Region:
        r"""
        @brief Returns the polygons of this region which are completely inside polygons from the other region

        @return A new region containing the polygons which are inside polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def inside_check(self, other: Region, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs an inside check with options
        @param d The minimum distance for which the polygons are checked
        @param other The other region against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative Negative output from the first input

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        If "negative" is true, only edges from the first input are output as pseudo edge-pairs where the distance is larger or equal to the limit. This is a way to flag the parts of the first input where the distance to the second input is bigger. Note that only the first input's edges are output. The output is still edge pairs, but each edge pair contains one edge from the original input and the reverse version of the edge as the second edge.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27. The interpretation of the 'negative' flag has been restriced to first-layout only output in 0.27.1.
        The 'enclosed_check' alias was introduced in version 0.27.5.
        """
    @overload
    def interacting(self, other: Edges, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which overlap or touch edges from the edge collection

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with edges of the edge collection to make the polygon selected. A polygon is selected by this method if the number of edges interacting with the polygon is between min_count and max_count (including max_count).

        @return A new region containing the polygons overlapping or touching edges from the edge collection

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.25.
        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def interacting(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which overlap or touch polygons from the other region

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with (different) polygons of the other region to make the polygon selected. A polygon is selected by this method if the number of polygons interacting with a polygon of this region is between min_count and max_count (including max_count).

        @return A new region containing the polygons overlapping or touching polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def interacting(self, other: Texts, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which overlap or touch texts

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with texts of the text collection to make the polygon selected. A polygon is selected by this method if the number of texts interacting with the polygon is between min_count and max_count (including max_count).

        @return A new region containing the polygons overlapping or touching texts

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns true, if the region is a simple box

        @return True if the region is a box.

        This method does not apply implicit merging if merge semantics is enabled.
        If the region is not merged, this method may return false even
        if the merged region would be a box.
        """
    def is_deep(self) -> bool:
        r"""
        @brief Returns true if the region is a deep (hierarchical) one

        This method has been added in version 0.26.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns true if the region is empty
        """
    def is_merged(self) -> bool:
        r"""
        @brief Returns true if the region is merged
        If the region is merged, polygons will not touch or overlap. You can ensure merged state by calling \merge.
        """
    def isolated_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs a space check between edges of different polygons with options
        @param d The minimum space for which the polygons are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative If true, edges not violation the condition will be output as pseudo-edge pairs

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27.
        """
    def members_of(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons which are members of the other region
        This method returns all polygons in self which can be found in the other region as well with exactly the same geometry.
        """
    @overload
    def merge(self) -> Region:
        r"""
        @brief Merge the region

        @return The region after is has been merged (self).

        Merging removes overlaps and joins touching polygons.
        If the region is already merged, this method does nothing
        """
    @overload
    def merge(self, min_wc: int) -> Region:
        r"""
        @brief Merge the region with options

        @param min_wc Overlap selection
        @return The region after is has been merged (self).

        Merging removes overlaps and joins touching polygons.
        This version provides one additional option: "min_wc" controls whether output is only produced if multiple polygons overlap. The value specifies the number of polygons that need to overlap. A value of 2 means that output is only produced if two or more polygons overlap.

        This method is equivalent to "merge(false, min_wc).
        """
    @overload
    def merge(self, min_coherence: bool, min_wc: int) -> Region:
        r"""
        @brief Merge the region with options

        @param min_coherence A flag indicating whether the resulting polygons shall have minimum coherence
        @param min_wc Overlap selection
        @return The region after is has been merged (self).

        Merging removes overlaps and joins touching polygons.
        This version provides two additional options: if "min_coherence" is set to true, "kissing corners" are resolved by producing separate polygons. "min_wc" controls whether output is only produced if multiple polygons overlap. The value specifies the number of polygons that need to overlap. A value of 2 means that output is only produced if two or more polygons overlap.
        """
    @overload
    def merged(self) -> Region:
        r"""
        @brief Returns the merged region

        @return The region after is has been merged.

        Merging removes overlaps and joins touching polygons.
        If the region is already merged, this method does nothing.
        In contrast to \merge, this method does not modify the region but returns a merged copy.
        """
    @overload
    def merged(self, min_wc: int) -> Region:
        r"""
        @brief Returns the merged region (with options)

        @return The region after is has been merged.

        This version provides one additional options: "min_wc" controls whether output is only produced if multiple polygons overlap. The value specifies the number of polygons that need to overlap. A value of 2 means that output is only produced if two or more polygons overlap.

        This method is equivalent to "merged(false, min_wc)".

        In contrast to \merge, this method does not modify the region but returns a merged copy.
        """
    @overload
    def merged(self, min_coherence: bool, min_wc: int) -> Region:
        r"""
        @brief Returns the merged region (with options)

        @param min_coherence A flag indicating whether the resulting polygons shall have minimum coherence
        @param min_wc Overlap selection
        @return The region after is has been merged (self).

        Merging removes overlaps and joins touching polygons.
        This version provides two additional options: if "min_coherence" is set to true, "kissing corners" are resolved by producing separate polygons. "min_wc" controls whether output is only produced if multiple polygons overlap. The value specifies the number of polygons that need to overlap. A value of 2 means that output is only produced if two or more polygons overlap.

        In contrast to \merge, this method does not modify the region but returns a merged copy.
        """
    @overload
    def minkowski_sum(self, b: Box) -> Region:
        r"""
        @brief Compute the Minkowski sum of the region and a box

        @param b The box.

        @return The new polygons representing the Minkowski sum of self and the box.

        The result is equivalent to the region-with-polygon Minkowski sum with the box used as the second polygon.

        The resulting polygons are not merged. In order to remove overlaps, use the \merge or \merged method.Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def minkowski_sum(self, b: Sequence[Point]) -> Region:
        r"""
        @brief Compute the Minkowski sum of the region and a contour of points (a trace)

        @param b The contour (a series of points forming the trace).

        @return The new polygons representing the Minkowski sum of self and the contour.

        The Minkowski sum of a region and a contour basically results in the area covered when "dragging" the region along the contour. The effect is similar to drawing the contour with a pencil that has the shape of the given region.

        The resulting polygons are not merged. In order to remove overlaps, use the \merge or \merged method.Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def minkowski_sum(self, e: Edge) -> Region:
        r"""
        @brief Compute the Minkowski sum of the region and an edge

        @param e The edge.

        @return The new polygons representing the Minkowski sum with the edge e.

        The Minkowski sum of a region and an edge basically results in the area covered when "dragging" the region along the line given by the edge. The effect is similar to drawing the line with a pencil that has the shape of the given region.

        The resulting polygons are not merged. In order to remove overlaps, use the \merge or \merged method.Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def minkowski_sum(self, p: Polygon) -> Region:
        r"""
        @brief Compute the Minkowski sum of the region and a polygon

        @param p The first argument.

        @return The new polygons representing the Minkowski sum of self and p.

        The Minkowski sum of a region and a polygon is basically the result of "painting" the region with a pen that has the shape of the second polygon.

        The resulting polygons are not merged. In order to remove overlaps, use the \merge or \merged method.Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def move(self, v: Vector) -> Region:
        r"""
        @brief Moves the region

        Moves the polygon by the given offset and returns the 
        moved region. The region is overwritten.

        @param v The distance to move the region.

        Starting with version 0.25 this method accepts a vector argument.

        @return The moved region (self).
        """
    @overload
    def move(self, x: int, y: int) -> Region:
        r"""
        @brief Moves the region

        Moves the region by the given offset and returns the 
        moved region. The region is overwritten.

        @param x The x distance to move the region.
        @param y The y distance to move the region.

        @return The moved region (self).
        """
    @overload
    def moved(self, v: Vector) -> Region:
        r"""
        @brief Returns the moved region (does not modify self)

        Moves the region by the given offset and returns the 
        moved region. The region is not modified.

        Starting with version 0.25 this method accepts a vector argument.

        @param p The distance to move the region.

        @return The moved region.
        """
    @overload
    def moved(self, x: int, y: int) -> Region:
        r"""
        @brief Returns the moved region (does not modify self)

        Moves the region by the given offset and returns the 
        moved region. The region is not modified.

        @param x The x distance to move the region.
        @param y The y distance to move the region.

        @return The moved region.
        """
    def non_rectangles(self) -> Region:
        r"""
        @brief Returns all polygons which are not rectangles
        This method returns all polygons in self which are not rectangles.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def non_rectilinear(self) -> Region:
        r"""
        @brief Returns all polygons which are not rectilinear
        This method returns all polygons in self which are not rectilinear.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def non_squares(self) -> Region:
        r"""
        @brief Returns all polygons which are not squares
        This method returns all polygons in self which are not squares.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    def not_covering(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which are not completely covering polygons from the other region

        @return A new region containing the polygons which are not covering polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This attribute is sometimes called 'enclosing' instead of 'covering', but this term is reserved for the respective DRC function.

        This method has been introduced in version 0.27.
        """
    def not_inside(self, other: Region) -> Region:
        r"""
        @brief Returns the polygons of this region which are not completely inside polygons from the other region

        @return A new region containing the polygons which are not inside polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def not_interacting(self, other: Edges, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which do not overlap or touch edges from the edge collection

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with edges of the edge collection to make the polygon not selected. A polygon is not selected by this method if the number of edges interacting with the polygon is between min_count and max_count (including max_count).

        @return A new region containing the polygons not overlapping or touching edges from the edge collection

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.25
        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def not_interacting(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which do not overlap or touch polygons from the other region

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with (different) polygons of the other region to make the polygon not selected. A polygon is not selected by this method if the number of polygons interacting with a polygon of this region is between min_count and max_count (including max_count).

        @return A new region containing the polygons not overlapping or touching polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def not_interacting(self, other: Texts, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which do not overlap or touch texts

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with texts of the text collection to make the polygon not selected. A polygon is not selected by this method if the number of texts interacting with the polygon is between min_count and max_count (including max_count).

        @return A new region containing the polygons not overlapping or touching texts

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27
        """
    def not_members_of(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons which are not members of the other region
        This method returns all polygons in self which can not be found in the other region with exactly the same geometry.
        """
    def not_outside(self, other: Region) -> Region:
        r"""
        @brief Returns the polygons of this region which are not completely outside polygons from the other region

        @return A new region containing the polygons which are not outside polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def not_overlapping(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which do not overlap polygons from the other region

        @return A new region containing the polygons not overlapping polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The count options have been introduced in version 0.27.
        """
    def notch_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs a space check between edges of the same polygon with options
        @param d The minimum space for which the polygons are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param shielded Enables shielding
        @param negative If true, edges not violation the condition will be output as pseudo-edge pairs

        This version is similar to the simple version with one parameter. In addition, it allows to specify many more options.

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the space check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded' and 'negative' options have been introduced in version 0.27.
        """
    def outside(self, other: Region) -> Region:
        r"""
        @brief Returns the polygons of this region which are completely outside polygons from the other region

        @return A new region containing the polygons which are outside polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def overlap_check(self, other: Region, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs an overlap check with options
        @param d The minimum overlap for which the polygons are checked
        @param other The other region against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative Negative output from the first input

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        If "negative" is true, only edges from the first input are output as pseudo edge-pairs where the overlap is larger or equal to the limit. This is a way to flag the parts of the first input where the overlap vs. the second input is bigger. Note that only the first input's edges are output. The output is still edge pairs, but each edge pair contains one edge from the original input and the reverse version of the edge as the second edge.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27. The interpretation of the 'negative' flag has been restriced to first-layout only output in 0.27.1.
        """
    def overlapping(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Returns the polygons of this region which overlap polygons from the other region

        @return A new region containing the polygons overlapping polygons from the other region

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The count options have been introduced in version 0.27.
        """
    @overload
    def perimeter(self) -> int:
        r"""
        @brief The total perimeter of the polygons

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merged semantics is not enabled, internal edges are counted as well.
        """
    @overload
    def perimeter(self, rect: Box) -> int:
        r"""
        @brief The total perimeter of the polygons (restricted to a rectangle)
        This version will compute the perimeter of the polygons, restricting the computation to the given rectangle.
        Edges along the border are handled in a special way: they are counted when they are oriented with their inside side toward the rectangle (in other words: outside edges must coincide with the rectangle's border in order to be counted).

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        If merged semantics is not enabled, internal edges are counted as well.
        """
    def pull_inside(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons of "other" which are inside polygons of this region
        The "pull_..." methods are similar to "select_..." but work the opposite way: they select shapes from the argument region rather than self. In a deep (hierarchical) context the output region will be hierarchically aligned with self, so the "pull_..." methods provide a way for re-hierarchization.

        @return The region after the polygons have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.26.1
        """
    @overload
    def pull_interacting(self, other: Edges) -> Edges:
        r"""
        @brief Returns all edges of "other" which are interacting with polygons of this region
        See \pull_inside for a description of the "pull_..." methods.

        @return The edge collection after the edges have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.26.1
        """
    @overload
    def pull_interacting(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons of "other" which are interacting with (overlapping, touching) polygons of this region
        See \pull_inside for a description of the "pull_..." methods.

        @return The region after the polygons have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.26.1
        """
    @overload
    def pull_interacting(self, other: Texts) -> Texts:
        r"""
        @brief Returns all texts of "other" which are interacting with polygons of this region
        See \pull_inside for a description of the "pull_..." methods.

        @return The text collection after the texts have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27
        """
    def pull_overlapping(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons of "other" which are overlapping polygons of this region
        See \pull_inside for a description of the "pull_..." methods.

        @return The region after the polygons have been selected (from other)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.26.1
        """
    def rectangles(self) -> Region:
        r"""
        @brief Returns all polygons which are rectangles
        This method returns all polygons in self which are rectangles.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def rectilinear(self) -> Region:
        r"""
        @brief Returns all polygons which are rectilinear
        This method returns all polygons in self which are rectilinear.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def round_corners(self, r_inner: float, r_outer: float, n: int) -> None:
        r"""
        @brief Corner rounding
        @param r_inner Inner corner radius (in database units)
        @param r_outer Outer corner radius (in database units)
        @param n The number of points per circle

        This method rounds the corners of the polygons in the region. Inner corners will be rounded with a radius of r_inner and outer corners with a radius of r_outer. The circles will be approximated by segments using n segments per full circle.

        This method modifies the region. \rounded_corners is a method that does the same but returns a new region without modifying self. Merged semantics applies for this method.
        """
    def rounded_corners(self, r_inner: float, r_outer: float, n: int) -> Region:
        r"""
        @brief Corner rounding
        @param r_inner Inner corner radius (in database units)
        @param r_outer Outer corner radius (in database units)
        @param n The number of points per circle

        See \round_corners for a description of this method. This version returns a new region instead of modifying self (out-of-place).
        """
    def scale_and_snap(self, gx: int, mx: int, dx: int, gy: int, my: int, dy: int) -> None:
        r"""
        @brief Scales and snaps the region to the given grid
        This method will first scale the region by a rational factor of mx/dx horizontally and my/dy vertically and then snap the region to the given grid - each x or y coordinate is brought on the gx or gy grid by rounding to the nearest value which is a multiple of gx or gy.

        If gx or gy is 0, the result is brought on a grid of 1.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.26.1.
        """
    def scaled_and_snapped(self, gx: int, mx: int, dx: int, gy: int, my: int, dy: int) -> Region:
        r"""
        @brief Returns the scaled and snapped region
        This method will scale and snap the region to the given grid and return the scaled and snapped region (see \scale_and_snap). The original region is not modified.

        This method has been introduced in version 0.26.1.
        """
    def select_covering(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons of this region which are completely covering polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This attribute is sometimes called 'enclosing' instead of 'covering', but this term is reserved for the respective DRC function.

        This method has been introduced in version 0.27.
        """
    def select_inside(self, other: Region) -> Region:
        r"""
        @brief Selects the polygons of this region which are completely inside polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def select_interacting(self, other: Edges, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which overlap or touch edges from the edge collection

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with edges of the edge collection to make the polygon selected. A polygon is selected by this method if the number of edges interacting with the polygon is between min_count and max_count (including max_count).

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.25
        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def select_interacting(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which overlap or touch polygons from the other region

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with (different) polygons of the other region to make the polygon selected. A polygon is selected by this method if the number of polygons interacting with a polygon of this region is between min_count and max_count (including max_count).

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def select_interacting(self, other: Texts, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons of this region which overlap or touch texts

        @return The region after the polygons have been selected (self)

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with texts of the text collection to make the polygon selected. A polygon is selected by this method if the number of texts interacting with the polygon is between min_count and max_count (including max_count).

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27
        """
    def select_not_covering(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons of this region which are not completely covering polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This attribute is sometimes called 'enclosing' instead of 'covering', but this term is reserved for the respective DRC function.

        This method has been introduced in version 0.27.
        """
    def select_not_inside(self, other: Region) -> Region:
        r"""
        @brief Selects the polygons of this region which are not completely inside polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def select_not_interacting(self, other: Edges, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which do not overlap or touch edges from the edge collection

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with edges of the edge collection to make the polygon not selected. A polygon is not selected by this method if the number of edges interacting with the polygon is between min_count and max_count (including max_count).

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.25
        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def select_not_interacting(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which do not overlap or touch polygons from the other region

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with (different) polygons of the other region to make the polygon not selected. A polygon is not selected by this method if the number of polygons interacting with a polygon of this region is between min_count and max_count (including max_count).

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The min_count and max_count arguments have been added in version 0.27.
        """
    @overload
    def select_not_interacting(self, other: Texts, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons of this region which do not overlap or touch texts

        'min_count' and 'max_count' impose a constraint on the number of times a polygon of this region has to interact with texts of the text collection to make the polygon not selected. A polygon is not selected by this method if the number of texts interacting with the polygon is between min_count and max_count (including max_count).

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27
        """
    def select_not_outside(self, other: Region) -> Region:
        r"""
        @brief Selects the polygons of this region which are not completely outside polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def select_not_overlapping(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which do not overlap polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The count options have been introduced in version 0.27.
        """
    def select_outside(self, other: Region) -> Region:
        r"""
        @brief Selects the polygons of this region which are completely outside polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def select_overlapping(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> Region:
        r"""
        @brief Selects the polygons from this region which overlap polygons from the other region

        @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The count options have been introduced in version 0.27.
        """
    def separation_check(self, other: Region, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs a separation check with options
        @param d The minimum separation for which the polygons are checked
        @param other The other region against which to check
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative Negative output from the first input

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        If "negative" is true, only edges from the first input are output as pseudo edge-pairs where the separation is larger or equal to the limit. This is a way to flag the parts of the first input where the distance to the second input is bigger. Note that only the first input's edges are output. The output is still edge pairs, but each edge pair contains one edge from the original input and the reverse version of the edge as the second edge.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27. The interpretation of the 'negative' flag has been restriced to first-layout only output in 0.27.1.
        """
    @overload
    def size(self, d: int) -> Region:
        r"""
        @brief Isotropic sizing (biasing)

        @return The region after the sizing has applied (self)

        This method is equivalent to "size(d, d, 2)".

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def size(self, d: int, mode: int) -> Region:
        r"""
        @brief Isotropic sizing (biasing)

        @return The region after the sizing has applied (self)

        This method is equivalent to "size(d, d, mode)".

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def size(self, dx: int, dy: int, mode: int) -> Region:
        r"""
        @brief Anisotropic sizing (biasing)

        @return The region after the sizing has applied (self)

        Shifts the contour outwards (dx,dy>0) or inwards (dx,dy<0).
        dx is the sizing in x-direction and dy is the sizing in y-direction. The sign of dx and dy should be identical.

        This method applies a sizing to the region. Before the sizing is done, the
        region is merged if this is not the case already.

        The mode defines at which bending angle cutoff occurs 
        (0:>0, 1:>45, 2:>90, 3:>135, 4:>approx. 168, other:>approx. 179)

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        The result is a set of polygons which may be overlapping, but are not self-
        intersecting. Polygons may overlap afterwards because they grew big enough to overlap their neighbors.
        In that case, \merge can be used to detect this overlaps by setting the "min_wc" parameter to value 1:

        @code
        r = RBA::Region::new
        r.insert(RBA::Box::new(0, 0, 50, 50))
        r.insert(RBA::Box::new(100, 0, 150, 50))
        r.size(50, 2)
        r.merge(false, 1)
        # r now is (50,-50;50,100;100,100;100,-50)
        @/code
        """
    @overload
    def sized(self, d: int) -> Region:
        r"""
        @brief Isotropic sizing (biasing)

        @return The region after the sizing has applied (self)

        This method is equivalent to "sized(d, d, 2)".

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def sized(self, d: int, mode: int) -> Region:
        r"""
        @brief Returns the isotropically sized region

        @return The sized region

        This method is returns the sized region (see \size), but does not modify self.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def sized(self, dx: int, dy: int, mode: int) -> Region:
        r"""
        @brief Returns the anisotropically sized region

        @return The sized region

        This method is returns the sized region (see \size), but does not modify self.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def smooth(self, d: int, keep_hv: Optional[bool] = ...) -> None:
        r"""
        @brief Smoothing
        @param d The smoothing tolerance (in database units)
        @param keep_hv If true, horizontal and vertical edges are maintained

        This method will simplify the merged polygons of the region by removing vertexes if the resulting polygon stays equivalent with the original polygon. Equivalence is measured in terms of a deviation which is guaranteed to not become larger than \d.
        This method modifies the region. \smoothed is a method that does the same but returns a new region without modifying self. Merged semantics applies for this method.
        """
    def smoothed(self, d: int, keep_hv: Optional[bool] = ...) -> Region:
        r"""
        @brief Smoothing
        @param d The smoothing tolerance (in database units)
        @param keep_hv If true, horizontal and vertical edges are maintained

        See \smooth for a description of this method. This version returns a new region instead of modifying self (out-of-place). It has been introduced in version 0.25.
        """
    def snap(self, gx: int, gy: int) -> None:
        r"""
        @brief Snaps the region to the given grid
        This method will snap the region to the given grid - each x or y coordinate is brought on the gx or gy grid by rounding to the nearest value which is a multiple of gx or gy.

        If gx or gy is 0, no snapping happens in that direction.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    def snapped(self, gx: int, gy: int) -> Region:
        r"""
        @brief Returns the snapped region
        This method will snap the region to the given grid and return the snapped region (see \snap). The original region is not modified.
        """
    def space_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., opposite_filter: Optional[Region.OppositeFilter] = ..., rect_filter: Optional[Region.RectFilter] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs a space check with options
        @param d The minimum space for which the polygons are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param opposite_filter Specifies a filter mode for errors happening on opposite sides of inputs shapes
        @param rect_filter Specifies an error filter for rectangular input shapes
        @param negative If true, edges not violation the condition will be output as pseudo-edge pairs

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        "opposite_filter" specifies whether to require or reject errors happening on opposite sides of a figure. "rect_filter" allows suppressing specific error configurations on rectangular input figures.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded', 'negative', 'not_opposite' and 'rect_sides' options have been introduced in version 0.27.
        """
    def split_covering(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are completely covering polygons from the other region and the ones which are not at the same time

        @return Two new regions: the first containing the result of \covering, the second the result of \not_covering

        This method is equivalent to calling \covering and \not_covering, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    def split_inside(self, other: Region) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are completely inside polygons from the other region and the ones which are not at the same time

        @return Two new regions: the first containing the result of \inside, the second the result of \not_inside

        This method is equivalent to calling \inside and \not_inside, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    @overload
    def split_interacting(self, other: Edges, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are interacting with edges from the other edge collection and the ones which are not at the same time

        @return Two new regions: the first containing the result of \interacting, the second the result of \not_interacting

        This method is equivalent to calling \interacting and \not_interacting, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    @overload
    def split_interacting(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are interacting with polygons from the other region and the ones which are not at the same time

        @return Two new regions: the first containing the result of \interacting, the second the result of \not_interacting

        This method is equivalent to calling \interacting and \not_interacting, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    @overload
    def split_interacting(self, other: Texts, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are interacting with texts from the other text collection and the ones which are not at the same time

        @return Two new regions: the first containing the result of \interacting, the second the result of \not_interacting

        This method is equivalent to calling \interacting and \not_interacting, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    def split_outside(self, other: Region) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are completely outside polygons from the other region and the ones which are not at the same time

        @return Two new regions: the first containing the result of \outside, the second the result of \not_outside

        This method is equivalent to calling \outside and \not_outside, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    def split_overlapping(self, other: Region, min_count: Optional[int] = ..., max_count: Optional[int] = ...) -> List[Region]:
        r"""
        @brief Returns the polygons of this region which are overlapping with polygons from the other region and the ones which are not at the same time

        @return Two new regions: the first containing the result of \overlapping, the second the result of \not_overlapping

        This method is equivalent to calling \overlapping and \not_overlapping, but is faster when both results are required.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept).

        This method has been introduced in version 0.27.
        """
    def squares(self) -> Region:
        r"""
        @brief Returns all polygons which are squares
        This method returns all polygons in self which are squares.Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    def strange_polygon_check(self) -> Region:
        r"""
        @brief Returns a region containing those parts of polygons which are "strange"
        Strange parts of polygons are self-overlapping parts or non-orientable parts (i.e. in the "8" configuration).

        Merged semantics does not apply for this method (see \merged_semantics= for a description of this concept)
        """
    def swap(self, other: Region) -> None:
        r"""
        @brief Swap the contents of this region with the contents of another region
        This method is useful to avoid excessive memory allocation in some cases. For managed memory languages such as Ruby, those cases will be rare. 
        """
    @overload
    def texts(self, expr: Optional[str] = ..., as_pattern: Optional[bool] = ..., enl: Optional[int] = ...) -> Region:
        r"""
        @hide
        This method is provided for DRC implementation only.
        """
    @overload
    def texts(self, dss: DeepShapeStore, expr: Optional[str] = ..., as_pattern: Optional[bool] = ..., enl: Optional[int] = ...) -> Region:
        r"""
        @hide
        This method is provided for DRC implementation only.
        """
    @overload
    def texts_dots(self, expr: Optional[str] = ..., as_pattern: Optional[bool] = ...) -> Edges:
        r"""
        @hide
        This method is provided for DRC implementation only.
        """
    @overload
    def texts_dots(self, dss: DeepShapeStore, expr: Optional[str] = ..., as_pattern: Optional[bool] = ...) -> Edges:
        r"""
        @hide
        This method is provided for DRC implementation only.
        """
    @overload
    def to_s(self) -> str:
        r"""
        @brief Converts the region to a string
        The length of the output is limited to 20 polygons to avoid giant strings on large regions. For full output use "to_s" with a maximum count parameter.
        """
    @overload
    def to_s(self, max_count: int) -> str:
        r"""
        @brief Converts the region to a string
        This version allows specification of the maximum number of polygons contained in the string.
        """
    @overload
    def transform(self, t: ICplxTrans) -> Region:
        r"""
        @brief Transform the region with a complex transformation (modifies self)

        Transforms the region with the given transformation.
        This version modifies the region and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.
        """
    @overload
    def transform(self, t: IMatrix2d) -> Region:
        r"""
        @brief Transform the region (modifies self)

        Transforms the region with the given 2d matrix transformation.
        This version modifies the region and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.

        This variant was introduced in version 0.27.
        """
    @overload
    def transform(self, t: IMatrix3d) -> Region:
        r"""
        @brief Transform the region (modifies self)

        Transforms the region with the given 3d matrix transformation.
        This version modifies the region and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.

        This variant was introduced in version 0.27.
        """
    @overload
    def transform(self, t: Trans) -> Region:
        r"""
        @brief Transform the region (modifies self)

        Transforms the region with the given transformation.
        This version modifies the region and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Region:
        r"""
        @brief Transforms the region with a complex transformation

        Transforms the region with the given complex transformation.
        Does not modify the region but returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.
        """
    @overload
    def transformed(self, t: IMatrix2d) -> Region:
        r"""
        @brief Transforms the region

        Transforms the region with the given 2d matrix transformation.
        Does not modify the region but returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.

        This variant was introduced in version 0.27.
        """
    @overload
    def transformed(self, t: IMatrix3d) -> Region:
        r"""
        @brief Transforms the region

        Transforms the region with the given 3d matrix transformation.
        Does not modify the region but returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.

        This variant was introduced in version 0.27.
        """
    @overload
    def transformed(self, t: Trans) -> Region:
        r"""
        @brief Transforms the region

        Transforms the region with the given transformation.
        Does not modify the region but returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.
        """
    def width_check(self, d: int, whole_edges: Optional[bool] = ..., metrics: Optional[Region.Metrics] = ..., ignore_angle: Optional[Any] = ..., min_projection: Optional[Any] = ..., max_projection: Optional[Any] = ..., shielded: Optional[bool] = ..., negative: Optional[bool] = ...) -> EdgePairs:
        r"""
        @brief Performs a width check with options
        @param d The minimum width for which the polygons are checked
        @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed
        @param min_projection The lower threshold of the projected length of one edge onto another
        @param max_projection The upper limit of the projected length of one edge onto another
        @param shielded Enables shielding
        @param negative If true, edges not violation the condition will be output as pseudo-edge pairs

        This version is similar to the simple version with one parameter. In addition, it allows to specify many more options.

        If "whole_edges" is true, the resulting \EdgePairs collection will receive the whole edges which contribute in the width check.

        "metrics" can be one of the constants \Euclidian, \Square or \Projection. See there for a description of these constants.
        Use nil for this value to select the default (Euclidian metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or above the given value, they will not contribute in the check. Setting this value to 90 (the default) will exclude edges with an angle of 90 degree or more from the check.
        Use nil for this value to select the default.

        "min_projection" and "max_projection" allow selecting edges by their projected value upon each other. It is sufficient if the projection of one edge on the other matches the specified condition. The projected length must be larger or equal to "min_projection" and less than "max_projection". If you don't want to specify one limit, pass nil to the respective value.

        "shielded" controls whether shielding is applied. Shielding means that rule violations are not detected 'through' other features. Measurements are only made where the opposite edge is unobstructed.
        Shielding often is not optional as a rule violation in shielded case automatically comes with rule violations between the original and the shielding features. If not necessary, shielding can be disabled by setting this flag to false. In general, this will improve performance somewhat.

        Merged semantics applies for the input of this method (see \merged_semantics= for a description of this concept)

        The 'shielded' and 'negative' options have been introduced in version 0.27.
        """
    @overload
    def with_angle(self, angle: float, inverse: bool) -> EdgePairs:
        r"""
        @brief Returns markers on every corner with the given angle (or not with the given angle)
        If the inverse flag is false, this method returns an error marker (an \EdgePair object) for every corner whose connected edges form an angle with the given value (in degree). If the inverse flag is true, the method returns markers for every corner whose angle is not the given value.

        The edge pair objects returned will contain both edges forming the angle.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_angle(self, amin: float, amax: float, inverse: bool) -> EdgePairs:
        r"""
        @brief Returns markers on every corner with an angle of more than amin and less than amax (or the opposite)
        If the inverse flag is false, this method returns an error marker (an \EdgePair object) for every corner whose connected edges form an angle whose value is more or equal to amin (in degree) or less (but not equal to) amax. If the inverse flag is true, the method returns markers for every corner whose angle is not matching that criterion.

        The edge pair objects returned will contain both edges forming the angle.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_area(self, area: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by area
        Filters the polygons of the region by area. If "inverse" is false, only polygons which have the given area are returned. If "inverse" is true, polygons not having the given area are returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_area(self, min_area: Any, max_area: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by area
        Filters the polygons of the region by area. If "inverse" is false, only polygons which have an area larger or equal to "min_area" and less than "max_area" are returned. If "inverse" is true, polygons having an area less than "min_area" or larger or equal than "max_area" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_area_ratio(self, ratio: float, inverse: bool) -> Region:
        r"""
        @brief Filters the polygons by the bounding box area to polygon area ratio
        The area ratio is defined by the ratio of bounding box area to polygon area. It's a measure how much the bounding box is approximating the polygon. 'Thin polygons' have a large area ratio, boxes has an area ratio of 1.
        The area ratio is always larger or equal to 1. 
        With 'inverse' set to false, this version filters polygons which have an area ratio equal to the given value. With 'inverse' set to true, all other polygons will be returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_area_ratio(self, min_ratio: Any, max_ratio: Any, inverse: bool, min_included: Optional[bool] = ..., max_included: Optional[bool] = ...) -> Region:
        r"""
        @brief Filters the polygons by the aspect ratio of their bounding boxes
        The area ratio is defined by the ratio of bounding box area to polygon area. It's a measure how much the bounding box is approximating the polygon. 'Thin polygons' have a large area ratio, boxes has an area ratio of 1.
        The area ratio is always larger or equal to 1. 
        With 'inverse' set to false, this version filters polygons which have an area ratio between 'min_ratio' and 'max_ratio'. With 'min_included' set to true, the 'min_ratio' value is included in the range, otherwise it's excluded. Same for 'max_included' and 'max_ratio'. With 'inverse' set to true, all other polygons will be returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_bbox_aspect_ratio(self, ratio: float, inverse: bool) -> Region:
        r"""
        @brief Filters the polygons by the aspect ratio of their bounding boxes
        Filters the polygons of the region by the aspect ratio of their bounding boxes. The aspect ratio is the ratio of larger to smaller dimension of the bounding box. A square has an aspect ratio of 1.

        With 'inverse' set to false, this version filters polygons which have a bounding box aspect ratio equal to the given value. With 'inverse' set to true, all other polygons will be returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_bbox_aspect_ratio(self, min_ratio: Any, max_ratio: Any, inverse: bool, min_included: Optional[bool] = ..., max_included: Optional[bool] = ...) -> Region:
        r"""
        @brief Filters the polygons by the aspect ratio of their bounding boxes
        Filters the polygons of the region by the aspect ratio of their bounding boxes. The aspect ratio is the ratio of larger to smaller dimension of the bounding box. A square has an aspect ratio of 1.

        With 'inverse' set to false, this version filters polygons which have a bounding box aspect ratio between 'min_ratio' and 'max_ratio'. With 'min_included' set to true, the 'min_ratio' value is included in the range, otherwise it's excluded. Same for 'max_included' and 'max_ratio'. With 'inverse' set to true, all other polygons will be returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_bbox_height(self, height: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box height
        Filters the polygons of the region by the height of their bounding box. If "inverse" is false, only polygons whose bounding box has the given height are returned. If "inverse" is true, polygons whose bounding box does not have the given height are returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_height(self, min_height: Any, max_height: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box height
        Filters the polygons of the region by the height of their bounding box. If "inverse" is false, only polygons whose bounding box has a height larger or equal to "min_height" and less than "max_height" are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_max(self, dim: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width or height, whichever is larger
        Filters the polygons of the region by the maximum dimension of their bounding box. If "inverse" is false, only polygons whose bounding box's larger dimension is equal to the given value are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_max(self, min_dim: Any, max_dim: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width or height, whichever is larger
        Filters the polygons of the region by the minimum dimension of their bounding box. If "inverse" is false, only polygons whose bounding box's larger dimension is larger or equal to "min_dim" and less than "max_dim" are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_min(self, dim: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width or height, whichever is smaller
        Filters the polygons inside the region by the minimum dimension of their bounding box. If "inverse" is false, only polygons whose bounding box's smaller dimension is equal to the given value are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_min(self, min_dim: Any, max_dim: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width or height, whichever is smaller
        Filters the polygons of the region by the minimum dimension of their bounding box. If "inverse" is false, only polygons whose bounding box's smaller dimension is larger or equal to "min_dim" and less than "max_dim" are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_width(self, width: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width
        Filters the polygons of the region by the width of their bounding box. If "inverse" is false, only polygons whose bounding box has the given width are returned. If "inverse" is true, polygons whose bounding box does not have the given width are returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_bbox_width(self, min_width: Any, max_width: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by bounding box width
        Filters the polygons of the region by the width of their bounding box. If "inverse" is false, only polygons whose bounding box has a width larger or equal to "min_width" and less than "max_width" are returned. If "inverse" is true, all polygons not matching this criterion are returned.
        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_holes(self, nholes: int, inverse: bool) -> Region:
        r"""
        @brief Filters the polygons by their number of holes
        Filters the polygons of the region by number of holes. If "inverse" is false, only polygons which have the given number of holes are returned. If "inverse" is true, polygons not having the given of holes are returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_holes(self, min_bholes: Any, max_nholes: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by their number of holes
        Filters the polygons of the region by number of holes. If "inverse" is false, only polygons which have a hole count larger or equal to "min_nholes" and less than "max_nholes" are returned. If "inverse" is true, polygons having a hole count less than "min_nholes" or larger or equal than "max_nholes" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_perimeter(self, perimeter: int, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by perimeter
        Filters the polygons of the region by perimeter. If "inverse" is false, only polygons which have the given perimeter are returned. If "inverse" is true, polygons not having the given perimeter are returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_perimeter(self, min_perimeter: Any, max_perimeter: Any, inverse: bool) -> Region:
        r"""
        @brief Filter the polygons by perimeter
        Filters the polygons of the region by perimeter. If "inverse" is false, only polygons which have a perimeter larger or equal to "min_perimeter" and less than "max_perimeter" are returned. If "inverse" is true, polygons having a perimeter less than "min_perimeter" or larger or equal than "max_perimeter" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)
        """
    @overload
    def with_relative_height(self, ratio: float, inverse: bool) -> Region:
        r"""
        @brief Filters the polygons by the ratio of height to width
        This method filters the polygons of the region by the ratio of height vs. width of their bounding boxes. 'Tall' polygons have a large value while 'flat' polygons have a small value. A square has a relative height of 1.

        An alternative method is 'with_area_ratio' which can be more efficient because it's isotropic.

        With 'inverse' set to false, this version filters polygons which have a relative height equal to the given value. With 'inverse' set to true, all other polygons will be returned.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """
    @overload
    def with_relative_height(self, min_ratio: Any, max_ratio: Any, inverse: bool, min_included: Optional[bool] = ..., max_included: Optional[bool] = ...) -> Region:
        r"""
        @brief Filters the polygons by the bounding box height to width ratio
        This method filters the polygons of the region by the ratio of height vs. width of their bounding boxes. 'Tall' polygons have a large value while 'flat' polygons have a small value. A square has a relative height of 1.

        An alternative method is 'with_area_ratio' which can be more efficient because it's isotropic.

        With 'inverse' set to false, this version filters polygons which have a relative height between 'min_ratio' and 'max_ratio'. With 'min_included' set to true, the 'min_ratio' value is included in the range, otherwise it's excluded. Same for 'max_included' and 'max_ratio'. With 'inverse' set to true, all other polygons will be returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \merged_semantics= for a description of this concept)

        This method has been introduced in version 0.27.
        """

class Shape:
    r"""
    @brief An object representing a shape in the layout database

    The shape proxy is basically a pointer to a shape of different kinds.
    No copy of the shape is created: if the shape proxy is copied the copy still
    points to the original shape. If the original shape is modified or deleted,
    the shape proxy will also point to a modified or invalid shape.
    The proxy can be "null" which indicates an invalid reference.

    Shape objects are used together with the \Shapes container object which
    stores the actual shape objects and uses Shape references as pointers inside the
    actual data storage. Shape references are used in various places, i.e. when removing or
    transforming objects inside a \Shapes container.
    """
    TBox: ClassVar[int]
    r"""
    """
    TBoxArray: ClassVar[int]
    r"""
    """
    TBoxArrayMember: ClassVar[int]
    r"""
    """
    TEdge: ClassVar[int]
    r"""
    """
    TEdgePair: ClassVar[int]
    r"""
    """
    TNull: ClassVar[int]
    r"""
    """
    TPath: ClassVar[int]
    r"""
    """
    TPathPtrArray: ClassVar[int]
    r"""
    """
    TPathPtrArrayMember: ClassVar[int]
    r"""
    """
    TPathRef: ClassVar[int]
    r"""
    """
    TPolygon: ClassVar[int]
    r"""
    """
    TPolygonPtrArray: ClassVar[int]
    r"""
    """
    TPolygonPtrArrayMember: ClassVar[int]
    r"""
    """
    TPolygonRef: ClassVar[int]
    r"""
    """
    TShortBox: ClassVar[int]
    r"""
    """
    TShortBoxArray: ClassVar[int]
    r"""
    """
    TShortBoxArrayMember: ClassVar[int]
    r"""
    """
    TSimplePolygon: ClassVar[int]
    r"""
    """
    TSimplePolygonPtrArray: ClassVar[int]
    r"""
    """
    TSimplePolygonPtrArrayMember: ClassVar[int]
    r"""
    """
    TSimplePolygonRef: ClassVar[int]
    r"""
    """
    TText: ClassVar[int]
    r"""
    """
    TTextPtrArray: ClassVar[int]
    r"""
    """
    TTextPtrArrayMember: ClassVar[int]
    r"""
    """
    TTextRef: ClassVar[int]
    r"""
    """
    TUserObject: ClassVar[int]
    r"""
    """
    box: Any
    r"""
    @brief Gets the box object

    Starting with version 0.23, this method returns nil, if the shape does not represent a box.@brief Replaces the shape by the given box
    This method replaces the shape by the given box. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    box_center: Point
    r"""
    @brief Returns the center of the box

    Applies to boxes only. Returns the center of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    @brief Sets the center of the box

    Applies to boxes only. Changes the center of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    """
    box_dcenter: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'box_center'.
    @brief Sets the center of the box with the point being given in micrometer units

    Applies to boxes only. Changes the center of the box and throws an exception if the shape is not a box.
    Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.
    """
    box_dheight: float
    r"""
    @brief Returns the height of the box in micrometer units

    Applies to boxes only. Returns the height of the box in micrometers and throws an exception if the shape is not a box.

    This method has been introduced in version 0.25.
    @brief Sets the height of the box

    Applies to boxes only. Changes the height of the box to the value given in micrometer units and throws an exception if the shape is not a box.
    Translation to database units happens internally.

    This method has been introduced in version 0.25.
    """
    box_dp1: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'box_p1'.
    @brief Sets the lower left corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the lower left point of the box and throws an exception if the shape is not a box.
    Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.
    """
    box_dp2: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'box_p2'.
    @brief Sets the upper right corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the upper right point of the box and throws an exception if the shape is not a box.
    Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.
    """
    box_dwidth: float
    r"""
    @brief Returns the width of the box in micrometer units

    Applies to boxes only. Returns the width of the box in micrometers and throws an exception if the shape is not a box.

    This method has been introduced in version 0.25.
    @brief Sets the width of the box in micrometer units

    Applies to boxes only. Changes the width of the box to the value given in micrometer units and throws an exception if the shape is not a box.
    Translation to database units happens internally.

    This method has been introduced in version 0.25.
    """
    box_height: int
    r"""
    @brief Returns the height of the box

    Applies to boxes only. Returns the height of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    @brief Sets the height of the box

    Applies to boxes only. Changes the height of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    """
    box_p1: Point
    r"""
    @brief Returns the lower left point of the box

    Applies to boxes only. Returns the lower left point of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    @brief Sets the lower left point of the box

    Applies to boxes only. Changes the lower left point of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    """
    box_p2: Point
    r"""
    @brief Returns the upper right point of the box

    Applies to boxes only. Returns the upper right point of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    @brief Sets the upper right point of the box

    Applies to boxes only. Changes the upper right point of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    """
    box_width: int
    r"""
    @brief Returns the width of the box

    Applies to boxes only. Returns the width of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    @brief Sets the width of the box

    Applies to boxes only. Changes the width of the box and throws an exception if the shape is not a box.

    This method has been introduced in version 0.23.
    """
    cell: Cell
    r"""
    @brief Gets a reference to the cell the shape belongs to

    This reference can be nil, if the Shape object is not living inside a cell

    This method has been introduced in version 0.22.@brief Moves the shape to a different cell

    Both the current and the target cell must reside in the same layout.

    This method has been introduced in version 0.23.
    """
    dbox: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'box'.
    @brief Replaces the shape by the given box (in micrometer units)
    This method replaces the shape by the given box, like \box= with a \Box argument does. This version translates the box from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    dedge: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'edge'.
    @brief Replaces the shape by the given edge (in micrometer units)
    This method replaces the shape by the given edge, like \edge= with a \Edge argument does. This version translates the edge from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    dedge_pair: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'edge_pair'.
    @brief Replaces the shape by the given edge pair (in micrometer units)
    This method replaces the shape by the given edge pair, like \edge_pair= with a \EdgePair argument does. This version translates the edge pair from micrometer units to database units internally.

    This method has been introduced in version 0.26.
    """
    dpath: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'path'.
    @brief Replaces the shape by the given path (in micrometer units)
    This method replaces the shape by the given path, like \path= with a \Path argument does. This version translates the path from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    dpolygon: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'polygon'.
    @brief Replaces the shape by the given polygon (in micrometer units)
    This method replaces the shape by the given polygon, like \polygon= with a \Polygon argument does. This version translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    dsimple_polygon: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'simple_polygon'.
    @brief Replaces the shape by the given simple polygon (in micrometer units)
    This method replaces the shape by the given text, like \simple_polygon= with a \SimplePolygon argument does. This version translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    dtext: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'text'.
    @brief Replaces the shape by the given text (in micrometer units)
    This method replaces the shape by the given text, like \text= with a \Text argument does. This version translates the text from micrometer units to database units internally.

    This method has been introduced in version 0.25.
    """
    edge: Any
    r"""
    @brief Returns the edge object

    Starting with version 0.23, this method returns nil, if the shape does not represent an edge.@brief Replaces the shape by the given edge
    This method replaces the shape by the given edge. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    edge_pair: Any
    r"""
    @brief Returns the edge pair object

    This method has been introduced in version 0.26.@brief Replaces the shape by the given edge pair
    This method replaces the shape by the given edge pair. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.26.
    """
    layer: int
    r"""
    @brief Returns the layer index of the layer the shape is on
    Throws an exception if the shape does not reside inside a cell.

    This method has been added in version 0.23.
    @brief Moves the shape to a layer given by the layer index object

    This method has been added in version 0.23.
    """
    layer_info: LayerInfo
    r"""
    @brief Returns the \LayerInfo object of the layer the shape is on
    If the shape does not reside inside a cell, an empty layer is returned.

    This method has been added in version 0.23.
    @brief Moves the shape to a layer given by a \LayerInfo object
    If no layer with the given properties exists, an exception is thrown.

    This method has been added in version 0.23.
    """
    path: Any
    r"""
    @brief Returns the path object

    Starting with version 0.23, this method returns nil, if the shape does not represent a path.@brief Replaces the shape by the given path object
    This method replaces the shape by the given path object. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    path_bgnext: int
    r"""
    @brief Gets the path's starting vertex extension

    Applies to paths only. Will throw an exception if the object is not a path.
    @brief Sets the path's starting vertex extension
    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.23.
    """
    path_dbgnext: float
    r"""
    @brief Gets the path's starting vertex extension in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.@brief Sets the path's starting vertex extension in micrometer units
    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.
    """
    path_dendext: float
    r"""
    @brief Gets the path's end vertex extension in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.@brief Sets the path's end vertex extension in micrometer units
    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.
    """
    path_dwidth: float
    r"""
    @brief Gets the path width in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.@brief Sets the path width in micrometer units
    Applies to paths only. Will throw an exception if the object is not a path.
    Conversion to database units is done internally.

    This method has been introduced in version 0.25.
    """
    path_endext: int
    r"""
    @brief Obtain the path's end vertex extension

    Applies to paths only. Will throw an exception if the object is not a path.
    @brief Sets the path's end vertex extension
    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.23.
    """
    path_width: int
    r"""
    @brief Gets the path width

    Applies to paths only. Will throw an exception if the object is not a path.
    @brief Sets the path width
    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.23.
    """
    polygon: Any
    r"""
    @brief Returns the polygon object

    Returns the polygon object that this shape refers to or converts the object to a polygon. Paths, boxes and simple polygons are converted to polygons. For paths this operation renders the path's hull contour.

    Starting with version 0.23, this method returns nil, if the shape does not represent a geometrical primitive that can be converted to a polygon.
    @brief Replaces the shape by the given polygon object
    This method replaces the shape by the given polygon object. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    prop_id: int
    r"""
    @brief Gets the properties ID associated with the shape

    The \Layout object can be used to retrieve the actual properties associated with the ID.@brief Sets the properties ID of this shape

    The \Layout object can be used to retrieve an ID for a given set of properties. Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    round_path: bool
    r"""
    @brief Returns true, if the path has round ends

    Applies to paths only. Will throw an exception if the object is not a path.
    @brief The path will be a round-ended path if this property is set to true

    Applies to paths only. Will throw an exception if the object is not a path.
    Please note that the extensions will apply as well. To get a path with circular ends, set the begin and end extensions to half the path's width.

    This method has been introduced in version 0.23.
    """
    simple_polygon: Any
    r"""
    @brief Returns the simple polygon object

    Returns the simple polygon object that this shape refers to or converts the object to a simple polygon. Paths, boxes and polygons are converted to simple polygons. Polygons with holes will have their holes removed but introducing cut lines that connect the hole contours with the outer contour. 
    Starting with version 0.23, this method returns nil, if the shape does not represent a geometrical primitive that can be converted to a simple polygon.
    @brief Replaces the shape by the given simple polygon object
    This method replaces the shape by the given simple polygon object. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    text: Any
    r"""
    @brief Returns the text object

    Starting with version 0.23, this method returns nil, if the shape does not represent a text.@brief Replaces the shape by the given text object
    This method replaces the shape by the given text object. This method can only be called for editable layouts. It does not change the user properties of the shape.
    Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.
    """
    text_dpos: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'text_pos'.
    @brief Sets the text's position in micrometer units
    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been added in version 0.25.
    """
    text_dsize: float
    r"""
    @brief Gets the text size in micrometer units

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.25.@brief Sets the text size in micrometer units

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.25.
    """
    text_dtrans: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    Note: This is an alias of 'text_trans'.
    @brief Sets the text transformation in micrometer units
    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.25.
    """
    text_font: int
    r"""
    @brief Gets the text's font

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text's font

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.
    """
    text_halign: int
    r"""
    @brief Gets the text's horizontal alignment

    Applies to texts only. Will throw an exception if the object is not a text.
    The return value is 0 for left alignment, 1 for center alignment and 2 to right alignment.

    This method has been introduced in version 0.22.
    @brief Sets the text's horizontal alignment

    Applies to texts only. Will throw an exception if the object is not a text.
    See \text_halign for a description of that property.

    This method has been introduced in version 0.23.
    """
    text_pos: Vector
    r"""
    @brief Gets the text's position

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text's position
    Applies to texts only. Will throw an exception if the object is not a text.
    """
    text_rot: int
    r"""
    @brief Gets the text's orientation code (see \Trans)

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text's orientation code (see \Trans)

    Applies to texts only. Will throw an exception if the object is not a text.
    """
    text_size: int
    r"""
    @brief Gets the text size

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text size

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.
    """
    text_string: str
    r"""
    @brief Obtain the text string

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text string

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.
    """
    text_trans: Trans
    r"""
    @brief Gets the text transformation

    Applies to texts only. Will throw an exception if the object is not a text.
    @brief Sets the text transformation
    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.
    """
    text_valign: int
    r"""
    @brief Gets the text's vertical alignment

    Applies to texts only. Will throw an exception if the object is not a text.
    The return value is 0 for top alignment, 1 for center alignment and 2 to bottom alignment.

    This method has been introduced in version 0.22.
    @brief Sets the text's vertical alignment

    Applies to texts only. Will throw an exception if the object is not a text.
    See \text_valign for a description of that property.

    This method has been introduced in version 0.23.
    """
    def __copy__(self) -> Shape:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Equality operator

        Equality of shapes is not specified by the identity of the objects but by the
        identity of the pointers - both shapes must refer to the same object.
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Inequality operator
        """
    def __repr__(self) -> str:
        r"""
        @brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    def __str__(self) -> str:
        r"""
        @brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def area(self) -> int:
        r"""
        @brief Returns the area of the shape
        This method has been added in version 0.22.
        """
    def array_dtrans(self) -> DTrans:
        r"""
        @brief Gets the array instance member transformation in micrometer units

        This attribute is valid only if \is_array_member? is true.
        The transformation returned describes the relative transformation of the 
        array member addressed. The displacement is given in micrometer units.

        This method has been added in version 0.25.
        """
    def array_trans(self) -> Trans:
        r"""
        @brief Gets the array instance member transformation

        This attribute is valid only if \is_array_member? is true.
        The transformation returned describes the relative transformation of the 
        array member addressed.
        """
    def assign(self, other: Shape) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Returns the bounding box of the shape
        """
    def box_dcenter_(self) -> DPoint:
        r"""
        @brief Returns the center of the box as a \DPoint object in micrometer units

        Applies to boxes only. Returns the center of the box and throws an exception if the shape is not a box.
        Conversion from database units to micrometers is done internally.

        This method has been introduced in version 0.25.
        """
    def box_dp1_(self) -> DPoint:
        r"""
        @brief Returns the lower left point of the box as a \DPoint object in micrometer units

        Applies to boxes only. Returns the lower left point of the box and throws an exception if the shape is not a box.
        Conversion from database units to micrometers is done internally.

        This method has been introduced in version 0.25.
        """
    def box_dp2_(self) -> DPoint:
        r"""
        @brief Returns the upper right point of the box as a \DPoint object in micrometer units

        Applies to boxes only. Returns the upper right point of the box and throws an exception if the shape is not a box.
        Conversion from database units to micrometers is done internally.

        This method has been introduced in version 0.25.
        """
    def darea(self) -> float:
        r"""
        @brief Returns the area of the shape in square micrometer units
        This method has been added in version 0.25.
        """
    def dbbox(self) -> DBox:
        r"""
        @brief Returns the bounding box of the shape in micrometer units
        This method has been added in version 0.25.
        """
    def dbox_(self) -> Any:
        r"""
        @brief Gets the box object in micrometer units
        See \box for a description of this method. This method returns the box after translation to micrometer units.

        This method has been added in version 0.25.
        """
    def dedge_(self) -> Any:
        r"""
        @brief Returns the edge object as a \DEdge object in micrometer units
        See \edge for a description of this method. This method returns the edge after translation to micrometer units.

        This method has been added in version 0.25.
        """
    def dedge_pair_(self) -> Any:
        r"""
        @brief Returns the edge pair object as a \DEdgePair object in micrometer units
        See \edge_pair for a description of this method. This method returns the edge pair after translation to micrometer units.

        This method has been added in version 0.26.
        """
    def delete(self) -> None:
        r"""
        @brief Deletes the shape

        After the shape is deleted, the shape object is emptied and points to nothing.

        This method has been introduced in version 0.23.
        """
    def delete_property(self, key: Any) -> None:
        r"""
        @brief Deletes the user property with the given key
        This method is a convenience method that deletes the property with the given key. It does nothing if no property with that key exists. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

        This method has been introduced in version 0.22.
        """
    def dpath_(self) -> Any:
        r"""
        @brief Returns the path object as a \DPath object in micrometer units
        See \path for a description of this method. This method returns the path after translation to micrometer units.

        This method has been added in version 0.25.
        """
    def dperimeter(self) -> float:
        r"""
        @brief Returns the perimeter of the shape in micrometer units

        This method will return an approximation of the perimeter for paths.

        This method has been added in version 0.25.
        """
    def dpolygon_(self) -> Any:
        r"""
        @brief Returns the polygon object in micrometer units

        Returns the polygon object that this shape refers to or converts the object to a polygon. The method returns the same object than \polygon, but translates it to micrometer units internally.

        This method has been introduced in version 0.25.
        """
    def dsimple_polygon_(self) -> Any:
        r"""
        @brief Returns the simple polygon object in micrometer units

        Returns the simple polygon object that this shape refers to or converts the object to a simple polygon. The method returns the same object than \simple_polygon, but translates it to micrometer units internally.

        This method has been introduced in version 0.25.
        """
    def dtext_(self) -> Any:
        r"""
        @brief Returns the path object as a \DText object in micrometer units
        See \text for a description of this method. This method returns the text after translation to micrometer units.

        This method has been added in version 0.25.
        """
    def dup(self) -> Shape:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def each_dedge(self) -> Iterator[DEdge]:
        r"""
        @brief Iterates over the edges of the object and returns edges in micrometer units

        This method iterates over all edges of polygons and simple polygons like \each_edge, but will deliver edges in micrometer units. Multiplication by the database unit is done internally.

        This method has been introduced in version 0.25.
        """
    @overload
    def each_dedge(self, contour: int) -> Iterator[DEdge]:
        r"""
        @brief Iterates over the edges of a single contour of the object and returns edges in micrometer units

        This method iterates over all edges of polygons and simple polygons like \each_edge, but will deliver edges in micrometer units. Multiplication by the database unit is done internally.

        This method has been introduced in version 0.25.
        """
    def each_dpoint(self) -> Iterator[DPoint]:
        r"""
        @brief Iterates over all points of the object and returns points in micrometer units

        This method iterates over all points of the object like \each_point, but it returns \DPoint objects that are given in micrometer units already. Multiplication with the database unit happens internally.

        This method has been introduced in version 0.25.
        """
    def each_dpoint_hole(self, hole_index: int) -> Iterator[DPoint]:
        r"""
        @brief Iterates over a hole contour of the object and returns points in micrometer units

        This method iterates over all points of the object's contour' like \each_point_hole, but it returns \DPoint objects that are given in micrometer units already. Multiplication with the database unit happens internally.

        This method has been introduced in version 0.25.
        """
    def each_dpoint_hull(self) -> Iterator[DPoint]:
        r"""
        @brief Iterates over the hull contour of the object and returns points in micrometer units

        This method iterates over all points of the object's contour' like \each_point_hull, but it returns \DPoint objects that are given in micrometer units already. Multiplication with the database unit happens internally.

        This method has been introduced in version 0.25.
        """
    @overload
    def each_edge(self) -> Iterator[Edge]:
        r"""
        @brief Iterates over the edges of the object

        This method applies to polygons and simple polygons and delivers all edges that form the polygon's contours. Hole edges are oriented counterclockwise while hull edges are oriented clockwise.

        It will throw an exception if the object is not a polygon.
        """
    @overload
    def each_edge(self, contour: int) -> Iterator[Edge]:
        r"""
        @brief Iterates over the edges of a single contour of the object
        @param contour The contour number (0 for hull, 1 for first hole ...)

        This method applies to polygons and simple polygons and delivers all edges that form the given contour of the polygon. The hull has contour number 0, the first hole has contour 1 etc.
        Hole edges are oriented counterclockwise while hull edges are oriented clockwise.

        It will throw an exception if the object is not a polygon.

        This method was introduced in version 0.24.
        """
    def each_point(self) -> Iterator[Point]:
        r"""
        @brief Iterates over all points of the object

        This method applies to paths and delivers all points of the path's center line.
        It will throw an exception for other objects.
        """
    def each_point_hole(self, hole_index: int) -> Iterator[Point]:
        r"""
        @brief Iterates over the points of a hole contour

        This method applies to polygons and delivers all points of the respective hole contour.
        It will throw an exception for other objects.
        Simple polygons deliver an empty sequence.

        @param hole The hole index (see holes () method)
        """
    def each_point_hull(self) -> Iterator[Point]:
        r"""
        @brief Iterates over the hull contour of the object

        This method applies to polygons and delivers all points of the polygon hull contour.
        It will throw an exception for other objects.
        """
    def has_prop_id(self) -> bool:
        r"""
        @brief Returns true, if the shape has properties, i.e. has a properties ID
        """
    def holes(self) -> int:
        r"""
        @brief Returns the number of holes

        This method applies to polygons and will throw an exception for other objects..
        Simple polygons deliver a value of zero.
        """
    def is_array_member(self) -> bool:
        r"""
        @brief Returns true, if the shape is a member of a shape array
        """
    def is_box(self) -> bool:
        r"""
        @brief Returns true if the shape is a box
        """
    def is_edge(self) -> bool:
        r"""
        @brief Returns true, if the object is an edge
        """
    def is_edge_pair(self) -> bool:
        r"""
        @brief Returns true, if the object is an edge pair

        This method has been introduced in version 0.26.
        """
    def is_null(self) -> bool:
        r"""
        @brief Returns true, if the shape reference is a null reference (not referring to a shape)
        """
    def is_path(self) -> bool:
        r"""
        @brief Returns true, if the shape is a path
        """
    def is_polygon(self) -> bool:
        r"""
        @brief Returns true, if the shape is a polygon

        This method returns true only if the object is a polygon or a simple polygon. Other objects can convert to polygons, for example paths, so it may be possible to use the \polygon method also if is_polygon? does not return true.
        """
    def is_simple_polygon(self) -> bool:
        r"""
        @brief Returns true, if the shape is a simple polygon

        This method returns true only if the object is a simple polygon. The simple polygon identity is contained in the polygon identity, so usually it is sufficient to use \is_polygon? and \polygon instead of specifically handle simply polygons. This method is provided only for specific optimisation purposes.
        """
    def is_text(self) -> bool:
        r"""
        @brief Returns true, if the object is a text
        """
    def is_user_object(self) -> bool:
        r"""
        @brief Returns true if the shape is a user defined object
        """
    def is_valid(self) -> bool:
        r"""
        @brief Returns true, if the shape is valid

        After the shape is deleted, the shape object is no longer valid and this method returns false.

        This method has been introduced in version 0.23.
        """
    def layout(self) -> Layout:
        r"""
        @brief Gets a reference to the Layout the shape belongs to

        This reference can be nil, if the Shape object is not living inside a layout.

        This method has been introduced in version 0.22.
        """
    def path_dlength(self) -> float:
        r"""
        @brief Returns the length of the path in micrometer units

        Applies to paths only. Will throw an exception if the object is not a path.
        This method returns the length of the spine plus extensions if present.
        The value returned is given in micrometer units.

        This method has been added in version 0.25.
        """
    def path_length(self) -> int:
        r"""
        @brief Returns the length of the path

        Applies to paths only. Will throw an exception if the object is not a path.
        This method returns the length of the spine plus extensions if present.

        This method has been added in version 0.23.
        """
    def perimeter(self) -> int:
        r"""
        @brief Returns the perimeter of the shape

        This method will return an approximation of the perimeter for paths.

        This method has been added in version 0.23.
        """
    def property(self, key: Any) -> Any:
        r"""
        @brief Gets the user property with the given key
        This method is a convenience method that gets the property with the given key. If no property with that key does not exist, it will return nil. Using that method is more convenient than using the layout object and the properties ID to retrieve the property value. 
        This method has been introduced in version 0.22.
        """
    def set_property(self, key: Any, value: Any) -> None:
        r"""
        @brief Sets the user property with the given key to the given value
        This method is a convenience method that sets the property with the given key to the given value. If no property with that key exists, it will create one. Using that method is more convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Note: GDS only supports integer keys. OASIS supports numeric and string keys. Calling this method will invalidate any iterators. It should not be called inside a loop iterating over shapes.

        This method has been introduced in version 0.22.
        """
    def shapes(self) -> Shapes:
        r"""
        @brief Gets a reference to the Shapes container the shape lives in

        This reference can be nil, if the Shape object is not referring to an actual shape.

        This method has been introduced in version 0.22.
        """
    def text_dpos_(self) -> DVector:
        r"""
        @brief Gets the text's position in micrometer units

        Applies to texts only. Will throw an exception if the object is not a text.

        This method has been added in version 0.25.
        """
    def text_dtrans_(self) -> DTrans:
        r"""
        @brief Gets the text transformation in micrometer units

        Applies to texts only. Will throw an exception if the object is not a text.

        This method has been added in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.
        """
    @overload
    def transform(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms the shape with the given complex transformation, given in micrometer units
        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, trans: DTrans) -> None:
        r"""
        @brief Transforms the shape with the given transformation, given in micrometer units
        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms the shape with the given complex transformation
        This method has been introduced in version 0.23.
        """
    @overload
    def transform(self, trans: Trans) -> None:
        r"""
        @brief Transforms the shape with the given transformation
        This method has been introduced in version 0.23.
        """
    def type(self) -> int:
        r"""
        @brief Return the type of the shape

        The returned values are the t_... constants available through the corresponding class members.
        """

class ShapeCollection:
    r"""
    @brief A base class for the shape collections (\Region, \Edges, \EdgePairs and \Texts)

    This class has been introduced in version 0.27.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """

class ShapeProcessor:
    r"""
    @brief The shape processor (boolean, sizing, merge on shapes)

    The shape processor implements the boolean and edge set operations (size, merge). Because the shape processor might allocate resources which can be reused in later operations, it is implemented as an object that can be used several times. The shape processor is similar to the \EdgeProcessor. The latter is specialized on handling polygons and edges directly. 
    """
    def __copy__(self) -> ShapeProcessor:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ShapeProcessor) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def boolean(self, in_a: Sequence[Shape], in_b: Sequence[Shape], mode: int) -> List[Edge]:
        r"""
        @brief Boolean operation on two given shape sets into an edge set

        See the \EdgeProcessor for a description of the boolean operations. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in_a The set of shapes to use for input A
        @param in_b The set of shapes to use for input A
        @param mode The boolean operation (see \EdgeProcessor)
        """
    @overload
    def boolean(self, in_a: Sequence[Shape], trans_a: Sequence[CplxTrans], in_b: Sequence[Shape], trans_b: Sequence[CplxTrans], mode: int) -> List[Edge]:
        r"""
        @brief Boolean operation on two given shape sets into an edge set

        See the \EdgeProcessor for a description of the boolean operations. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        @param in_a The set of shapes to use for input A
        @param trans_a A set of transformations to apply before the shapes are used
        @param in_b The set of shapes to use for input A
        @param trans_b A set of transformations to apply before the shapes are used
        @param mode The boolean operation (see \EdgeProcessor)
        """
    @overload
    def boolean(self, layout_a: Layout, cell_a: Cell, layer_a: int, layout_b: Layout, cell_b: Cell, layer_b: int, out: Shapes, mode: int, hierarchical: bool, resolve_holes: bool, min_coherence: bool) -> None:
        r"""
        @brief Boolean operation on shapes from layouts

        See the \EdgeProcessor for a description of the boolean operations. This implementation takes shapes
        from layout cells (optionally all in hierarchy) and produces new shapes in a shapes container. 
        @param layout_a The layout from which to take the shapes for input A
        @param cell_a The cell (in 'layout') from which to take the shapes for input A
        @param layer_a The cell (in 'layout') from which to take the shapes for input A
        @param layout_b The layout from which to take the shapes for input B
        @param cell_b The cell (in 'layout') from which to take the shapes for input B
        @param layer_b The cell (in 'layout') from which to take the shapes for input B
        @param out The shapes container where to put the shapes into (is cleared before)
        @param mode The boolean operation (see \EdgeProcessor)
        @param hierarchical Collect shapes from sub cells as well
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def boolean_to_polygon(self, in_a: Sequence[Shape], in_b: Sequence[Shape], mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Boolean operation on two given shape sets into a polygon set

        See the \EdgeProcessor for a description of the boolean operations. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in_a The set of shapes to use for input A
        @param in_b The set of shapes to use for input A
        @param mode The boolean operation (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def boolean_to_polygon(self, in_a: Sequence[Shape], trans_a: Sequence[CplxTrans], in_b: Sequence[Shape], trans_b: Sequence[CplxTrans], mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Boolean operation on two given shape sets into a polygon set

        See the \EdgeProcessor for a description of the boolean operations. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        @param in_a The set of shapes to use for input A
        @param trans_a A set of transformations to apply before the shapes are used
        @param in_b The set of shapes to use for input A
        @param trans_b A set of transformations to apply before the shapes are used
        @param mode The boolean operation (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    def dup(self) -> ShapeProcessor:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def merge(self, in_: Sequence[Shape], min_wc: int) -> List[Edge]:
        r"""
        @brief Merge the given shapes

        See the \EdgeProcessor for a description of the merge method. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to merge
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        """
    @overload
    def merge(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], min_wc: int) -> List[Edge]:
        r"""
        @brief Merge the given shapes

        See the \EdgeProcessor for a description of the merge method. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        @param in The set of shapes to merge
        @param trans A corresponding set of transformations to apply on the shapes
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        """
    @overload
    def merge(self, layout: Layout, cell: Cell, layer: int, out: Shapes, hierarchical: bool, min_wc: int, resolve_holes: bool, min_coherence: bool) -> None:
        r"""
        @brief Merge the given shapes from a layout into a shapes container

        See the \EdgeProcessor for a description of the merge method. This implementation takes shapes
        from a layout cell (optionally all in hierarchy) and produces new shapes in a shapes container. 
        @param layout The layout from which to take the shapes
        @param cell The cell (in 'layout') from which to take the shapes
        @param layer The cell (in 'layout') from which to take the shapes
        @param out The shapes container where to put the shapes into (is cleared before)
        @param hierarchical Collect shapes from sub cells as well
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def merge_to_polygon(self, in_: Sequence[Shape], min_wc: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Merge the given shapes

        See the \EdgeProcessor for a description of the merge method. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to merge
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def merge_to_polygon(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], min_wc: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Merge the given shapes

        See the \EdgeProcessor for a description of the merge method. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        @param in The set of shapes to merge
        @param trans A corresponding set of transformations to apply on the shapes
        @param min_wc The minimum wrap count for output (0: all polygons, 1: at least two overlapping)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size(self, in_: Sequence[Shape], d: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces an edge set. This is isotropic version that does not allow
        to specify different values in x and y direction. 
        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to size
        @param d The sizing value
        @param mode The sizing mode (see \EdgeProcessor)
        """
    @overload
    def size(self, in_: Sequence[Shape], dx: int, dy: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to size
        @param dx The sizing value in x-direction
        @param dy The sizing value in y-direction
        @param mode The sizing mode (see \EdgeProcessor)
        """
    @overload
    def size(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], d: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces an edge set. This is isotropic version that does not allow
        to specify different values in x and y direction. 
        @param in The set of shapes to size
        @param trans A corresponding set of transformations to apply on the shapes
        @param d The sizing value
        @param mode The sizing mode (see \EdgeProcessor)
        """
    @overload
    def size(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], dx: int, dy: int, mode: int) -> List[Edge]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces an edge set.

        @param in The set of shapes to size
        @param trans A corresponding set of transformations to apply on the shapes
        @param dx The sizing value in x-direction
        @param dy The sizing value in y-direction
        @param mode The sizing mode (see \EdgeProcessor)
        """
    @overload
    def size(self, layout: Layout, cell: Cell, layer: int, out: Shapes, d: int, mode: int, hierarchical: bool, resolve_holes: bool, min_coherence: bool) -> None:
        r"""
        @brief Sizing operation on shapes from layouts

        See the \EdgeProcessor for a description of the sizing operation. This implementation takes shapes
        from a layout cell (optionally all in hierarchy) and produces new shapes in a shapes container. This is the isotropic version which does not allow specification of different sizing values in x and y-direction. 
        @param layout The layout from which to take the shapes
        @param cell The cell (in 'layout') from which to take the shapes
        @param layer The cell (in 'layout') from which to take the shapes
        @param out The shapes container where to put the shapes into (is cleared before)
        @param d The sizing value (see \EdgeProcessor)
        @param mode The sizing mode (see \EdgeProcessor)
        @param hierarchical Collect shapes from sub cells as well
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size(self, layout: Layout, cell: Cell, layer: int, out: Shapes, dx: int, dy: int, mode: int, hierarchical: bool, resolve_holes: bool, min_coherence: bool) -> None:
        r"""
        @brief Sizing operation on shapes from layouts

        See the \EdgeProcessor for a description of the sizing operation. This implementation takes shapes
        from a layout cell (optionally all in hierarchy) and produces new shapes in a shapes container. 
        @param layout The layout from which to take the shapes
        @param cell The cell (in 'layout') from which to take the shapes
        @param layer The cell (in 'layout') from which to take the shapes
        @param out The shapes container where to put the shapes into (is cleared before)
        @param dx The sizing value in x-direction (see \EdgeProcessor)
        @param dy The sizing value in y-direction (see \EdgeProcessor)
        @param mode The sizing mode (see \EdgeProcessor)
        @param hierarchical Collect shapes from sub cells as well
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size_to_polygon(self, in_: Sequence[Shape], d: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces a polygon set. This is isotropic version that does not allow
        to specify different values in x and y direction. 
        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to size
        @param d The sizing value
        @param mode The sizing mode (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size_to_polygon(self, in_: Sequence[Shape], dx: int, dy: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        This version does not feature a transformation for each shape (unity is assumed).

        @param in The set of shapes to size
        @param dx The sizing value in x-direction
        @param dy The sizing value in y-direction
        @param mode The sizing mode (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size_to_polygon(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], d: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces a polygon set. This is isotropic version that does not allow
        to specify different values in x and y direction. 
        @param in The set of shapes to size
        @param trans A corresponding set of transformations to apply on the shapes
        @param d The sizing value
        @param mode The sizing mode (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """
    @overload
    def size_to_polygon(self, in_: Sequence[Shape], trans: Sequence[CplxTrans], dx: int, dy: int, mode: int, resolve_holes: bool, min_coherence: bool) -> List[Polygon]:
        r"""
        @brief Size the given shapes

        See the \EdgeProcessor for a description of the sizing method. This implementation takes shapes
        rather than polygons for input and produces a polygon set.

        @param in The set of shapes to size
        @param trans A corresponding set of transformations to apply on the shapes
        @param dx The sizing value in x-direction
        @param dy The sizing value in y-direction
        @param mode The sizing mode (see \EdgeProcessor)
        @param resolve_holes true, if holes should be resolved into the hull
        @param min_coherence true, if minimum polygons should be created for touching corners
        """

class Shapes:
    r"""
    @brief A collection of shapes

    A shapes collection is a collection of geometrical objects, such as polygons, boxes, paths, edges, edge pairs or text objects.

    Shapes objects are the basic containers for geometrical objects of a cell. Inside a cell, there is one Shapes object per layer.
    """
    SAll: ClassVar[int]
    r"""
    @brief Indicates that all shapes shall be retrieved
    """
    SAllWithProperties: ClassVar[int]
    r"""
    @brief Indicates that all shapes with properties shall be retrieved
    """
    SBoxes: ClassVar[int]
    r"""
    @brief Indicates that boxes shall be retrieved
    """
    SEdgePairs: ClassVar[int]
    r"""
    @brief Indicates that edge pairs shall be retrieved
    """
    SEdges: ClassVar[int]
    r"""
    @brief Indicates that edges shall be retrieved
    """
    SPaths: ClassVar[int]
    r"""
    @brief Indicates that paths shall be retrieved
    """
    SPolygons: ClassVar[int]
    r"""
    @brief Indicates that polygons shall be retrieved
    """
    SProperties: ClassVar[int]
    r"""
    @brief Indicates that only shapes with properties shall be retrieved
    """
    SRegions: ClassVar[int]
    r"""
    @brief Indicates that objects which can be polygonized shall be retrieved (paths, boxes, polygons etc.)

    This constant has been added in version 0.27.
    """
    STexts: ClassVar[int]
    r"""
    @brief Indicates that texts be retrieved
    """
    SUserObjects: ClassVar[int]
    r"""
    @brief Indicates that user objects shall be retrieved
    """
    def __copy__(self) -> Shapes:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def __iter__(self) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes

        This call is equivalent to each(SAll). This convenience method has been introduced in version 0.16
        """
    def __len__(self) -> int:
        r"""
        @brief Gets the number of shapes in this container
        This method was introduced in version 0.16
        @return The number of shapes in this container
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Shapes) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear(self) -> None:
        r"""
        @brief Clears the shape container
        This method has been introduced in version 0.16. It can only be used in editable mode.
        """
    def dump_mem_statistics(self, detailed: Optional[bool] = ...) -> None:
        r"""
        @hide
        """
    def dup(self) -> Shapes:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def each(self) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes

        This call is equivalent to each(SAll). This convenience method has been introduced in version 0.16
        """
    @overload
    def each(self, flags: int) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes

        @param flags An "or"-ed combination of the S... constants
        """
    @overload
    def each_overlapping(self, region: Box) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that overlap the search box (region)
        @param region The rectangular search region

        This call is equivalent to each_overlapping(SAll,region). This convenience method has been introduced in version 0.16
        """
    @overload
    def each_overlapping(self, region: DBox) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that overlap the search box (region) where the search box is given in micrometer units
        @param region The rectangular search region as a \DBox object in micrometer units
        This call is equivalent to each_touching(SAll,region).

        This method was introduced in version 0.25
        """
    @overload
    def each_overlapping(self, flags: int, region: Box) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that overlap the search box (region)
        This method was introduced in version 0.16

        @param flags An "or"-ed combination of the S... constants
        @param region The rectangular search region
        """
    @overload
    def each_overlapping(self, flags: int, region: DBox) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that overlap the search box (region) where the search box is given in micrometer units
        @param flags An "or"-ed combination of the S... constants
        @param region The rectangular search region as a \DBox object in micrometer units

        This method was introduced in version 0.25
        """
    @overload
    def each_touching(self, region: Box) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that touch the search box (region)
        @param region The rectangular search region

        This call is equivalent to each_touching(SAll,region). This convenience method has been introduced in version 0.16
        """
    @overload
    def each_touching(self, region: DBox) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that touch the search box (region) where the search box is given in micrometer units
        @param region The rectangular search region as a \DBox object in micrometer units
        This call is equivalent to each_touching(SAll,region).

        This method was introduced in version 0.25
        """
    @overload
    def each_touching(self, flags: int, region: Box) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that touch the search box (region)
        This method was introduced in version 0.16

        @param flags An "or"-ed combination of the S... constants
        @param region The rectangular search region
        """
    @overload
    def each_touching(self, flags: int, region: DBox) -> Iterator[Shape]:
        r"""
        @brief Gets all shapes that touch the search box (region) where the search box is given in micrometer units
        @param flags An "or"-ed combination of the S... constants
        @param region The rectangular search region as a \DBox object in micrometer units

        This method was introduced in version 0.25
        """
    def erase(self, shape: Shape) -> None:
        r"""
        @brief Erases the shape pointed to by the given \Shape object
        This method has been introduced in version 0.16. It can only be used in editable mode.
        Erasing a shape will invalidate the shape reference. Access to this reference may then render invalid results.

        @param shape The shape which to destroy
        """
    def find(self, shape: Shape) -> Shape:
        r"""
        @brief Finds a shape inside this collected
        This method has been introduced in version 0.21.
        This method tries to find the given shape in this collection. The original shape may be located in another collection. If the shape is found, this method returns a reference to the shape in this collection, otherwise a null reference is returned.
        """
    @overload
    def insert(self, box: Box) -> Shape:
        r"""
        @brief Inserts a box into the shapes list
        @return A reference to the new shape (a \Shape object)

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, box: DBox) -> Shape:
        r"""
        @brief Inserts a micrometer-unit box into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Box argument, except that it will internally translate the box from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, edge: DEdge) -> Shape:
        r"""
        @brief Inserts a micrometer-unit edge into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Edge argument, except that it will internally translate the edge from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, edge: Edge) -> Shape:
        r"""
        @brief Inserts an edge into the shapes list

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, edge_pair: DEdgePair) -> Shape:
        r"""
        @brief Inserts a micrometer-unit edge pair into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \EdgePair argument, except that it will internally translate the edge pair from micrometer to database units.

        This variant has been introduced in version 0.26.
        """
    @overload
    def insert(self, edge_pair: EdgePair) -> Shape:
        r"""
        @brief Inserts an edge pair into the shapes list

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Inserts the edges from the edge pair collection into this shape container
        @param edges The edge pairs to insert

        This method inserts all edge pairs from the edge pair collection into this shape container.

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, edges: Edges) -> None:
        r"""
        @brief Inserts the edges from the edge collection into this shape container
        @param edges The edges to insert

        This method inserts all edges from the edge collection into this shape container.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert(self, iter: RecursiveShapeIterator) -> None:
        r"""
        @brief Inserts the shapes taken from a recursive shape iterator
        @param iter The iterator from which to take the shapes from

        This method iterates over all shapes from the iterator and inserts them into the container.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert(self, path: DPath) -> Shape:
        r"""
        @brief Inserts a micrometer-unit path into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Path argument, except that it will internally translate the path from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, path: Path) -> Shape:
        r"""
        @brief Inserts a path into the shapes list
        @return A reference to the new shape (a \Shape object)

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, polygon: DPolygon) -> Shape:
        r"""
        @brief Inserts a micrometer-unit polygon into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Polygon argument, except that it will internally translate the polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, polygon: Polygon) -> Shape:
        r"""
        @brief Inserts a polygon into the shapes list
        @return A reference to the new shape (a \Shape object)

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, region: Region) -> None:
        r"""
        @brief Inserts the polygons from the region into this shape container
        @param region The region to insert

        This method inserts all polygons from the region into this shape container.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert(self, shape: Shape) -> Shape:
        r"""
        @brief Inserts a shape from a shape reference into the shapes list
        @return A reference (a \Shape object) to the newly created shape
        This method has been introduced in version 0.16.
        """
    @overload
    def insert(self, shapes: Shapes) -> None:
        r"""
        @brief Inserts the shapes taken from another shape container
        @param shapes The other container from which to take the shapes from

        This method takes all shapes from the given container and inserts them into this one.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert(self, simple_polygon: DSimplePolygon) -> Shape:
        r"""
        @brief Inserts a micrometer-unit simple polygon into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \SimplePolygon argument, except that it will internally translate the polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, simple_polygon: SimplePolygon) -> Shape:
        r"""
        @brief Inserts a simple polygon into the shapes list
        @return A reference to the new shape (a \Shape object)

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, text: DText) -> Shape:
        r"""
        @brief Inserts a micrometer-unit text into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Text argument, except that it will internally translate the text from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, text: Text) -> Shape:
        r"""
        @brief Inserts a text into the shapes list
        @return A reference to the new shape (a \Shape object)

        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, texts: Texts) -> None:
        r"""
        @brief Inserts the texts from the text collection into this shape container
        @param texts The texts to insert

        This method inserts all texts from the text collection into this shape container.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, box: Box, property_id: int) -> Shape:
        r"""
        @brief Inserts a box with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, box: DBox, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit box with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Box argument and a property ID, except that it will internally translate the box from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, edge: DEdge, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit edge with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Edge argument and a property ID, except that it will internally translate the edge from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, edge: Edge, property_id: int) -> Shape:
        r"""
        @brief Inserts an edge with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape.
        """
    @overload
    def insert(self, edge_pair: DEdgePair, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit edge pair with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \EdgePair argument and a property ID, except that it will internally translate the edge pair from micrometer to database units.

        This variant has been introduced in version 0.26.
        """
    @overload
    def insert(self, edge_pair: EdgePair, property_id: int) -> Shape:
        r"""
        @brief Inserts an edge pair with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, edge_pairs: EdgePairs, trans: DCplxTrans) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection into this shape container with a transformation (given in micrometer units)
        @param edges The edge pairs to insert
        @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Before an edge pair is inserted, the given transformation is applied.

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, edge_pairs: EdgePairs, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection into this shape container with a transformation
        @param edges The edge pairs to insert
        @param trans The transformation to apply

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Before an edge pair is inserted, the given transformation is applied.

        This method has been introduced in version 0.26.
        """
    @overload
    def insert(self, edges: Edges, trans: DCplxTrans) -> None:
        r"""
        @brief Inserts the edges from the edge collection into this shape container with a transformation (given in micrometer units)
        @param edges The edges to insert
        @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all edges from the edge collection into this shape container.
        Before an edge is inserted, the given transformation is applied.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, edges: Edges, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the edges from the edge collection into this shape container with a transformation
        @param edges The edges to insert
        @param trans The transformation to apply

        This method inserts all edges from the edge collection into this shape container.
        Before an edge is inserted, the given transformation is applied.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert(self, iter: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the shapes taken from a recursive shape iterator with a transformation
        @param iter The iterator from which to take the shapes from
        @param trans The transformation to apply

        This method iterates over all shapes from the iterator and inserts them into the container.
        The given transformation is applied before the shapes are inserted.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert(self, path: DPath, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit path with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Path argument and a property ID, except that it will internally translate the path from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, path: Path, property_id: int) -> Shape:
        r"""
        @brief Inserts a path with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, polygon: DPolygon, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit polygon with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Polygon argument and a property ID, except that it will internally translate the polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, polygon: Polygon, property_id: int) -> Shape:
        r"""
        @brief Inserts a polygon with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, region: Region, trans: DCplxTrans) -> None:
        r"""
        @brief Inserts the polygons from the region into this shape container with a transformation (given in micrometer units)
        @param region The region to insert
        @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all polygons from the region into this shape container.
        Before a polygon is inserted, the given transformation is applied.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, region: Region, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the polygons from the region into this shape container with a transformation
        @param region The region to insert
        @param trans The transformation to apply

        This method inserts all polygons from the region into this shape container.
        Before a polygon is inserted, the given transformation is applied.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert(self, shape: Shape, trans: DCplxTrans) -> Shape:
        r"""
        @brief Inserts a shape from a shape reference into the shapes list with a complex integer transformation (given in micrometer units)
        @param shape The shape to insert
        @param trans The transformation to apply before the shape is inserted (displacement in micrometer units)
        @return A reference (a \Shape object) to the newly created shape
        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape: Shape, trans: DTrans) -> Shape:
        r"""
        @brief Inserts a shape from a shape reference into the shapes list with a transformation (given in micrometer units)
        @param shape The shape to insert
        @param trans The transformation to apply before the shape is inserted (displacement in micrometers)
        @return A reference (a \Shape object) to the newly created shape
        This method has been introduced in version 0.25.
        """
    @overload
    def insert(self, shape: Shape, trans: ICplxTrans) -> Shape:
        r"""
        @brief Inserts a shape from a shape reference into the shapes list with a complex integer transformation
        @param shape The shape to insert
        @param trans The transformation to apply before the shape is inserted
        @return A reference (a \Shape object) to the newly created shape
        This method has been introduced in version 0.22.
        """
    @overload
    def insert(self, shape: Shape, trans: Trans) -> Shape:
        r"""
        @brief Inserts a shape from a shape reference into the shapes list with a transformation
        @param shape The shape to insert
        @param trans The transformation to apply before the shape is inserted
        @return A reference (a \Shape object) to the newly created shape
        This method has been introduced in version 0.22.
        """
    @overload
    def insert(self, shapes: Shapes, flags: int) -> None:
        r"""
        @brief Inserts the shapes taken from another shape container
        @param shapes The other container from which to take the shapes from
        @param flags The filter flags for taking the shapes from the input container (see S... constants)

        This method takes all selected shapes from the given container and inserts them into this one.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert(self, shapes: Shapes, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the shapes taken from another shape container with a transformation
        @param shapes The other container from which to take the shapes from
        @param trans The transformation to apply

        This method takes all shapes from the given container and inserts them into this one after applying the given transformation.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert(self, simple_polygon: DSimplePolygon, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit simple polygon with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \SimplePolygon argument and a property ID, except that it will internally translate the simple polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, simple_polygon: SimplePolygon, property_id: int) -> Shape:
        r"""
        @brief Inserts a simple polygon with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, text: DText, property_id: int) -> Shape:
        r"""
        @brief Inserts a micrometer-unit text with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        This method behaves like the \insert version with a \Text argument and a property ID, except that it will internally translate the text from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def insert(self, text: Text, property_id: int) -> Shape:
        r"""
        @brief Inserts a text with properties into the shapes list
        @return A reference to the new shape (a \Shape object)
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape
        """
    @overload
    def insert(self, texts: Texts, trans: DCplxTrans) -> None:
        r"""
        @brief Inserts the texts from the text collection into this shape container with a transformation (given in micrometer units)
        @param edges The text to insert
        @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all texts from the text collection into this shape container.
        Before an text is inserted, the given transformation is applied.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, texts: Texts, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the texts from the text collection into this shape container with a transformation
        @param edges The texts to insert
        @param trans The transformation to apply

        This method inserts all texts from the text collection into this shape container.
        Before an text is inserted, the given transformation is applied.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, shapes: Shapes, flags: int, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the shapes taken from another shape container with a transformation
        @param shapes The other container from which to take the shapes from
        @param flags The filter flags for taking the shapes from the input container (see S... constants)
        @param trans The transformation to apply

        This method takes all selected shapes from the given container and inserts them into this one after applying the given transformation.

        This method has been introduced in version 0.25.3.
        """
    @overload
    def insert_as_edges(self, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as individual edges into this shape container
        @param edge_pairs The edge pairs to insert

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Each edge from the edge pair is inserted individually into the shape container.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert_as_edges(self, edge_pairs: EdgePairs, trans: DCplxTrans) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as individual into this shape container with a transformation (given in micrometer units)
        @param edges The edge pairs to insert
        @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Each edge from the edge pair is inserted individually into the shape container.
        Before each edge is inserted into the shape collection, the given transformation is applied.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert_as_edges(self, edge_pairs: EdgePairs, trans: ICplxTrans) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as individual into this shape container with a transformation
        @param edges The edge pairs to insert
        @param trans The transformation to apply

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Each edge from the edge pair is inserted individually into the shape container.
        Before each edge is inserted into the shape collection, the given transformation is applied.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert_as_polygons(self, edge_pairs: EdgePairs, e: int) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as polygons into this shape container
        @param edge_pairs The edge pairs to insert
        @param e The extension to apply when converting the edges to polygons (in database units)

        This method inserts all edge pairs from the edge pair collection into this shape container.
        The edge pairs are converted to polygons covering the area between the edges.
        The extension parameter specifies a sizing which is applied when converting the edge pairs to polygons. This way, degenerated edge pairs (i.e. two point-like edges) do not vanish.

        This method has been introduced in version 0.23.
        """
    @overload
    def insert_as_polygons(self, edge_pairs: EdgePairs, e: float) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as polygons into this shape container
        @param edge_pairs The edge pairs to insert
        @param e The extension to apply when converting the edges to polygons (in micrometer units)

        This method is identical to the version with a integer-type \e parameter, but for this version the \e parameter is given in micrometer units.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert_as_polygons(self, edge_pairs: EdgePairs, e: DCplxTrans, trans: float) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as polygons into this shape container with a transformation
        @param edges The edge pairs to insert
        @param e The extension to apply when converting the edges to polygons (in micrometer units)
        @param trans The transformation to apply (displacement in micrometer units)

        This method is identical to the version with a integer-type \e and \trans parameter, but for this version the \e parameter is given in micrometer units and the \trans parameter is a micrometer-unit transformation.

        This method has been introduced in version 0.25.
        """
    @overload
    def insert_as_polygons(self, edge_pairs: EdgePairs, e: ICplxTrans, trans: int) -> None:
        r"""
        @brief Inserts the edge pairs from the edge pair collection as polygons into this shape container with a transformation
        @param edges The edge pairs to insert
        @param e The extension to apply when converting the edges to polygons (in database units)
        @param trans The transformation to apply

        This method inserts all edge pairs from the edge pair collection into this shape container.
        The edge pairs are converted to polygons covering the area between the edges.
        The extension parameter specifies a sizing which is applied when converting the edge pairs to polygons. This way, degenerated edge pairs (i.e. two point-like edges) do not vanish.
        Before a polygon is inserted into the shape collection, the given transformation is applied.

        This method has been introduced in version 0.23.
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns a value indicating whether the shapes container is empty
        This method has been introduced in version 0.20.
        """
    def is_valid(self, shape: Shape) -> bool:
        r"""
        @brief Tests if the given \Shape object is still pointing to a valid object
        This method has been introduced in version 0.16.
        If the shape represented by the given reference has been deleted, this method returns false. If however, another shape has been inserted already that occupies the original shape's position, this method will return true again.
        """
    @overload
    def replace(self, shape: Shape, box: Box) -> Shape:
        r"""
        @brief Replaces the given shape with a box
        @return A reference to the new shape (a \Shape object)

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    @overload
    def replace(self, shape: Shape, box: DBox) -> Shape:
        r"""
        @brief Replaces the given shape with a box given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with a \Box argument, except that it will internally translate the box from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, edge: DEdge) -> Shape:
        r"""
        @brief Replaces the given shape with an edge given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with an \Edge argument, except that it will internally translate the edge from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, edge: Edge) -> Shape:
        r"""
        @brief Replaces the given shape with an edge object

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    @overload
    def replace(self, shape: Shape, edge_pair: DEdgePair) -> Shape:
        r"""
        @brief Replaces the given shape with an edge pair given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with an \EdgePair argument, except that it will internally translate the edge pair from micrometer to database units.

        This variant has been introduced in version 0.26.
        """
    @overload
    def replace(self, shape: Shape, edge_pair: EdgePair) -> Shape:
        r"""
        @brief Replaces the given shape with an edge pair object

        It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.

        This method has been introduced in version 0.26.
        """
    @overload
    def replace(self, shape: Shape, path: DPath) -> Shape:
        r"""
        @brief Replaces the given shape with a path given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with a \Path argument, except that it will internally translate the path from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, path: Path) -> Shape:
        r"""
        @brief Replaces the given shape with a path
        @return A reference to the new shape (a \Shape object)

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    @overload
    def replace(self, shape: Shape, polygon: DPolygon) -> Shape:
        r"""
        @brief Replaces the given shape with a polygon given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with a \Polygon argument, except that it will internally translate the polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, polygon: Polygon) -> Shape:
        r"""
        @brief Replaces the given shape with a polygon
        @return A reference to the new shape (a \Shape object)

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    @overload
    def replace(self, shape: Shape, simple_polygon: DSimplePolygon) -> Shape:
        r"""
        @brief Replaces the given shape with a simple polygon given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with a \SimplePolygon argument, except that it will internally translate the simple polygon from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, simple_polygon: SimplePolygon) -> Shape:
        r"""
        @brief Replaces the given shape with a simple polygon
        @return A reference to the new shape (a \Shape object)

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    @overload
    def replace(self, shape: Shape, text: DText) -> Shape:
        r"""
        @brief Replaces the given shape with a text given in micrometer units
        @return A reference to the new shape (a \Shape object)

        This method behaves like the \replace version with a \Text argument, except that it will internally translate the text from micrometer to database units.

        This variant has been introduced in version 0.25.
        """
    @overload
    def replace(self, shape: Shape, text: Text) -> Shape:
        r"""
        @brief Replaces the given shape with a text object
        @return A reference to the new shape (a \Shape object)

        This method has been introduced with version 0.16. It replaces the given shape with the object specified. It does not change the property Id. To change the property Id, use the \replace_prop_id method. To replace a shape and discard the property Id, erase the shape and insert a new shape.
        This method is permitted in editable mode only.
        """
    def replace_prop_id(self, shape: Shape, property_id: int) -> Shape:
        r"""
        @brief Replaces (or install) the properties of a shape
        @return A \Shape object representing the new shape
        This method has been introduced in version 0.16. It can only be used in editable mode.
        Changes the properties Id of the given shape or install a properties Id on that shape if it does not have one yet.
        The property Id must be obtained from the \Layout object's property_id method which associates a property set with a property Id.
        This method will potentially invalidate the shape reference passed to it. Use the reference returned for future references.
        """
    def size(self) -> int:
        r"""
        @brief Gets the number of shapes in this container
        This method was introduced in version 0.16
        @return The number of shapes in this container
        """
    @overload
    def transform(self, trans: DCplxTrans) -> None:
        r"""
        @brief Transforms all shapes with the given transformation (given in micrometer units)
        This method will invalidate all references to shapes inside this collection.
        The displacement of the transformation is given in micrometer units.

        It has been introduced in version 0.25.
        """
    @overload
    def transform(self, trans: DTrans) -> None:
        r"""
        @brief Transforms all shapes with the given transformation (given in micrometer units)
        This method will invalidate all references to shapes inside this collection.
        The displacement of the transformation is given in micrometer units.

        It has been introduced in version 0.25.
        """
    @overload
    def transform(self, trans: ICplxTrans) -> None:
        r"""
        @brief Transforms all shapes with the given complex integer transformation
        This method will invalidate all references to shapes inside this collection.

        It has been introduced in version 0.23.
        """
    @overload
    def transform(self, trans: Trans) -> None:
        r"""
        @brief Transforms all shapes with the given transformation
        This method will invalidate all references to shapes inside this collection.

        It has been introduced in version 0.23.
        """
    @overload
    def transform(self, shape: Shape, trans: DCplxTrans) -> Shape:
        r"""
        @brief Transforms the shape given by the reference with the given complex transformation, where the transformation is given in micrometer units
        @param trans The transformation to apply (displacement in micrometer units)
        @return A reference (a \Shape object) to the new shape
        The original shape may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, shape: Shape, trans: DTrans) -> Shape:
        r"""
        @brief Transforms the shape given by the reference with the given transformation, where the transformation is given in micrometer units
        @param trans The transformation to apply (displacement in micrometer units)
        @return A reference (a \Shape object) to the new shape
        The original shape may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        This method has been introduced in version 0.25.
        """
    @overload
    def transform(self, shape: Shape, trans: ICplxTrans) -> Shape:
        r"""
        @brief Transforms the shape given by the reference with the given complex integer space transformation
        @return A reference (a \Shape object) to the new shape
        This method has been introduced in version 0.22.
        The original shape may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.
        """
    @overload
    def transform(self, shape: Shape, trans: Trans) -> Shape:
        r"""
        @brief Transforms the shape given by the reference with the given transformation
        @return A reference (a \Shape object) to the new shape
        The original shape may be deleted and re-inserted by this method. Therefore, a new reference is returned.
        It is permitted in editable mode only.

        This method has been introduced in version 0.16.
        """

class TechnologyComponent:
    r"""
    @brief A part of a technology definition
    Technology components extend technology definitions (class \Technology) by specialized subfeature definitions. For example, the net tracer supplies it's technology-dependent specification through a technology component called \NetTracerTechnology.

    Components are managed within technologies and can be accessed from a technology using \Technology#component.

    This class has been introduced in version 0.25.
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def description(self) -> str:
        r"""
        @brief Gets the human-readable description string of the technology component
        """
    def name(self) -> str:
        r"""
        @brief Gets the formal name of the technology component
        This is the name by which the component can be obtained from a technology using \Technology#component.
        """

class Technology:
    r"""
    @brief Represents a technology

    This class represents one technology from a set of technologies. The set of technologies available in the system can be obtained with \technology_names. Individual technology definitions are returned with \technology_by_name. Use \create_technology to register new technologies and \remove_technology to delete technologies.

    The Technology class has been introduced in version 0.25.
    """
    add_other_layers: bool
    r"""
    @brief Gets the flag indicating whether to add other layers to the layer properties
    @brief Sets the flag indicating whether to add other layers to the layer properties
    """
    dbu: float
    r"""
    @brief Gets the default database unit

    The default database unit is the one used when creating a layout for example.@brief Sets the default database unit
    """
    default_base_path: str
    r"""
    @brief Gets the default base path

    See \base_path for details about the default base path.
    @hide
    """
    description: str
    r"""
    @brief Gets the description

    The technology description is shown to the user in technology selection dialogs and for display purposes.@brief Sets the description
    """
    explicit_base_path: str
    r"""
    @brief Gets the explicit base path

    See \base_path for details about the explicit base path.
    @brief Sets the explicit base path

    See \base_path for details about the explicit base path.
    """
    group: str
    r"""
    @brief Gets the technology group

    The technology group is used to group certain technologies together in the technology selection menu. Technologies with the same group are put under a submenu with that group title.

    The 'group' attribute has been introduced in version 0.26.2.
    @brief Sets the technology group
    See \group for details about this attribute.

    The 'group' attribute has been introduced in version 0.26.2.
    """
    layer_properties_file: str
    r"""
    @brief Gets the path of the layer properties file

    If empty, no layer properties file is associated with the technology. If non-empty, this path will be corrected by the base path (see \correct_path) and this layer properties file will be loaded for layouts with this technology.@brief Sets the path of the layer properties file

    See \layer_properties_file for details about this property.
    """
    load_layout_options: LoadLayoutOptions
    r"""
    @brief Gets the layout reader options

    This method returns the layout reader options that are used when reading layouts with this technology.

    Change the reader options by modifying the object and using the setter to change it:

    @code
    opt = tech.load_layout_options
    opt.dxf_dbu = 2.5
    tech.load_layout_options = opt
    @/code
    @brief Sets the layout reader options

    See \load_layout_options for a description of this property.
    """
    name: str
    r"""
    @brief Gets the name of the technology@brief Sets the name of the technology
    """
    save_layout_options: SaveLayoutOptions
    r"""
    @brief Gets the layout writer options

    This method returns the layout writer options that are used when writing layouts with this technology.

    Change the reader options by modifying the object and using the setter to change it:

    @code
    opt = tech.save_layout_options
    opt.dbu = 0.01
    tech.save_layout_options = opt
    @/code
    @brief Sets the layout writer options

    See \save_layout_options for a description of this property.
    """
    @classmethod
    def clear_technologies(cls) -> None:
        r"""
        @brief Clears all technologies

        This method has been introduced in version 0.26.
        """
    @classmethod
    def technologies_to_xml(cls) -> str:
        r"""
        @brief Returns a XML representation of all technologies registered in the system

        \technologies_from_xml can be used to restore the technology definitions. This method is provided mainly as a substitute for the pre-0.25 way of accessing technology data through the 'technology-data' configuration parameter. This method will return the equivalent string.
        """
    @classmethod
    def technology_names(cls) -> List[str]:
        r"""
        @brief Gets a list of technology names defined in the system
        """
    def __copy__(self) -> Technology:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Technology) -> None:
        r"""
        @brief Assigns another object to self
        """
    def base_path(self) -> str:
        r"""
        @brief Gets the base path of the technology

        The base path is the effective path where files are read from if their file path is a relative one. If the explicit path is set (see \explicit_base_path=), it is
        used. If not, the default path is used. The default path is the one from which
        a technology file was imported. The explicit one is the one that is specified
        explicitly with \explicit_base_path=.
        """
    def component(self, name: str) -> TechnologyComponent:
        r"""
        @brief Gets the technology component with the given name
        The names are unique system identifiers. For all names, use \component_names.
        """
    def component_names(self) -> List[str]:
        r"""
        @brief Gets the names of all components available for \component
        """
    def correct_path(self, path: str) -> str:
        r"""
        @brief Makes a file path relative to the base path if one is specified

        This method turns an absolute path into one relative to the base path. Only files below the base path will be made relative. Files above or beside won't be made relative.

        See \base_path for details about the default base path.
        """
    def create_technology(self, name: str) -> Technology:
        r"""
        @brief Creates a new (empty) technology with the given name

        This method returns a reference to the new technology.
        """
    def dup(self) -> Technology:
        r"""
        @brief Creates a copy of self
        """
    def eff_layer_properties_file(self) -> str:
        r"""
        @brief Gets the effective path of the layer properties file
        """
    def eff_path(self, path: str) -> str:
        r"""
        @brief Makes a file path relative to the base path if one is specified

        This method will return the actual path for a file from the file's path. If the input path is a relative one, it will be made absolute by using the base path.

        See \base_path for details about the default base path.
        """
    def has_technology(self, name: str) -> bool:
        r"""
        @brief Returns a value indicating whether there is a technology with this name
        """
    def load(self, file: str) -> None:
        r"""
        @brief Loads the technology definition from a file
        """
    def remove_technology(self, name: str) -> None:
        r"""
        @brief Removes the technology with the given name
        """
    def save(self, file: str) -> None:
        r"""
        @brief Saves the technology definition to a file
        """
    def technologies_from_xml(self, xml: str) -> None:
        r"""
        @brief Loads the technologies from a XML representation

        See \technologies_to_xml for details. This method is the corresponding setter.
        """
    def technology_by_name(self, name: str) -> Technology:
        r"""
        @brief Gets the technology object for a given name
        """
    def technology_from_xml(self, xml: str) -> Technology:
        r"""
        @brief Loads the technology from a XML representation

        See \technology_to_xml for details.
        """
    def to_xml(self) -> str:
        r"""
        @brief Returns a XML representation of this technolog

        \technology_from_xml can be used to restore the technology definition.
        """

class Text:
    r"""
    @brief A text object

    A text object has a point (location), a text, a text transformation,
    a text size and a font id. Text size and font id are provided to be
    be able to render the text correctly.
    Text objects are used as labels (i.e. for pins) or to indicate a particular position.

    The \Text class uses integer coordinates. A class that operates with floating-point coordinates is \DText.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    font: int
    r"""
    @brief Get the font number
    @brief Set the font number
    """
    halign: int
    r"""
    @brief Get the horizontal alignment

    See \halign= for a description of this property.
    @brief Set the horizontal alignment

    This property specifies how the text is aligned relative to the anchor point. Allowed values for this property are 0 (left), 1 (center) and 2 (right).
    This property has been introduced in version 0.22.
    """
    size: int
    r"""
    @brief Get the text height
    @brief Set the text height of this object
    """
    string: str
    r"""
    @brief Get the text string
    @brief Assign a text string to this object
    """
    trans: Trans
    r"""
    @brief Get the transformation
    @brief Assign a transformation (text position and orientation) to this object
    """
    valign: int
    r"""
    @brief Get the vertical alignment

    See \valign= for a description of this property.
    @brief Set the vertical alignment

    This property specifies how the text is aligned relative to the anchor point. Allowed values for this property are 0 (top), 1 (center) and 2 (bottom).
    This property has been introduced in version 0.22.
    """
    x: int
    r"""
    @brief Gets the x location of the text

    This method has been introduced in version 0.23.
    @brief Sets the x location of the text

    This method has been introduced in version 0.23.
    """
    y: int
    r"""
    @brief Gets the y location of the text

    This method has been introduced in version 0.23.
    @brief Sets the y location of the text

    This method has been introduced in version 0.23.
    """
    @classmethod
    def from_s(cls, s: str) -> Text:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> Text:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, text: object) -> bool:
        r"""
        @brief Equality


        Return true, if this text object and the given text are equal 
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given text object. This method enables texts as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        Creates a text with unit transformation and empty text.
        """
    @overload
    def __init__(self, dtext: DText) -> None:
        r"""
        @brief Creates an integer coordinate text from a floating-point coordinate text
        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dtext'.
        """
    @overload
    def __init__(self, string: str, trans: Trans) -> None:
        r"""
        @brief Constructor with string and transformation


        A string and a transformation is provided to this constructor. The transformation specifies the location and orientation of the text object.
        """
    @overload
    def __init__(self, string: str, x: int, y: int) -> None:
        r"""
        @brief Constructor with string and location


        A string and a location is provided to this constructor. The location is specifies as a pair of x and y coordinates.

        This method has been introduced in version 0.23.
        """
    @overload
    def __init__(self, string: str, trans: Trans, height: int, font: int) -> None:
        r"""
        @brief Constructor with string, transformation, text height and font


        A string and a transformation is provided to this constructor. The transformation specifies the location and orientation of the text object. In addition, the text height and font can be specified.
        """
    def __lt__(self, t: Text) -> bool:
        r"""
        @brief Less operator
        @param t The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __ne__(self, text: object) -> bool:
        r"""
        @brief Inequality


        Return true, if this text object and the given text are not equal 
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def __str__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Text) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> Text:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given text object. This method enables texts as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def move(self, distance: Vector) -> Text:
        r"""
        @brief Moves the text by a certain distance (modifies self)


        Moves the text by a given offset and returns the moved
        text. Does not check for coordinate overflows.

        @param p The offset to move the text.

        @return A reference to this text object
        """
    @overload
    def move(self, dx: int, dy: int) -> Text:
        r"""
        @brief Moves the text by a certain distance (modifies self)


        Moves the text by a given distance in x and y direction and returns the moved
        text. Does not check for coordinate overflows.

        @param dx The x distance to move the text.
        @param dy The y distance to move the text.

        @return A reference to this text object

        This method was introduced in version 0.23.
        """
    @overload
    def moved(self, distance: Vector) -> Text:
        r"""
        @brief Returns the text moved by a certain distance (does not modify self)


        Moves the text by a given offset and returns the moved
        text. Does not modify *this. Does not check for coordinate
        overflows.

        @param p The offset to move the text.

        @return The moved text.
        """
    @overload
    def moved(self, dx: int, dy: int) -> Text:
        r"""
        @brief Returns the text moved by a certain distance (does not modify self)


        Moves the text by a given offset and returns the moved
        text. Does not modify *this. Does not check for coordinate
        overflows.

        @param dx The x distance to move the text.
        @param dy The y distance to move the text.

        @return The moved text.

        This method was introduced in version 0.23.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DText:
        r"""
        @brief Converts the text to a floating-point coordinate text
        The database unit can be specified to translate the integer-coordinate text into a floating-point coordinate text in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert to a string
        """
    @overload
    def transformed(self, t: CplxTrans) -> DText:
        r"""
        @brief Transform the text with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed text (a DText now)
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Text:
        r"""
        @brief Transform the text with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed text (in this case an integer coordinate object now)

        This method has been introduced in version 0.18.
        """
    @overload
    def transformed(self, t: Trans) -> Text:
        r"""
        @brief Transform the text with the given simple transformation


        @param t The transformation to apply
        @return The transformed text
        """

class DText:
    r"""
    @brief A text object

    A text object has a point (location), a text, a text transformation,
    a text size and a font id. Text size and font id are provided to be
    be able to render the text correctly.
    Text objects are used as labels (i.e. for pins) or to indicate a particular position.

    The \DText class uses floating-point coordinates. A class that operates with integer coordinates is \Text.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    font: int
    r"""
    @brief Get the font number
    @brief Set the font number
    """
    halign: int
    r"""
    @brief Get the horizontal alignment

    See \halign= for a description of this property.
    @brief Set the horizontal alignment

    This property specifies how the text is aligned relative to the anchor point. Allowed values for this property are 0 (left), 1 (center) and 2 (right).
    This property has been introduced in version 0.22.
    """
    size: float
    r"""
    @brief Get the text height
    @brief Set the text height of this object
    """
    string: str
    r"""
    @brief Get the text string
    @brief Assign a text string to this object
    """
    trans: DTrans
    r"""
    @brief Get the transformation
    @brief Assign a transformation (text position and orientation) to this object
    """
    valign: int
    r"""
    @brief Get the vertical alignment

    See \valign= for a description of this property.
    @brief Set the vertical alignment

    This property specifies how the text is aligned relative to the anchor point. Allowed values for this property are 0 (top), 1 (center) and 2 (bottom).
    This property has been introduced in version 0.22.
    """
    x: float
    r"""
    @brief Gets the x location of the text

    This method has been introduced in version 0.23.
    @brief Sets the x location of the text

    This method has been introduced in version 0.23.
    """
    y: float
    r"""
    @brief Gets the y location of the text

    This method has been introduced in version 0.23.
    @brief Sets the y location of the text

    This method has been introduced in version 0.23.
    """
    @classmethod
    def from_s(cls, s: str) -> DText:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DText:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, text: object) -> bool:
        r"""
        @brief Equality


        Return true, if this text object and the given text are equal 
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given text object. This method enables texts as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        Creates a text with unit transformation and empty text.
        """
    @overload
    def __init__(self, Text: Text) -> None:
        r"""
        @brief Creates a floating-point coordinate text from an integer coordinate text

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_itext'.
        """
    @overload
    def __init__(self, string: str, trans: DTrans) -> None:
        r"""
        @brief Constructor with string and transformation


        A string and a transformation is provided to this constructor. The transformation specifies the location and orientation of the text object.
        """
    @overload
    def __init__(self, string: str, x: float, y: float) -> None:
        r"""
        @brief Constructor with string and location


        A string and a location is provided to this constructor. The location is specifies as a pair of x and y coordinates.

        This method has been introduced in version 0.23.
        """
    @overload
    def __init__(self, string: str, trans: DTrans, height: float, font: int) -> None:
        r"""
        @brief Constructor with string, transformation, text height and font


        A string and a transformation is provided to this constructor. The transformation specifies the location and orientation of the text object. In addition, the text height and font can be specified.
        """
    def __lt__(self, t: DText) -> bool:
        r"""
        @brief Less operator
        @param t The object to compare against
        This operator is provided to establish some, not necessarily a certain sorting order
        """
    def __ne__(self, text: object) -> bool:
        r"""
        @brief Inequality


        Return true, if this text object and the given text are not equal 
        """
    def __repr__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def __str__(self) -> str:
        r"""
        @brief Convert to a string
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DText) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DText:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given text object. This method enables texts as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def move(self, distance: DVector) -> DText:
        r"""
        @brief Moves the text by a certain distance (modifies self)


        Moves the text by a given offset and returns the moved
        text. Does not check for coordinate overflows.

        @param p The offset to move the text.

        @return A reference to this text object
        """
    @overload
    def move(self, dx: float, dy: float) -> DText:
        r"""
        @brief Moves the text by a certain distance (modifies self)


        Moves the text by a given distance in x and y direction and returns the moved
        text. Does not check for coordinate overflows.

        @param dx The x distance to move the text.
        @param dy The y distance to move the text.

        @return A reference to this text object

        This method was introduced in version 0.23.
        """
    @overload
    def moved(self, distance: DVector) -> DText:
        r"""
        @brief Returns the text moved by a certain distance (does not modify self)


        Moves the text by a given offset and returns the moved
        text. Does not modify *this. Does not check for coordinate
        overflows.

        @param p The offset to move the text.

        @return The moved text.
        """
    @overload
    def moved(self, dx: float, dy: float) -> DText:
        r"""
        @brief Returns the text moved by a certain distance (does not modify self)


        Moves the text by a given offset and returns the moved
        text. Does not modify *this. Does not check for coordinate
        overflows.

        @param dx The x distance to move the text.
        @param dy The y distance to move the text.

        @return The moved text.

        This method was introduced in version 0.23.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Text:
        r"""
        @brief Converts the text to an integer coordinate text

        The database unit can be specified to translate the floating-point coordinate Text in micron units to an integer-coordinate text in database units. The text's coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief Convert to a string
        """
    @overload
    def transformed(self, t: DCplxTrans) -> DText:
        r"""
        @brief Transform the text with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed text (a DText now)
        """
    @overload
    def transformed(self, t: DTrans) -> DText:
        r"""
        @brief Transform the text with the given simple transformation


        @param t The transformation to apply
        @return The transformed text
        """
    @overload
    def transformed(self, t: VCplxTrans) -> Text:
        r"""
        @brief Transforms the text with the given complex transformation


        @param t The magnifying transformation to apply
        @return The transformed text (in this case an integer coordinate text)

        This method has been introduced in version 0.25.
        """

class Texts(ShapeCollection):
    r"""
    @brief Texts (a collection of texts)

    Text objects are useful as labels for net names, to identify certain regions and to specify specific locations in general. Text collections provide a way to store - also in a hierarchical fashion - and manipulate a collection of text objects.

    Text objects can be turned into polygons by creating small boxes around the texts (\polygons). Texts can also be turned into dot-like edges (\edges). Texts can be filtered by string, either by matching against a fixed string (\with_text) or a glob-style pattern (\with_match).

    Text collections can be filtered geometrically against a polygon \Region using \interacting or \non-interacting. Vice versa, texts can be used to select polygons from a \Region using \pull_interacting.

    Beside that, text collections can be transformed, flattened and combined, similar to \EdgePairs.

    This class has been introduced in version 0.27.
    """
    def __add__(self, other: Texts) -> Texts:
        r"""
        @brief Returns the combined text collection of self and the other one

        @return The resulting text collection

        This operator adds the texts of the other collection to self and returns a new combined set.
        """
    def __and__(self, other: Region) -> Texts:
        r"""
        Note: This is an alias of 'interacting'.
        @brief Returns the texts from this text collection which are inside or on the edge of polygons from the given region

        @return A new text collection containing the texts inside or on the edge of polygons from the region
        """
    def __copy__(self) -> Texts:
        r"""
        @brief Creates a copy of self
        """
    def __getitem__(self, n: int) -> Text:
        r"""
        @brief Returns the nth text

        This method returns nil if the index is out of range. It is available for flat texts only - i.e. those for which \has_valid_texts? is true. Use \flatten to explicitly flatten an text collection.

        The \each iterator is the more general approach to access the texts.
        """
    def __iadd__(self, other: Texts) -> Texts:
        r"""
        @brief Adds the texts of the other text collection to self

        @return The text collection after modification (self)

        This operator adds the texts of the other collection to self.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor

        This constructor creates an empty text collection.
        """
    @overload
    def __init__(self, array: Sequence[Text]) -> None:
        r"""
        @brief Constructor from an text array

        This constructor creates an text collection from an array of \Text objects.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator) -> None:
        r"""
        @brief Constructor from a hierarchical shape set

        This constructor creates a text collection from the shapes delivered by the given recursive shape iterator.
        Only texts are taken from the shape set and other shapes are ignored.
        This method allows feeding the text collection from a hierarchy of cells.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::Texts::new(layout.begin_shapes(cell, layer))
        @/code
        """
    @overload
    def __init__(self, shapes: Shapes) -> None:
        r"""
        @brief Shapes constructor

        This constructor creates an text collection from a \Shapes collection.
        """
    @overload
    def __init__(self, text: Text) -> None:
        r"""
        @brief Constructor from a single edge pair object

        This constructor creates an text collection with a single text.
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore) -> None:
        r"""
        @brief Creates a hierarchical text collection from an original layer

        This constructor creates a text collection from the shapes delivered by the given recursive shape iterator.
        This version will create a hierarchical text collection which supports hierarchical operations.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        r = RBA::Texts::new(layout.begin_shapes(cell, layer))
        @/code
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Constructor from a hierarchical shape set with a transformation

        This constructor creates a text collection from the shapes delivered by the given recursive shape iterator.
        Only texts are taken from the shape set and other shapes are ignored.
        The given transformation is applied to each text taken.
        This method allows feeding the text collection from a hierarchy of cells.
        The transformation is useful to scale to a specific database unit for example.

        @code
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::Texts::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code
        """
    @overload
    def __init__(self, shape_iterator: RecursiveShapeIterator, dss: DeepShapeStore, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a hierarchical text collection from an original layer with a transformation

        This constructor creates a text collection from the shapes delivered by the given recursive shape iterator.
        This version will create a hierarchical text collection which supports hierarchical operations.
        The transformation is useful to scale to a specific database unit for example.

        @code
        dss    = RBA::DeepShapeStore::new
        layout = ... # a layout
        cell   = ... # the index of the initial cell
        layer  = ... # the index of the layer from where to take the shapes from
        dbu    = 0.1 # the target database unit
        r = RBA::Texts::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu / dbu))
        @/code
        """
    def __iter__(self) -> Iterator[Text]:
        r"""
        @brief Returns each text of the text collection
        """
    def __repr__(self) -> str:
        r"""
        @brief Converts the text collection to a string
        The length of the output is limited to 20 texts to avoid giant strings on large collections. For full output use "to_s" with a maximum count parameter.
        """
    def __str__(self) -> str:
        r"""
        @brief Converts the text collection to a string
        The length of the output is limited to 20 texts to avoid giant strings on large collections. For full output use "to_s" with a maximum count parameter.
        """
    def __sub__(self, other: Region) -> Texts:
        r"""
        Note: This is an alias of 'not_interacting'.
        @brief Returns the texts from this text collection which are not inside or on the edge of polygons from the given region

        @return A new text collection containing the texts not inside or on the edge of polygons from the region
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ShapeCollection) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Return the bounding box of the text collection
        The bounding box is the box enclosing all origins of all texts.
        """
    def clear(self) -> None:
        r"""
        @brief Clears the text collection
        """
    def count(self) -> int:
        r"""
        @brief Returns the (flat) number of texts in the text collection

        The count is computed 'as if flat', i.e. texts inside a cell are multiplied by the number of times a cell is instantiated.

        Starting with version 0.27, the method is called 'count' for consistency with \Region. 'size' is still provided as an alias.
        """
    def data_id(self) -> int:
        r"""
        @brief Returns the data ID (a unique identifier for the underlying data storage)
        """
    def disable_progress(self) -> None:
        r"""
        @brief Disable progress reporting
        Calling this method will disable progress reporting. See \enable_progress.
        """
    def dup(self) -> Texts:
        r"""
        @brief Creates a copy of self
        """
    def each(self) -> Iterator[Text]:
        r"""
        @brief Returns each text of the text collection
        """
    def edges(self) -> Edges:
        r"""
        @brief Returns dot-like edges for the texts
        @return An edge collection containing the individual, dot-like edges
        """
    def enable_progress(self, label: str) -> None:
        r"""
        @brief Enable progress reporting
        After calling this method, the text collection will report the progress through a progress bar while expensive operations are running.
        The label is a text which is put in front of the progress bar.
        Using a progress bar will imply a performance penalty of a few percent typically.
        """
    @overload
    def extents(self, d: Optional[int] = ...) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the texts
        Text bounding boxes are point-like boxes which vanish unless an enlargement of >0 is specified.
        The bounding box is centered at the text's location.
        The boxes will not be merged, so it is possible to determine overlaps of these boxes for example.
        """
    @overload
    def extents(self, dx: int, dy: int) -> Region:
        r"""
        @brief Returns a region with the enlarged bounding boxes of the texts
        This method acts like the other version of \extents, but allows giving different enlargements for x and y direction.
        """
    def flatten(self) -> None:
        r"""
        @brief Explicitly flattens an text collection

        If the collection is already flat (i.e. \has_valid_texts? returns true), this method will not change the collection.
        """
    def has_valid_texts(self) -> bool:
        r"""
        @brief Returns true if the text collection is flat and individual texts can be accessed randomly
        """
    def hier_count(self) -> int:
        r"""
        @brief Returns the (hierarchical) number of texts in the text collection

        The count is computed 'hierarchical', i.e. texts inside a cell are counted once even if the cell is instantiated multiple times.

        This method has been introduced in version 0.27.
        """
    @overload
    def insert(self, text: Text) -> None:
        r"""
        @brief Inserts a text into the collection
        """
    @overload
    def insert(self, texts: Texts) -> None:
        r"""
        @brief Inserts all texts from the other text collection into this collection
        """
    def insert_into(self, layout: Layout, cell_index: int, layer: int) -> None:
        r"""
        @brief Inserts this texts into the given layout, below the given cell and into the given layer.
        If the text collection is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.
        """
    def insert_into_as_polygons(self, layout: Layout, cell_index: int, layer: int, e: int) -> None:
        r"""
        @brief Inserts this texts into the given layout, below the given cell and into the given layer.
        If the text collection is a hierarchical one, a suitable hierarchy will be built below the top cell or and existing hierarchy will be reused.

        The texts will be converted to polygons with the enlargement value given be 'e'. See \polygon or \extents for details.
        """
    def interacting(self, other: Region) -> Texts:
        r"""
        @brief Returns the texts from this text collection which are inside or on the edge of polygons from the given region

        @return A new text collection containing the texts inside or on the edge of polygons from the region
        """
    def is_deep(self) -> bool:
        r"""
        @brief Returns true if the edge pair collection is a deep (hierarchical) one
        """
    def is_empty(self) -> bool:
        r"""
        @brief Returns true if the collection is empty
        """
    @overload
    def move(self, p: Vector) -> Texts:
        r"""
        @brief Moves the text collection

        Moves the texts by the given offset and returns the 
        moved text collection. The text collection is overwritten.

        @param p The distance to move the texts.

        @return The moved texts (self).
        """
    @overload
    def move(self, x: int, y: int) -> Texts:
        r"""
        @brief Moves the text collection

        Moves the edge pairs by the given offset and returns the 
        moved texts. The edge pair collection is overwritten.

        @param x The x distance to move the texts.
        @param y The y distance to move the texts.

        @return The moved texts (self).
        """
    @overload
    def moved(self, p: Vector) -> Texts:
        r"""
        @brief Returns the moved text collection (does not modify self)

        Moves the texts by the given offset and returns the 
        moved texts. The text collection is not modified.

        @param p The distance to move the texts.

        @return The moved texts.
        """
    @overload
    def moved(self, x: int, y: int) -> Texts:
        r"""
        @brief Returns the moved edge pair collection (does not modify self)

        Moves the texts by the given offset and returns the 
        moved texts. The text collection is not modified.

        @param x The x distance to move the texts.
        @param y The y distance to move the texts.

        @return The moved texts.
        """
    def not_interacting(self, other: Region) -> Texts:
        r"""
        @brief Returns the texts from this text collection which are not inside or on the edge of polygons from the given region

        @return A new text collection containing the texts not inside or on the edge of polygons from the region
        """
    def polygons(self, e: Optional[int] = ...) -> Region:
        r"""
        @brief Converts the edge pairs to polygons
        This method creates polygons from the texts. This is equivalent to calling \extents.
        """
    def pull_interacting(self, other: Region) -> Region:
        r"""
        @brief Returns all polygons of "other" which are including texts of this text set
        The "pull_..." method is similar to "select_..." but works the opposite way: it selects shapes from the argument region rather than self. In a deep (hierarchical) context the output region will be hierarchically aligned with self, so the "pull_..." method provide a way for re-hierarchization.

        @return The region after the polygons have been selected (from other)

        Merged semantics applies for the polygon region.
        """
    def select_interacting(self, other: Region) -> Texts:
        r"""
        @brief Selects the texts from this text collection which are inside or on the edge of polygons from the given region

        @return A text collection after the texts have been selected (self)

        In contrast to \interacting, this method will modify self.
        """
    def select_not_interacting(self, other: Region) -> Texts:
        r"""
        @brief Selects the texts from this text collection which are not inside or on the edge of polygons from the given region

        @return A text collection after the texts have been selected (self)

        In contrast to \interacting, this method will modify self.
        """
    def swap(self, other: Texts) -> None:
        r"""
        @brief Swap the contents of this collection with the contents of another collection
        This method is useful to avoid excessive memory allocation in some cases. For managed memory languages such as Ruby, those cases will be rare. 
        """
    @overload
    def to_s(self) -> str:
        r"""
        @brief Converts the text collection to a string
        The length of the output is limited to 20 texts to avoid giant strings on large collections. For full output use "to_s" with a maximum count parameter.
        """
    @overload
    def to_s(self, max_count: int) -> str:
        r"""
        @brief Converts the text collection to a string
        This version allows specification of the maximum number of texts contained in the string.
        """
    @overload
    def transform(self, t: ICplxTrans) -> Texts:
        r"""
        @brief Transform the text collection with a complex transformation (modifies self)

        Transforms the text collection with the given transformation.
        This version modifies the text collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed text collection.
        """
    @overload
    def transform(self, t: Trans) -> Texts:
        r"""
        @brief Transform the text collection (modifies self)

        Transforms the text collection with the given transformation.
        This version modifies the text collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed text collection.
        """
    @overload
    def transformed(self, t: ICplxTrans) -> Texts:
        r"""
        @brief Transform the text collection with a complex transformation

        Transforms the text with the given complex transformation.
        Does not modify the text collection but returns the transformed texts.

        @param t The transformation to apply.

        @return The transformed texts.
        """
    @overload
    def transformed(self, t: Trans) -> Texts:
        r"""
        @brief Transform the edge pair collection

        Transforms the texts with the given transformation.
        Does not modify the edge pair collection but returns the transformed texts.

        @param t The transformation to apply.

        @return The transformed texts.
        """
    def with_match(self, pattern: str, inverse: bool) -> Texts:
        r"""
        @brief Filter the text by glob pattern
        "pattern" is a glob-style pattern (e.g. "A*" will select all texts starting with a capital "A").
        If "inverse" is false, this method returns the texts matching the pattern.
        If "inverse" is true, this method returns the texts not matching the pattern.
        """
    def with_text(self, text: str, inverse: bool) -> Texts:
        r"""
        @brief Filter the text by text string
        If "inverse" is false, this method returns the texts with the given string.
        If "inverse" is true, this method returns the texts not having the given string.
        """

class TileOutputReceiverBase:
    r"""
    @hide
    @alias TileOutputReceiver
    """
    def __copy__(self) -> TileOutputReceiverBase:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: TileOutputReceiverBase) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> TileOutputReceiverBase:
        r"""
        @brief Creates a copy of self
        """
    def processor(self) -> TilingProcessor:
        r"""
        @brief Gets the processor the receiver is attached to

        This attribute is set before begin and can be nil if the receiver is not attached to a processor.

        This method has been introduced in version 0.25.
        """

class TileOutputReceiver(TileOutputReceiverBase):
    r"""
    @brief A receiver abstraction for the tiling processor.

    The tiling processor (\TilingProcessor) is a framework for executing sequences of operations on tiles of a layout or multiple layouts. The \TileOutputReceiver class is used to specify an output channel for the tiling processor. See \TilingProcessor#output for more details.

    This class has been introduced in version 0.23.
    """
    def _assign(self, other: TileOutputReceiverBase) -> None:
        r"""
        @brief Assigns another object to self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _dup(self) -> TileOutputReceiver:
        r"""
        @brief Creates a copy of self
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def begin(self, nx: int, ny: int, p0: DPoint, dx: float, dy: float, frame: DBox) -> None:
        r"""
        @brief Initiates the delivery
        This method is called before the first tile delivers it's data.

        @param nx The number of tiles in x direction
        @param ny The number of tiles in y direction
        @param p0 The initial point
        @param dx The tile's x dimension
        @param dy The tile's y dimension
        @param frame The overall frame that is the basis of the tiling
        The tile's coordinates will be p0+(ix*dx,iy*dy)..p0+((ix+1)*dx,(iy+1)*dy) 
        where ix=0..nx-1, iy=0..ny-1.

        All coordinates are given in micron. If tiles are not used, nx and ny are 0.

        The frame parameter has been added in version 0.25.
        """
    def finish(self, success: bool) -> None:
        r"""
        @brief Indicates the end of the execution

        This method is called when the tiling processor has finished the last tile and script item.
        The success flag is set to true, if every tile has finished successfully. Otherwise, this value is false.

        The success flag has been added in version 0.25.
        """
    def put(self, ix: int, iy: int, tile: Box, obj: Any, dbu: float, clip: bool) -> None:
        r"""
        @brief Delivers data for one tile

        When the script's "_output" function is called, the data will be delivered through this
        method. "obj" is the data passed as the second argument to _output.
        The interpretation of the object remains subject to the implementation.

        The obj and clip parameters are taken from the _output method call inside the script.
        If clip is set to true, this usually means that output shall be clipped to the tile.

        @param ix The x index of the tile
        @param iy The y index of the tile
        @param tile The tile's box
        @param obj The object which is delivered
        @param dbu The database unit
        @param clip True if clipping at the tile box is requested
        """

class TilingProcessor:
    r"""
    @brief A processor for layout which distributes tasks over tiles

    The tiling processor executes one or several scripts on one or multiple layouts providing a tiling scheme. In that scheme, the processor divides the original layout into rectangular tiles and executes the scripts on each tile separately. The tiling processor allows one to specify multiple, independent scripts which are run separately on each tile. It can make use of multi-core CPU's by supporting multiple threads running the tasks in parallel (with respect to tiles and scripts).

    Tiling a optional - if no tiles are specified, the tiling processing basically operates flat and parallelization extends to the scripts only.

    Tiles can be overlapping to gather input from neighboring tiles into the current tile. In order to provide that feature, a border can be specified which gives the amount by which the search region is extended beyond the border of the tile. To specify the border, use the \TilingProcessor#tile_border method.

    The basis of the tiling processor are \Region objects and expressions. Expressions are a built-in simple language to form simple scripts. Expressions allow access to the objects and methods built into KLayout. Each script can consist of multiple operations. Scripts are specified using \TilingProcessor#queue.

    Input is provided to the script through variables holding a \Region object each. From outside the tiling processor, input is specified with the \TilingProcessor#input method. This method is given a name and a \RecursiveShapeIterator object which delivers the data for the input. On the script side, a \Region object is provided through a variable named like the first argument of the "input" method.

    Inside the script the following functions are provided:

    @ul
    @li"_dbu" delivers the database unit used for the computations @/li
    @li"_tile" delivers a region containing a mask for the tile (a rectangle) or nil if no tiling is used @/li
    @li"_output" is used to deliver output (see below) @/li
    @/ul

    Output can be obtained from the tiling processor by registering a receiver with a channel. A channel is basically a name. Inside the script, the name describes a variable which can be used as the first argument of the "_output" function to identify the channel. A channel is registers using the \TilingProcessor#output method. Beside the name, a receiver must be specified. A receiver is either another layout (a cell of that), a report database or a custom receiver implemented through the \TileOutputReceiver class.

    The "_output" function expects two or three parameters: one channel id (the variable that was defined by the name given in the output method call) and an object to output (a \Region, \Edges, \EdgePairs or a geometrical primitive such as \Polygon or \Box). In addition, a boolean argument can be given indicating whether clipping at the tile shall be applied. If clipping is requested (the default), the shapes will be clipped at the tile's box.

    The tiling can be specified either through a tile size, a tile number or both. If a tile size is specified with the \TilingProcessor#tile_size method, the tiling processor will compute the number of tiles required. If the tile count is given (through \TilingProcessor#tiles), the tile size will be computed. If both are given, the tiling array is fixed and the array is centered around the original layout's center. If the tiling origin is given as well, the tiling processor will use the given array without any modifications.

    Once the tiling processor has been set up, the operation can be launched using \TilingProcessor#execute.

    This is some sample code. It performs two XOR operations between two layouts and delivers the results to a report database:

    @code
    ly1 = ... # first layout
    ly2 = ... # second layout

    rdb = RBA::ReportDatabase::new("xor")
    output_cell = rdb.create_cell(ly1.top_cell.name)
    output_cat1 = rbd.create_category("XOR 1-10")
    output_cat2 = rbd.create_category("XOR 2-11")

    tp = RBA::TilingProcessor::new
    tp.input("a1", ly1, ly1.top_cell.cell_index, RBA::LayerInfo::new(1, 0))
    tp.input("a2", ly1, ly1.top_cell.cell_index, RBA::LayerInfo::new(2, 0))
    tp.input("b1", ly2, ly2.top_cell.cell_index, RBA::LayerInfo::new(11, 0))
    tp.input("b2", ly2, ly2.top_cell.cell_index, RBA::LayerInfo::new(12, 0))
    tp.output("o1", rdb, output_cell, output_cat1)
    tp.output("o2", rdb, output_cell, output_cat2)
    tp.queue("_output(o1, a1 ^ b1)")
    tp.queue("_output(o2, a2 ^ b2)")
    tp.tile_size(50.0, 50.0)
    tp.execute("Job description")
    @/code

    This class has been introduced in version 0.23.
    """
    dbu: float
    r"""
    @brief Gets the database unit under which the computations will be done
    @brief Sets the database unit under which the computations will be done

    All data used within the scripts will be brought to that database unit. If none is given it will be the database unit of the first layout given or 1nm if no layout is specified.
    """
    frame: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the layout frame

    The layout frame is the box (in micron units) taken into account for computing
    the tiles if the tile counts are not given. If the layout frame is not set or
    set to an empty box, the processor will try to derive the frame from the given
    inputs.

    This method has been introduced in version 0.25.
    """
    scale_to_dbu: bool
    r"""
    @brief Gets a valid indicating whether automatic scaling to database unit is enabled

    This method has been introduced in version 0.23.2.@brief Enables or disabled automatic scaling to database unit

    If automatic scaling to database unit is enabled, the input is automatically scaled to the database unit set inside the tile processor. This is the default.

    This method has been introduced in version 0.23.2.
    """
    threads: int
    r"""
    @brief Gets the number of threads to use
    @brief Specifies the number of threads to use
    """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def execute(self, desc: str) -> None:
        r"""
        @brief Runs the job

        This method will initiate execution of the queued scripts, once for every tile. The desc is a text shown in the progress bar for example.
        """
    @overload
    def input(self, name: str, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \EdgePairs object. Edge pair collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant has been introduced in version 0.27.
        """
    @overload
    def input(self, name: str, edges: Edges) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \Edges object. Edge collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, iter: RecursiveShapeIterator) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a recursive shape iterator, hence from a hierarchy of shapes from a layout.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, region: Region) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a \Region object. Regions don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, texts: Texts) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \Texts object. Text collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant has been introduced in version 0.27.
        """
    @overload
    def input(self, name: str, edge_pairs: EdgePairs, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \EdgePairs object. Edge pair collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant has been introduced in version 0.27.
        """
    @overload
    def input(self, name: str, edges: Edges, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \Edges object. Edge collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant allows one to specify an additional transformation too. It has been introduced in version 0.23.2.

        """
    @overload
    def input(self, name: str, iter: RecursiveShapeIterator, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a recursive shape iterator, hence from a hierarchy of shapes from a layout.
        In addition, a transformation can be specified which will be applied to the shapes before they are used.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, region: Region, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a \Region object. Regions don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant allows one to specify an additional transformation too. It has been introduced in version 0.23.2.
        """
    @overload
    def input(self, name: str, texts: Texts, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from an \Texts object. Text collections don't always come with a database unit, hence a database unit should be specified with the \dbu= method unless a layout object is specified as input too.

        The name specifies the variable under which the input can be used in the scripts.
        This variant has been introduced in version 0.27.
        """
    @overload
    def input(self, name: str, layout: Layout, cell_index: int, layer: int) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a layout and the hierarchy below the cell with the given cell index.
        "layer" is the layer index of the input layer.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, layout: Layout, cell_index: int, lp: LayerInfo) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a layout and the hierarchy below the cell with the given cell index.
        "lp" is a \LayerInfo object specifying the input layer.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, layout: Layout, cell_index: int, layer: int, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a layout and the hierarchy below the cell with the given cell index.
        "layer" is the layer index of the input layer.
        In addition, a transformation can be specified which will be applied to the shapes before they are used.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def input(self, name: str, layout: Layout, cell_index: int, lp: LayerInfo, trans: ICplxTrans) -> None:
        r"""
        @brief Specifies input for the tiling processor
        This method will establish an input channel for the processor. This version receives input from a layout and the hierarchy below the cell with the given cell index.
        "lp" is a \LayerInfo object specifying the input layer.
        In addition, a transformation can be specified which will be applied to the shapes before they are used.

        The name specifies the variable under which the input can be used in the scripts.
        """
    @overload
    def output(self, name: str, edge_pairs: EdgePairs) -> None:
        r"""
        @brief Specifies output to an \EdgePairs object
        This method will establish an output channel to an \EdgePairs object. The output sent to that channel will be put into the specified edge pair collection.
        Only \EdgePair objects are accepted. Other objects are discarded.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.

        @param name The name of the channel
        @param edge_pairs The \EdgePairs object to which the data is sent
        """
    @overload
    def output(self, name: str, edges: Edges) -> None:
        r"""
        @brief Specifies output to an \Edges object
        This method will establish an output channel to an \Edges object. The output sent to that channel will be put into the specified edge collection.
        'Solid' objects such as polygons will be converted to edges by resolving their hulls into edges. Edge pairs are resolved into single edges.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.

        @param name The name of the channel
        @param edges The \Edges object to which the data is sent
        """
    @overload
    def output(self, name: str, rec: TileOutputReceiverBase) -> None:
        r"""
        @brief Specifies output for the tiling processor
        This method will establish an output channel for the processor. For that it registers an output receiver which will receive data from the scripts. The scripts call the _output function to deliver data.
        "name" will be name of the variable which must be passed to the first argument of the _output function in order to address this channel.

        Please note that the tiling processor will destroy the receiver object when it is freed itself. Hence if you need to address the receiver object later, make sure that the processor is still alive, i.e. by assigning the object to a variable.

        The following code uses the output receiver. It takes the shapes of a layer from a layout, computes the area of each tile and outputs the area to the custom receiver:

        @code
        layout = ... # the layout
        cell = ... # the top cell's index
        layout = ... # the input layer

        class MyReceiver < RBA::TileOutputReceiver
          def put(ix, iy, tile, obj, dbu, clip)
            puts "got area for tile #{ix+1},#{iy+1}: #{obj.to_s}"
          end
        end

        tp = RBA::TilingProcessor::new

        # register the custom receiver
        tp.output("my_receiver", MyReceiver::new)
        tp.input("the_input", layout.begin_shapes(cell, layer))
        tp.tile_size(100, 100)  # 100x100 um tile size
        # The script clips the input at the tile and computes the (merged) area:
        tp.queue("_output(my_receiver, (the_input & _tile).area)")
        tp.execute("Job description")
        @/code
        """
    @overload
    def output(self, name: str, region: Region) -> None:
        r"""
        @brief Specifies output to a \Region object
        This method will establish an output channel to a \Region object. The output sent to that channel will be put into the specified region.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.
        Edges sent to this channel are discarded. Edge pairs are converted to polygons.

        @param name The name of the channel
        @param region The \Region object to which the data is sent
        """
    @overload
    def output(self, name: str, sum: float) -> None:
        r"""
        @brief Specifies output to single value
        This method will establish an output channel which sums up float data delivered by calling the _output function.
        In order to specify the target for the data, a \Value object must be provided for the "sum" parameter.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.
        """
    @overload
    def output(self, name: str, texts: Texts) -> None:
        r"""
        @brief Specifies output to an \Texts object
        This method will establish an output channel to an \Texts object. The output sent to that channel will be put into the specified edge pair collection.
        Only \Text objects are accepted. Other objects are discarded.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.

        @param name The name of the channel
        @param texts The \Texts object to which the data is sent

        This variant has been introduced in version 0.27.
        """
    @overload
    def output(self, name: str, layout: Layout, cell: int, layer_index: int) -> None:
        r"""
        @brief Specifies output to a layout layer
        This method will establish an output channel to a layer in a layout. The output sent to that channel will be put into the specified layer and cell. In this version, the layer is specified through a layer index, hence it must be created before.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.

        @param name The name of the channel
        @param layout The layout to which the data is sent
        @param cell The index of the cell to which the data is sent
        @param layer_index The layer index where the output will be sent to
        """
    @overload
    def output(self, name: str, layout: Layout, cell: int, lp: LayerInfo) -> None:
        r"""
        @brief Specifies output to a layout layer
        This method will establish an output channel to a layer in a layout. The output sent to that channel will be put into the specified layer and cell. In this version, the layer is specified through a \LayerInfo object, i.e. layer and datatype number. If no such layer exists, it will be created.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.

        @param name The name of the channel
        @param layout The layout to which the data is sent
        @param cell The index of the cell to which the data is sent
        @param lp The layer specification where the output will be sent to
        """
    @overload
    def output(self, name: str, rdb: rdb.ReportDatabase, cell_id: int, category_id: int) -> None:
        r"""
        @brief Specifies output to a report database
        This method will establish an output channel for the processor. The output sent to that channel will be put into the report database given by the "rdb" parameter. "cell_id" specifies the cell and "category_id" the category to use.

        The name is the name which must be used in the _output function of the scripts in order to address that channel.
        """
    def queue(self, script: str) -> None:
        r"""
        @brief Queues a script for parallel execution

        With this method, scripts are registered that are executed in parallel on each tile.
        The scripts have "Expressions" syntax and can make use of several predefined variables and functions.
        See the \TilingProcessor class description for details.
        """
    def tile_border(self, bx: float, by: float) -> None:
        r"""
        @brief Sets the tile border

        Specifies the tile border. The border is a margin that is considered when fetching shapes. By specifying a border you can fetch shapes into the tile's data which are outside the tile but still must be considered in the computations (i.e. because they might grow into the tile).

        The tile border is given in micron.
        """
    def tile_origin(self, xo: float, yo: float) -> None:
        r"""
        @brief Sets the tile origin

        Specifies the origin (lower left corner) of the tile field. If no origin is specified, the tiles are centered to the layout's bounding box. Giving the origin together with the tile count and dimensions gives full control over the tile array.

        The tile origin is given in micron.
        """
    def tile_size(self, w: float, h: float) -> None:
        r"""
        @brief Sets the tile size

        Specifies the size of the tiles to be used. If no tile size is specified, tiling won't be used and all computations will be done on the whole layout.

        The tile size is given in micron.
        """
    def tiles(self, nw: int, nh: int) -> None:
        r"""
        @brief Sets the tile count

        Specifies the number of tiles to be used. If no tile number is specified, the number of tiles required is computed from the layout's dimensions and the tile size. If a number is given, but no tile size, the tile size will be computed from the layout's dimensions.
        """
    def var(self, name: str, value: Any) -> None:
        r"""
        @brief Defines a variable for the tiling processor script

        The name specifies the variable under which the value can be used in the scripts.
        """

class Trans:
    r"""
    @brief A simple transformation

    Simple transformations only provide rotations about angles which a multiples of 90 degree.
    Together with the mirror options, this results in 8 distinct orientations (fixpoint transformations).
    These can be combined with a displacement which is applied after the rotation/mirror.
    This version acts on integer coordinates. A version for floating-point coordinates is \DTrans.

    Here are some examples for using the Trans class:

    @code
    t = RBA::Trans::new(0, 100)  # displacement by 100 DBU in y direction
    # the inverse: -> "r0 0,-100"
    t.inverted.to_s
    # concatenation: -> "r90 -100,0"
    (RBA::Trans::R90 * t).to_s
    # apply to a point: -> "0,100"
    RBA::Trans::R90.trans(RBA::Point::new(100, 0))
    @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[Trans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[Trans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[Trans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[Trans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[Trans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[Trans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[Trans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[Trans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: int
    r"""
    @brief Gets the angle in units of 90 degree

    This value delivers the rotation component. In addition, a mirroring at the x axis may be applied before if the \is_mirror? property is true. @brief Sets the angle in units of 90 degree
    @param a The new angle

    This method was introduced in version 0.20.
    """
    disp: Vector
    r"""
    @brief Gets to the displacement vector

    Staring with version 0.25 the displacement type is a vector.@brief Sets the displacement
    @param u The new displacement

    This method was introduced in version 0.20.
    Staring with version 0.25 the displacement type is a vector.
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag

    This method was introduced in version 0.20.
    """
    rot: int
    r"""
    @brief Gets the angle/mirror code

    The angle/mirror code is one of the constants R0, R90, R180, R270, M0, M45, M90 and M135. rx is the rotation by an angle of x counter clockwise. mx is the mirroring at the axis given by the angle x (to the x-axis). @brief Sets the angle/mirror code
    @param r The new angle/rotation code (see \rot property)

    This method was introduced in version 0.20.
    """
    @classmethod
    def from_s(cls, s: str) -> Trans:
        r"""
        @brief Creates a transformation from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> Trans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, dtrans: DTrans) -> None:
        r"""
        @brief Creates an integer coordinate transformation from a floating-point coordinate transformation

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dtrans'.
        """
    @overload
    def __init__(self, u: Vector) -> None:
        r"""
        @brief Creates a transformation using a displacement only

        @param u The displacement
        """
    @overload
    def __init__(self, c: Trans, u: Optional[Vector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement
        @param y The vertical displacement
        """
    @overload
    def __init__(self, c: Trans, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, rot: int, mirr: Optional[bool] = ..., u: Optional[Vector] = ...) -> None:
        r"""
        @brief Creates a transformation using angle and mirror flag

        The sequence of operations is: mirroring at x axis,
        rotation, application of displacement.

        @param rot The rotation in units of 90 degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, rot: int, mirr: bool, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation using angle and mirror flag and two coordinate values for displacement

        The sequence of operations is: mirroring at x axis,
        rotation, application of displacement.

        @param rot The rotation in units of 90 degree
        @param mirrx True, if mirrored at x axis
        @param x The horizontal displacement
        @param y The vertical displacement
        """
    def __lt__(self, other: Trans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: Box) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: Edge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, path: Path) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: Polygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: Trans) -> Trans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: Text) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, v: Vector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: Box) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: Edge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, path: Path) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: Polygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: Trans) -> Trans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: Text) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, v: Vector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Trans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: int) -> int:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> Trans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> Trans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this object by the
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> Trans:
        r"""
        @brief Returns the inverted transformation
        Returns the inverted transformation

        @return The inverted transformation
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DTrans:
        r"""
        @brief Converts the transformation to a floating-point coordinate transformation

        The database unit can be specified to translate the integer-coordinate transformation into a floating-point coordinate transformation in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def trans(self, box: Box) -> Box:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: Edge) -> Edge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: Point) -> Point:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, path: Path) -> Path:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: Text) -> Text:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, v: Vector) -> Vector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """

class DTrans:
    r"""
    @brief A simple transformation

    Simple transformations only provide rotations about angles which a multiples of 90 degree.
    Together with the mirror options, this results in 8 distinct orientations (fixpoint transformations).
    These can be combined with a displacement which is applied after the rotation/mirror.
    This version acts on floating-point coordinates. A version for integer coordinates is \Trans.

    Here are some examples for using the DTrans class:

    @code
    t = RBA::DTrans::new(0, 100)  # displacement by 100 DBU in y direction
    # the inverse: -> "r0 0,-100"
    t.inverted.to_s
    # concatenation: -> "r90 -100,0"
    (RBA::DTrans::new(RBA::DTrans::R90) * t).to_s
    # apply to a point: -> "0,100"
    RBA::DTrans::new(RBA::DTrans::R90).trans(RBA::DPoint::new(100, 0))
    @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[DTrans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[DTrans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[DTrans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[DTrans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[DTrans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[DTrans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[DTrans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[DTrans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: int
    r"""
    @brief Gets the angle in units of 90 degree

    This value delivers the rotation component. In addition, a mirroring at the x axis may be applied before if the \is_mirror? property is true. @brief Sets the angle in units of 90 degree
    @param a The new angle

    This method was introduced in version 0.20.
    """
    disp: DVector
    r"""
    @brief Gets to the displacement vector

    Staring with version 0.25 the displacement type is a vector.@brief Sets the displacement
    @param u The new displacement

    This method was introduced in version 0.20.
    Staring with version 0.25 the displacement type is a vector.
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag

    This method was introduced in version 0.20.
    """
    rot: int
    r"""
    @brief Gets the angle/mirror code

    The angle/mirror code is one of the constants R0, R90, R180, R270, M0, M45, M90 and M135. rx is the rotation by an angle of x counter clockwise. mx is the mirroring at the axis given by the angle x (to the x-axis). @brief Sets the angle/mirror code
    @param r The new angle/rotation code (see \rot property)

    This method was introduced in version 0.20.
    """
    @classmethod
    def from_s(cls, s: str) -> DTrans:
        r"""
        @brief Creates a transformation from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DTrans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, trans: Trans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from an integer coordinate transformation

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_itrans'.
        """
    @overload
    def __init__(self, u: DVector) -> None:
        r"""
        @brief Creates a transformation using a displacement only

        @param u The displacement
        """
    @overload
    def __init__(self, c: DTrans, u: Optional[DVector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement
        @param y The vertical displacement
        """
    @overload
    def __init__(self, c: DTrans, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, rot: int, mirr: Optional[bool] = ..., u: Optional[DVector] = ...) -> None:
        r"""
        @brief Creates a transformation using angle and mirror flag

        The sequence of operations is: mirroring at x axis,
        rotation, application of displacement.

        @param rot The rotation in units of 90 degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, rot: int, mirr: bool, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation using angle and mirror flag and two coordinate values for displacement

        The sequence of operations is: mirroring at x axis,
        rotation, application of displacement.

        @param rot The rotation in units of 90 degree
        @param mirrx True, if mirrored at x axis
        @param x The horizontal displacement
        @param y The vertical displacement
        """
    def __lt__(self, other: DTrans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: DBox) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: DEdge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, path: DPath) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: DPolygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: DTrans) -> DTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: DText) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, v: DVector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: DBox) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: DEdge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, path: DPath) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: DPolygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: DTrans) -> DTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: DText) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, v: DVector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DTrans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: float) -> float:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> DTrans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> DTrans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this object by the
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> DTrans:
        r"""
        @brief Returns the inverted transformation
        Returns the inverted transformation

        @return The inverted transformation
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Trans:
        r"""
        @brief Converts the transformation to an integer coordinate transformation

        The database unit can be specified to translate the floating-point coordinate transformation in micron units to an integer-coordinate transformation in database units. The transformation's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def trans(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: DPoint) -> DPoint:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, path: DPath) -> DPath:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: DText) -> DText:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, v: DVector) -> DVector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """

class DCplxTrans:
    r"""
    @brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an arbitrary
    angle and a displacement. This is also the order, the operations are applied.

    A complex transformation provides a superset of the simple transformation.
    In many applications, a complex transformation computes floating-point coordinates to minimize rounding effects.
    This version can transform floating-point coordinate objects.

    Complex transformations are extensions of the simple transformation classes (\DTrans in that case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be combined with the '*' operator to form the transformation which is equivalent to applying the second and then the first. Here is some code:

    @code
    # Create a transformation that applies a magnification of 1.5, a rotation by 90 degree
    # and displacement of 10 in x and 20 units in y direction:
    t = RBA::CplxTrans::new(1.5, 90, false, 10.0, 20.0)
    t.to_s            # r90 *1.5 10,20
    # compute the inverse:
    t.inverted.to_s   # r270 *0.666666667 -13,7
    # Combine with another displacement (applied after that):
    (RBA::CplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25
    # Transform a point:
    t.trans(RBA::Point::new(100, 200)).to_s # -290,170
    @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[DCplxTrans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: float
    r"""
    @brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple trans (i.e. \Trans), a rotation angle of 180 degree delivers a value of 2 for the angle attribute. The complex transformation, supporting any rotation angle returns the angle in degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).
    @brief Sets the angle
    @param a The new angle
    See \angle for a description of that attribute.
    """
    disp: DVector
    r"""
    @brief Gets the displacement
    @brief Sets the displacement
    @param u The new displacement
    """
    mag: float
    r"""
    @brief Gets the magnification
    @brief Sets the magnification
    @param m The new magnification
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag
    """
    @classmethod
    def from_s(cls, s: str) -> DCplxTrans:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> DCplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Creates a transformation from a magnification

        Creates a magnifying transformation without displacement and rotation given the magnification m.
        """
    @overload
    def __init__(self, t: DTrans) -> None:
        r"""
        @brief Creates a transformation from a simple transformation alone

        Creates a magnifying transformation from a simple transformation and a magnification of 1.0.
        """
    @overload
    def __init__(self, trans: CplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_itrans'.
        """
    @overload
    def __init__(self, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, trans: VCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, u: DVector) -> None:
        r"""
        @brief Creates a transformation from a displacement

        Creates a transformation with a displacement only.

        This method has been added in version 0.25.
        """
    @overload
    def __init__(self, t: DTrans, m: float) -> None:
        r"""
        @brief Creates a transformation from a simple transformation and a magnification

        Creates a magnifying transformation from a simple transformation and a magnification.
        """
    @overload
    def __init__(self, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation from a x and y displacement

        This constructor will create a transformation with the specified displacement
        but no rotation.

        @param x The x displacement
        @param y The y displacement
        """
    @overload
    def __init__(self, c: DCplxTrans, m: Optional[float] = ..., u: Optional[DVector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, c: DCplxTrans, m: float, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, u: DVector) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param x The x displacement
        @param y The y displacement
        """
    def __lt__(self, other: DCplxTrans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: DBox) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: DEdge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, p: DVector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __mul__(self, path: DPath) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: DPolygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: CplxTrans) -> CplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: DCplxTrans) -> DCplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: DText) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: DBox) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: DEdge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: DPoint) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: DVector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __rmul__(self, path: DPath) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: DPolygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: CplxTrans) -> CplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: DCplxTrans) -> DCplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: DText) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: DCplxTrans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: float) -> float:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> DCplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> DCplxTrans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> DCplxTrans:
        r"""
        @brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation
        """
    def is_complex(self) -> bool:
        r"""
        @brief Returns true if the transformation is a complex one

        If this predicate is false, the transformation can safely be converted to a simple transformation.
        Otherwise, this conversion will be lossy.
        The predicate value is equivalent to 'is_mag || !is_ortho'.

        This method has been introduced in version 0.27.5.
        """
    def is_mag(self) -> bool:
        r"""
        @brief Tests, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents
        a magnification.
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def is_ortho(self) -> bool:
        r"""
        @brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.
        """
    def is_unity(self) -> bool:
        r"""
        @brief Tests, whether this is a unit transformation
        """
    def rot(self) -> int:
        r"""
        @brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method
        will return the corresponding fixpoint transformation, not taking into account
        magnification and displacement. If the transformation is not orthogonal, the result
        reflects the quadrant the rotation goes into.
        """
    def s_trans(self) -> DTrans:
        r"""
        @brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles.
        Rotation angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.
        """
    def to_itrans(self, dbu: Optional[float] = ...) -> ICplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer input and output coordinates

        The database unit can be specified to translate the floating-point coordinate displacement in micron units to an integer-coordinate displacement in database units. The displacement's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_trans(self) -> CplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer input coordinates

        This method has been introduced in version 0.25.
        """
    def to_vtrans(self, dbu: Optional[float] = ...) -> VCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer output coordinates

        The database unit can be specified to translate the floating-point coordinate displacement in micron units to an integer-coordinate displacement in database units. The displacement's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    @overload
    def trans(self, box: DBox) -> DBox:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: DEdge) -> DEdge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: DPoint) -> DPoint:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, p: DVector) -> DVector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def trans(self, path: DPath) -> DPath:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: DPolygon) -> DPolygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: DText) -> DText:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """

class CplxTrans:
    r"""
    @brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an arbitrary
    angle and a displacement. This is also the order, the operations are applied.
    This version can transform integer-coordinate objects into floating-point coordinate objects. This is the generic and exact case, for example for non-integer magnifications.

    Complex transformations are extensions of the simple transformation classes (\Trans or \DTrans in that case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be combined with the '*' operator to form the transformation which is equivalent to applying the second and then the first. Here is some code:

    @code
    # Create a transformation that applies a magnification of 1.5, a rotation by 90 degree
    # and displacement of 10 in x and 20 units in y direction:
    t = RBA::DCplxTrans::new(1.5, 90, false, 10.0, 20.0)
    t.to_s            # r90 *1.5 10,20
    # compute the inverse:
    t.inverted.to_s   # r270 *0.666666667 -13,7
    # Combine with another displacement (applied after that):
    (RBA::DCplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25
    # Transform a point:
    t.trans(RBA::DPoint::new(100, 200)).to_s # -290,170
    @/code

    The inverse type of the CplxTrans type is VCplxTrans which will transform floating-point to integer coordinate objects. Transformations of CplxTrans type can be concatenated (operator *) with either itself or with transformations of compatible input or output type. This means, the operator CplxTrans * ICplxTrans is allowed (output types of ICplxTrans and input of CplxTrans are identical) while CplxTrans * DCplxTrans is not.
    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[CplxTrans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: float
    r"""
    @brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple trans (i.e. \Trans), a rotation angle of 180 degree delivers a value of 2 for the angle attribute. The complex transformation, supporting any rotation angle returns the angle in degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).
    @brief Sets the angle
    @param a The new angle
    See \angle for a description of that attribute.
    """
    disp: DVector
    r"""
    @brief Gets the displacement
    @brief Sets the displacement
    @param u The new displacement
    """
    mag: float
    r"""
    @brief Gets the magnification
    @brief Sets the magnification
    @param m The new magnification
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag
    """
    @classmethod
    def from_s(cls, s: str) -> CplxTrans:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> CplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Creates a transformation from a magnification

        Creates a magnifying transformation without displacement and rotation given the magnification m.
        """
    @overload
    def __init__(self, t: Trans) -> None:
        r"""
        @brief Creates a transformation from a simple transformation alone

        Creates a magnifying transformation from a simple transformation and a magnification of 1.0.
        """
    @overload
    def __init__(self, trans: DCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dtrans'.
        """
    @overload
    def __init__(self, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, trans: VCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, u: DVector) -> None:
        r"""
        @brief Creates a transformation from a displacement

        Creates a transformation with a displacement only.

        This method has been added in version 0.25.
        """
    @overload
    def __init__(self, t: Trans, m: float) -> None:
        r"""
        @brief Creates a transformation from a simple transformation and a magnification

        Creates a magnifying transformation from a simple transformation and a magnification.
        """
    @overload
    def __init__(self, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation from a x and y displacement

        This constructor will create a transformation with the specified displacement
        but no rotation.

        @param x The x displacement
        @param y The y displacement
        """
    @overload
    def __init__(self, c: CplxTrans, m: Optional[float] = ..., u: Optional[DVector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, c: CplxTrans, m: float, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, u: DVector) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param x The x displacement
        @param y The y displacement
        """
    def __lt__(self, other: CplxTrans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: Box) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: Edge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: Point) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, p: Vector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __mul__(self, path: Path) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: Polygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: CplxTrans) -> CplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: ICplxTrans) -> CplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: VCplxTrans) -> DCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: Text) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: Box) -> DBox:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: Edge) -> DEdge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: Point) -> DPoint:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: Vector) -> DVector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __rmul__(self, path: Path) -> DPath:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: Polygon) -> DPolygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: CplxTrans) -> CplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: ICplxTrans) -> CplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: VCplxTrans) -> DCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: Text) -> DText:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: CplxTrans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: int) -> float:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> CplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> CplxTrans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> VCplxTrans:
        r"""
        @brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation
        """
    def is_complex(self) -> bool:
        r"""
        @brief Returns true if the transformation is a complex one

        If this predicate is false, the transformation can safely be converted to a simple transformation.
        Otherwise, this conversion will be lossy.
        The predicate value is equivalent to 'is_mag || !is_ortho'.

        This method has been introduced in version 0.27.5.
        """
    def is_mag(self) -> bool:
        r"""
        @brief Tests, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents
        a magnification.
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def is_ortho(self) -> bool:
        r"""
        @brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.
        """
    def is_unity(self) -> bool:
        r"""
        @brief Tests, whether this is a unit transformation
        """
    def rot(self) -> int:
        r"""
        @brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method
        will return the corresponding fixpoint transformation, not taking into account
        magnification and displacement. If the transformation is not orthogonal, the result
        reflects the quadrant the rotation goes into.
        """
    def s_trans(self) -> Trans:
        r"""
        @brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles.
        Rotation angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.
        """
    def to_itrans(self, dbu: Optional[float] = ...) -> ICplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer input and output coordinates

        The database unit can be specified to translate the floating-point coordinate displacement in micron units to an integer-coordinate displacement in database units. The displacement's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_trans(self) -> DCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with floating-point input coordinates

        This method has been introduced in version 0.25.
        """
    def to_vtrans(self, dbu: Optional[float] = ...) -> VCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer output and floating-point input coordinates

        The database unit can be specified to translate the floating-point coordinate displacement in micron units to an integer-coordinate displacement in database units. The displacement's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.
        """
    @overload
    def trans(self, box: Box) -> DBox:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: Edge) -> DEdge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: Point) -> DPoint:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, p: Vector) -> DVector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def trans(self, path: Path) -> DPath:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: Polygon) -> DPolygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: Text) -> DText:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """

class ICplxTrans:
    r"""
    @brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an arbitrary
    angle and a displacement. This is also the order, the operations are applied.
    This version can transform integer-coordinate objects into the same, which may involve rounding and can be inexact.

    Complex transformations are extensions of the simple transformation classes (\Trans in that case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be combined with the '*' operator to form the transformation which is equivalent to applying the second and then the first. Here is some code:

    @code
    # Create a transformation that applies a magnification of 1.5, a rotation by 90 degree
    # and displacement of 10 in x and 20 units in y direction:
    t = RBA::ICplxTrans::new(1.5, 90, false, 10.0, 20.0)
    t.to_s            # r90 *1.5 10,20
    # compute the inverse:
    t.inverted.to_s   # r270 *0.666666667 -13,7
    # Combine with another displacement (applied after that):
    (RBA::ICplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25
    # Transform a point:
    t.trans(RBA::Point::new(100, 200)).to_s  # -290,170
    @/code

    This class has been introduced in version 0.18.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[ICplxTrans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: float
    r"""
    @brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple trans (i.e. \Trans), a rotation angle of 180 degree delivers a value of 2 for the angle attribute. The complex transformation, supporting any rotation angle returns the angle in degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).
    @brief Sets the angle
    @param a The new angle
    See \angle for a description of that attribute.
    """
    disp: Vector
    r"""
    @brief Gets the displacement
    @brief Sets the displacement
    @param u The new displacement
    """
    mag: float
    r"""
    @brief Gets the magnification
    @brief Sets the magnification
    @param m The new magnification
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag
    """
    @classmethod
    def from_s(cls, s: str) -> ICplxTrans:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> ICplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Creates a transformation from a magnification

        Creates a magnifying transformation without displacement and rotation given the magnification m.
        """
    @overload
    def __init__(self, t: Trans) -> None:
        r"""
        @brief Creates a transformation from a simple transformation alone

        Creates a magnifying transformation from a simple transformation and a magnification of 1.0.
        """
    @overload
    def __init__(self, trans: CplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_trans'.
        """
    @overload
    def __init__(self, trans: DCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method 'from_dtrans'.
        """
    @overload
    def __init__(self, trans: VCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25.
        """
    @overload
    def __init__(self, u: Vector) -> None:
        r"""
        @brief Creates a transformation from a displacement

        Creates a transformation with a displacement only.

        This method has been added in version 0.25.
        """
    @overload
    def __init__(self, t: Trans, m: float) -> None:
        r"""
        @brief Creates a transformation from a simple transformation and a magnification

        Creates a magnifying transformation from a simple transformation and a magnification.
        """
    @overload
    def __init__(self, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation from a x and y displacement

        This constructor will create a transformation with the specified displacement
        but no rotation.

        @param x The x displacement
        @param y The y displacement
        """
    @overload
    def __init__(self, c: ICplxTrans, m: Optional[float] = ..., u: Optional[Vector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, c: ICplxTrans, m: float, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, u: Vector) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param x The x displacement
        @param y The y displacement
        """
    def __lt__(self, other: ICplxTrans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: Box) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: Edge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, p: Vector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __mul__(self, path: Path) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: Polygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: ICplxTrans) -> ICplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: VCplxTrans) -> VCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: Text) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: Box) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: Edge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: Point) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: Vector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __rmul__(self, path: Path) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: Polygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: ICplxTrans) -> ICplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: VCplxTrans) -> VCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: Text) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: ICplxTrans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: int) -> int:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> ICplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> ICplxTrans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> ICplxTrans:
        r"""
        @brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation
        """
    def is_complex(self) -> bool:
        r"""
        @brief Returns true if the transformation is a complex one

        If this predicate is false, the transformation can safely be converted to a simple transformation.
        Otherwise, this conversion will be lossy.
        The predicate value is equivalent to 'is_mag || !is_ortho'.

        This method has been introduced in version 0.27.5.
        """
    def is_mag(self) -> bool:
        r"""
        @brief Tests, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents
        a magnification.
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def is_ortho(self) -> bool:
        r"""
        @brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.
        """
    def is_unity(self) -> bool:
        r"""
        @brief Tests, whether this is a unit transformation
        """
    def rot(self) -> int:
        r"""
        @brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method
        will return the corresponding fixpoint transformation, not taking into account
        magnification and displacement. If the transformation is not orthogonal, the result
        reflects the quadrant the rotation goes into.
        """
    def s_trans(self) -> Trans:
        r"""
        @brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles.
        Rotation angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.
        """
    def to_itrans(self, dbu: Optional[float] = ...) -> DCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with floating-point input and output coordinates

        The database unit can be specified to translate the integer coordinate displacement in database units to a floating-point displacement in micron units. The displacement's' coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_trans(self) -> VCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with floating-point input coordinates

        This method has been introduced in version 0.25.
        """
    def to_vtrans(self, dbu: Optional[float] = ...) -> CplxTrans:
        r"""
        @brief Converts the transformation to another transformation with floating-point output coordinates

        The database unit can be specified to translate the integer coordinate displacement in database units to a floating-point displacement in micron units. The displacement's' coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.
        """
    @overload
    def trans(self, box: Box) -> Box:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: Edge) -> Edge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: Point) -> Point:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, p: Vector) -> Vector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def trans(self, path: Path) -> Path:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: Polygon) -> Polygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: Text) -> Text:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """

class VCplxTrans:
    r"""
    @brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an arbitrary
    angle and a displacement. This is also the order, the operations are applied.
    This version can transform floating point coordinate objects into integer coordinate objects, which may involve rounding and can be inexact.

    Complex transformations are extensions of the simple transformation classes (\Trans in that case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be combined with the '*' operator to form the transformation which is equivalent to applying the second and then the first. Here is some code:

    @code
    # Create a transformation that applies a magnification of 1.5, a rotation by 90 degree
    # and displacement of 10 in x and 20 units in y direction:
    t = RBA::VCplxTrans::new(1.5, 90, false, 10, 20)
    t.to_s            # r90 *1.5 10,20
    # compute the inverse:
    t.inverted.to_s   # r270 *0.666666667 -13,7
    # Combine with another displacement (applied after that):
    (RBA::VCplxTrans::new(5, 5) * t).to_s     # r90 *1.5 15,25
    # Transform a point:
    t.trans(RBA::DPoint::new(100, 200)).to_s  # -290,170
    @/code

    The VCplxTrans type is the inverse transformation of the CplxTrans transformation and vice versa.Transformations of VCplxTrans type can be concatenated (operator *) with either itself or with transformations of compatible input or output type. This means, the operator VCplxTrans * CplxTrans is allowed (output types of CplxTrans and input of VCplxTrans are identical) while VCplxTrans * ICplxTrans is not.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    M0: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "mirrored at the x-axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M135: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "mirrored at the 135 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M45: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "mirrored at the 45 degree axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    M90: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "mirrored at the y (90 degree) axis" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R0: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "unrotated" (unit) transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R180: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "rotated by 180 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R270: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "rotated by 270 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    R90: ClassVar[VCplxTrans]
    r"""
    @brief A constant giving "rotated by 90 degree counterclockwise" transformation
    The previous integer constant has been turned into a transformation in version 0.25.
    """
    angle: float
    r"""
    @brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple trans (i.e. \Trans), a rotation angle of 180 degree delivers a value of 2 for the angle attribute. The complex transformation, supporting any rotation angle returns the angle in degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).
    @brief Sets the angle
    @param a The new angle
    See \angle for a description of that attribute.
    """
    disp: Vector
    r"""
    @brief Gets the displacement
    @brief Sets the displacement
    @param u The new displacement
    """
    mag: float
    r"""
    @brief Gets the magnification
    @brief Sets the magnification
    @param m The new magnification
    """
    mirror: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets the mirror flag
    "mirroring" describes a reflection at the x-axis which is included in the transformation prior to rotation.@param m The new mirror flag
    """
    @classmethod
    def from_s(cls, s: str) -> VCplxTrans:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)

        This method has been added in version 0.23.
        """
    def __copy__(self) -> VCplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, other: object) -> bool:
        r"""
        @brief Tests for equality
        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Creates a unit transformation
        """
    @overload
    def __init__(self, m: float) -> None:
        r"""
        @brief Creates a transformation from a magnification

        Creates a magnifying transformation without displacement and rotation given the magnification m.
        """
    @overload
    def __init__(self, t: DTrans) -> None:
        r"""
        @brief Creates a transformation from a simple transformation alone

        Creates a magnifying transformation from a simple transformation and a magnification of 1.0.
        """
    @overload
    def __init__(self, trans: CplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour
        """
    @overload
    def __init__(self, trans: DCplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour
        """
    @overload
    def __init__(self, trans: ICplxTrans) -> None:
        r"""
        @brief Creates a floating-point coordinate transformation from another coordinate flavour
        """
    @overload
    def __init__(self, u: Vector) -> None:
        r"""
        @brief Creates a transformation from a displacement

        Creates a transformation with a displacement only.

        This method has been added in version 0.25.
        """
    @overload
    def __init__(self, t: DTrans, m: float) -> None:
        r"""
        @brief Creates a transformation from a simple transformation and a magnification

        Creates a magnifying transformation from a simple transformation and a magnification.
        """
    @overload
    def __init__(self, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation from a x and y displacement

        This constructor will create a transformation with the specified displacement
        but no rotation.

        @param x The x displacement
        @param y The y displacement
        """
    @overload
    def __init__(self, c: VCplxTrans, m: Optional[float] = ..., u: Optional[Vector] = ...) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param u The Additional displacement
        """
    @overload
    def __init__(self, c: VCplxTrans, m: float, x: float, y: float) -> None:
        r"""
        @brief Creates a transformation from another transformation plus a magnification and displacement

        Creates a new transformation from a existing transformation. This constructor is provided for creating duplicates and backward compatibility since the constants are transformations now. It will copy the original transformation and add the given displacement.

        This variant has been introduced in version 0.25.

        @param c The original transformation
        @param x The Additional displacement (x)
        @param y The Additional displacement (y)
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, u: Vector) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param u The displacement
        """
    @overload
    def __init__(self, mag: float, rot: float, mirrx: bool, x: int, y: int) -> None:
        r"""
        @brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis,
        rotation, application of displacement.

        @param mag The magnification
        @param rot The rotation angle in units of degree
        @param mirrx True, if mirrored at x axis
        @param x The x displacement
        @param y The y displacement
        """
    def __lt__(self, other: VCplxTrans) -> bool:
        r"""
        @brief Provides a 'less' criterion for sorting
        This method is provided to implement a sorting order. The definition of 'less' is opaque and might change in future versions.
        """
    @overload
    def __mul__(self, box: DBox) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, edge: DEdge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, p: DPoint) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __mul__(self, p: DVector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __mul__(self, path: DPath) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, polygon: DPolygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __mul__(self, t: CplxTrans) -> ICplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: DCplxTrans) -> VCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, t: VCplxTrans) -> VCplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __mul__(self, text: DText) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __ne__(self, other: object) -> bool:
        r"""
        @brief Tests for inequality
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, box: DBox) -> Box:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, edge: DEdge) -> Edge:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, p: DPoint) -> Point:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def __rmul__(self, p: DVector) -> Vector:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def __rmul__(self, path: DPath) -> Path:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, polygon: DPolygon) -> Polygon:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def __rmul__(self, t: CplxTrans) -> ICplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: DCplxTrans) -> VCplxTrans:
        r"""
        @brief Multiplication (concatenation) of transformations

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, t: VCplxTrans) -> VCplxTrans:
        r"""
        @brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before
        @return The modified transformation
        """
    @overload
    def __rmul__(self, text: DText) -> Text:
        r"""
        Note: This is an alias of 'trans'.
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: VCplxTrans) -> None:
        r"""
        @brief Assigns another object to self
        """
    def ctrans(self, d: float) -> int:
        r"""
        @brief Transforms a distance

        The "ctrans" method transforms the given distance.
        e = t(d). For the simple transformations, there
        is no magnification and no modification of the distance
        therefore.

        @param d The distance to transform
        @return The transformed distance
        """
    def dup(self) -> VCplxTrans:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given transformation. This method enables transformations as hash keys.

        This method has been introduced in version 0.25.
        """
    def invert(self) -> VCplxTrans:
        r"""
        @brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's
        inverted one.

        @return The inverted transformation
        """
    def inverted(self) -> CplxTrans:
        r"""
        @brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation
        """
    def is_complex(self) -> bool:
        r"""
        @brief Returns true if the transformation is a complex one

        If this predicate is false, the transformation can safely be converted to a simple transformation.
        Otherwise, this conversion will be lossy.
        The predicate value is equivalent to 'is_mag || !is_ortho'.

        This method has been introduced in version 0.27.5.
        """
    def is_mag(self) -> bool:
        r"""
        @brief Tests, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents
        a magnification.
        """
    def is_mirror(self) -> bool:
        r"""
        @brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis followed by a rotation by the angle given by the \angle property. 
        """
    def is_ortho(self) -> bool:
        r"""
        @brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.
        """
    def is_unity(self) -> bool:
        r"""
        @brief Tests, whether this is a unit transformation
        """
    def rot(self) -> int:
        r"""
        @brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method
        will return the corresponding fixpoint transformation, not taking into account
        magnification and displacement. If the transformation is not orthogonal, the result
        reflects the quadrant the rotation goes into.
        """
    def s_trans(self) -> DTrans:
        r"""
        @brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles.
        Rotation angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.
        """
    def to_itrans(self, dbu: Optional[float] = ...) -> DCplxTrans:
        r"""
        @brief Converts the transformation to another transformation with floating-point output coordinates

        The database unit can be specified to translate the integer coordinate displacement in database units to a floating-point displacement in micron units. The displacement's' coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def to_trans(self) -> ICplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer input coordinates

        This method has been introduced in version 0.25.
        """
    def to_vtrans(self, dbu: Optional[float] = ...) -> CplxTrans:
        r"""
        @brief Converts the transformation to another transformation with integer input and floating-point output coordinates

        The database unit can be specified to translate the integer coordinate displacement in database units to an floating-point displacement in micron units. The displacement's' coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.
        """
    @overload
    def trans(self, box: DBox) -> Box:
        r"""
        @brief Transforms a box

        't*box' or 't.trans(box)' is equivalent to box.transformed(t).

        @param box The box to transform
        @return The transformed box

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, edge: DEdge) -> Edge:
        r"""
        @brief Transforms an edge

        't*edge' or 't.trans(edge)' is equivalent to edge.transformed(t).

        @param edge The edge to transform
        @return The transformed edge

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, p: DPoint) -> Point:
        r"""
        @brief Transforms a point

        The "trans" method or the * operator transforms the given point.
        q = t(p)

        The * operator has been introduced in version 0.25.

        @param p The point to transform
        @return The transformed point
        """
    @overload
    def trans(self, p: DVector) -> Vector:
        r"""
        @brief Transforms a vector

        The "trans" method or the * operator transforms the given vector.
        w = t(v)

        Vector transformation has been introduced in version 0.25.

        @param v The vector to transform
        @return The transformed vector
        """
    @overload
    def trans(self, path: DPath) -> Path:
        r"""
        @brief Transforms a path

        't*path' or 't.trans(path)' is equivalent to path.transformed(t).

        @param path The path to transform
        @return The transformed path

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, polygon: DPolygon) -> Polygon:
        r"""
        @brief Transforms a polygon

        't*polygon' or 't.trans(polygon)' is equivalent to polygon.transformed(t).

        @param polygon The polygon to transform
        @return The transformed polygon

        This convenience method has been introduced in version 0.25.
        """
    @overload
    def trans(self, text: DText) -> Text:
        r"""
        @brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform
        @return The transformed text

        This convenience method has been introduced in version 0.25.
        """

class Utils:
    r"""
    @brief This namespace provides a collection of utility functions

    This class has been introduced in version 0.27.
    """
    def __copy__(self) -> Utils:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: Utils) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> Utils:
        r"""
        @brief Creates a copy of self
        """
    @overload
    def spline_interpolation(self, control_points: Sequence[DPoint], degree: int, knots: Sequence[float], relative_accuracy: float, absolute_accuracy: float) -> List[DPoint]:
        r"""
        @brief This function computes the Spline curve for a given set of control points (point, weight), degree and knots.

        This is the version for non-rational splines. It lacks the weight vector.
        """
    @overload
    def spline_interpolation(self, control_points: Sequence[Point], degree: int, knots: Sequence[float], relative_accuracy: float, absolute_accuracy: float) -> List[Point]:
        r"""
        @brief This function computes the Spline curve for a given set of control points (point, weight), degree and knots.

        This is the version for integer-coordinate points for non-rational splines.
        """
    @overload
    def spline_interpolation(self, control_points: Sequence[DPoint], weights: Sequence[float], degree: int, knots: Sequence[float], relative_accuracy: float, absolute_accuracy: float) -> List[DPoint]:
        r"""
        @brief This function computes the Spline curve for a given set of control points (point, weight), degree and knots.

        The knot vector needs to be padded and it's size must fulfill the condition:

        @code
          knots.size == control_points.size + degree + 1
        @/code

        The accuracy parameters allow tuning the resolution of the curve to target a specific approximation quality.
        "relative_accuracy" gives the accuracy relative to the local curvature radius, "absolute" accuracy gives the
        absolute accuracy. "accuracy" is the allowed deviation of polygon approximation from the ideal curve.
        The computed curve should meet at least one of the accuracy criteria. Setting both limits to a very small
        value will result in long run times and a large number of points returned.

        This function supports both rational splines (NURBS) and non-rational splines. The latter use weights of
        1.0 for each point.

        The return value is a list of points forming a path which approximates the spline curve.
        """
    @overload
    def spline_interpolation(self, control_points: Sequence[Point], weights: Sequence[float], degree: int, knots: Sequence[float], relative_accuracy: float, absolute_accuracy: float) -> List[Point]:
        r"""
        @brief This function computes the Spline curve for a given set of control points (point, weight), degree and knots.

        This is the version for integer-coordinate points.
        """

class DVector:
    r"""
    @brief A vector class with double (floating-point) coordinates
    A vector is a distance in cartesian, 2 dimensional space. A vector is given by two coordinates (x and y) and represents the distance between two points. Being the distance, transformations act differently on vectors: the displacement is not applied. 
    Vectors are not geometrical objects by itself. But they are frequently used in the database API for various purposes. Other than the integer variant (\Vector), points with floating-point coordinates can represent fractions of a database unit or vectors in physical (micron) units.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    x: float
    r"""
    @brief Accessor to the x coordinate
    @brief Write accessor to the x coordinate
    """
    y: float
    r"""
    @brief Accessor to the y coordinate
    @brief Write accessor to the y coordinate
    """
    @classmethod
    def from_s(cls, s: str) -> DVector:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)
        """
    @overload
    def __add__(self, p: DPoint) -> DPoint:
        r"""
        @brief Adds a vector and a point


        Returns the point p shifted by the vector.
        """
    @overload
    def __add__(self, v: DVector) -> DVector:
        r"""
        @brief Adds two vectors


        Adds vector v to self by adding the coordinates.
        """
    def __copy__(self) -> DVector:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, v: object) -> bool:
        r"""
        @brief Equality test operator

        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given vector. This method enables vectors as hash keys.

        This method has been introduced in version 0.25.
        """
    def __imul__(self, f: float) -> DVector:
        r"""
        @brief Scaling by some factor


        Scales object in place. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a null vector with coordinates (0,0)
        """
    @overload
    def __init__(self, p: DPoint) -> None:
        r"""
        @brief Default constructor: creates a vector from a point
        This constructor is equivalent to computing p-point(0,0).
        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self, vector: Vector) -> None:
        r"""
        @brief Creates a floating-point coordinate vector from an integer coordinate vector
        """
    @overload
    def __init__(self, x: float, y: float) -> None:
        r"""
        @brief Constructor for a vector from two coordinate values

        """
    def __itruediv__(self, d: float) -> DVector:
        r"""
        @brief Division by some divisor


        Divides the object in place. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def __lt__(self, v: DVector) -> bool:
        r"""
        @brief "less" comparison operator


        This operator is provided to establish a sorting
        order
        """
    @overload
    def __mul__(self, f: float) -> DVector:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __mul__(self, v: DVector) -> float:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def __ne__(self, v: object) -> bool:
        r"""
        @brief Inequality test operator

        """
    def __neg__(self) -> DVector:
        r"""
        @brief Compute the negative of a vector


        Returns a new vector with -x,-y.
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, f: float) -> DVector:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __rmul__(self, v: DVector) -> float:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def __sub__(self, v: DVector) -> DVector:
        r"""
        @brief Subtract two vectors


        Subtract vector v from self by subtracting the coordinates.
        """
    def __truediv__(self, d: float) -> DVector:
        r"""
        @brief Division by some divisor


        Returns the scaled object. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def abs(self) -> float:
        r"""
        Note: This is an alias of 'length'.
        @brief Returns the length of the vector
        'abs' is an alias provided for compatibility with the former point type.
        """
    def assign(self, other: DVector) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> DVector:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given vector. This method enables vectors as hash keys.

        This method has been introduced in version 0.25.
        """
    def length(self) -> float:
        r"""
        @brief Returns the length of the vector
        'abs' is an alias provided for compatibility with the former point type.
        """
    def sprod(self, v: DVector) -> float:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def sprod_sign(self, v: DVector) -> int:
        r"""
        @brief Computes the scalar product between self and the given vector and returns a value indicating the sign of the product


        @return 1 if the scalar product is positive, 0 if it is zero and -1 if it is negative.
        """
    def sq_abs(self) -> float:
        r"""
        Note: This is an alias of 'sq_length'.
        @brief The square length of the vector
        'sq_abs' is an alias provided for compatibility with the former point type.
        """
    def sq_length(self) -> float:
        r"""
        @brief The square length of the vector
        'sq_abs' is an alias provided for compatibility with the former point type.
        """
    def to_itype(self, dbu: Optional[float] = ...) -> Vector:
        r"""
        @brief Converts the point to an integer coordinate point

        The database unit can be specified to translate the floating-point coordinate vector in micron units to an integer-coordinate vector in database units. The vector's' coordinates will be divided by the database unit.
        """
    def to_p(self) -> DPoint:
        r"""
        @brief Turns the vector into a point
        This method returns the point resulting from adding the vector to (0,0).
        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def vprod(self, v: DVector) -> float:
        r"""
        @brief Computes the vector product between self and the given vector


        The vector product of a and b is defined as: vp = ax*by-ay*bx.
        """
    def vprod_sign(self, v: DVector) -> int:
        r"""
        @brief Computes the vector product between self and the given vector and returns a value indicating the sign of the product


        @return 1 if the vector product is positive, 0 if it is zero and -1 if it is negative.
        """

class Vector:
    r"""
    @brief A integer vector class
    A vector is a distance in cartesian, 2 dimensional space. A vector is given by two coordinates (x and y) and represents the distance between two points. Being the distance, transformations act differently on vectors: the displacement is not applied. 
    Vectors are not geometrical objects by itself. But they are frequently used in the database API for various purposes.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the database objects.
    """
    x: int
    r"""
    @brief Accessor to the x coordinate
    @brief Write accessor to the x coordinate
    """
    y: int
    r"""
    @brief Accessor to the y coordinate
    @brief Write accessor to the y coordinate
    """
    @classmethod
    def from_s(cls, s: str) -> Vector:
        r"""
        @brief Creates an object from a string
        Creates the object from a string representation (as returned by \to_s)
        """
    @overload
    def __add__(self, p: Point) -> Point:
        r"""
        @brief Adds a vector and a point


        Returns the point p shifted by the vector.
        """
    @overload
    def __add__(self, v: Vector) -> Vector:
        r"""
        @brief Adds two vectors


        Adds vector v to self by adding the coordinates.
        """
    def __copy__(self) -> Vector:
        r"""
        @brief Creates a copy of self
        """
    def __eq__(self, v: object) -> bool:
        r"""
        @brief Equality test operator

        """
    def __hash__(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given vector. This method enables vectors as hash keys.

        This method has been introduced in version 0.25.
        """
    def __imul__(self, f: float) -> Vector:
        r"""
        @brief Scaling by some factor


        Scales object in place. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __init__(self) -> None:
        r"""
        @brief Default constructor: creates a null vector with coordinates (0,0)
        """
    @overload
    def __init__(self, dvector: DVector) -> None:
        r"""
        @brief Creates an integer coordinate vector from a floating-point coordinate vector
        """
    @overload
    def __init__(self, p: Point) -> None:
        r"""
        @brief Default constructor: creates a vector from a point
        This constructor is equivalent to computing p-point(0,0).
        This method has been introduced in version 0.25.
        """
    @overload
    def __init__(self, x: int, y: int) -> None:
        r"""
        @brief Constructor for a vector from two coordinate values

        """
    def __itruediv__(self, d: float) -> Vector:
        r"""
        @brief Division by some divisor


        Divides the object in place. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def __lt__(self, v: Vector) -> bool:
        r"""
        @brief "less" comparison operator


        This operator is provided to establish a sorting
        order
        """
    @overload
    def __mul__(self, f: float) -> Vector:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __mul__(self, v: Vector) -> int:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def __ne__(self, v: object) -> bool:
        r"""
        @brief Inequality test operator

        """
    def __neg__(self) -> Vector:
        r"""
        @brief Compute the negative of a vector


        Returns a new vector with -x,-y.
        """
    def __repr__(self) -> str:
        r"""
        @brief String conversion
        """
    @overload
    def __rmul__(self, f: float) -> Vector:
        r"""
        @brief Scaling by some factor


        Returns the scaled object. All coordinates are multiplied with the given factor and if necessary rounded.
        """
    @overload
    def __rmul__(self, v: Vector) -> int:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def __str__(self) -> str:
        r"""
        @brief String conversion
        """
    def __sub__(self, v: Vector) -> Vector:
        r"""
        @brief Subtract two vectors


        Subtract vector v from self by subtracting the coordinates.
        """
    def __truediv__(self, d: float) -> Vector:
        r"""
        @brief Division by some divisor


        Returns the scaled object. All coordinates are divided with the given divisor and if necessary rounded.
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def abs(self) -> float:
        r"""
        Note: This is an alias of 'length'.
        @brief Returns the length of the vector
        'abs' is an alias provided for compatibility with the former point type.
        """
    def assign(self, other: Vector) -> None:
        r"""
        @brief Assigns another object to self
        """
    def dup(self) -> Vector:
        r"""
        @brief Creates a copy of self
        """
    def hash(self) -> int:
        r"""
        @brief Computes a hash value
        Returns a hash value for the given vector. This method enables vectors as hash keys.

        This method has been introduced in version 0.25.
        """
    def length(self) -> float:
        r"""
        @brief Returns the length of the vector
        'abs' is an alias provided for compatibility with the former point type.
        """
    def sprod(self, v: Vector) -> int:
        r"""
        @brief Computes the scalar product between self and the given vector


        The scalar product of a and b is defined as: vp = ax*bx+ay*by.
        """
    def sprod_sign(self, v: Vector) -> int:
        r"""
        @brief Computes the scalar product between self and the given vector and returns a value indicating the sign of the product


        @return 1 if the scalar product is positive, 0 if it is zero and -1 if it is negative.
        """
    def sq_abs(self) -> float:
        r"""
        Note: This is an alias of 'sq_length'.
        @brief The square length of the vector
        'sq_abs' is an alias provided for compatibility with the former point type.
        """
    def sq_length(self) -> float:
        r"""
        @brief The square length of the vector
        'sq_abs' is an alias provided for compatibility with the former point type.
        """
    def to_dtype(self, dbu: Optional[float] = ...) -> DVector:
        r"""
        @brief Converts the vector to a floating-point coordinate vector
        The database unit can be specified to translate the integer-coordinate vector into a floating-point coordinate vector in micron units. The database unit is basically a scaling factor.
        """
    def to_p(self) -> Point:
        r"""
        @brief Turns the vector into a point
        This method returns the point resulting from adding the vector to (0,0).
        This method has been introduced in version 0.25.
        """
    def to_s(self) -> str:
        r"""
        @brief String conversion
        """
    def vprod(self, v: Vector) -> int:
        r"""
        @brief Computes the vector product between self and the given vector


        The vector product of a and b is defined as: vp = ax*by-ay*bx.
        """
    def vprod_sign(self, v: Vector) -> int:
        r"""
        @brief Computes the vector product between self and the given vector and returns a value indicating the sign of the product


        @return 1 if the vector product is positive, 0 if it is zero and -1 if it is negative.
        """

class LEFDEFReaderConfiguration:
    r"""
    @brief Detailed LEF/DEF reader options
    This class is a aggregate belonging to the \LoadLayoutOptions class. It provides options for the LEF/DEF reader. These options have been placed into a separate class to account for their complexity.
    This class specifically handles layer mapping. This is the process of generating layer names or GDS layer/datatypes from LEF/DEF layers and purpose combinations. There are basically two ways: to use a map file or to use pattern-based production rules.

    To use a layer map file, set the \map_file attribute to the name of the layer map file. The layer map file lists the GDS layer and datatype numbers to generate for the geometry.

    The pattern-based approach will use the layer name and attach a purpose-dependent suffix to it. Use the ..._suffix attributes to specify this suffix. For routing, the corresponding attribute is \routing_suffix for example. A purpose can also be mapped to a specific GDS datatype using the corresponding ..._datatype attributes.
    The decorated or undecorated names are looked up in a layer mapping table in the next step. The layer mapping table is specified using the \layer_map attribute. This table can be used to map layer names to specific GDS layers by using entries of the form 'NAME: layer-number'.

    If a layer map file is present, the pattern-based attributes are ignored.
    """
    blockages_datatype: int
    r"""
    @brief Gets the blockage marker layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the blockage marker layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    blockages_suffix: str
    r"""
    @brief Gets the blockage marker layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the blockage marker layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    cell_outline_layer: str
    r"""
    @brief Gets the layer on which to produce the cell outline (diearea).
    This attribute is a string corresponding to the string representation of \LayerInfo. This string can be either a layer number, a layer/datatype pair, a name or a combination of both. See \LayerInfo for details.
    The setter for this attribute is \cell_outline_layer=. See also \produce_cell_outlines.@brief Sets the layer on which to produce the cell outline (diearea).
    See \cell_outline_layer for details.
    """
    create_other_layers: bool
    r"""
    @brief Gets a value indicating whether layers not mapped in the layer map shall be created too
    See \layer_map for details.@brief Sets a value indicating whether layers not mapped in the layer map shall be created too
    See \layer_map for details.
    """
    dbu: float
    r"""
    @brief Gets the database unit to use for producing the layout.
    This value specifies the database to be used for the layout that is read. When a DEF file is specified with a different database unit, the layout is translated into this database unit.
    @brief Sets the database unit to use for producing the layout.
    See \dbu for details.
    """
    fills_datatype: int
    r"""
    @brief Gets the fill geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.@brief Sets the fill geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.
    """
    fills_datatype_str: str
    r"""
    @hide@hide
    """
    fills_suffix: str
    r"""
    @brief Gets the fill geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.@brief Sets the fill geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.
    """
    fills_suffix_str: str
    r"""
    @hide@hide
    """
    instance_property_name: Any
    r"""
    @brief Gets a value indicating whether and how to produce instance names as properties.
    If set to a value not nil, instance names will be attached to the instances generated as user properties.
    This attribute then specifies the user property name to be used for attaching the instance names.
    If set to nil, no instance names will be produced.

    The corresponding setter is \instance_property_name=.

    This method has been introduced in version 0.26.4.@brief Sets a value indicating whether and how to produce instance names as properties.
    See \instance_property_name for details.

    This method has been introduced in version 0.26.4.
    """
    labels_datatype: int
    r"""
    @brief Gets the labels layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the labels layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    labels_suffix: str
    r"""
    @brief Gets the label layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the label layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    layer_map: LayerMap
    r"""
    @brief Gets the layer map to be used for the LEF/DEF reader
    @return A reference to the layer map
    Because LEF/DEF layer mapping is substantially different than for normal layout files, the LEF/DEF reader employs a separate layer mapping table. The LEF/DEF specific layer mapping is stored within the LEF/DEF reader's configuration and can be accessed with this attribute. The layer mapping table of \LoadLayoutOptions will be ignored for the LEF/DEF reader.

    The setter is \layer_map=. \create_other_layers= is available to control whether layers not specified in the layer mapping table shall be created automatically.@brief Sets the layer map to be used for the LEF/DEF reader
    See \layer_map for details.
    """
    lef_files: List[str]
    r"""
    @brief Gets the list technology LEF files to additionally import
    Returns a list of path names for technology LEF files to read in addition to the primary file. Relative paths are resolved relative to the file to read or relative to the technology base path.

    The setter for this property is \lef_files=.@brief Sets the list technology LEF files to additionally import
    See \lef_files for details.
    """
    lef_labels_datatype: int
    r"""
    @brief Gets the lef_labels layer datatype value.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    @brief Sets the lef_labels layer datatype value.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    """
    lef_labels_suffix: str
    r"""
    @brief Gets the label layer name suffix.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    @brief Sets the label layer name suffix.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    """
    lef_pins_datatype: int
    r"""
    @brief Gets the LEF pin geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the LEF pin geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    lef_pins_datatype_str: str
    r"""
    @hide@hide
    """
    lef_pins_suffix: str
    r"""
    @brief Gets the LEF pin geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the LEF pin geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    lef_pins_suffix_str: str
    r"""
    @hide@hide
    """
    macro_layout_files: List[str]
    r"""
    @brief Gets the list of layout files to read for substituting macros in DEF
    These files play the same role than the macro layouts (see \macro_layouts), except that this property specifies a list of file names. The given files are loaded automatically to resolve macro layouts instead of LEF geometry. See \macro_resolution_mode for details when this happens. Relative paths are resolved relative to the DEF file to read or relative to the technology base path.
    Macros in need for substitution are looked up in the layout files by searching for cells with the same name. The files are scanned in the order they are given in the file list.
    The files from \macro_layout_files are scanned after the layout objects specified with \macro_layouts.

    The setter for this property is \macro_layout_files=.

    This property has been added in version 0.27.1.
    @brief Sets the list of layout files to read for substituting macros in DEF
    See \macro_layout_files for details.

    This property has been added in version 0.27.1.
    """
    macro_layouts: List[Layout]
    r"""
    @brief Gets the layout objects used for resolving LEF macros in the DEF reader.
    The DEF reader can either use LEF geometry or use a separate source of layouts for the LEF macros. The \macro_resolution_mode controls whether to use LEF geometry. If LEF geometry is not used, the DEF reader will look up macro cells from the \macro_layouts and pull cell layouts from there.

    The LEF cells are looked up as cells by name from the macro layouts in the order these are given in this array.

    \macro_layout_files is another way of specifying such substitution layouts. This method accepts file names instead of layout objects.

    This property has been added in version 0.27.
    @brief Sets the layout objects used for resolving LEF macros in the DEF reader.
    See \macro_layouts for more details about this property.

    Layout objects specified in the array for this property are not owned by the \LEFDEFReaderConfiguration object. Be sure to keep some other reference to these Layout objects if you are storing away the LEF/DEF reader configuration object.

    This property has been added in version 0.27.
    """
    macro_resolution_mode: int
    r"""
    @brief Gets the macro resolution mode (LEF macros into DEF).
    This property describes the way LEF macros are turned into layout cells when reading DEF. There are three modes available:

    @ul
      @li 0: produce LEF geometry unless a FOREIGN cell is specified @/li
      @li 1: produce LEF geometry always and ignore FOREIGN @/li
      @li 2: Never produce LEF geometry and assume FOREIGN always @/li
    @/ul

    If substitution layouts are specified with \macro_layouts, these are used to provide macro layouts in case no LEF geometry is taken.

    This property has been added in version 0.27.
    @brief Sets the macro resolution mode (LEF macros into DEF).
    See \macro_resolution_mode for details about this property.

    This property has been added in version 0.27.
    """
    map_file: str
    r"""
    @brief Gets the layer map file to use.
    If a layer map file is given, the reader will pull the layer mapping from this file. The layer mapping rules specified in the reader options are ignored in this case. These are the name suffix rules for vias, blockages, routing, special routing, pins etc. and the corresponding datatype rules. The \layer_map attribute will also be ignored. 
    The layer map file path will be resolved relative to the technology base path if the LEF/DEF reader options are used in the context of a technology.

    This property has been added in version 0.27.
    @brief Sets the layer map file to use.
    See \map_file for details about this property.

    This property has been added in version 0.27.
    """
    net_property_name: Any
    r"""
    @brief Gets a value indicating whether and how to produce net names as properties.
    If set to a value not nil, net names will be attached to the net shapes generated as user properties.
    This attribute then specifies the user property name to be used for attaching the net names.
    If set to nil, no net names will be produced.

    The corresponding setter is \net_property_name=.@brief Sets a value indicating whether and how to produce net names as properties.
    See \net_property_name for details.
    """
    obstructions_datatype: int
    r"""
    @brief Gets the obstruction marker layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the obstruction marker layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    obstructions_suffix: str
    r"""
    @brief Gets the obstruction marker layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the obstruction marker layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    paths_relative_to_cwd: None
    r"""
    WARNING: This variable can only be set, not retrieved.
    @brief Sets a value indicating whether to use paths relative to cwd (true) or DEF file (false) for map or LEF files
    This write-only attribute has been introduced in version 0.27.9.
    """
    pin_property_name: Any
    r"""
    @brief Gets a value indicating whether and how to produce pin names as properties.
    If set to a value not nil, pin names will be attached to the pin shapes generated as user properties.
    This attribute then specifies the user property name to be used for attaching the pin names.
    If set to nil, no pin names will be produced.

    The corresponding setter is \pin_property_name=.

    This method has been introduced in version 0.26.4.@brief Sets a value indicating whether and how to produce pin names as properties.
    See \pin_property_name for details.

    This method has been introduced in version 0.26.4.
    """
    pins_datatype: int
    r"""
    @brief Gets the pin geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the pin geometry layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    pins_datatype_str: str
    r"""
    @hide@hide
    """
    pins_suffix: str
    r"""
    @brief Gets the pin geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the pin geometry layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    pins_suffix_str: str
    r"""
    @hide@hide
    """
    placement_blockage_layer: str
    r"""
    @brief Gets the layer on which to produce the placement blockage.
    This attribute is a string corresponding to the string representation of \LayerInfo. This string can be either a layer number, a layer/datatype pair, a name or a combination of both. See \LayerInfo for details.The setter for this attribute is \placement_blockage_layer=. See also \produce_placement_blockages.@brief Sets the layer on which to produce the placement blockage.
    See \placement_blockage_layer for details.
    """
    produce_blockages: bool
    r"""
    @brief Gets a value indicating whether routing blockage markers shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether routing blockage markers shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_cell_outlines: bool
    r"""
    @brief Gets a value indicating whether to produce cell outlines (diearea).
    If set to true, cell outlines will be produced on the layer given by \cell_outline_layer. @brief Sets a value indicating whether to produce cell outlines (diearea).
    See \produce_cell_outlines for details.
    """
    produce_fills: bool
    r"""
    @brief Gets a value indicating whether fill geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.@brief Sets a value indicating whether fill geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.

    Fill support has been introduced in version 0.27.
    """
    produce_labels: bool
    r"""
    @brief Gets a value indicating whether labels shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether labels shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_lef_labels: bool
    r"""
    @brief Gets a value indicating whether lef_labels shall be produced.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    @brief Sets a value indicating whether lef_labels shall be produced.
    See \produce_via_geometry for details about the layer production rules.

    This method has been introduced in version 0.27.2
    """
    produce_lef_pins: bool
    r"""
    @brief Gets a value indicating whether LEF pin geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether LEF pin geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_obstructions: bool
    r"""
    @brief Gets a value indicating whether obstruction markers shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether obstruction markers shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_pins: bool
    r"""
    @brief Gets a value indicating whether pin geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether pin geometries shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_placement_blockages: bool
    r"""
    @brief Gets a value indicating whether to produce placement blockage regions.
    If set to true, polygons will be produced representing the placement blockage region on the layer given by \placement_blockage_layer. @brief Sets a value indicating whether to produce placement blockage regions.
    See \produce_placement_blockages for details.
    """
    produce_regions: bool
    r"""
    @brief Gets a value indicating whether to produce regions.
    If set to true, polygons will be produced representing the regions on the layer given by \region_layer.

    The attribute has been introduced in version 0.27.@brief Sets a value indicating whether to produce regions.
    See \produce_regions for details.

    The attribute has been introduced in version 0.27.
    """
    produce_routing: bool
    r"""
    @brief Gets a value indicating whether routing geometry shall be produced.
    See \produce_via_geometry for details about the layer production rules.@brief Sets a value indicating whether routing geometry shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    """
    produce_special_routing: bool
    r"""
    @brief Gets a value indicating whether special routing geometry shall be produced.
    See \produce_via_geometry for details about the layer production rules.

    The differentiation between special and normal routing has been introduced in version 0.27.@brief Sets a value indicating whether special routing geometry shall be produced.
    See \produce_via_geometry for details about the layer production rules.
    The differentiation between special and normal routing has been introduced in version 0.27.
    """
    produce_via_geometry: bool
    r"""
    @brief Sets a value indicating whether via geometries shall be produced.

    If set to true, shapes will be produced for each via. The layer to be produced will be determined from the via layer's name using the suffix provided by \via_geometry_suffix. If there is a specific mapping in the layer mapping table for the via layer including the suffix, the layer/datatype will be taken from the layer mapping table. If there is a mapping to the undecorated via layer, the datatype will be substituted with the \via_geometry_datatype value. If no mapping is defined, a unique number will be assigned to the layer number and the datatype will be taken from the \via_geometry_datatype value.

    For example: the via layer is 'V1', \via_geometry_suffix is 'GEO' and \via_geometry_datatype is 1. Then:

    @ul
    @li If there is a mapping for 'V1.GEO', the layer and datatype will be taken from there. @/li
    @li If there is a mapping for 'V1', the layer will be taken from there and the datatype will be taken from \via_geometry_datatype.     The name of the produced layer will be 'V1.GEO'. @/li
    @li If there is no mapping for both, the layer number will be a unique value, the datatype will be taken from \via_geometry_datatype     and the layer name will be 'V1.GEO'. @/li@/ul
    @brief Sets a value indicating whether via geometries shall be produced.
    See \produce_via_geometry for details.
    """
    read_lef_with_def: bool
    r"""
    @brief Gets a value indicating whether to read all LEF files in the same directory than the DEF file.
    If this property is set to true (the default), the DEF reader will automatically consume all LEF files next to the DEF file in addition to the LEF files specified with \lef_files. If set to false, only the LEF files specified with \lef_files will be read.

    This property has been added in version 0.27.
    @brief Sets a value indicating whether to read all LEF files in the same directory than the DEF file.
    See \read_lef_with_def for details about this property.

    This property has been added in version 0.27.
    """
    region_layer: str
    r"""
    @brief Gets the layer on which to produce the regions.
    This attribute is a string corresponding to the string representation of \LayerInfo. This string can be either a layer number, a layer/datatype pair, a name or a combination of both. See \LayerInfo for details.The setter for this attribute is \region_layer=. See also \produce_regions.

    The attribute has been introduced in version 0.27.@brief Sets the layer on which to produce the regions.
    See \region_layer for details.

    The attribute has been introduced in version 0.27.
    """
    routing_datatype: int
    r"""
    @brief Gets the routing layer datatype value.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the routing layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    """
    routing_datatype_str: str
    r"""
    @hide@hide
    """
    routing_suffix: str
    r"""
    @brief Gets the routing layer name suffix.
    See \produce_via_geometry for details about the layer production rules.@brief Sets the routing layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    """
    routing_suffix_str: str
    r"""
    @hide@hide
    """
    separate_groups: bool
    r"""
    @brief Gets a value indicating whether to create separate parent cells for individual groups.
    If this property is set to true, instances belonging to different groups are separated by putting them into individual parent cells. These parent cells are named after the groups and are put into the master top cell.
    If this property is set to false (the default), no such group parents will be formed.
    This property has been added in version 0.27.
    @brief Sets a value indicating whether to create separate parent cells for individual groups.
    See \separate_groups for details about this property.

    This property has been added in version 0.27.
    """
    special_routing_datatype: int
    r"""
    @brief Gets the special routing layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    The differentiation between special and normal routing has been introduced in version 0.27.@brief Sets the special routing layer datatype value.
    See \produce_via_geometry for details about the layer production rules.
    The differentiation between special and normal routing has been introduced in version 0.27.
    """
    special_routing_datatype_str: str
    r"""
    @hide@hide
    """
    special_routing_suffix: str
    r"""
    @brief Gets the special routing layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    The differentiation between special and normal routing has been introduced in version 0.27.@brief Sets the special routing layer name suffix.
    See \produce_via_geometry for details about the layer production rules.
    The differentiation between special and normal routing has been introduced in version 0.27.
    """
    special_routing_suffix_str: str
    r"""
    @hide@hide
    """
    via_cellname_prefix: str
    r"""
    @brief Gets the via cellname prefix.
    Vias are represented by cells. The cell name is formed by combining the via cell name prefix and the via name.

    This property has been added in version 0.27.
    @brief Sets the via cellname prefix.
    See \via_cellname_prefix for details about this property.

    This property has been added in version 0.27.
    """
    via_geometry_datatype: int
    r"""
    @brief Gets the via geometry layer datatype value.
    See \produce_via_geometry for details about this property.
    @brief Sets the via geometry layer datatype value.
    See \produce_via_geometry for details about this property.
    """
    via_geometry_datatype_str: str
    r"""
    @hide@hide
    """
    via_geometry_suffix: str
    r"""
    @brief Gets the via geometry layer name suffix.
    See \produce_via_geometry for details about this property.
    @brief Sets the via geometry layer name suffix.
    See \produce_via_geometry for details about this property.
    """
    via_geometry_suffix_str: str
    r"""
    @hide@hide
    """
    def __copy__(self) -> LEFDEFReaderConfiguration:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: LEFDEFReaderConfiguration) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear_fill_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the fill layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_fills_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the fill layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_lef_pins_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the LEF pin layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_lef_pins_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the LEF pin layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_pin_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the pin layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_pins_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the pin layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_routing_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the routing layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_routing_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the routing layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_special_routing_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the special routing layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_special_routing_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the special routing layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_via_geometry_datatypes_per_mask(self) -> None:
        r"""
        @brief Clears the via geometry layer datatypes per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def clear_via_geometry_suffixes_per_mask(self) -> None:
        r"""
        @brief Clears the via geometry layer name suffix per mask.
        See \produce_via_geometry for details about this property.


        Mask specific rules have been introduced in version 0.27.
        """
    def dup(self) -> LEFDEFReaderConfiguration:
        r"""
        @brief Creates a copy of self
        """
    def fills_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the fill geometry layer datatype value per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def fills_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the fill geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def lef_pins_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the LEF pin geometry layer datatype value per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def lef_pins_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the LEF pin geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def pins_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the pin geometry layer datatype value per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def pins_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the pin geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def routing_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the routing geometry layer datatype value per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def routing_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the routing geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_fills_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the fill geometry layer datatype value.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_fills_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the fill geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_lef_pins_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the LEF pin geometry layer datatype value.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_lef_pins_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the LEF pin geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_pins_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the pin geometry layer datatype value.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_pins_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the pin geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_routing_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the routing geometry layer datatype value.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_routing_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the routing geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_special_routing_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the special routing geometry layer datatype value.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_special_routing_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the special routing geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_via_geometry_datatype_per_mask(self, mask: int, datatype: int) -> None:
        r"""
        @brief Sets the via geometry layer datatype value.
        See \produce_via_geometry for details about this property.
        The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def set_via_geometry_suffix_per_mask(self, mask: int, suffix: str) -> None:
        r"""
        @brief Sets the via geometry layer name suffix per mask.
        See \produce_via_geometry for details about this property.
        The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def special_routing_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the special routing geometry layer datatype value per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def special_routing_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the special routing geometry layer name suffix per mask.
        See \produce_via_geometry for details about the layer production rules.The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def via_geometry_datatype_(self, mask: int) -> int:
        r"""
        @brief Gets the via geometry layer datatype value per mask.
        See \produce_via_geometry for details about this property.
        The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """
    def via_geometry_suffix_per_mask(self, mask: int) -> str:
        r"""
        @brief Gets the via geometry layer name suffix per mask.
        See \produce_via_geometry for details about this property.
        The mask number is a zero-based mask index (0: MASK 1, 1: MASK 2 ...).

        Mask specific rules have been introduced in version 0.27.
        """

class NetTracerTechnology(TechnologyComponent):
    r"""
    @brief A technology description for the net tracer

    This object represents the technology description for the net tracer (represented by the \NetTracer class).
    A technology description basically consists of connection declarations.
    A connection is given by either two or three expressions describing two conductive materials.
    With two expressions, the connection describes a transition from one material to another one.
    With three expressions, the connection describes a transition from one material to another through a connection (a "via").

    The conductive material is derived from original layers either directly or through boolean expressions. These expressions can include symbols which are defined through the \symbol method.

    For details about the expressions see the description of the net tracer feature.

    This class has been introduced in version 0.25.
    """
    def __copy__(self) -> NetTracerTechnology:
        r"""
        @brief Creates a copy of self
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: TechnologyComponent) -> None:
        r"""
        @brief Assigns another object to self
        """
    @overload
    def connection(self, a: str, b: str) -> None:
        r"""
        @brief Defines a connection between two materials
        See the class description for details about this method.
        """
    @overload
    def connection(self, a: str, via: str, b: str) -> None:
        r"""
        @brief Defines a connection between materials through a via
        See the class description for details about this method.
        """
    def dup(self) -> NetTracerTechnology:
        r"""
        @brief Creates a copy of self
        """
    def symbol(self, name: str, expr: str) -> None:
        r"""
        @brief Defines a symbol for use in the material expressions.
        Defines a sub-expression to be used in further symbols or material expressions. For the detailed notation of the expression see the description of the net tracer feature.
        """

class NetElement:
    r"""
    @brief A net element for the NetTracer net tracing facility

    This object represents a piece of a net extracted by the net tracer. See the description of \NetTracer for more details about the net tracer feature.

    The NetTracer object represents one shape of the net. The shape can be an original shape or a shape derived in a boolean operation. In the first case, the shape refers to a shape within a cell or a subcell of the original top cell. In the latter case, the shape is a synthesized one and outside the original layout hierarchy.

    In any case, the \shape method will deliver the shape and \trans the transformation of the shape into the original top cell. To obtain a flat representation of the net, the shapes need to be transformed by this transformation.

    \layer will give the layer the shape is located at, \cell_index will denote the cell that contains the shape.

    This class has been introduced in version 0.25.
    """
    def __copy__(self) -> NetElement:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetElement) -> None:
        r"""
        @brief Assigns another object to self
        """
    def bbox(self) -> Box:
        r"""
        @brief Delivers the bounding box of the shape as seen from the original top cell
        """
    def cell_index(self) -> int:
        r"""
        @brief Gets the index of the cell the shape is inside
        """
    def dup(self) -> NetElement:
        r"""
        @brief Creates a copy of self
        """
    def layer(self) -> int:
        r"""
        @brief Gets the index of the layer the shape is on
        """
    def shape(self) -> Shape:
        r"""
        @brief Gets the shape that makes up this net element
        See the class description for more details about this attribute.
        """
    def trans(self) -> ICplxTrans:
        r"""
        @brief Gets the transformation to apply for rendering the shape in the original top cell
        See the class description for more details about this attribute.
        """

class NetTracer:
    r"""
    @brief The net tracer feature

    The net tracer class provides an interface to the net tracer feature. It is accompanied by the \NetElement and \NetTracerTechnology classes. The latter will provide the technology definition for the net tracer while the \NetElement objects represent a piece of the net after it has been extracted.

    The technology definition is optional. The net tracer can be used with a predefined technology as well. The basic scheme of using the net tracer is to instantiate a net tracer object and run the extraction through the \NetTracer#trace method. After this method was executed successfully, the resulting net can be obtained from the net tracer object by iterating over the \NetElement objects of the net tracer.

    Here is some sample code:

    @code
    ly = RBA::CellView::active.layout

    tracer = RBA::NetTracer::new

    tech = RBA::NetTracerTechnology::new
    tech.connection("1/0", "2/0", "3/0")

    tracer.trace(tech, ly, ly.top_cell, RBA::Point::new(7000, 1500), ly.find_layer(1, 0))

    tracer.each_element do |e|
      puts e.shape.polygon.transformed(e.trans)
    end
    @/code

    This class has been introduced in version 0.25.
    """
    trace_depth: int
    r"""
    @brief gets the trace depth
    See \trace_depth= for a description of this property.

    This method has been introduced in version 0.26.4.
    @brief Sets the trace depth (shape limit)
    Set this value to limit the maximum number of shapes delivered. Upon reaching this count, the tracer will stop and report the net as 'incomplete' (see \incomplete?).
    Setting a trace depth if 0 is equivalent to 'unlimited'.
    The actual number of shapes delivered may be a little less than the depth because of internal marker shapes which are taken into account, but are not delivered.

    This method has been introduced in version 0.26.4.
    """
    def __copy__(self) -> NetTracer:
        r"""
        @brief Creates a copy of self
        """
    def __init__(self) -> None:
        r"""
        @brief Creates a new object of this class
        """
    def _create(self) -> None:
        r"""
        @brief Ensures the C++ object is created
        Use this method to ensure the C++ object is created, for example to ensure that resources are allocated. Usually C++ objects are created on demand and not necessarily when the script object is created.
        """
    def _destroy(self) -> None:
        r"""
        @brief Explicitly destroys the object
        Explicitly destroys the object on C++ side if it was owned by the script interpreter. Subsequent access to this object will throw an exception.
        If the object is not owned by the script, this method will do nothing.
        """
    def _destroyed(self) -> bool:
        r"""
        @brief Returns a value indicating whether the object was already destroyed
        This method returns true, if the object was destroyed, either explicitly or by the C++ side.
        The latter may happen, if the object is owned by a C++ object which got destroyed itself.
        """
    def _is_const_object(self) -> bool:
        r"""
        @brief Returns a value indicating whether the reference is a const reference
        This method returns true, if self is a const reference.
        In that case, only const methods may be called on self.
        """
    def _manage(self) -> None:
        r"""
        @brief Marks the object as managed by the script side.
        After calling this method on an object, the script side will be responsible for the management of the object. This method may be called if an object is returned from a C++ function and the object is known not to be owned by any C++ instance. If necessary, the script side may delete the object if the script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def _unmanage(self) -> None:
        r"""
        @brief Marks the object as no longer owned by the script side.
        Calling this method will make this object no longer owned by the script's memory management. Instead, the object must be managed in some other way. Usually this method may be called if it is known that some C++ object holds and manages this object. Technically speaking, this method will turn the script's reference into a weak reference. After the script engine decides to delete the reference, the object itself will still exist. If the object is not managed otherwise, memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.
        """
    def assign(self, other: NetTracer) -> None:
        r"""
        @brief Assigns another object to self
        """
    def clear(self) -> None:
        r"""
        @brief Clears the data from the last extraction
        """
    def dup(self) -> NetTracer:
        r"""
        @brief Creates a copy of self
        """
    def each_element(self) -> Iterator[NetElement]:
        r"""
        @brief Iterates over the elements found during extraction
        The elements are available only after the extraction has been performed.
        """
    def incomplete(self) -> bool:
        r"""
        @brief Returns a value indicating whether the net is incomplete
        A net may be incomplete if the extraction has been stopped by the user for example. This attribute is useful only after the extraction has been performed.
        """
    def name(self) -> str:
        r"""
        @brief Returns the name of the net found during extraction
        The net name is extracted from labels found during the extraction. This attribute is useful only after the extraction has been performed.
        """
    def num_elements(self) -> int:
        r"""
        @brief Returns the number of elements found during extraction
        This attribute is useful only after the extraction has been performed.
        """
    @overload
    def trace(self, tech: NetTracerTechnology, layout: Layout, cell: Cell, start_point: Point, start_layer: int) -> None:
        r"""
        @brief Runs a net extraction

        This method runs an extraction with the given parameters.
        To make the extraction successful, a shape must be present at the given start point on the start layer. The start layer must be a valid layer mentioned within the technology specification.

        This version runs a single extraction - i.e. it will extract all elements connected to the given seed point. A path extraction version is provided as well which will extract one (the presumably shortest) path between two points.

        @param tech The technology definition
        @param layout The layout on which to run the extraction
        @param cell The cell on which to run the extraction (child cells will be included)
        @param start_point The start point from which to start extraction of the net
        @param start_layer The layer from which to start extraction
        """
    @overload
    def trace(self, tech: str, layout: Layout, cell: Cell, start_point: Point, start_layer: int) -> None:
        r"""
        @brief Runs a net extraction taking a predefined technology
        This method behaves identical as the version with a technology object, except that it will look for a technology with the given name to obtain the extraction setup.
        """
    @overload
    def trace(self, tech: NetTracerTechnology, layout: Layout, cell: Cell, start_point: Point, start_layer: int, stop_point: Point, stop_layer: int) -> None:
        r"""
        @brief Runs a path extraction

        This method runs an path extraction with the given parameters.
        To make the extraction successful, a shape must be present at the given start point on the start layer and at the given stop point at the given stop layer. The start and stop layers must be a valid layers mentioned within the technology specification.

        This version runs a path extraction and will deliver elements forming one path leading from the start to the end point.

        @param tech The technology definition
        @param layout The layout on which to run the extraction
        @param cell The cell on which to run the extraction (child cells will be included)
        @param start_point The start point from which to start extraction of the net
        @param start_layer The layer from which to start extraction
        @param stop_point The stop point at which to stop extraction of the net
        @param stop_layer The layer at which to stop extraction
        """
    @overload
    def trace(self, tech: str, layout: Layout, cell: Cell, start_point: Point, start_layer: int, stop_point: Point, stop_layer: int) -> None:
        r"""
        @brief Runs a path extraction taking a predefined technology
        This method behaves identical as the version with a technology object, except that it will look for a technology with the given name to obtain the extraction setup.
        """

